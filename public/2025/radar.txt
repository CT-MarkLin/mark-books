`Prisma ORM(Apr 2025, 试验)
Prisma ORM 是一个开源的数据库工具包，帮助 Node.js 和 Typescript 应用简化应用数据库操作。它提供了一种现代化的、类型安全的数据库访问方式，能够自动化数据库模式迁移，并提供直观的查询 API。与传统 ORM 不同，Prisma ORM 使用纯 JavaScript 对象定义数据库类型，而无需依赖装饰器或类。我们对 Prisma ORM 的使用体验非常积极，它不仅更符合 TypeScript 的开发生态，还能很好地融入函数式编程范式中。
ElysiaJs(Apr 2025, 评估)
ElysiaJS 是一个端到端类型安全的 TypeScript Web 框架，最初主要为 Bun 设计，但也兼容其他的 JavaScript 运行环境。与tRPC等替代方案不同（这类方案会强制要求特定的 API 接口结构），ElysiaJS 不强制任何特定的 API 接口结构。这使得开发者可以创建符合行业标准的 API，如 RESTful、JSON: API 或 OpenAPI，同时仍能提供端到端的类型安全。ElysiaJS 在 Bun 运行环境上运行表现极好，在某些基准测试中甚至可与 Java 或 Go Web 框架相媲美。如果你在构建backend-for-frontend (BFF)，ElysiaJS 是一个尤其值得考虑的选择。
小语言模型(SLMs)(Apr 2025, 试验)
最近发布的 DeepSeek R1 充分展示了 小语言模型(SLMs） 为何仍然备受关注。满血版 R1 拥有 6710 亿个参数，并且需要约 1342GB 的 VRAM 才能运行，这通常只能通过八块最先进的 NVIDIA GPU 组成的“迷你集群”来实现。然而，DeepSeek 也提供了“蒸馏版”，即 Qwen 和 Llama 等更小的开放权重模型，使其能力得以迁移，并能够在更普通的硬件上运行。尽管这些小型版本在性能上有所折损，但相较于以往的小语言模型，依然实现了巨大的性能飞跃。小语言模型领域仍在不断创新。自上次技术雷达以来，Meta 推出了 Llama 3.2，涵盖 10 亿和 30 亿参数规模；微软发布了 Phi-4，其 140 亿参数模型在质量上表现出色；谷歌则推出了 PaliGemma 2，一个支持视觉-语言任务的模型，提供 30 亿、100 亿和 280 亿参数版本。这些只是近期发布的小型模型中的一部分，但无疑表明了这一趋势仍值得持续关注。
小语言模型(SLMs)(Oct 2024, 试验)
大语言模型（LLMs）在许多应用领域中被证明是有用的，但它们的体积庞大可能会带来一些问题：响应一个提示需要大量计算资源，导致查询速度慢且成本高；这些模型是专有的，体积庞大，必须由第三方托管在云中，这可能对敏感数据造成问题；而且，在大多数情况下，训练一个模型的费用是非常高的。最后一个问题可以通过RAG 模式来解决，该模式绕过了训练和微调基础模型的需求，但成本和隐私问题往往依然存在。为此，我们现在看到对 小语言模型(SLMs) 的兴趣日益增长。与更流行的 LLMs 相比，SLMs 的参数更少、精度较低，通常在 35 亿到 100 亿个参数之间。最近的研究表明，在适当的上下文中，正确设置时，SLMs 可以执行甚至超越 LLMs。它们的体积也使得在 端侧设备上运行成为可能。我们之前提到过谷歌的 Gemini Nano，但随着微软推出其Phi-3系列，该领域正在迅速发展。
Tyk hybrid API management(Apr 2025, 暂缓)
我们观察到多个团队在使用 Tyk hybrid API management 解决方案时遇到了问题。虽然托管控制平面和自管数据平面的设计理念为复杂的基础设施（如多云和混合云）提供了灵活性，但团队反馈在 Tyk 的 AWS 托管环境中，控制平面发生的故障通常是通过内部发现的，而非由 Tyk 主动检测到，这暴露了 Tyk 在可观测性方面的潜在不足。此外，事故支持的响应速度似乎偏慢，仅通过工单和邮件进行沟通在这些紧急情况下并不理想。同时，团队还反映 Tyk 文档的成熟度不足，尤其在处理复杂场景和问题时，文档往往不能提供足够的指导。此外，Tyk 生态系统中的其他产品似乎也不够成熟。例如，企业开发者门户被报告为不向后兼容，且定制能力有限。特别是在 Tyk 的混合部署场景中，我们建议谨慎使用，并将继续关注其成熟度的发展。
软件物料清单（SBOM）(Apr 2025, 采纳)
自我们在 2021 年首次提到 软件物料清单（SBOM） 以来，其生成已经从新兴实践转变为我们项目中的默认选项。SBOM 生态系统显著成熟，提供了强大的工具支持，并实现了与 CI/CD 系统的无缝集成。工具如 Syft、Trivy 和 Snyk 能够从源代码到容器镜像生成全面的 SBOM，同时支持漏洞扫描。FOSSA 和 Chainloop 等平台通过与开发工作流集成以及实施安全策略，进一步提升了安全风险管理能力。尽管统一的 SBOM 标准仍在演化，但对 SPDX 和 CycloneDX 的广泛支持已显著降低了采用门槛。同时，AI 系统也需要 SBOM 的支持。英国政府的 AI 网络安全行为准则 和 CISA 的 AI 网络安全协作手册 就证明了这一点。我们将继续关注该领域的发展动态。
软件物料清单（SBOM）(Oct 2022, 试验)
在保障系统安全性的压力不变且总体安全威胁不减的情况下，一个机器可读的 软件物料清单 （SBOM）可以帮助团队掌握他们所依赖的库中的安全问题。随着美国总统令的发布，业界对 SBOM 的概念和如何创建 SBOM 都有了清晰的认识，例如国家标准与技术研究院（NIST）也针对如何执行总统令提出了更详细的建议。现在我们已经具备了在项目中使用 SBOM 的生产经验，项目范围从小型企业到大型跨国公司，甚至是政府部门，而且我们确信它能为我们提供益处。更多的机构和政府部门应当考虑索取正在使用的软件的 SBOM。随着 Firebase Android BOM 等可以自动罗列应用软件 BOM 中依赖库的新工具的不断出现，这项技术也将持续强化。
软件物料清单（SBOM）(Mar 2022, 试验)
在保障系统安全性的压力不变且总体安全威胁不减的情况下，一个机器可读的 软件物料清单 （SBOM）可以帮助团队掌握他们所依赖的库中的安全问题。最近的 Log4Shell 零日远程漏洞十分严重且影响广泛。如果团队准备好了一个 SBOM，它就可以被扫描并被快速修复。现在我们已经具备了在项目中使用 SBOM 的生产经验，项目范围从小型企业到大型跨国公司，甚至是政府部门，而且我们确信它能为我们提供益处。一些工具（例如：Syft ），能够让使用 SBOM 进行漏洞检测变得容易。
软件物料清单（SBOM）(Oct 2021, 评估)
2021年5月，美国白宫发布了《关于改善国家网络安全的行政命令》。该文件提出了一些与我们在过去的技术雷达中展示的项目相关的技术要求，例如零信任架构以及使用安全策略即代码的自动合规性扫描。该文档的大部分内容都致力于提高软件供应链的安全性。特别引起我们注意的一项是要求政府软件应包含机器可读的软件物料清单 (SBOM)，它被定义为“包含构建软件使用的各种组件的详细信息和供应链关系的正式记录”。换句话说，它不仅应该详细说明交付的组件，还应该详细说明用于交付软件的工具和框架。这一秩序有可能开启软件开发透明和开放的新时代。这无疑会对以软件为生的我们产生影响。即使不是全部，今天生产的绝大部分软件产品都包含或在构建过程中使用了开源组件。通常，消费者无法得知哪个版本的软件包可能会影响其产品的安全性。于是他们不得不依赖零售供应商提供的安全警报和补丁。该行政命令确保向消费者提供所有组件的明确描述，使他们能够实施自己的安全控制方案。由于 SBOM 是机器可读的，这些控制可以自动化。从这一举措我们感受到了向拥抱开源软件的转变，在享受开源的同时我们也会实际解决它带来的安全风险。
Cursor(Apr 2025, 试验)
我们依然对 Cursor 这款以 AI 为核心的代码编辑器印象深刻，它在竞争激烈的 AI 代码辅助领域依然保持领先地位。其代码上下文编排功能十分高效，并支持多种模型，包括使用自定义 API 密钥的选项。Cursor 团队经常在其他厂商之前推出创新的用户体验功能，并在聊天功能中集成了丰富的上下文提供者，例如 Git 差异对比（git diffs）、先前的 AI 对话、网络搜索、库文档以及 MCP 集成等。与 Cline 和 Windsurf 等工具类似，Cursor 也因其强大的智能代理编码模式而脱颖而出。该模式允许开发者直接通过 AI 聊天界面指导实现过程，工具可以自主读取和修改文件，并执行命令。此外，我们还欣赏 Cursor 在检测生成代码的 lint 及编译错误方面的能力，它能够主动识别并进行修正。
Cursor(Oct 2024, 评估)
AI 辅助编程工具的竞赛仍在继续，而其中最引人注目的一个就是 Cursor。Cursor 是一个以 AI 为核心的代码编辑器，旨在通过深度整合 AI 到编码工作流中来提升开发者的生产力。虽然我们在之前的雷达评估中已经关注到它，但显然，Cursor 近期的持续改进已为其带来了质的飞跃。在我们的使用中，Cursor 展现了基于现有代码库的强大上下文推理能力。尽管其他 AI 代码工具如 GitHub Copilot 已经可以围绕代码片段进行代码生成或协作，Cursor 的多行和多文件编辑操作让它脱颖而出。Cursor 是基于 VSCode 代码库分叉开发的，提供了一种符合开发者直觉的快速且直观的交互方式。通过快捷键 ctrl/cmd+K 和 ctrl/cmd+L 即可完成强大的操作。Cursor 在 AI 编程工具的竞赛中引领了新一轮的竞争，尤其是在开发者交互和代码库理解方面更为突出。
v0(Apr 2025, 评估)
v0 是由 Vercel 开发的一款 AI 工具，可根据截图、Figma 设计或简单的提示生成前端代码。它支持包括 React、Vue、shadcn 和 Tailwind 在内的多种前端框架。除了 AI 生成代码的功能之外，v0 还提供了出色的用户体验，包括预览生成的代码并一步部署到 Vercel 的能力。尽管构建真实世界的应用程序通常需要集成多个功能，不仅仅局限于单个界面，但 v0 为原型设计提供了一个稳固的工具，并可作为开发复杂应用程序的起点初始化代码。
架构建议流程(Apr 2025, 试验)
在大型软件团队中，一个持久的挑战是确定由谁来做出塑造系统演进的架构决策。State of DevOps 报告 显示，传统的架构评审委员会（Architecture Review Boards）方式往往适得其反，不仅阻碍了工作流，还与低组织绩效相关。一种引人注目的替代方案是 架构建议流程 —— 这是一种去中心化的方法，任何人都可以做出架构决策，前提是他们向受影响的人和具有相关专业知识的人寻求建议。这种方法使团队能够在不牺牲架构质量的前提下优化工作流，无论是在小规模还是大规模环境中。乍看之下，这种方法似乎具有争议性，但像 架构决策记录（ADR） 和建议论坛这样的实践能够确保决策是经过充分信息支持的，同时赋予那些最接近实际工作的人员决策权。我们看到这一模型在越来越多的组织中取得了成功，包括那些处于高度监管行业的组织。
Fuzz测试(Apr 2025, 采纳)
Fuzz 测试 ，或称模糊测试，是一种已经存在很长时间但仍然较少被广泛了解的测试技术。其目标是向软件系统输入各种无效数据并观察其行为。例如，对于一个 HTTP 端点，错误的请求通常应返回 4xx_ 错误，但 fuzz 测试往往会引发 5xx_ 错误甚至更严重的问题。随着工具的完善以及文档支持的增强，fuzz 测试在如今显得尤为重要，尤其是在更多 AI 生成代码和自满于 AI 生成的代码的背景下。因此，现在是采用 fuzz 测试的好时机，以确保代码的健壮性和安全性。
torchtune(Apr 2025, 评估)
torchtune 是一个专为 PyTorch 设计的库，用于编写、后训练以及实验性探索大语言模型。它支持单 GPU 和多 GPU 设置，并通过 FSDP2 实现分布式训练。该库提供基于 YAML 的 recipes（配方），用于微调、推理、评估以及量化感知训练等任务。每个配方都聚焦于特定功能，避免复杂的参数标志配置，注重代码清晰性而非过度抽象化。此外，torchtune 包含一个强大的 CLI，可用于高效地下载模型、管理配方和运行实验。
Synthesized(Apr 2025, 评估)
在软件开发中，一个常见的挑战是为开发和测试环境生成测试数据。理想情况下，测试数据应尽可能接近生产环境，同时确保不暴露任何个人身份信息或敏感信息。虽然这看似简单，但测试数据的生成却远非易事。这也是我们对 Synthesized 感兴趣的原因——一个可以屏蔽和子集化现有生产数据，或生成具有统计相关性的合成数据的平台。Synthesized 可直接集成到构建流水线中，并提供隐私屏蔽功能，通过不可逆的数据混淆技术（如哈希、随机化和分组）实现逐属性匿名化。此外，它还可以生成大量合成数据用于性能测试。尽管该平台包含了当下流行的生成式 AI 功能，但其核心功能针对开发团队长期存在的一个真实挑战，值得进一步探索。
利用生成式AI理解遗留代码库(Apr 2025, 试验)
过去几个月， 利用生成式 AI 理解遗留代码库 这一领域取得了显著进展。主流工具如 GitHub Copilot 已被广泛宣传能够帮助现代化改造遗留代码库。类似 Sourcegraph Cody 等工具，也正在让开发者更轻松地导航和理解整个代码库。这些工具综合运用多种生成式 AI 技术提供上下文感知（Context-aware）的帮助，极大地简化了对复杂遗留系统的分析与处理。此外，S3LLM 等专业框架则展示了大语言模型（LLMs）如何有效处理大规模科学计算软件（例如 Fortran 或 Pascal），将 GenAI 强化的代码理解能力推广到传统企业 IT 以外的场景。我们认为，鉴于全球范围内大量的遗留代码，这种技术未来将持续获得更多关注并加速普及。
利用生成式AI理解遗留代码库(Oct 2024, 试验)
生成式 AI (GenAI) 和大型语言模型 (LLMs) 能帮助开发人员编写和理解代码。尤其是在处理遗留代码库时，这种帮助显得尤为有用，特别是当文档质量差、过时或具有误导性时。自我们上次讨论此话题以来， 利用生成式 AI 理解遗留代码库 的技术和产品得到了进一步的发展，我们已经成功实践了一些方法，尤其是在帮助大型机现代化改造的逆向工程中。我们使用的一个特别有前景的技术是 retrieval-augmented generation (RAG) 方法，其中信息检索基于代码库的知识图谱。知识图谱可以保留代码库的结构化信息，而这往往超出了 LLM 从文本代码中推导的内容。这对于那些不具备自我描述性和一致性的遗留代码库尤其有帮助。另一个提升代码理解的机会是，图谱可以通过现有的或 AI 生成的文档、外部依赖关系、业务领域知识等内容进一步丰富，从而让 AI 的工作更加轻松。
利用生成式AI理解遗留代码库(Apr 2024, 评估)
生成式人工智能（GenAI）和大语言模型（LLMs）可以帮助开发者编写和理解代码。在实际应用中，目前主要体现在较小的代码片段，但更多的产品和技术正在涌现，用于 利用 GenAI 理解遗留代码库 。这在遗留代码库文档记录不完整、或者过时的文档具有误导性时尤其有用。例如，Driver AI 或 bloop 使用了 RAG ，结合了语言智能、代码搜索与 LLMs，以帮助用户在代码库中定位自己的位置。更大的上下文窗口的新兴模型也将帮助这些技术更适配大型代码库。GenAI 对遗留代码的另一个有前景的应用是在大型机（mainframe）现代化领域，这里的瓶颈通常围绕着需要理解现有代码库、并将这种理解转化为现代化项目需求的逆向工程师。这些逆向工程师有了 GenAI 的帮助可以更快地完成工作。
Railway(Apr 2025, 试验)
Heroku 曾是许多开发者快速发布和部署应用程序的优秀选择。近年来，我们也看到了像 Vercel 这样更现代、轻量且易用的平台的兴起，虽然它们主要面向前端应用的部署。而在全栈部署领域的一个替代选择是 Railway，这是一个云端 PaaS 平台，简化了从 GitHub/Docker 部署到生产环境可观测性的整个流程。\nRailway 支持大多数主流编程框架、数据库以及容器化部署。作为应用程序的长期托管平台，您可能需要仔细比较不同平台的成本。目前，我们的团队对 Railway 的部署和可观测性体验良好。其操作流畅，并且能够很好地与我们倡导的 持续部署 实践相结合。
Tamagui(Apr 2025, 评估)
Tamagui 是一个用于高效共享 React Web 和 React Native 样式的库。它提供了一个 设计系统，包含可复用的已样式化和未样式化组件，可以在多个平台上无缝渲染。其可选的 优化编译器 通过将样式化组件转换为网页上的原子化 CSS 和原生视图上的提升样式对象，显著提升了性能。
pg_mooncake(Apr 2025, 评估)
pg_mooncake 是一个 PostgreSQL 扩展，用于添加列式存储和向量化执行功能。其列存表可存储为 Iceberg 或 Delta Lake 表格，数据可以存放在本地文件系统或兼容 S3 的云存储中。 pg_mooncake 支持从 Parquet、CSV 文件甚至 Hugging Face 数据集加载数据，非常适合需要列式存储的重度数据分析场景。它消除了在技术栈中添加专用列式存储技术的需求，为数据密集型分析提供了高效解决方案。
Tonic.ai(Apr 2025, 评估)
Tonic.ai 属于一类日益增长的平台，专注于为开发、测试和 QA 环境生成真实且去标识化的合成数据。与 Synthesized 类似，Tonic.ai 提供一套全面的工具，满足各种数据合成需求，这与 Synthetic Data Vault 更偏向于库的方式形成对比。Tonic.ai 能生成结构化和非结构化数据，在保持生产数据统计属性的同时，通过差分隐私技术确保隐私和合规。其关键功能包括自动检测、分类和去除非结构化数据中的敏感信息，以及通过 Tonic Ephemeral 按需提供数据库环境。此外，Tonic Textual 是一个安全的数据湖解决方案，帮助 AI 开发人员利用非结构化数据支持 检索增强生成（RAG） 系统和 LLM 微调。对于希望在严格的数据隐私要求下加速工程开发并生成可扩展且真实数据的团队，Tonic.ai 是一个值得评估的平台。
推理模型（Reasoning Models）(Apr 2025, 评估)
自上次雷达发布以来， 推理模型（Reasoning Models） 的突破和普及是人工智能领域最重要的进展之一。这些模型，也被称为“思考模型”，在诸如前沿数学和编码等基准测试中，它们已达到人类顶级水平的表现。\n推理模型通常通过强化学习(RL)或监督式微调(SFT)进行训练，增强了诸如逐步思考（思维链）、探索替代方案（思维树）和自我修正等能力。典型代表包括 OpenAI 的 o1 / o3 、 DeepSeek R1 和 Gemini 2.0 Flash Thinking。然而，这些模型应被视为与通用大型语言模型（LLM）不同的类别，而非简单的高级版本。\n这种能力提升伴随着代价。推理模型需要更长的响应时间和更高的 token 消耗，因此我们戏称它们为“更慢的 AI”（如果当前的 AI 还不够慢的话）。并非所有任务都值得采用这类模型。对于文本摘要、内容生成或快速响应聊天机器人等简单任务，通用 LLM 仍然是更好的选择。我们建议在 STEM 领域、复杂问题解决和决策制定中使用推理模型——例如，将 LLM 用作评判者或通过推理模型显式的 CoT 输出来提高最终结果的可解释性。截至撰写本文时，混合推理模型 Claude 3.7 Sonnet 已发布，暗示了传统 LLM 和推理模型之间融合的可能性。
Nyx(Apr 2025, 试验)
Nyx 是一个多功能的语义化版本发布工具，支持各种软件工程项目。它对编程语言无依赖，并兼容所有主流的持续集成和源代码管理平台，具备极高的适配性。尽管许多团队在 主干开发 中使用语义化版本管理，Nyx 还支持 Gitflow、OneFlow 和 GitHub Flow 等工作流。在生产环境中，Nyx 的一大优势是其自动生成变更日志的能力，并且内置支持 Conventional Commits 规范。\n如前几期技术雷达中所提到的，我们对依赖长期分支的开发模式（如 Gitflow 和 GitOps）持谨慎态度，因为这些模式引入了许多挑战，即使是像 Nyx 这样强大的工具也难以完全解决这些问题。我们强烈推荐在 CI/CD 工作流中尝试 Nyx，尤其是在主干开发中，我们已经多次见证其成功应用。
Chainloop(Apr 2025, 评估)
Chainloop 是一个开源的软件供应链安全平台，帮助安全团队强制执行合规性要求，同时允许开发团队将安全合规无缝集成到 CI/CD 流水线中。它包括一个控制平面（Control Plane），作为安全策略的单一事实来源，以及一个 CLI，用于在 CI/CD 工作流 中运行声明（attestations）以确保合规性。安全团队可以定义 工作流契约（Workflow Contracts），明确需要收集哪些工件（如 SBOM 和漏洞报告）、存储位置以及如何评估合规性。Chainloop 使用 OPA 的策略语言 Rego 验证声明，例如确保 CycloneDX 格式的 SBOM 符合版本要求。在工作流执行过程中，安全工件（如 SBOM）会附加到声明中，并推送到控制平面进行强制执行和审计。此方法确保可以一致且大规模地实施合规性，同时最大限度地减少开发工作流中的摩擦。最终，它实现了一个符合 SLSA 三级标准的单一事实来源，用于元数据、工件和声明的管理。
Grafana Tempo(Apr 2025, 试验)
Grafana Tempo 是一个高可扩展的分布式追踪后端，支持诸如 OpenTelemetry 等开放标准。Tempo 专为成本效率设计，依赖对象存储进行长期追踪数据的保存，并支持追踪查询、基于 Span 的指标生成以及与日志和指标的关联。Tempo 默认使用 Apache Parquet 为基础的列式块格式，提高了查询性能，并使下游工具能够访问追踪数据。查询通过 TraceQL 和 Tempo CLI 执行。Grafana Alloy 也可以配置以收集并转发追踪数据到 Tempo。我们的团队在 GKE 上自托管了 Tempo，使用 MinIO 作为对象存储，结合 OpenTelemetry 收集器以及 Grafana 用于追踪数据的可视化。
TabPFN(Apr 2025, 评估)
TabPFN 是一个基于 Transformer 的模型，专为在小规模表格数据集上实现快速而准确的分类而设计。它利用了上下文学习（In-Context Learning, ICL），直接从标注样本中进行预测，无需超参数调整或额外训练。TabPFN 在数百万个合成数据集上预训练，因而能够很好地泛化到不同的数据分布，同时对缺失值和异常值具有较强的处理能力。它的优势包括高效处理异构数据以及对无信息特征的鲁棒性。\nTabPFN 尤其适用于对速度和准确性要求较高的小规模应用场景。然而，它在处理大规模数据集时面临扩展性挑战，并且在回归任务中能力有限。作为一项前沿解决方案，TabPFN 值得评估，尤其是在表格分类任务中，它有潜力超越传统模型，并为 Transformer 在表格数据中的应用开辟新可能性。
Gemma Scope(Apr 2025, 评估)
机械解释性（Mechanistic Interpretability）——理解大型语言模型的内部运行机制——正在成为一个日益重要的领域。像 Gemma Scope 和开源库 Mishax 这样的工具，为 Gemma2 系列开源模型提供了深入的洞察。这些解释性工具在调试模型的意外行为、识别导致幻觉、偏见或其他失败案例的组件方面发挥了关键作用，并通过提供更深入的可见性来建立对模型的信任。虽然这一领域对研究人员尤其具有吸引力，但需要注意的是，随着 DeepSeek-R1 的近期发布，模型训练正在成为超越传统大玩家的更多企业的可行选择。随着生成式 AI 的不断发展，解释性与安全性的重要性只会与日俱增。
Metabase(Apr 2025, 试验)
Metabase 是一款开源的分析和商业智能工具，允许用户从各种数据源（包括关系型数据库和 NoSQL 数据库）中可视化和分析数据。该工具帮助用户创建可视化和报告，将其组织到仪表板中，并轻松分享数据洞察。此外，它还提供了一个 SDK，用于在 Web 应用程序中嵌入交互式仪表板，并能够匹配应用程序的主题和样式——这使其对开发者非常友好。通过官方支持和社区支持的数据连接器，Metabase 在不同的数据环境中表现出极大的灵活性。作为一款轻量级的 BI 工具，我们的团队发现它在管理应用程序中的交互式仪表板和报告方面非常实用。
Windsurf(Apr 2025, 评估)
Windsurf 是 Codeium 推出的 AI 编程助手，以其“代理型”（agentic）能力而闻名。类似于 Cursor 和 Cline，Windsurf 允许开发者通过 AI 聊天驱动实现代码的导航、修改以及命令的执行。它经常发布针对“代理模式”的全新功能和集成。例如，最近它推出了一个浏览器预览功能，使代理能够轻松访问 DOM 元素和浏览器控制台，还提供了一个网页研究功能，让 Windsurf 在适当情况下可以在互联网上查找文档和解决方案。Windsurf 支持多种主流 AI 模型，用户可以启用并引用网页搜索、库文档以及 MCP（Model Context Protocol）集成作为额外的上下文提供者。这些能力让 Windsurf 成为开发者高效工作的强大工具。
Effect(Apr 2025, 试验)
Effect 是一个强大的 TypeScript 库，用于构建复杂的同步和异步程序。在 Web 应用开发中，常常需要为异步处理、并发、状态管理和错误处理等任务编写大量样板代码。而 Effect-TS 通过采用函数式编程的方法简化了这些流程。借助 TypeScript 的类型系统，Effect 能够在编译时捕获难以检测的问题。我们的团队曾使用过 fp-ts 进行函数式编程，但发现 Effect-TS 提供的抽象更贴近日常任务的需求，同时使代码更易于组合和测试。尽管传统方法如 Promise/try-catch 或 async/await 也能处理类似场景，但在使用 Effect 之后，我们的团队发现没有理由回到传统方法。
NeMo Guardrails(Apr 2025, 试验)
NeMo Guardrails 是 NVIDIA 提供的一个易于使用的开源工具包，可帮助开发者为用于对话式应用的大型语言模型实施“护栏”。自我们上一次在技术雷达中提到它以来，NeMo 在团队中的应用显著增加，并且不断改进。最近对 NeMo Guardrails 的更新主要集中在扩展集成能力和加强安全性、数据管理及控制方面，与该项目的核心目标保持一致。\nNeMo 的文档进行了重大改进，提高了可用性，并新增了多个集成，包括 AutoAlign 和 Patronus Lynx，同时支持 Colang 2.0。关键升级包括增强了内容安全性和安全功能，以及最近发布的支持通过输出轨道流式处理 LLM 内容的功能，从而提高性能。我们还看到新增了对 Prompt Security 的支持。此外，NVIDIA 还发布了三种新的微服务：内容安全微服务、主题控制微服务 和 越狱检测微服务，这些微服务都已集成至 NeMo Guardrails。\n基于其不断扩展的功能集和在生产中的日益广泛使用，我们将 NeMo Guardrails 的状态提升至试验（Trial）。建议查看最新的发布说明，以全面了解自我们上次提到以来的所有更新内容。
NeMo Guardrails(Apr 2024, 评估)
NeMo Guardrails 是 NVIDIA 的一个易用开源的工具包，它可以使开发人员在会话应用的大语言模型上实现一套防护措施。尽管大语言模型在构建交互式体验上有巨大的潜力，但他们在事实准确性、偏见和潜在的滥用方面上存在一些固有的局限性，这使得我们需要采取一些必要的保护措施。Guardrails 提供了一个有前景的方法来确保大语言模型的责任性和可信性。尽管当谈到大语言模型的保护措施时都会有多种选择，但是我们团队发现 NeMo Guardrails 尤其有用，因为它支持可编程的规则和运行时的集成，并且可以应用到现有的大语言模型的应用上，而不需要大量的代码修改。
.NET Aspire(Apr 2025, 评估)
.NET Aspire 旨在简化开发者本地机器上分布式应用的编排工作。Aspire 允许您在本地开发环境中编排多个服务，包括多个 .NET 项目、依赖的数据库和 Docker 容器——所有这些都可以通过一条命令完成。此外，Aspire 为本地开发提供了观察工具，包括日志记录、跟踪和指标仪表板，这些工具与用于预生产或生产环境的工具解耦。这大大改善了开发者在构建、调整和调试任何系统的可观察性方面的开发体验。
模型上下文协议（MCP）(Apr 2025, 评估)
在提示生成中，最大的挑战之一是确保 AI 工具能够访问与任务相关的所有上下文信息。这些上下文信息通常已经存在于我们每天使用的系统中，如维基、问题追踪器、数据库或可观察性系统。AI 工具与这些信息源的无缝集成可以显著提高 AI 生成输出的质量。\n模型上下文协议（MCP）是由 Anthropic 发布的开放标准，提供了一个标准化的框架，用于将 LLM 应用与外部数据源和工具集成。它定义了 MCP 服务器和客户端，服务器访问数据源，客户端则集成并使用这些数据来增强提示。许多编码助手已经实现了 MCP 集成，使其能够作为 MCP 客户端运行。MCP 服务器可以通过两种方式运行：本地运行，作为在用户机器上运行的 Python 或 Node 进程；或者远程运行，作为通过 SSE 连接的服务器（尽管我们尚未看到远程服务器的使用）。目前，MCP 主要以第一种方式使用，开发者通过克隆开源的 MCP 服务器 实现 来使用它。虽然本地运行的服务器提供了一种避免第三方依赖的简洁方式，但它们对于非技术用户仍然不够友好，并且带来了治理和更新管理等挑战。尽管如此，可以预见这一标准未来可能会发展成一个更成熟、更易于用户使用的生态系统。
Claude Sonnet(Apr 2025, 试验)
Claude Sonnet 是一款擅长编码，写作，分析和视觉处理的先进语言模型。它可在浏览器，终端和大多数主流 IDE 中使用，并支持与GitHub Copilot 集成。截至目前的基准测试显示，该模型在 3.5 和 3.7 版本中的表现显著优于早前推出的模型。它还擅长解析图表并从图片中提取文本，同时提供以开发者体验为中心的特性，譬如它在浏览器 UI 中的“Artifacts”功能，用于生成和交互动态内容（如代码片段和 HTML 设计）。\n我们在软件开发中较为广泛地使用了 Claude Sonnet 的 3.5 版本，并发现它在多个项目中显著地提高了生产力。它在从零开始的项目（greenfield projects）中表现尤为出色，特别是在协同软件设计和架构讨论方面。尽管目前还难言有 AI 模型是“稳定”的编码助手，但 Claude Sonnet 已经是我们使用过的模型中最可靠的一个。截至撰写本文时，Claude 3.7也已发布，并展现出很大潜力，但我们尚未在生产环境中进行全面测试。
Plerion(Apr 2025, 试验)
Plerion 是一个专注于 AWS 的云安全平台，通过与托管服务提供商集成，帮助发现云基础设施、服务器和应用程序中的风险、错误配置和漏洞。与 Wiz类似，Plerion 使用基于风险的优先级策略对检测到的问题进行排序，旨在帮助用户“专注于最重要的 1% 问题”。 我们的团队对 Plerion 的使用体验非常积极，认为它为客户提供了重要的洞察力，并进一步强调了对组织实施主动安全监控的重要性。
VectorChord(Apr 2025, 评估)
VectorChord 是一个用于向量相似性搜索的 PostgreSQL 扩展，由 pgvecto.rs 的创建者开发，作为其继任者。它是开源的，与 pgvector 数据类型兼容，并且专为磁盘高效和高性能的向量搜索而设计。它采用 IVF（倒排文件索引）以及 RaBitQ 量化技术，能够实现快速、可扩展且准确的向量搜索，同时显著降低计算需求。与该领域其他 PostgreSQL 扩展一样，它利用了 PostgreSQL 的生态系统，使向量搜索能够与标准事务操作并行执行。尽管 VectorChord 仍处于早期阶段，但对于向量搜索的工作负载，值得您进行评估。
自满于 AI 生成的代码(Apr 2025, 暂缓)
随着 AI 编码助手的普及，越来越多的数据和研究也揭示了关于 自满于 AI 生成的代码 所带来的问题。GitClear 最新的代码质量研究显示，到 2024 年，重复代码和代码频繁变更的现象比预测的还要严重，而提交历史中的重构活动却在减少。同样反映出对 AI 的自满，微软的研究显示，AI 驱动的信心往往以牺牲批判性思维为代价——这种模式在长期使用编码助手时表现得尤为明显。随着监督式软件工程代理的兴起，这种风险进一步放大，因为当 AI 生成的变更集越来越大时，开发者在审查这些结果时面临的挑战也随之增加。而 vibe coding 的出现——即开发者在审查极少的情况下让 AI 生成代码——更是说明了人们对 AI 生成输出的信任正在增长。这种方法可能适用于原型或其他一次性代码，但我们强烈建议不要将其用于生产环境的代码。
自满于 AI 生成的代码(Oct 2024, 暂缓)
AI 编程助手，如 GitHub Copilot 和 Tabnine，已经变得非常受欢迎。根据 StackOverflow 2024 年开发者调查 的数据，“72% 的受访者对开发中的 AI 工具持赞成或非常赞成的态度”。尽管我们也看到了这些工具的好处，但我们对它们在中长期对代码质量的影响持谨慎态度，并提醒开发者警惕 自满于 AI 生成的代码 。在经历了几次积极的 AI 辅助体验后，很容易在审查 AI 建议时变得不够谨慎。像 GitClear 的这项研究 显示了代码库快速增长的趋势，我们怀疑这与更大的 Pull Request 有关。还有 GitHub 的这项研究 让我们开始思考，提到的 15% 的 Pull Request 合并率的增加是否真的是好事，还是人们因为过于信任 AI 的结果而更快地合并了更大的请求。我们仍在使用 一年多前提供的基本 “入门建议”，也就是要警惕自动化偏见、沉没成本谬误、锚定偏见和审查疲劳。我们还建议程序员建立一个良好的 在何时何地不使用和信任 AI 心理框架 。
从LLMs获取结构化输出(Apr 2025, 评估)
从 LLMs 获取结构化输出 是指通过定义的结构模式来约束语言模型的响应。这可以通过指示通用模型以特定格式响应，或者通过微调模型使其“原生”输出例如 JSON 的结构化数据来实现。OpenAI 现在支持结构化输出，允许开发人员提供 JSON Schema、pydantic 或 Zod 对象来约束模型响应。这种能力在函数调用、API 交互和外部集成中尤其有价值，因为这些场景中格式的准确性和一致性至关重要。结构化输出不仅提升了 LLMs 与代码交互的方式，还支持更广泛的使用场景，例如生成用于呈现图表的标记语言。此外，结构化输出已被证明可以减少模型输出中的幻觉现象。
从LLMs获取结构化输出(Oct 2024, 评估)
从 LLMs 获取结构化输出 是指通过定义的结构模式来约束语言模型的响应。这可以通过指示通用模型以特定格式响应，或者通过微调模型使其“原生”输出例如 JSON 的结构化数据来实现。OpenAI 现在支持结构化输出，允许开发人员提供 JSON Schema、pydantic 或 Zod 对象来约束模型响应。这种能力在函数调用、API 交互和外部集成中尤其有价值，因为这些场景中格式的准确性和一致性至关重要。结构化输出不仅提升了 LLMs 与代码交互的方式，还支持更广泛的使用场景，例如生成用于呈现图表的标记语言。此外，结构化输出已被证明可以减少模型输出中的幻觉现象。
Weights & Biases(Apr 2025, 试验)
Weights & Biases 持续发展，自上次在技术雷达中提及以来，增加了更多面向 LLM 的功能。他们扩展了 Traces 并推出了 Weave，一个超越 LLM 系统跟踪的完整平台。Weave 支持创建系统评估、定义自定义指标、使用 LLM 作为任务（如摘要）的评判工具，并保存数据集以捕捉不同行为进行分析。这有助于优化 LLM 组件，并在本地和全局层面跟踪性能。该平台还支持迭代开发和高效调试，这对错误难以检测的代理系统尤为重要。此外，它还允许收集宝贵的人类反馈，这些反馈可以用于后续模型微调，从而进一步提升模型的表现和可靠性。
Weights & Biases(Apr 2024, 试验)
Weights & Biases 是一个机器学习（ML）平台，它通过实验跟踪、数据集版本控制、模型性能可视化和模型管理来帮助更快地构建模型。它可以集成到现有的 ML 代码中，以便将实时指标、终端日志和系统统计数据实时传输到仪表板进行进一步分析。近期，Weights & Biases 扩展到了与大语言模型可观测性相关的 Traces。Traces 可视化了提示链的执行流程以及中间的输入/输出，并提供了关于链执行的元数据（例如使用的 token 和开始与结束时间）。我们的团队发现它对于调试和更深入了解链式架构非常有用。
Weights & Biases(Oct 2021, 试验)
使用机器学习（ML）平台 Weights & Biases 的实验跟踪、数据集版本控制、模型性能可视化和模型管理功能，能够更快地构建模型。此外还可以将其与现有的机器学习代码集成，从而将实时指标、终端日志和系统统计数据快速传输到仪表盘中，用于进一步分析。我们的团队已经使用了 Weights & Biases ，非常喜欢它在模型构建方面的协作功能。
FastGraphRAG(Apr 2025, 评估)
FastGraphRAG 是 GraphRAG 的一个开源实现，专为高检索准确性和性能而设计。它利用个性化 PageRank 限制图导航范围，仅关注图中与查询最相关的节点，从而提升检索准确性并改善大语言模型（LLM）的响应质量。FastGraphRAG 还提供图形的可视化表示，帮助用户理解节点关系及其检索过程。该工具支持增量更新，非常适合处理动态和不断演变的数据集。针对大规模 GraphRAG 用例进行了优化，FastGraphRAG 在提升性能的同时有效降低了资源消耗。
YOLO(Apr 2025, 评估)
YOLO (You Only Look Once)系列由 Ultralytics 开发，并持续在推动计算机视觉模型领域的进步。其最新版本 YOLO11 在精度和效率方面比以前的版本有了显著的提升。YOLO11 可以在极少资源消耗下高速运行图像分类任务，这使其适用于边缘设备的实时应用。此外，我们发现使用同样的框架还可以执行姿势估计，物体检测，图像分割以及其他任务，这一特性十分强大。这一重大进展也提醒我们，“传统”的机器学习模型的表现可能比像大语言模型(LLM)等通用 AI 模型更加出色。
资源受限应用中使用 Swift(Apr 2025, 评估)
自从 Swift 6.0 发布以来，这门语言已经超越了 Apple 生态系统的限制，通过对主要操作系统的改进支持，使在 资源受限应用中使用 Swift 变得更加可行。传统上，这一领域主要由 C、C++ 以及近年来的 Rust 占据，因为它们具备低级别的控制、高性能以及符合诸如 MISRA、ISO 26262 和 ASIL 等标准的认证编译器和库。尽管 Rust 已逐步获得类似的认证，但 Swift 尚未开始这一认证过程，这限制了其在安全关键型应用中的使用。\nSwift 的日益普及，得益于其在性能与安全特性之间的良好平衡，包括强类型安全和自动引用计数（ARC）内存管理功能。虽然 Rust 的所有权模型提供了更强的内存安全保证，但 Swift 提供了一种不同的权衡方式，这种方式对某些开发者来说更加易于接受。Swift 和 Rust 都基于 LLVM/Clang 编译器后端，这使得一方的技术进步也能惠及另一方。凭借其将代码编译为优化机器码的能力、开源的开发模式以及不断扩展的跨平台支持，Swift 正逐步成为应用范围更广的有力竞争者——远远超越了其最初的 iOS 根基。
按需特权访问管理（Just-in-time Privileged Access Management）(Apr 2025, 试验)
最小权限原则 确保用户和系统仅拥有执行任务所需的最低权限。特权凭证滥用是 安全漏洞 的主要原因之一，其中权限提升是常见的攻击向量。攻击者通常从低级访问权限开始，利用软件漏洞或配置错误获取管理员权限，尤其是在账号拥有过多或不必要权限时。另一个常被忽视的风险是静态特权（standing privileges）——即持续可用的特权访问，这大大增加了攻击面。 按需特权访问管理（Just-in-time Privileged Access Management） 有效缓解了这一问题，通过仅在需要时授予访问权限，并在任务完成后立即撤销权限，从而最大限度地降低暴露风险。真正的最小权限安全模型确保用户、应用程序和系统仅在最短时间内拥有完成任务所需的必要权限，这是合规性和监管安全的关键要求。我们的团队通过自动化工作流程实现了这一模型：触发轻量化的审批流程，为用户分配临时角色并限制访问权限，同时为每个角色强制设置生存时间（TTL），确保权限在任务完成后自动过期，从而进一步减少特权滥用的风险。
Module Federation(Apr 2025, 试验)
Module Federation 允许在微前端之间指定共享模块并实现依赖的去重。随着 2.0 版本的发布，模块联邦已经发展到可以独立于 webpack 工作。此更新引入了一些关键功能，包括联邦运行时（Federation Runtime）、全新的插件 API，以及对流行框架（如 React 和 Angular）及热门构建工具（如 Rspack 和 Vite）的支持。通过采用模块联邦，大型 Web 应用可以拆分为更小、更易管理的微前端，使不同的团队能够独立开发、部署和扩展，同时高效地共享依赖项和组件。
Module Federation(Apr 2021, 评估)
Webpack 5 模块联邦 功能的发布，受到了微前端架构开发者的高度期待。该功能引入了一种更加标准化的方式来优化模块依赖和共享代码的管理与加载。模块联邦允许共享模块规范，通过一次加载多个模块使用的代码，从而帮助消除微前端之间的重复依赖。它还能够区分本地模块和远程模块，远程模块实际上并不是构建的一部分，而是异步加载的。与诸如npm软件包之类的构建时依赖项相比，这可以显著简化那些随着多个下游依赖而更新的模块的部署。但是请注意，这要求你将所有微前端与Webpack捆绑在一起，而不是像导入映射那样，最终可能会成为W3C标准的一部分。
数据产品思维(Apr 2025, 采纳)
企业正在积极采用 数据产品思维 作为管理数据资产的标准实践。这一方法将数据视为具有自身生命周期、质量标准，并专注于满足消费者需求的“产品”。无论组织选择 数据网格 还是 Lakehouse 架构，我们现在将其推荐为数据管理的默认建议。\n我们强调数据产品思维中的以消费者为中心的原则，以推动更大的采用率和价值实现。这意味着通过 设计数据产品，从用例出发反向工作。同时，我们专注于使用现代数据目录（如 DataHub、Collibra、Atlan 和 Informatica）捕获和管理业务相关元数据与技术元数据。这些实践提升了数据的可发现性和可用性。此外，我们将数据产品思维应用于扩展 AI 项目，创建 AI 就绪数据。这一方法涵盖了全面的生命周期管理，确保数据不仅得到良好治理并具备高质量，同时在不再需要时能够符合法律和监管要求进行退役。
数据产品思维(Sep 2023, 试验)
数据产品思维 重视将数据消费者视为客户，确保他们在数据价值链中的无缝体验。这包括易用的数据发现、理解、信任、访问和消费。产品思维 不是一个新概念，过去我们在运维中施用了这一概念，建立了运维产品和微服务，它伴随着构建长期的跨功能的团队在组织中拥有并分享他们的数据。通过结合数据和产品思维，我们相信组织能够使用 FAIR (可发现, 可访问, 可互通且可复用) 原则进行数据运营。我们的团队使用如Collibra 和 DataHub 的数据目录实现数据产品的 可发现性。为了建立信任，我们发布数据质量和 服务等级指标 ，比如数据产品的及时性、完整性和一致性, 并使用 Soda Core 和 Great Expectations 等工具自动化数据质量检查。 数据可观测性可同时通过Monte Carlo等平台实现。\n我们已经看到数据产品随着时间的推移，演变为多个用例的可重用构建块。随着我们在识别和构建价值驱动的数据产品上的进展，后续用例的上市时间也随之加快。因此，我们的建议是，采纳 针对 FAIR 数据的数据产品思维 。
软件工程代理(software engineering agents)(Apr 2025, 试验)
自我们六个月前首次讨论 软件工程代理(software engineering agents) 以来，行业内仍然缺乏对“代理(Agent)”这一术语的统一定义。然而，一个重要的进展已经浮现——并非完全自主的编码代理（其能力仍然令人怀疑）——而是在 IDE 内的监督代理模式(supervised agentic modes)。这些模式允许开发者通过聊天驱动实现，工具不仅可以修改多个文件中的代码，还能执行命令、运行测试并响应 IDE 反馈（如 linting 或编译错误）。\n这种方式有时被称为“面向聊天的编程(chat-oriented programming，CHOP)”或“从提示到代码(prompt-to-code)”，它让开发者保持控制的同时，将更多责任转移给 AI，这跟传统的自动补全类辅助工具有很大不同。该领域的领先工具包括 Cursor、Cline 和 Windsurf，而 GitHub Copilot 稍显落后，但正在快速追赶。这些代理模式的有效性取决于所使用的模型（以 Claude's Sonnet 系列为当前业界领先）以及工具与 IDE 集成的深度，为开发者提供良好的体验。\n我们发现这些工作流具有吸引力且潜力巨大，并显著提高了编码速度。然而，保持问题范围小有助于开发者更好地审查 AI 生成的更改。这种方法在低抽象提示以及AI 友好的代码库中效果最佳——这些代码库结构良好且经过充分测试。随着这些模式的改进，它们也会加剧开发者自满于 AI 生成的代码。为了缓解这一问题，我们建议采用结对编程和其他严格的审查实践，尤其是在生产代码中。
软件工程代理(software engineering agents)(Oct 2024, 评估)
目前在生成式 AI (GenAI) 领域最热门的话题之一是 软件工程代理 （software engineering agents）的概念。这些编程辅助工具不仅仅是在代码片段上帮助工程师，它们的目标是扩大解决问题的范围，理想情况下能够自主完成任务，且减少人为干预。其理念是，这些工具能够接收 GitHub issue 或 Jira ticket，提出计划并进行代码更改，甚至创建供人类审查的 pull request。这是提升 AI 编程辅助工具影响力的下一步逻辑，但想要实现覆盖广泛编码任务的通用代理的目标仍然非常雄心勃勃，目前的工具尚未令人信服地展示出这一点。然而，我们认为对于范围较小、较简单的任务，这种工具将很快起到作用，帮助开发人员腾出时间处理更复杂的问题。正在发布和推广测试版代理的工具包括 GitHub Copilot Workspace、 qodo flow 、 Tabnine's 的 JIRA 代理 ，以及 Amazon Q Developer 。SWE Bench 基准测试列出了更多此类工具，但我们建议对 AI 领域的基准测试保持一定的谨慎态度。
Deno(Apr 2025, 评估)
由 Node.js 的发明者 Ryan Dahl 创建的 Deno，旨在修正他认为 Node.js 存在的错误。Deno 具有更严格的沙盒机制、内置的依赖管理以及原生的 TypeScript 支持——这也是对其用户群体的重要吸引力。许多开发者在 TypeScript 项目中更偏爱 Deno，因为它更像是一个真正的 TypeScript 运行时和工具链，而不仅仅是 Node.js 的一个附加组件。\n自从被列入2019 年技术雷达以来，Deno 取得了显著进展。Deno 2 版本引入了对 Node.js 和 npm 库的兼容性支持，并推出了长期支持 (LTS) 版本及其他改进。此前，阻碍 Deno 采用的主要障碍之一是需要重写 Node.js 应用程序，而这些更新降低了迁移的难度，同时扩展了对相关工具和系统的依赖选项。鉴于 Node.js 和 npm 庞大的生态系统，这些变化有望进一步推动 Deno 的普及。\n此外，Deno 的标准库已趋于稳定，有助于遏制 npm 生态中过多低价值软件包的泛滥。Deno 提供的工具链和标准库，使 TypeScript 或 JavaScript 在服务器端开发中更具吸引力。然而，我们也提醒开发者，不应仅仅为了避免多语言编程而选择某个平台。
Deno(Apr 2019, 评估)
As a group we have mixed feelings about programming in JavaScript on the server side, especially when the rationale for doing so is simply to avoid polyglot programming. That said, if you decide to use JavaScript or TypeScript on the server, have a look at Deno. Written by Ryan Dahl, the inventor of Node.js, Deno aims to avoid what Ryan considers mistakes that were made in Node.js. It brings a strict sandbox system and built-in dependency and package management, and it supports TypeScript out of the box. Deno is built using Rust and V8.
Dapr(Apr 2025, 试验)
自从我们上次在技术雷达中介绍 Dapr 以来，它已经有了显著的发展。它的许多新特性包括任务调度、虚拟角色以及更为复杂的重试策略和可观察性组件。它的构建模块列表不断扩展，新增了任务、加密等功能。我们的团队还注意到 Dapr 在安全默认设置方面的日益关注，支持 mTLS 和无发行版镜像。总体而言，我们对 Dapr 的表现感到满意，并期待其未来演进。
Dapr(Apr 2023, 评估)
Dapr 是分布式应用程序运行时 (Distributed Application Runtime) 的缩写，帮助开发人员构建在云中运行的具有弹性、无状态和有状态微服务。一些人可能会将其与服务网格 (service mesh) 混淆，因为它使用一个边车 (Sidecar) 架构，作为应用程序旁边独立运行的进程。Dapr 更加面向应用程序，并专注于封装构建分布式应用所需的容错性和连接性。例如，Dapr 提供多个构建块 (building blocks)，从服务调用和消息发布/订阅到分布式锁定等都是分布式通信中常见的模式。我们团队最近在一个项目上评估了 Dapr；基于这一成功经验，他们期待将其引入未来其他项目中。
GitLab CI/CD(Apr 2025, 采纳)
GitLab CI/CD 已发展为 GitLab 内部一个高度集成的系统，涵盖从代码集成、测试到部署和监控的所有环节。它支持复杂的工作流，包括多阶段流水线、缓存、并行执行和自动扩展运行器，非常适合大型项目和复杂流水线需求。我们特别想强调其内置的安全和合规工具（如 SAST 和 DAST 分析），使其非常适合具有高合规性要求的场景。此外，它还与 Kubernetes 无缝集成，支持云原生工作流，并提供实时日志、测试报告和可追溯性，以增强可观察性。
GitLab CI/CD(Mar 2022, 试验)
如果你正在使用 GitLab 管理软件交付，可以看看 GitLab CI/CD 能否满足持续集成和交付的需求。我们发现配合本地部署的 GitLab 以及自托管运行器时，GitLab CI/CD 尤其好用，因为这种组合可以解决使用基于云的解决方案经常会遇到的授权问题。自托管运行器可以完全根据需求进行配置，并安装合适的操作系统以及依赖项，因此流水线的运行速度比使用云供应的运行器要快得多，因为云供应的运行器每次都需要配置。\n除了基本的构建、测试和部署流水线，GitLab 的产品还支持 Services、Auto Devops、ChatOps 以及其他高级功能。Services 十分适合将 Docker 服务（如 Postgres 或 Testcontainer ）连接至用于集成测试与端到端测试的作业。Auto Devops 功能无需配置即可创建流水线，非常适用于刚开始进行持续交付的团队，以及有许多代码仓库的组织，可以避免手动创建许多流水线。
Unblocked(Apr 2025, 试验)
Unblocked 是一款现成的 AI 团队助手。通过与代码库、企业文档平台、项目管理工具以及沟通工具的集成，Unblocked 能帮助解答关于复杂业务和技术概念、架构设计与实现以及操作流程的问题。这在处理大型或遗留系统时尤为有用。在使用 Unblocked 的过程中，我们观察到团队更重视快速获取与代码和用户故事相关的上下文信息，而非生成代码或用户故事。对于这些生成任务，特别是编码场景，软件工程代理 更为适合。
Unblocked(Oct 2024, 评估)
Unblocked提供软件开发生命周期 (SDLC) 资产和工件的发现功能。它与常见的应用程序生命周期管理 (ALM) 和协作工具集成，帮助团队理解代码库及相关资源。通过提供代码的即时相关上下文，Unblocked 改善了代码理解，使导航和理解复杂系统变得更加容易。工程团队可以安全合规地访问与其工作相关的讨论、资产和文档。Unblocked 还捕捉并分享了通常掌握在经验丰富团队成员手中的本地知识，使宝贵的见解能够为所有人访问，不论经验水平如何。
turbopuffer(Apr 2025, 评估)
turbopuffer 是一个无服务器的多租户搜索引擎，能够在对象存储上无缝集成向量搜索和全文搜索。我们非常欣赏其架构和设计选择，尤其是在耐久性、可扩展性和成本效率方面的专注。通过将对象存储用作预写日志并保持查询节点的无状态化，它非常适合高规模的搜索工作负载。\nturbopuffer 专为性能和准确性而设计，开箱即可提供高召回率，即使是复杂的基于过滤条件的查询也不例外。它将冷查询结果缓存到 NVMe SSD，并将经常访问的命名空间保存在内存中，从而实现对数十亿文档的低延迟搜索。这使其非常适合大规模文档检索、向量搜索以及检索增强生成（RAG）等 AI 应用。然而，其对对象存储的依赖也带来了查询延迟的权衡，使其在需要无状态分布式计算的工作负载中最为高效。turbopuffer 驱动了诸如 Cursor 这样的大规模生产系统，但目前仅通过推荐或邀请方式获得访问权限。
ModernBERT(Apr 2025, 评估)
BERT（Bidirectional Encoder Representations from Transformers）的继任者 ModernBERT 是一系列新一代的 encoder-only transformer 模型，专为广泛的自然语言处理（NLP）任务设计。作为一个可直接替代 BERT 的升级版本，ModernBERT 不仅提升了性能和准确性，还解决了 BERT 的一些局限——特别是通过引入“交替注意力”（Alternating Attention）实现了对极长上下文长度的支持。 对于有 NLP 需求的团队，在默认选择 通用生成式模型 之前，请优先考虑 ModernBERT。
Tuple(Apr 2025, 试验)
Tuple 是一款专为远程结对编程优化的工具，最初设计是为了填补 Slack 的 Screenhero 停止服务后留下的空白。自我们上次在技术雷达中提到它以来，Tuple 已获得更广泛的应用，并解决了之前的诸多问题和限制，现在还支持 Windows 平台。一个关键的改进是增强了桌面共享功能，新增的隐私功能允许用户在共享屏幕时隐藏私人应用窗口（如短信），同时专注于共享工具（例如浏览器窗口）。此前，UI 限制让 Tuple 更像是一个专用的结对编程工具，而不是通用的协作工具。随着这些更新，用户现在可以在 IDE 之外的内容上进行协作。\n但需要注意的是，远程结对的伙伴可以访问整个桌面。如果没有正确配置，这可能会成为安全隐患，尤其是在结对伙伴不够值得信任的情况下。我们强烈建议在使用 Tuple 之前，教育团队了解其隐私设置、最佳实践和使用礼仪。\n我们鼓励团队将最新版 Tuple 纳入开发工作流中进行尝试。它与我们的务实的远程结对建议一致，提供了低延迟的结对体验、直观的用户体验（UX）和显著的易用性改进。
Tuple(Apr 2021, 试验)
Tuple是一个相对较新的远程结对编程工具，它希望能够填补Slack放弃Screenhero后留下的市场空白。虽然它现在还有比如暂时只能在Mac OS上使用（即将支持Linux），以及一些界面问题需要解决。但即使有这些限制，我们也已经在使用中拥有了很好的体验。和类似Zoom这种通用的视频屏幕共享工具不同，Tuple支持有两个鼠标光标的双侧控制；也和其他的选择比如Visual Studio Live Share不同，它不需要受限于IDE内。Tuple支持语音和视频通话、剪切板共享和相对其他工具较低的延迟；你还可以轻松的在另一方的屏幕上画画和擦除。这些特性让Tuple成为了一款十分方便直观和对开发者友好的工具。
DeepSeek R1(Apr 2025, 评估)
DeepSeek-R1 是 DeepSeek 推出的第一代 推理模型 。在一系列非推理模型的基础上，DeepSeek 的工程师设计并应用了多种方法来最大化硬件使用率。这些方法包括多头潜在注意力（Multi-Head Latent Attention, MLA）、专家混合（Mixture of Experts, MoE）门控、8 位浮点训练（FP8）以及底层 PTX 编程。这些方法结合其 高性能计算协同设计 方法使 DeepSeek-R1 在显著降低训练和推理成本的同时，达到与最先进模型(state-of-the-art)相媲美的表现。\nDeepSeek-R1-Zero 另一个显著创新在于: 工程师们可以通过简单的强化学习（RL），无需监督微调（SFT）即可让非推理模型展现出推理能力。此外，所有的 DeepSeek 模型都为开放权重，即它们可以被自由获取，但训练代码和训练数据仍然为专有。该代码库还包括六个从 DeepSeek-R1 蒸馏而来的稠密模型，基于 Llama 和 Qwen 构建，其中的 DeepSeek-R1-Distill-Qwen-32B 在多个基准测试中超越了 OpenAI-o1-mini。
Humanloop(Apr 2025, 评估)
Humanloop 是一个新兴的平台，致力于通过在关键决策点引入人类反馈，使 AI 系统更加可靠、适应性更强并且更符合用户需求。平台提供了用于人工标注、主动学习和人工参与的微调工具，同时支持根据业务需求对大语言模型进行评估。此外，它还帮助优化生成式 AI 解决方案的生命周期，以更高的成本效益实现更大的控制和效率。Humanloop 支持通过共享工作区、版本控制的提示管理以及 CI/CD 集成进行协作，从而有效防止回归。它还提供了可观测性功能，例如追踪、日志记录、警报和安全防护，用于监控和优化 AI 系统性能。这些功能使其在部署 AI 于高风险或受监管领域的组织中尤为重要，在这些领域中，人类监督是关键。凭借对负责任 AI 实践的关注，Humanloop 对于希望构建可扩展且符合伦理要求的 AI 系统的团队来说，值得认真评估。
GoFr(Apr 2025, 评估)
GoFr 是一个专为构建 Golang 微服务而设计的框架，通过抽象常见的微服务功能（如日志记录、追踪、指标、配置管理和 Swagger API 文档生成）来简化开发工作。它支持多种数据库，处理数据库迁移，并且能够与 Kafka 和 NATs 等消息代理进行 pub/sub 操作。此外，GoFr 还包括支持定时任务的 cron 作业功能。该框架旨在降低构建和维护微服务的复杂性，让开发者能够将更多精力集中于业务逻辑的编写，而非基础设施的管理。尽管市面上已有许多流行的 Go 库用于构建 Web API，但 GoFr 正在逐步获得关注，非常值得基于 Golang 的微服务开发团队探索和使用。
Supabase(Apr 2025, 评估)
Supabase 是一个开源的 Firebase 替代方案，用于构建可扩展且安全的后端。它提供了一整套集成服务，包括 PostgreSQL 数据库、认证、即时 API、Edge Functions、实时订阅、存储以及向量嵌入。 Supabase 的目标是简化后端开发，使开发者能够专注于构建前端体验，同时利用开源技术的强大功能和灵活性。与 Firebase 不同，Supabase 基于 PostgreSQL 构建。如果您正在进行原型设计或开发 MVP（最小可行产品），Supabase 值得考虑，因为在原型阶段之后，它更容易迁移到其他 SQL 解决方案。
模型蒸馏(Apr 2025, 试验)
Scaling laws 是推动 AI 快速发展的关键原则之一，即更大的模型、更大的数据集和更多的计算资源能够带来更强大的 AI 系统。然而，消费级硬件和边缘设备往往缺乏运行大尺寸模型的能力，因此产生了对 模型蒸馏 的需求。\n模型蒸馏 将知识从一个更大、更强的模型（教师模型）转移到一个更小、更高效的模型（学生模型）。这一过程通常包括从教师模型生成一个样本数据集，并对学生模型进行微调，以捕获其统计特性。与通过移除参数来压缩模型的 剪枝 技术或 量化 不同，蒸馏旨在保留领域特定的知识，同时将精度损失降到最低。此外，蒸馏还可以与量化结合使用，以进一步优化模型。\n这种技术最早由 Geoffrey Hinton 等人提出，现已被广泛应用。一个显著的例子是 Qwen/Llama 的 DeepSeek R1 蒸馏版本，它们在小模型中保留了强大的推理能力。随着蒸馏技术的日益成熟，它已不再局限于研究实验室，而是被广泛应用于从工业项目到个人项目的各类场景中。像 OpenAI 和 Amazon Bedrock 这样的供应商也提供了详细的指南，帮助开发者蒸馏自己的 小语言模型（SLMs）。我们认为，采用模型蒸馏技术能够帮助组织更好地管理 LLM 部署成本，同时释放 本地设备上 LLM 推理 的潜力。
Open WebUI(Apr 2025, 评估)
Open WebUI 是一个开源的自托管 AI 平台，功能多样且强大。它支持兼容 OpenAI 的 API，并能够与 OpenRouter 和 GroqCloud 等提供商集成。通过 Ollama，它可以完全离线运行，连接到本地或 自托管 的模型。Open WebUI 内置了 RAG（检索增强生成） 功能，让用户可以在聊天驱动的体验中与本地或基于网络的文档互动。平台提供了细粒度的 RBAC（基于角色的访问控制）功能，可以为不同用户组配置不同的模型和平台能力。此外，Open WebUI 支持通过 Functions 进行扩展，这些基于 Python 的构建模块能够自定义和增强平台功能。一个重要功能是其 模型评估 系统，其中包含用于在特定任务上对比 LLM 的模型竞技场。Open WebUI 可根据不同需求部署于各类场景——无论是个人 AI 助手、团队协作助手，还是企业级 AI 平台，都能灵活适配。
Renovate(Apr 2025, 采纳)
Renovate 已经变成了我们很多团队在依赖项版本管理工具的首选。虽然Dependabot仍然是 GitHub 仓库的一个安全默认选项，我们依然推荐评估 Renovate，因为它提供了更全面且可定制的方案。为了最大程度发挥 Renovate 的优势，应配置它来监控并更新所有依赖项，包括工具、基础设施以及私有或内部托管的依赖项。同时为了减少开发者的工作量，可以考虑自动合并依赖更新的 PR.
Renovate(Apr 2024, 试验)
作为软件构建过程的一部分，自动监控和更新依赖项已成为整个行业的标准实践。这样一来，在开源软件包发布安全更新时，用户不必盲目猜测。多年来，Dependabot 一直是这一实践的标准工具，但 Renovate 在出现后逐渐成为许多团队的第一选择。他们发现 Renovate 更适合现代软件开发环境，其中可部署的系统不仅依赖于代码和库，还包括运行时工具、基础设施和第三方服务。除了代码之外，Renovate 还涵盖了对这些辅助工件的依赖性。我们的团队还发现 Renovate 通过配置和定制选项提供了更多的灵活性。尽管 Dependabot 仍然是一个安全的默认选择，并且能够更方便地与 GitHub 集成，但我们建议评估 Renovate，看看它是否可以进一步减轻开发人员手动维护应用生态系统安全的负担。
MailSlurp(Apr 2025, 试验)
测试涉及电子邮件的工作流通常复杂且耗时。开发团队需要为自动化构建自定义的电子邮件 API 客户端，同时还需要设置临时收件箱以满足手动测试场景的需求，例如在主要发布之前进行用户测试或内部产品培训。当开发客户入职产品时，这些挑战会变得更加明显。我们对 MailSlurp 的使用体验非常积极。它是一个邮件服务器和 SMS API 服务，提供用于创建收件箱和电话号码的 REST API，同时还支持直接在代码中验证电子邮件和消息。其无代码的仪表板对于手动测试准备也非常有用。此外，像自定义域名、webhook、自动回复和转发等功能在更复杂的场景中也值得一试。
uv(Apr 2025, 采纳)
自上一次技术雷达以来，我们积累了更多关于 uv 的实践经验，并收到了团队的极大好评。uv 是一个由 Rust 编写的下一代 Python 包和项目管理工具，其核心价值主张是“极快的速度”。在基准测试中，uv 的性能远超其他 Python 包管理工具，加速了构建和测试周期，显著提升了开发者体验。除了性能，uv 还提供了统一的工具集，有效取代了像 Poetry、pyenv 和 pipx 等工具。然而，我们对包管理工具的担忧依然存在：一个强大的生态系统、成熟的社区和长期支持至关重要。由于 uv 相对较新，将其移至 Adopt 阶段是一个大胆的决定。然而，许多数据团队都渴望 摆脱 Python 的传统包管理系统。而我们的前线开发者也一致推荐 uv，认为这是目前最好的工具。
uv(Oct 2024, 评估)
Rust 因为其启动性能非常适合编写命令行工具，我们看到一些工具链正在用它重写。我们在之前的雷达报告中提到过Ruff，这是一个用 Rust 编写的 Python linter。在本期报告中，我们评估了uv，这是一个用 Rust 编写的 Python 包管理工具。uv 的价值主张是“超快”，在基准测试中，它的性能大幅超过其他 Python 包管理工具。然而，在我们的雷达评估中，我们讨论了在构建工具中优化几秒钟是否真的算是一个显著的提升。相比于性能，对于一个包管理系统来说，更重要的是生态系统、成熟的社区和长期的支持。尽管如此，我们项目团队的反馈表明，这一小幅速度提升可能会极大改善反馈周期和整体开发者体验——我们通常手动使 CI/CD 缓存变得非常复杂，以实现这微小的性能提升。uv 简化了我们的 Python 环境管理。考虑到在 Python 开发的包和环境管理方面仍有很大的改进空间，我们认为 uv 是一个值得评估的选择。
Vite(Apr 2025, 采纳)
自从 Vite 上次出现在 radar 以来，它的影响力在进一步提升。作为一个高性能的前端构建工具，Vite 提供了快速热重载的特性。它正在被众多前端框架采用并推荐为默认选择，比如 Vue, SvelteKit，以及最近 废弃了 create-react-app的 React。此外 Vite 最近获得了重大投资，这促成了VoidZero 的成立。VoidZero 是一个专注于 Vite 发展的组织，这笔投资预计将加速 Vite 的开发，并提升其项目的长期可持续性。
Vite(Apr 2023, 试验)
Vite 是一款前端构建工具，在之前的技术雷达被评为评估级别后变得更加成熟与流行。它迅速地成为了我们许多团队开始前端项目时的默认选择。Vite 提供了一套基于浏览器内 ES 模块的应用的构建，打包和依赖管理工具。因为它利用了 esbuild 原生的速度和 Rollup 进行打包, Vite 显著地提升了前端开发体验。此外，当与 React 一起使用时，Vite 为广泛使用却缺乏维护的 Create React App 提供了一个有吸引力的替代品。Vite 依赖于 ES 模块，不同于大多数旧工具，它不提供 shim 和 polyfills，这表示它不兼容那些不支持 ES 模块的旧浏览器。如果要支持旧浏览器，我们的某些团队会在模块层导入 polyfills 来让 Vite 能在多个环境都能使用。
Vite(Oct 2021, 评估)
快速反馈是优质开发体验的关键。代码更改后，得到反馈前等待的一两分钟可谓最影响开发流程的。可惜随着应用规模和复杂性的增长，流行的前端构建工具大多已经不够快了。之前我们介绍了esbuild，它通过编译为本机语言而非JavaScript来实现，显著地改善了性能。Vite基于esbuild构建，相比其他工具带来了重大改进。它主要由两个部分组成：一个开发服务器，基于原生ES模块提供了丰富的内建功能，如极快的模块热更新（HMR）；以及一套构建指令，它使用Rollup打包你的代码。不同于大多数旧工具，Vite依赖于ES模块，它不提供shim和polyfills，这表示它不兼容那些不支持ES模块的旧浏览器。如果要支持旧浏览器，我们部分团队会在开发时使用Vite，而生产构建时使用其他工具。
AnythingLLM(Apr 2025, 评估)
AnythingLLM 是一个开源桌面应用程序，可以与大型文档或内容交互，支持开箱即用的大语言模型（LLMs）和向量数据库集成。它具备可插拔的嵌入模型架构，可以与大多数商业化 LLM 以及由 Ollama 管理的开源模型一起使用。除了支持 检索增强生成（RAG） 模式外，用户还可以创建和组织不同技能作为代理（agents）来执行自定义任务和工作流。AnythingLLM 允许用户将文档和交互分组到不同的工作空间中，这些工作空间类似于长生命周期的线程，每个线程都有独立的上下文。最近，它还新增了通过简单的 Docker 镜像部署为多用户 Web 应用的功能。一些团队已将其用作本地个人助手，发现它是一个强大且实用的工具。
OpenRewrite(Apr 2025, 试验)
OpenRewrite 一直是我们进行大规模代码重构的得力工具，尤其适用于基于规则的重构场景，例如迁移到广泛使用的库的新 API 版本，或对从相同模板创建的多个服务进行更新。除了对 Java 的强大支持外，OpenRewrite 还引入了对 JavaScript 等语言的支持。在框架（如 Angular）采用短期 LTS 发布周期的背景下，保持项目及时升级变得越来越重要，而 OpenRewrite 在这一过程中表现出色。虽然使用 AI 编程助手是另一种选择，但对于基于规则的更改，AI 通常运行较慢、成本更高且可靠性较低。我们特别欣赏 OpenRewrite 内置的丰富规则集（recipes），这些规则明确描述了需要执行的更改。其重构引擎、内置规则集以及构建工具插件均为开源软件，这为团队在需要进行大规模代码更新时提供了更大的便利和灵活性。
OpenRewrite(Sep 2023, 评估)
我们已经看到了一些代码智能工具的使用案例：例如把一个广泛使用的库迁移到新的 API 版本，了解一个库中刚发现的漏洞对整个企业的影响，以及对从同一模板创建的多个服务应用更新时。在这一领域，Sourcegraph 仍然是一个很受欢迎的工具。OpenRewrite是另一个我们想提及的工具。我们的团队已经在 Java 中使用它解决特定的问题，比如更新用入门套件创建的服务。目前它仍在持续拓宽覆盖的语言和使用案例。我们喜欢它附带的变革方案，这些方案描述了需要进行的更改，例如用于跨版本迁移常用框架。重构引擎、捆绑方案和构建工具插件都是开源软件，这使得团队在需要时可以更容易地使用 OpenRewrite。代码智能工具都是基于将源代码解析为抽象语法树（AST），这些工具将如何受到大语言模型领域快速发展的影响，我们拭目以待。
威胁建模(Apr 2025, 采纳)
在快速发展的 AI 驱动软件开发领域，威胁建模 比以往任何时候都更为关键，它不仅能够帮助构建安全的软件，同时还能保持敏捷性并避免出现 “安全三明治” 的情况。威胁建模是一组用于识别和分类潜在威胁的技术，可广泛应用于各种场景，包括生成式 AI 应用 ，这些应用 带来了独特的安全风险 。要想取得成效，威胁建模必须贯穿软件生命周期的各个阶段并定期执行，同时与其他安全实践相结合才能发挥最佳效果。这些实践包括定义跨职能的安全需求，以应对项目技术中的常见风险，以及利用自动化安全扫描工具进行持续监控，从而保障系统安全。
威胁建模(Oct 2022, 采纳)
我们继续推荐团队实施威胁建模——一系列有助于在开发过程中发现潜在威胁并对其进行分类的技术——但是我们想要强调的是，这件事不是只在项目开始时做一次就能一劳永逸的，团队需要避免 security sandwich 现象。这是因为，在任何软件的整个生命周期中，由于外部事件以及需求和架构的调整，可能会出现新的威胁，而现有的威胁将继续发展。这就意味着，威胁建模需要定期重复——重复的频率视情况而定，需要综合考虑诸多因素，例如执行的成本和对业务的潜在风险等。如果结合其他技术使用，例如建立跨功能的安全需求来发现项目所采用的技术有什么公共风险，以及使用自动化安全扫描，这时威胁建模将变得非常有用处。
威胁建模(Nov 2016, 采纳)
With the number of high-profile security breaches in the past months, software development teams no longer need convincing that they must place an emphasis on writing secure software and dealing with their users' data in a responsible way. The teams face a steep learning curve, though, and the vast number of potential threats—ranging from organized crime and government spying to teenagers who attack systems "for the lulz"—can be overwhelming. Threat Modeling provides a set of techniques that help you identify and classify potential threats early in the development process. It is important to understand that it is only part of a strategy to stay ahead of threats. When used in conjunction with techniques such as establishing cross-functional security requirements to address common risks in the technologies a project uses and using automated security scanners, threat modeling can be a powerful asset.
威胁建模(Nov 2015, 采纳)
With the number of high-profile security breaches in the past months, software development teams no longer need convincing that they must place an emphasis on writing secure software and dealing with their users’ data in a responsible way. The teams face a steep learning curve, though, and the vast number of potential threats - ranging from organized crime and government spying to teenagers who attack systems 'for the lulz' can be overwhelming. Threat Modeling provides a set of techniques, mostly from a defensive perspective, that help you understand and classify potential threats. Turned into 'evil-user stories', threat models can give a team a manageable and effective approach to making their systems more secure.
威胁建模(May 2015, 试验)
At this point the vast majority of development teams are aware of the importance of writing secure software and dealing with their users’ data in a responsible way. They do face a steep learning curve and a vast number of potential threats, ranging from organized crime and government spying to teenagers who attack systems 'for the lulz'. Threat Modelingis a set of techniques, mostly from a defensive perspective, that help understand and classify potential threats. When turned into 'evil user stories' this can give a team a manageable and effective approach to making their systems more secure.
Browser Use(Apr 2025, 评估)
Browser Use 是一个开源的 Python 库，使基于 LLM 的 AI 代理能够使用网页浏览器并访问 Web 应用。它可以控制浏览器并执行包括页面导航、输入操作和文本提取在内的各种步骤。该库支持多标签页管理，能够在多个 Web 应用之间协调执行操作。在需要 LLM 代理访问网页内容、执行操作并获取结果的场景中，该库非常有用。它支持多种 LLM，并利用 Playwright 来控制浏览器，结合视觉理解与 HTML 结构提取，以优化 Web 交互体验。该库在多代理场景中正逐渐受到关注，使代理能够协作完成涉及 Web 交互的复杂工作流。
AI驱动的UI测试(Apr 2025, 评估)
AI 在软件团队中的应用正逐步超越单纯的代码生成，新的技术正在涌现。其中， AI 驱动的 UI 测试 正受到越来越多的关注，它利用 LLM 的能力来理解图形用户界面（GUI）。目前，该领域主要有几种不同的实现方式。一种方法是使用针对 UI 快照处理进行微调的多模态 LLM，这类工具允许测试脚本以自然语言编写，并能自主导航应用程序。例如，QA.tech 和 LambdaTest 的 KaneAI 就属于这一类别。另一种方法，则是像 Browser Use 这样，结合多模态基础模型与 Playwright，通过对网页结构的深入理解进行测试，而不是依赖于特定微调的模型。\n在测试策略中引入 AI 驱动的 UI 测试时，需要考虑其价值所在。这些方法可以补充人工探索性测试。尽管 LLM 的非确定性特性可能会导致测试结果的不稳定性，但它的模糊匹配能力也可能成为优势，尤其适用于缺少选择器的遗留应用程序或经常变更标签和点击路径的应用。
D2(Apr 2025, 试验)
D2 是一个开源的图表即代码工具，帮助用户通过文本创建和定制图表。它引入了 D2 图表脚本语言，以简单的声明式语法优先保证可读性而非紧凑性。D2 自带默认主题，并使用与 Mermaid 相同的布局引擎。我们的团队非常欣赏其轻量化的语法，尤其适用于软件文档和架构图的场景。
AI友好的代码设计(Apr 2025, 评估)
监督式软件工程代理的能力正在不断提升，它们现在能够识别所需的更新，并对代码库进行更大范围的修改。然而，我们也注意到，开发者对 AI 生成代码的自满情绪 正在增加，很多人不愿意审查由 AI 创建的大型变更集。一个常见的理由是：既然未来的修改可以交给 AI 来完成，那么面向人类的代码质量就没那么重要了。然而，事实恰恰相反——AI 编程助手在结构良好的代码库上表现得更好，因此 AI 友好的代码设计 对于代码的可维护性至关重要。\n值得庆幸的是，面向人类的优秀软件设计同样能够为 AI 提供助力。比如，明确的命名可以为代码提供领域上下文和功能信息；模块化和抽象设计能够限制代码改动范围，使 AI 的工作上下文更易于处理；而 DRY（don’t repeat yourself）原则则能减少重复代码，让 AI 更容易确保行为一致性。到目前为止，最适合 AI 的设计模式依然与传统的软件设计最佳实践密切相关。随着 AI 的不断发展，我们预计会有更多专门针对 AI 的设计模式出现。因此，从现在开始以 AI 友好的视角来思考代码设计，将会对未来大有裨益。
OpenTelemetry(Apr 2025, 采纳)
OpenTelemetry 正迅速成为可观察性领域的行业标准。随着 OpenTelemetry 协议 (OTLP) 规范的发布，行业内有了一个标准化的方式来处理追踪 (traces)、指标 (metrics) 和日志 (logs)。这减少了在监控分布式解决方案和满足互操作性需求时的多重集成或主要代码重构的需要。随着 OpenTelemetry 扩展对日志和性能分析的支持，OTLP 为所有遥测数据提供了一个一致的传输格式，简化了应用的仪表化过程，使全栈可观察性对于微服务架构更加易于实现且具有可扩展性。OTLP 已被诸如 Datadog 、New Relic 和 Grafana 等供应商采纳，帮助企业构建灵活的、与供应商无关的可观察性技术栈，避免被锁定在专有解决方案中。OTLP 支持 gzip 和 zstd 压缩，大幅减少遥测数据的大小并降低带宽使用——这对于处理高遥测数据量的环境尤为关键。为了支持长期发展，OTLP 确保 OpenTelemetry 保持强大且面向未来的标准，巩固了其作为遥测传输事实标准的地位。
OpenTelemetry(Sep 2023, 试验)
我们使用 OpenTelemetry 作为解决方案已经有一段时间了，并且在之前的雷达中推荐试用。它能够在多个服务和应用之间无缝地捕获、检测和管理遥测数据，从而改善我们的观察堆栈。OpenTelemetry 的灵活性和与多样化环境的兼容性使其成为我们工具包中有价值的补充。目前，我们对最近发布的 OpenTelemetry Protocol (OTLP) 特别感兴趣，该规范包括了 gRPC 和 HTTP 两种协议。这一协议标准化了遥测数据的格式和传输方式，促进了互操作性并简化了与其他监控和分析工具的集成。随着我们继续探索该协议的集成潜力，我们正在评估它对我们的监控和可观察性策略以及整个监控领域的长期影响。
OpenTelemetry(May 2020, 试验)
OpenTelemetry 是一个开源可观测性项目，它合并了OpenTracing 和 OpenCensus。OpenTelemetry 项目包含规范、库、代理和其他组件，以便从服务中捕获遥测信息，更好地观察、管理和调试服务。它涵盖了可观测性的三大支柱——分布式跟踪、指标和日志记录（目前处于 beta 测试版），且其规范通过correlations连接这三大支柱。这样就可以使用指标 来查明问题，找到相应的 跟踪 信息，以定位问题，并最终研究相应的 日志 ，以查找确切的根本原因。 OpenTelemetry 组件可以连接到后端可观察性系统，例如 Prometheus 、 Jaeger 及其他 系统。OpenTracing 的形成，是朝着融合标准化与工具简化而迈出的积极一步。
OpenTelemetry(Nov 2017, 试验)
As monolithic applications are being replaced with more complex (micro)service ecosystems, tracing requests across multiple services is becoming the norm. With majority contribution from LightStep and Uber OpenTracing is rapidly becoming the de facto standard for distributed tracing. There is a growing number of tracers supporting OpenTracing standard, including Zipkin, Instana, and Jaeger. OpenTracing currently provides vendor-neutral implementation in multiple languages including: Go, JavaScript, Java, Python, Objective-C, C#, C++, Ruby and PHP.
OpenTelemetry(Mar 2017, 试验)
As monolithic applications are being replaced with more complex (micro)service ecosystems, tracing requests across multiple services is becoming the norm. With majority contribution from LightStep and Uber OpenTracing is rapidly becoming the de facto standard for distributed tracing. There is a growing number of tracers supporting OpenTracing standard, including Zipkin, Instana, and Jaeger. OpenTracing currently provides vendor-neutral implementation in multiple languages including: Go, JavaScript, Java, Python, Objective-C, C#, C++, Ruby and PHP.
Grafana Alloy(Apr 2025, 试验)
前身为 Grafana Agent，Grafana Alloy 是一个开源的 OpenTelemetry Collector。Alloy 被设计为一个一体化的遥测数据收集器，用于收集包括日志、指标和跟踪在内的所有遥测数据。它支持常用的遥测数据格式，如 OpenTelemetry、Prometheus 和 Datadog。随着 Promtail 最近被弃用，Alloy 正逐渐成为遥测数据收集的首选工具——特别是在使用 Grafana 可观察性技术栈时，用于日志数据的收集。
kubenetmon(Apr 2025, 评估)
监控和理解与 Kubernetes 相关的网络流量可能是一项挑战，尤其是当您的基础设施跨多个可用区、区域或云时。由 ClickHouse 构建并最近开源的 kubenetmon，旨在通过提供主要云提供商之间详尽的 Kubernetes 数据传输计量解决这一问题。如果您正在运行 Kubernetes 并对账单中不清晰的数据传输成本感到困扰，不妨探索一下 kubenetmon。
Jujutsu(Apr 2025, 评估)
Git 是当前占据主导地位的分布式版本控制系统（VCS），拥有绝大多数的市场份额。然而，尽管 Git 已在过去十多年中占据主导地位，开发者仍然在其复杂的分支、合并、变基以及冲突解决工作流中苦苦挣扎。这种持续的挫败感催生了一系列旨在缓解痛点的工具——有些通过可视化方式简化复杂性，有些则提供图形界面以完全抽象操作过程。\nJujutsu 更进一步，提供了一个完整的 Git 替代方案，同时通过 使用 Git 仓库作为存储后端 保持兼容性。这使开发者能够继续使用现有的 Git 服务器和服务，同时受益于 Jujutsu 简化的工作流。Jujutsu 将自己定位为“既简单又强大”，强调为不同经验水平的开发者提供易用性。其一大亮点是 一流的冲突解决功能，这一特性有潜力显著改善开发者的使用体验。
Grafana Loki(Apr 2025, 试验)
Grafana Loki是一个受 Prometheus 启发的横向可扩展，高可用的多租户日志聚合系统。Loki 只对日志的元数据进行索引，并把它当做日志流的标签集，而日志数据本身则储存在像 S3, GCS 或 Azure Blob Storage 这样的块存储方案中。这样做的好处是 Loki 比竞争对手的运维复杂度更低，同时也降低了存储成本。正如你所期待的那样，它与 Grafana 和Grafana Alloy深度集成，即使其他的日志采集机制也被支持。\nLoki 3.0 引入了对原生OpenTelemetry的支持，这使得与 OpenTelemetry 系统的数据摄入与集成如配置一个端点一样简单。此外，它还提供了高级的多租户功能，例如通过 shuffle-sharding 的方式实现各租户间的隔离，避免异常的租户(比如正在执行高负载查询或者出现故障)影响到集群中的其他租户。如果你还没有关注 Grafana 生态系统的最新发展，现在正是个好时机——它正在快速地演进。
本地编码助手(Apr 2025, 暂缓)
由于对代码机密性的担忧，许多组织对第三方 AI 编码助手保持谨慎态度。因此，许多开发者开始考虑使用 本地编码助手 ，即完全在本地机器上运行的 AI 工具，无需将代码发送到外部服务器。然而，本地助手仍然落后于依赖更大型、更强大模型的云端助手。即使是在高端开发者设备上，较小的模型仍然存在能力上的局限性。我们发现它们难以处理复杂的提示词，缺乏解决更大问题所需的上下文窗口，并且通常无法触发工具集成或函数调用。这些能力对于当前编码辅助领域的前沿技术——代理式工作流——尤为重要。\n因此，我们建议在使用本地助手时保持较低的期望值，但也有一些功能在本地环境中是可行的。目前一些流行的 IDE 已将较小的模型嵌入其核心功能中，例如 Xcode 的预测代码补全和 JetBrains 的整行代码补全。此外，可在本地运行的大语言模型，如 Qwen Coder，为本地的行内建议和处理简单编码查询迈出了重要一步。您还可以使用 Continue 测试这些功能，该工具支持通过 Ollama 等运行时集成本地模型。
React Hook Form(Apr 2025, 采纳)
我们将 React Hook Form 视为 Formik 的替代方案。由于默认使用非受控组件，它提供了显著更好的开箱即用的表现，特别是在大型表单上。React Hook Form 很好地和各种基于 schema 的验证库（比如Yup, Zod 等）进行了集成。此外 React Hook Form 提供了很大的灵活性，使其易于和现有代码库和其他库集成。你可以把 React Hook Form 和像shadcn或者AntD这样的外部受控组件库一起使用。凭借出色的性能、无缝集成和活跃的开发社区，它是构建大型表单或表单密集型应用的可靠选择。
React Hook Form(Apr 2021, 评估)
构建Web表单仍然是前端开发的长期挑战之一，尤其在使用React技术栈的时候。 我们有很多团队在使用React，他们也一直在使用Formik来简化这个过程。但是现在一些团队正在评估 React Hook Form 作为潜在的替代方法。 React Hooks在React Hook Form出现之前就已经存在，因此可以将它们作为一级概念： 该框架通过钩子将表单元素注册和跟踪为不受控制的组件，从而大大减少了重新渲染的需要。 它的大小和所需的样板代码数量也非常轻量级。
Presidio(Apr 2025, 评估)
Presidio 是一个数据保护 SDK，用于在结构化和非结构化文本中 识别 和 匿名化 敏感数据。它可以通过命名实体识别（NER）、正则表达式和基于规则的逻辑检测个人身份信息（PII），如信用卡号、姓名和位置等。Presidio 支持 自定义 PII 实体识别和去标识化，使企业能够根据其特定的隐私要求进行调整。尽管 Presidio 能够自动识别敏感信息，但它并非万无一失，可能会遗漏或误识别数据。在依赖其结果时，务必保持谨慎。
Turborepo(Apr 2025, 试验)
Turborepo 通过分析、缓存、并行化和优化构建任务，帮助管理大型 JavaScript 或 TypeScript monorepo，从而加速构建过程。在大型 monorepo 中，项目之间通常存在相互依赖关系；每次更改时重新构建所有依赖项既低效又耗时，而 Turborepo 简化了这一过程。与Nx 不同，Turborepo 的默认配置使用多个 package.json 文件（每个项目一个）。这种方式允许在单个 monorepo 中包含不同版本的依赖项（如不同版本的 React），而 Nx 并不提倡这种做法。尽管这可能被视为一种反模式，但它确实能够解决某些特定用例，例如从多仓库迁移到 monorepo 的过程中，团队可能暂时需要多个版本的依赖项。根据我们的经验，Turborepo 设置相对简单且性能表现优秀。
Turborepo(Apr 2023, 评估)
单一代码库的话题似乎永远会引起我们的兴趣。一些地方已经采用了单一代码库来管理整个组织的代码，而另一些地方则将这个概念应用于某些特定的应用程序，比如移动应用程序或组合的 UI/BFF 开发。无论单一代码库是否适合使用，行业似乎都在重新寻找能够有效地管理大型代码库并将它们构建成可部署单元的工具。\nTurborepo 是这个领域中的一个相对较新的工具，它为大型的 JavaScript 或 TypeScript 代码库提供了一种与 Nx 或 Lerna 不同的选择。大型代码库的挑战之一是如何快速地执行构建，以使其不会中断开发者的流程或降低效率。\nTurborepo 是用 Rust 编写的，这使得它有不错的性能；它还采用递增构建和缓存中间步骤的方法，进一步加速构建过程。但是，它会改变开发者工作流程，需要时间学习，并且最适用于具有需要多个不同的方法独立构建的大型代码库。\n我们发现 Turborepo 的文档很少，这导致一些团队目前仍然坚持使用更成熟的工具。然而，Turborepo 及其新的伴侣 Turbopack （目前处于测试版）是否继续发展仍值得评估和查看。
PydanticAI(Apr 2025, 评估)
随着构建基于 LLM 的应用程序以及代理的技术的快速发展，构建和编排这种应用的框架往往难以跟上步伐，或者找到合适的长期适用的抽象。PydanticAI是该领域的最新成员，旨在简化实现过程的同时，避免不必要的复杂度。它由著名的Pydantic的开发者们打造，并吸收了早期框架的经验——其中的很多框架已经依赖 Pydantic。PydanticAI 没有尝试成为一个多功能工具，而是提供了一个轻量级但是功能强大的方案。它不仅兼容主流的模型 API，而且内置了结构化输出处理的特性，并且引入了基于图形的抽象层来管理复杂的代理工作流。
Mergiraf(Apr 2025, 评估)
解决合并冲突可能是软件开发中最不受欢迎的活动之一。尽管有一些技术可以减少合并的复杂性，例如实践持续集成（按照其原意至少每天合并到共享主干），但我们仍看到在合并上花费了过多的精力。长期功能分支 是一个原因，而 AI 辅助编码也往往会增加变更集的规模。Mergiraf 可能是一个解决方案——这是一款新工具，通过查看语法树而不是将代码视为文本行来解决合并冲突。作为一个 git 合并驱动程序，它可以被配置为让 git 子命令（如 merge 和 cherry-pick）自动使用 Mergiraf，而不是默认的合并算法，从而显著提高合并效率和准确性。
Hasura GraphQL engine(Apr 2025, 试验)
Hasura GraphQL engine 是一个通用的数据访问层，可简化在不同数据源上构建、运行和管理高质量 API 的过程。它能够为各种数据库（包括 PostgreSQL、MongoDB 和 ClickHouse）及数据源即时生成 GraphQL API，使开发者能够快速且安全地获取所需数据。我们发现，Hasura 在实现 服务端资源聚合 的 GraphQL 应用场景中非常易用，并已将其应用于多个 数据产品项目中。然而，对于其强大的联合查询和统一模式管理功能，我们仍然保持 谨慎态度。值得一提的是，Hasura 最近推出了 PromptQL 功能，允许开发者利用大语言模型（LLM）实现更自然直观的数据交互。
提示工程（Prompt Engineering）(Apr 2025, 试验)
提示工程（Prompt Engineering） 是指为生成式 AI 模型设计与优化提示词（Prompt）的过程，其目标是生成高质量、上下文相关（Context-aware）的响应。这一过程通常包括针对特定任务或应用场景，精心构建清晰、具体且上下文相关的提示，以实现模型输出效果的最优化。随着大语言模型能力的不断提升，尤其是推理模型的出现，提示工程的实践也必须随之调整。根据我们在 AI 代码生成方面的经验，少样本提示（few-shot prompting） 在与推理模型协作时，可能不如简单的零样本提示（zero-shot prompting）表现出色。此外，被广泛使用的思维链（Chain-of-Thought，CoT）提示技术也可能降低推理模型的表现——原因可能在于当前推理模型通过强化学习已内置了 微调过的 CoT 机制 。\n我们的实际经验也得到了学术研究的印证，即“高级模型可能消除软件工程领域对提示工程的依赖”。但在实际场景中，传统提示 工程技术仍然是减少模型幻觉（Hallucinations）并提升输出质量的重要手段，特别是在考虑推理模型与普通 LLM 在响应时间和 Token 成本等因素存在显著差异的前提下。在构建自主代理应用（Agentic Applications）时，我们建议根据实际需求策略性地选择模型，并持续迭代与优化提示模板及相应的工程方法。如何在性能、响应速度与 Token 成本之间找到最佳平衡，依然是充分发挥 LLM 效能的关键所在。
提示工程（Prompt Engineering）(Apr 2023, 评估)
提示工程 （Prompt engineering）指的是为生成式 AI 模型设计和优化提示的过程，以获得高质量的模型响应。这个过程包括精心设计特定、清晰易懂和与所需任务或应用相关的提示，以引导模型输出有用的结果。提示工程旨在增强大型语言模型（LLM）在问题回答、算术推理任务或特定领域上下文中的能力。在软件开发中，我们可以使用提示工程让 LLM 根据与利益相关者的简要对话或一些笔记撰写故事、API 或测试套件。培养有效的提示技巧正在成为处理人工智能系统的重要技能。提示工程被一些人认为是一门艺术，而另一些人则认为它是一门科学。同时我们也需要考虑到其潜在的安全风险，例如“提示注入攻击”。
System Initiative(Apr 2025, 评估)
我们对 System Initiative 依然感到非常兴奋。这款实验性工具为 DevOps 工作开辟了一条全新的激进方向。我们非常欣赏该工具背后富有创造性的思考，并希望它能够激励更多人突破基础设施即代码（Infrastructure-as-Code）的现状。System Initiative 目前已结束 Beta 阶段，并以 Apache 2.0 许可的形式免费开源。尽管其开发者已经在生产环境中使用该工具来管理基础设施，但它在满足大型企业需求的规模化能力方面仍有改进空间。然而，我们依然认为值得一试，以体验一种与众不同的 DevOps 工具方法。
System Initiative(Apr 2024, 评估)
近年来，几乎没有新兴工具能挑战 Terraform 作为基础设施即代码工具的主导地位。尽管出现了 Pulumi、CDK 以及最近的 Wing 等替代方案，但 Terraform 的模块化、声明式范式已被证明是最持久流传的。事实上，所有这些方法都有一个共同的目标，即模块化代码创建单一的基础设施。System Initiative 是一款全新的、实验性的工具，代表了 DevOps 工作的一个新方向。可以将 System Initiative 视为基础设施的数字孪生。对 System Initiative 状态的交互式更改会导致相应的变更集，可以应用于基础设施本身。同样，基础设施的变更也会反映在 System Initiative 状态中。这种方法的一个巨大优势体现在，它为应用部署和可观测性等事务创造的协作环境。工程师通过具有整个环境图形表示的用户界面，与 System Initiative 进行交互。除了管理云基础设施，您还可以使用该工具来管理容器、脚本、工具等。尽管我们通常对这类 GUI 工具持怀疑态度，但 System Initiative 可以通过 TypeScript 代码扩展来处理新资产或执行策略。我们非常喜欢这个工具中所体现的创造性思维，并希望它能鼓励其他人突破基础设施即代码方法的现状。System Initiative 是免费和开源的，基于 Apache 2.0 许可，目前处于公开测试阶段。维护者自己还不建议将该工具用于生产环境，但我们认为它值得在当前状态下检查，体验一种完全不同的 DevOps 工具方法。
Java后量子密码学（Java post-quantum cryptography）(Apr 2025, 评估)
非对称加密——这一保障了多数现代通信安全的核心概念——依赖于数学上难以求解的问题。然而，今天使用的算法中的问题在量子计算机面前将变得容易解决，这推动了替代方案的研究。基于格的密码学是其中最被看好的候选技术。尽管与密码学相关的量子计算机仍需多年以后才能面世，对于那些需要长期保证安全的应用来说，后量子密码学已成为一个值得关注的领域。此外还存在一种风险，攻击者可能会记录当前的加密数据并等待量子计算机推出后破解。\nJava 后量子密码学 在 JDK 24 中迈出了第一步，该版本预计在 3 月底正式发布。此次更新引入了JEP 496 和 JEP 497 ，分别实现了一种密钥封装机制以及一套数字签名算法。二者均基于标准并设计为可以抵挡未来可能的量子计算攻击。虽然来自 Open Quantum Safe 项目的liboqs已经提供了基于 C 语言的实现并提供了 JNI 封装，但原生 Java 版本实现的出现依旧鼓舞人心。
Android XR SDK(Apr 2025, 评估)
Google 和三星与高通合作推出了 Android XR, 这是一款专门为扩展现实(Extended Reality, XR)设计的操作系统。它在未来计划支持智能眼镜以及其他智能设备。大多数的安卓应用无需修改或者只需少量修改即可运行在该系统上，但它的核心理念是从零构建全新的空间应用，或者将现有的应用“空间化”。目前，全新的 Android XR SDK 被指定为此类项目的首选开发工具。Google 还提供了开发指南帮助开发者选择 SDK 内集成的工具与技术。目前，该 SDK 已经推出开发预览版本。
Restate(Apr 2025, 评估)
Restate 是一个持久化执行平台，类似于 Temporal ，由 Apache Flink 的原始创始人开发。功能方面，它提供了将工作流作为代码、状态事件处理、Saga 模式和持久化状态机等特性。Restate 使用 Rust 编写，并作为单个二进制文件部署，利用分布式日志记录事件，并通过基于 Flexible Paxos 的虚拟共识算法来实现，这保证了在节点故障时的持久性。平台提供了 Java、Go、Rust 和 TypeScript 等常见语言的 SDK。我们仍然认为，在分布式系统中最好避免使用分布式事务，因为这会带来额外的复杂性和不可避免的运维开销。然而，如果在你的环境中无法避免分布式事务，这个平台是值得评估的。
Helicone(Apr 2025, 评估)
类似于 Langfuse、Weights & Biases和 Arize Phoenix，Helicone 是一个面向企业需求的托管 LLMOps 平台，专注于管理 LLM 成本、评估 ROI 和降低风险。作为一个开源且以开发者为中心的平台，Helicone 支持生产级 AI 应用，覆盖整个 LLM 生命周期的提示词实验、监控、调试和优化。它能够实时分析来自不同 LLM 提供商的成本、利用率、性能以及代理堆栈跟踪。虽然 Helicone 大大简化了 LLM 运维管理，但作为一个正在发展的平台，它可能需要一定的专业知识才能充分利用其先进功能。我们的团队目前正在使用该平台，并获得了良好的体验。
Redactive(Apr 2025, 评估)
Redactive 是一个企业级 AI 赋能平台，专为帮助受监管的组织安全地为 AI 应用（例如 AI 助手和协作工具）准备非结构化数据而设计。它可以与像 Confluence 这样的内容平台集成，创建用于 检索增强生成（RAG） 搜索的安全文本索引。通过仅提供实时数据并从源系统强制执行实时用户权限，Redactive 确保 AI 模型访问的是准确且授权的信息，而不会影响安全性。此外，它还为工程团队提供工具，支持他们安全地使用任何大语言模型构建 AI 应用场景。对于正在探索 AI 驱动解决方案的组织，Redactive 提供了一种简化的数据准备和合规方法，在安全与可访问性之间取得平衡，为团队在受控环境中试验 AI 能力提供支持。
Graphiti(Apr 2025, 评估)
Graphiti 构建了动态且时间感知的知识图谱，能够捕捉不断演化的事实和关系。我们的团队使用 GraphRAG 来挖掘数据之间的关系，从而提升检索与响应的准确性。在数据集不断变化的情况下，Graphiti 在图的边上维护了时间元数据，用以记录关系的生命周期。它能够将结构化和非结构化数据以离散的Episodes 形式进行摄取，并支持基于时间、全文检索、语义和图算法的查询融合。 对于基于 LLM 的应用程序——无论是 RAG 模式还是 Agentic 方法——Graphiti 都能够支持长期记忆和基于状态的推理。
Trino(Apr 2025, 采纳)
Trino 是一个开源的分布式 SQL 查询引擎，专为大数据的交互式分析查询而设计。它针对本地和云端环境进行了优化，支持直接在数据驻留的位置进行查询，包括关系型数据库和各种专有数据存储（通过连接器）。Trino 还能够查询存储为 Parquet 等文件格式的数据，以及像 Apache Iceberg 这样的开放表格格式。其内置的查询联邦功能允许将多个数据源的数据作为一个逻辑表进行查询，非常适合需要聚合多种来源数据的分析工作负载。Trino 是许多流行技术栈（如 AWS Athena、Starburst 和其他专有数据平台）的重要组成部分。我们的团队在各种用例中成功使用了 Trino，对于跨多个数据源进行分析的数据集查询，Trino 一直是一个可靠的选择。
Trino(Sep 2023, 试验)
Trino 以前被称之为 PrestoSQL，是一个专为面向大数据交互式分析查询而设计的开源分布式 SQL 查询引擎。经过优化后，它可以在本地或者云上环境运行，并支持对 Hive、Cassandra、关系型数据库、甚至专有数据存储等多种不同的数据源进行查询。它支持基于密码的认证、LDAP 和 OAuth 的身份验证机制，同时具备在 catalog、schema 和 table 级别授予权限和访问控制的能力。我们的团队根据可视化、报告或机器学习用例等消费模式，使用资源组进行管理和限制资源分配。基于 JMX 的监控提供了丰富的指标集，帮助实现在查询或用户级别进行成本分配。我们的团队将 Trino 用作跨各种数据源的数据访问网关，当涉及到查询极大规模的数据时，Trino 对我们的团队来说是一个可靠的选择。Trino起源于2015年11月首次在Radar上亮相的Presto项目，具体可参考Facebook project 。
Cline(Apr 2025, 试验)
Cline 是一个开源的 VSCode 扩展程序，目前在监督型 软件工程代理领域中是最强有力的竞争者之一。它让开发者能够完全通过 Cline 聊天来驱动实现，并与他们已经使用的 IDE 无缝集成。Cline 的核心功能包括计划与执行模式（Plan & Act mode）、透明的 token 使用跟踪以及 MCP 集成，帮助开发者高效地与 LLM 交互。Cline 展现了在处理复杂开发任务方面的高级能力，尤其是在结合 Claude 3.5 Sonnet 时表现突出。它支持处理大型代码库、自动化无头浏览器测试，并能够主动修复错误。与基于云的解决方案不同，Cline 通过本地存储数据增强了隐私保护。其开源特性不仅确保了更高的透明度，还支持社区驱动的改进。需要注意的是，由于 Cline 的代码上下文编排虽然高效，但资源消耗较高，因此开发者需关注 token 使用成本。另外，Cline 可能面临 速率限制 的潜在瓶颈，这可能会减慢工作流。在此问题解决之前，建议使用像 OpenRouter 这样提供更优速率限制的 API 提供商。
能力边界作为理解系统故障的模型(Apr 2025, 评估)
优雅扩展性理论 定义了适应性系统（包括构建和操作软件的社会技术系统）的基本规则。这一理论中的一个关键概念是 能力边界（competence envelope） —— 系统在面对失败时能够 稳健 运作的边界。当系统被推到能力边界之外时，它会变得脆弱，更容易崩溃。该模型为理解系统故障提供了一个有价值的视角，例如在 2024 Canva 故障 中观察到的复杂故障。\n残余性理论 是软件架构思维中最近的发展，它提供了一种方法，可以通过故意引入压力源并分析系统随时间对历史压力源的适应情况，来测试系统的能力边界。这些方法与社会技术系统中的反脆弱性、弹性和稳健性概念相一致。我们期待这些理论在实践中的应用，为提升系统的适应性与可靠性提供新的思路和工具。
LangGraph(Apr 2025, 试验)
LangGraph 是一款面向基于 LLM 的多 agent 应用构建的编排（Orchestration）框架。与抽象程度较高的 LangChain 相比，它提供了更底层的节点（Nodes）和边（Edges）等基本原语，允许开发者精细地控制 agent 工作流、记忆管理与状态持久化。这种基于图的设计使工作流更加可控且易于定制，使得在生产级应用中的调试、扩展和维护变得更加容易。尽管其学习曲线较陡，但 LangGraph 凭借其轻量化与模块化设计，在开发 agent 应用时展现出了强大的灵活性和扩展性。
API 请求集合做为 API 产品的制品(Apr 2025, 试验)
将 API 视为产品 意味着优先考虑开发者体验，不仅需要在 API 本身中融入合理和标准化的设计，还需要提供全面的文档以及流畅的入门体验。虽然 OpenAPI（如 Swagger）规范可以有效记录 API 接口，但入门仍然是一个挑战。开发者需要快速获取可用的示例，包括预配置的身份验证和真实的测试数据。随着 API 客户端工具（例如 Postman、Bruno 和 Insomnia）的逐步成熟，我们建议将 API 请求集合做为 API 产品的制品 。API 请求集合应经过精心设计，以引导开发者完成关键工作流程，帮助他们轻松理解 API 的领域语言和功能。为了保持请求集合的最新状态，我们建议将其存储在代码库中，并将其与 API 的发布流水线集成在一起。
CrewAI(Apr 2025, 评估)
CrewAI 是一个专为构建和管理 AI 代理而设计的平台，它能让多个 AI 代理协同工作，共同完成复杂任务。我们可以将其理解为一群 AI 工作者组成的团队，每个成员都有自己的专长，并能齐心协力以达成共同目标。我们曾经在雷达中的LLM 驱动自主代理中提及过它。除了现有的 Python 开源库以外，CrewAI 现在还推出了企业级的解决方案，使组织可以创建基于代理的应用程序并应用于真实业务场景，在云基础设施上运行，并连接到现有的数据源（如 SharePoint 或者 JIRA）。我们已经多次使用 CrewAI 去应对生产环境中出现的问题，例如自动验证促销码，调查交易失败的原因以及处理客户支持相关的请求。在代理技术快速发展的背景下，我们对 CrewAI 的能力充满信心，因此将其归入“评估”类别。
SAFe™(Apr 2025, 暂缓)
我们持续观察到 SAFe™ (Scaled Agile Framework®)（规模化敏捷框架）正被广泛采用。同时我们也注意到，SAFe 过度标准化和阶段性门限的流程会造成阻碍，这可能助长信息孤岛，其自上而下的管控模式会在价值流中产生浪费，并抑制工程人才的创造力，还会限制团队的自主性和实验空间。企业之所以采用 SAFe，一个关键原因是组织敏捷化过程非常复杂，他们希望像 SAFe 这样的框架能够提供一个基于流程的简单捷径，从而实现敏捷转型。鉴于 SAFe 的广泛应用——包括在我们的客户中——我们已经培训了 100 多名 Thoughtworks 咨询顾问，以便更好地为他们提供支持。尽管我们拥有深入的知识并且做了诸多尝试，但我们仍然认为，面对复杂问题，有时确实没有简单的解决方案。因此，我们一直建议采用与全面变革计划相结合的更加精简、价值驱动的方法和治理模式。\nScaled Agile Framework® 和 SAFe™ 是 Scaled Agile, Inc. 的商标。
SAFe™(Apr 2021, 暂缓)
我们对“做敏捷之前先得变得敏捷”的定位以及我们对该主题的观点应该不会让人感到意外。根据Gartner 2019年5月的报告来看，规模化敏捷框架® (Scaled Agile Framework®)是被考虑和使用得最多的企业敏捷框架，我们也看到越来越多的企业正在经历组织变革，因此我们认为是时候再次提高对该主题的认知了。我们遇到过一些组织在过度标准化的规模化敏捷框架（SAFe）和阶段化流程中苦苦挣扎。这些流程在组织架构及其运作模式中造成摩擦。它还会导致组织中形成孤岛，阻碍平台成为真正的业务能力推动者。自上而下的管控会在价值流中产生浪费，阻碍工程人才的创造力，同时限制团队的自主性和试验。相较于衡量工作量并关注标准化的仪式，我们更加推荐采用一种更精益的，以价值驱动的方法和治理来帮助组织减少摩擦，例如价值驱动的数字化转型或者团队认知负荷评估，以识别团队的类型并确定他们应该如何更好地互动。\nScaled Agile Framework® 和SAFe™均为Scaled Agile公司的商标。
SAFe™(Apr 2016, 暂缓)
The Scaled Agile Framework® (aka  SAFe™ ) continues to gain mindshare in many organizations at scale. In addition, tools and certification are becoming a significant aspect of the adoption of SAFe™. We continue to be concerned that actual adoptions are prone to over-standardization and are tending towards large release practices, resulting in practices that hinder agile adoption. In its place, we continue to recommend lean approaches that include experimentation and incorporate continuous improvement practices like the Improvement Katas offer organizations a better model for scaling agile.\nScaled Agile Framework® and SAFe™ are trademarks of Scaled Agile, Inc.
SAFe™(May 2015, 暂缓)
Scaling agile across enterprises is a continuing challenge. Several approaches have been proposed, with SAFe™ being one gaining significant mindshare. While SAFe™ provides a useful checklist for areas of concern, they are easy to misuse, by introducing the same kind of large release tendencies like the release train and gated control processes that agile removes. Enterprises in particular look for a degree of commonality across endeavors that SAFe™ seems to provide, promoting aggressive standardization when some degree of customization provides significant value. Other lean approaches that include experimentation and incorporate continuous improvement practices like the Improvement Katas offer organizations a better model for scaling agile.\nScaled Agile Framework® and SAFe™ are trademarks of Scaled Agile, Inc.
MarkItDown(Apr 2025, 试验)
MarkItDown 能将多种格式（PDF、HTML、PowerPoint、Word）转换为 Markdown，从而增强文本的可读性和上下文保留。由于 LLM 可以从格式化提示（如标题和章节）中获取上下文，Markdown 能够很好地保留结构以提升理解能力。在基于 RAG 的应用中，我们的团队使用 MarkItDown 将文档预处理为 Markdown 格式，确保逻辑标记（如标题、子章节）保持完整。在生成嵌入之前，结构感知的分块方法帮助保留了完整的章节上下文，从而提升了查询响应的清晰度，尤其是对于复杂文档而言。Markdown 被广泛用于文档编写，而 MarkItDown 的 CLI 工具也因此成为一个极具价值的开发者生产力工具。
JSON Crack(Apr 2025, 试验)
JSON Crack 是一个用于在 Visual Studio Code 中将文本数据渲染为交互式图表的扩展工具。尽管其名称中包含“JSON”，但它实际上支持包括 YAML、TOML 和 XML 在内的多种格式。与 Mermaid 和 D2 不同，这些工具通过文本形式生成特定的可视化图表，而 JSON Crack 则是一个用于直观查看以文本格式存储数据的工具。其布局算法表现良好，并且支持选择性隐藏分支和节点，是探索数据集的绝佳选择。此外，它还提供了一个基于 Web 的配套工具，但我们对在线代码格式化或解析服务的依赖仍需保持谨慎。需要注意的是，JSON Crack 有节点数量的限制，对于超过几百个节点的文件会引导用户使用其商业版工具。
Gleam(Apr 2025, 评估)
Erlang/OTP 是一个强大的平台，用于构建高并发、可扩展且具备容错能力的分布式系统。传统上，其语言是动态类型的，而 Gleam 在语言层面引入了类型安全。Gleam 构建于 BEAM 之上，将函数式编程的表达能力与编译时的类型安全相结合，从而减少运行时错误并提高可维护性。Gleam 拥有现代化的语法，与 OTP 生态系统高度集成，充分利用了 Erlang 和 Elixir 的优势，同时确保了强大的互操作性。Gleam 社区活跃且友好，我们期待它的持续发展。
逆向ETL（Reverse ETL）(Apr 2025, 暂缓)
我们注意到，所谓的 逆向 ETL（Reverse ETL） 正在迅速扩散。常规 ETL 在传统数据架构中是很常见的，它将数据从事务处理系统传输到集中式分析系统（如数据仓库或数据湖）。尽管这种架构存在许多已被广泛记录的缺点，其中一些问题通过 数据网格 方法得到了缓解，但它在企业中仍然很常见。在这种架构中，将数据从集中分析系统逆向回流到事务处理系统，在某些特定场景下有其合理性，例如，集中系统可以汇总来自多个来源的数据，或者在向数据网格迁移的过程中，作为一种 过渡架构 的一部分。然而，我们观察到一个令人担忧的趋势，产品供应商正利用 Reverse ETL 的概念，将越来越多的业务逻辑转移到一个集中式的平台（即它们的产品）中。这种方法加剧了集中式数据架构所导致的许多问题。例如，过度依赖于将业务逻辑嵌入到一个庞大的中央数据平台中，会导致数据管理复杂性增加，并削弱领域团队对其数据的控制能力。因此，我们建议在从庞大的集中数据平台向事务处理系统引入数据流时，务必保持高度谨慎。
Databricks Delta Live Tables(Apr 2025, 试验)
Delta Live Tables（DLT）在简化和优化数据管道管理方面持续展现出其价值，通过声明式方法支持实时流处理和批量处理。通过自动化复杂的数据工程任务（如手动检查点管理），DLT 减少了运营开销，同时确保了端到端系统的稳健性。其简化管道编排的能力，几乎无需人工干预，大大提升了可靠性和灵活性。此外，像物化视图这样的功能为特定用例提供了增量更新和性能优化。\n然而，团队需要深入理解 DLT 的细节，才能充分利用其优势并规避潜在的陷阱。作为一种有主见的抽象层，DLT 自行管理表数据，并限制每次仅允许单个管道插入数据。流式表仅支持追加操作，这需要在设计中仔细考量。此外，删除 DLT 管道时会同时删除底层表和数据，可能带来一定的操作性问题。
Databricks Delta Live Tables(Oct 2024, 评估)
Databricks Delta Live Tables是一个声明式框架，旨在构建可靠、可维护和可测试的数据处理管道。它允许数据工程师使用声明式方法定义数据转换，并自动管理底层基础设施和数据流。Delta Live Tables 的一个突出特点是其强大的监控能力。它提供了整个数据管道的有向无环图 (DAG)，直观地表示从源到最终表的数据移动。这种可见性对于复杂的流水线至关重要，帮助数据工程师和数据科学家跟踪数据血缘和依赖关系。Delta Live Tables 深度集成到 Databricks 生态系统中，这也带来了一些定制接口的挑战。我们建议团队在使用 Delta Live Tables 之前仔细评估输入和输出接口的兼容性。
GraphRAG(Apr 2025, 试验)
在上次关于检索增强生成(RAG)的更新中，我们已经介绍了 GraphRAG 。它最初在微软的文章中被描述为一个两步的流程：(1) 对文档进行分块，并使用基于大语言模型的分析构建知识图谱；(2) 通过嵌入检索的方式在查询时检索相关块，沿着知识图谱的边缘发现更多相关的分块，这些分块后续会被添加到增强提示中。在许多情况下，这种方法提高了大语言模型生成的响应数据的质量。我们在使用生成式 AI 理解遗留代码库的过程中也观察到了类似的好处——通过像抽象语法树和代码依赖这样的结构化信息去构建知识图谱。GraphRAG 模式正在获得更多的关注，像 Neo4j 的GraphRAG Python 库这样的工具与架构正在不断出现以支持该模式。同时，我们认为Graphiti也符合广义上的 GraphRAG 模式。
Node超载(Apr 2025, 暂缓)
几年前，我们观察到了一种现象，即 Node 超载 ：Node.js 经常被用在一些不合理的场景中，甚至在没有考虑其他替代方案的情况下就被选择了。尽管我们理解某些团队倾向于使用单一语言栈——即便要付出一些权衡的代价——但我们仍然倡导 多语言编程（Polyglot Programming） 。当时，我们指出 Node.js 因在 IO 密集型工作负载中的高效性而享有应得的声誉，但也提到其他框架已经赶上，提供了更好的 API 和更优越的整体性能。同时，我们警告说，Node.js 从未适合计算密集型工作负载，这一局限性至今仍然是一个重大的挑战。如今，随着数据密集型工作负载的兴起，我们看到团队在应对这些问题时也面临着越来越大的困难。
Node超载(Oct 2020, 暂缓)
技术都有被滥用的趋势，尤其是广为流行的技术。比如现在所见到的“Node泛滥”现象，就是一种随意或误用 Node.js 的趋势。其中有两点很突出。首先，我们经常听到这样的说法——应该使用Node.js，这样只用一种编程语言，就能完成前后端的所有代码。对此，我们还是坚持认为多语言编程是一种更好的方法，尽管我们也将JavaScript作为一等语言。其次，我们经常听到团队将性能作为选择 Node.js 的理由。这种观点已经被大量比较合理的基准数据所否定，但其来源还是有历史原因的。当初， Node.js 变得流行时，还是首个使用非阻塞编程模型的主流框架。该模型让 Node.js 非常适合IO密集型任务（我们在2012年的Node.js文章中提到了这一点）。由于单线程的特点，Node.js 从来就不是计算密集型任务的理想选择。而现在，其他平台已经拥有功能强大的非阻塞框架（其中一些已经配备既优雅又现代的 API ）。所以性能已不再是选择 Node.js 的理由。
Node超载(May 2020, 暂缓)
技术都有被滥用的趋势，尤其是广为流行的技术。比如现在所见到的“Node泛滥”现象，就是一种随意或误用 Node.js 的趋势。其中有两点很突出。首先，我们经常听到这样的说法——应该使用Node，这样只用一种编程语言，就能完成前后端的所有代码。对此，我们还是坚持认为多语言编程是一种更好的方法，尽管我们也将JavaScript作为一等语言。其次，我们经常听到团队将性能作为选择 Node.js 的理由。这种观点已经被大量比较合理的基准数据所否定，但其来源还是有历史原因的。当初， Node.js 变得流行时，还是首个使用非阻塞编程模型的主流框架。该模型让 Node.js 非常适合IO密集型任务（我们在2012年的Node.js文章中提到了这一点）。由于单线程的特点，Node.js 从来就不是计算密集型任务的理想选择。而现在，其他平台已经拥有功能强大的非阻塞框架（其中一些已经配备既优雅又现代的 API ）。所以性能已不再是选择 Node.js 的理由。
Arize Phoenix(Apr 2025, 评估)
随着大语言模型和AI agent 应用的日益普及，LLM 可观测性的重要性不断凸显。此前，我们曾推荐过 Langfuse 和 Weights & Biases (W&B) 等平台。 Arize Phoenix 是该领域另一个值得关注的新兴平台，我们团队在实际使用中也取得了积极的体验。Phoenix 提供了诸如 LLM 链路追踪、评估和提示词管理等核心功能，并可与主流 LLM 提供商和开发框架无缝集成，以在低成本、低配置的情况下实现对 LLM 输出内容、延迟和 Token 消耗等指标的深度洞察。目前我们仅限于对其开源工具的使用经验，而更全面的商业版 Arize 平台拥有更多高级能力，我们也期待未来对此进行进一步探索。
Hurl(Apr 2025, 评估)
Hurl 是处理一系列 HTTP 请求的利器，这些请求可通过使用 Hurl 特定语法的纯文本文件定义。除了发送请求以外，Hurl 还可以验证响应数据，确保请求返回特定的 HTTP 状态码，使用 XPATH, JSONPath 或者正则表达式断言响应头和内容，以及提取相应数据到变量之中，以便在链式请求之中调用。\n凭借这些特性，Hurl 不仅可以胜任简单的 API 自动化工作，而且也能作为 API 的自动测试工具使用。它支持生成基于 HTML 或 JSON 格式的详细测试报告，这使它在测试流程中更具实用性。虽然像 Bruno 和 Postman 这样的专业工具提供了图形用户界面以及更丰富的功能，但 Hurl 更以简洁著称。和同样使用纯文本文件的Bruno类似，Hurl 的测试文件也可以存储在代码仓库中。
AI 加速影子 IT（AI-accelerated Shadow IT）(Apr 2025, 暂缓)
AI 正在降低非专业开发人员自行构建和集成软件的门槛，使他们无需等待 IT 部门响应自己的需求。尽管我们对这种技术带来的潜力感到兴奋，但同时也开始关注到 AI 加速影子 IT（AI-accelerated Shadow IT） 的初步迹象。一些无代码（No-code）工作流自动化平台已支持对 AI API（如 OpenAI 或 Anthropic）的集成，这使得用户可能倾向于将 AI 用作“胶带”，将此前难以实现的系统集成临时拼凑起来，例如通过 AI 将聊天消息转换为 ERP 系统的 API 调用。同时，越来越多具有自主 Agent 能力的 AI 编码助手，甚至允许仅经过基础培训的非技术人员创建内部工具应用。\n这些迹象呈现出类似于电子表格（Spreadsheets）当年迅速扩散的特征：虽然为企业关键流程提供了快速解决方案，但在长期运行后往往会造成规模更大的技术债（Tech Debt）。如果不加管控，这种新型影子 IT 将导致未经治理的应用程序激增，安全隐患加剧，数据分散在不同系统内。我们建议企业对此风险保持警觉，并谨慎评估快速问题解决与长期技术稳定性之间的平衡与取舍。
OpenRouter(Apr 2025, 评估)
OpenRouter 是一个统一的 API，可以用于访问多个大型语言模型（LLM）。它为 主流 LLM 提供商 提供了单一的集成点，简化了实验过程，降低了供应商锁定的风险，并通过将请求路由到最合适的模型来优化成本。像 Cline 和 Open WebUI 这样的流行工具都使用 OpenRouter 作为它们的端点。在我们的技术雷达讨论中，我们质疑大多数项目是否真的需要在模型之间切换，尤其考虑到 OpenRouter 为了盈利，在这一封装层之上需要增加价格加成。然而，我们也认识到 OpenRouter 提供了多种负载均衡策略，有助于优化成本。其一项特别有用的功能是绕过 API 速率限制。如果您的应用程序超出了单一 LLM 提供商的速率限制，OpenRouter 可以帮助您突破这一限制，实现更高的吞吐量。
ABsmartly(Apr 2025, 试验)
ABsmartly 是一款先进的 A/B 测试与实验平台，专为快速且可信的决策制定而设计。其核心亮点是 Group Sequential Testing (GST) 引擎，与传统 A/B 测试工具相比，可将测试结果的速度提升高达 80%。平台提供实时报告、深度数据分割以及通过 API 优先的方式实现的无缝全栈集成，支持在网页、移动端、微服务和机器学习模型中运行实验。\nABsmartly 专注于解决可扩展、数据驱动实验中的关键挑战，使得更快的迭代和更敏捷的产品开发成为可能。通过零延迟执行、强大的深度分割能力以及对多平台实验的支持，ABsmartly 对希望扩大实验文化并优先推动数据驱动创新的组织尤为有价值。借助其显著缩短的测试周期和自动化结果分析能力，ABsmartly 帮助我们比传统 A/B 测试平台更高效地优化功能和用户体验。
Wiz(Oct 2024, 采纳)
Wiz 已成为我们多个项目中的云安全平台首选。我们的团队喜欢它能够比类似工具更早地检测到风险和威胁，因为它能够持续扫描变更。Wiz 可以检测并警报尚未部署到生产环境的工件（如容器镜像、基础设施代码）以及生产环境中的工作负载（如容器、虚拟机和云服务）的错误配置、漏洞和泄露的机密。我们也非常欣赏它为开发团队和领导团队提供的强大报告功能。该分析帮助我们了解漏洞如何影响特定服务，从而能够在该上下文中解决问题。
Wiz(Sep 2023, 试验)
Wiz 是日渐成熟的云安全平台领域里又一竞争者，它能让用户在一个平台上预防、检测和应对安全风险和威胁。Wiz 能对尚未部署到生产环境的构建产物（容器镜像、基础设施代码）以及生产工作负载（容器、虚拟机和云服务）的错误配置、漏洞和泄漏的机密数据进行检测并发出警报。 它还能将发现的问题置于特定客户的云环境的上下文中，使响应团队能够更好地了解问题并确定修复优先级。我们的团队在使用 Wiz 时获得了良好的体验。他们发现 Wiz 正在快速发展并不断增加新的功能。值得称赞的是，由于 Wiz 能持续扫描变化，团队因此能够比使用一些其他类似工具更快地发现风险和威胁。
FoundationDB(Oct 2024, 评估)
FoundationDB 是一个多模型数据库，2015 年被苹果公司收购，并于 2018 年 4 月开源。FoundationDB 的核心是一个分布式键值存储，提供严格的可序列化事务。自从我们在技术雷达中首次提到它以来，它已经有了显著的改进，包括智能数据分布以避免写入热点、新的存储引擎、性能优化以及 多区域复制 支持。我们正在一个正在进行的项目中使用 FoundationDB，并对其解耦架构 印象深刻。该架构允许我们独立扩展集群的不同部分。例如，我们可以根据特定的工作负载和硬件调整事务日志、存储服务器和代理的数量。尽管功能丰富，FoundationDB 仍然非常易于运行和操作大型集群。
FoundationDB(Nov 2019, 评估)
FoundationDB是一个开源的多重模型数据库。在被苹果公司收购三年后，于2018年4月进行了开源。它的核心是一个提供严格可序列化操作的分布式的键值存储。比较有意思的地方是FoundationDB是它的扩展层的概念。扩展层是在其核心键值存储之上的一些无状态组件，例如记录层和文档层。同时FoundationDB为模拟测试设置了很高的标准，它们每天运行这些测试来模拟各种系统故障。出色的性能、严谨的测试和简单的操作使得它不单只是一个数据库，有人也用它来作为核心底层，并基于此开发分布式系统。
领域叙事(Domain storytelling)(Oct 2024, 试验)
领域驱动设计（DDD）已成为我们开发软件的基础方法。我们利用它来建模事件、指导软件设计、在微服务周围建立上下文边界，以及阐述复杂的业务需求。DDD 建立了一种普遍语言，非技术利益相关者和软件开发人员都可以用来有效沟通业务。一旦建立，领域模型会不断演变。但许多团队发现很难开始使用 DDD。构建初始领域模型没有一种通用的方法。我们最近遇到的一种前景看好的技术是领域叙事(Domain storytelling)。领域叙事是一种引导技术，业务专家被提示描述业务中的活动。在专家的叙述过程中，主持人使用图示语言捕捉实体和参与者之间的关系和动作。使这些故事可视化的过程有助于澄清和发展参与者之间的共同理解。由于没有单一的最佳方法来开发领域模型，领域叙事提供了一个值得关注的替代方案，或者作为更全面的 DDD 方法，作为我们经常用来开始 DDD 的另一种技术事件风暴的补充。
禁用大语言模型(Oct 2024, 暂缓)
与其在工作场所全面 禁用大语言模型 ，组织应专注于提供一套经过批准的 AI 工具。禁令只会促使员工寻找未经批准且可能不安全的替代方案，带来不必要的风险。正如个人计算机早期一样，人们会使用他们认为有效的工具来完成工作，无论是否存在障碍。如果公司不提供安全且获得认可的替代方案，员工可能会使用未经批准的大语言模型，这会带来知识产权、数据泄露和法律责任的风险。相反，提供安全、经企业批准的大语言模型或 AI 工具可以确保安全性和生产力的双赢。一个良好管理的方案能够帮助组织管理数据隐私、安全性、合规性和成本问题，同时赋能员工利用大语言模型的功能。最理想的情况下，对 AI 工具的妥善管理访问可以加速组织学习如何在工作场所中最好地利用 AI。
LinearB(Oct 2024, 试验)
LinearB 是一个软件工程智能平台，为我们的工程领导者提供数据驱动的洞察，以支持持续改进。它对关键领域进行对齐，如基准测试、工作流自动化以及增强开发者体验和生产力的针对性投资。我们对 LinearB 的体验表明，它能够在工程团队中培育改进和效率的文化。我们的团队使用该平台来跟踪关键的工程指标，识别需要改进的领域，并实施基于证据的行动。这些功能与 LinearB 的核心价值主张高度一致：基准测试、自动化收集指标，并实现数据驱动的改进。LinearB 集成了源代码、应用生命周期、CI/CD 和沟通工具，使用预配置和自定义的工程指标，提供有关开发者体验、生产力和团队绩效的全面定量洞察。作为 交付核心四指标 的支持者，我们特别欣赏 LinearB 对这些特定指标的强烈关注，以及其衡量软件交付性能关键方面的能力，这对于提升效率至关重要。历史上，团队在收集交付核心四指标特定指标时会面临挑战，往往依赖复杂的自定义仪表盘或手动过程。LinearB 持续提供一个引人注目的解决方案，能够自动跟踪这些指标，并提供实时数据，以支持围绕开发者体验、生产力和可预测性进行的主动决策。
LinearB(Apr 2024, 评估)
LinearB 是一个旨在为工程领导者提供数据驱动洞察以实现持续改进的平台。它主要在三个关键领域发挥作用：基准测试、工作流自动化和投资。我们在使用 LinearB 的度量工具时发现，它有助于支持持续改进。我们的一个团队利用该平台跟踪工程度量、识别和讨论改进机会，并根据数据定义可行的步骤，从而取得了可衡量的进展。我们很高兴看到这与 LinearB 的核心价值主张相一致：基准、自动化和改进。LinearB 与 GitHub、GitLab、Bitbucket 和 Jira 集成。它提供了一套全面的预配置工程度量，重点关注DORA 度量（部署频率、交付周期、变更失败率和恢复时间）。作为 DORA 研究定义的四个关键度量的坚定支持者，我们欣赏 LinearB 在度量对软件交付效能真正重要的维度的重视。一直以来，收集 DORA 特定度量都是一个挑战。许多团队不得不借助复杂的 CD 管道仪器、自定义仪表板或依赖手动流程。尽管我们的体验仅限于一个团队，但 LinearB 似乎是工程度量收集和跟踪以及培养数据驱动持续改进方法的一个引人注目的替代品。
Passkeys(Oct 2024, 试验)
在 FIDO 联盟的引导下，并由 Apple、Google 和 Microsoft 支持，passkeys正逐步接近主流可用性。使用 passkeys 设置新登录会生成一对密钥：网站接收公钥，而用户保留私钥。登录过程使用非对称加密，用户通过证明自己拥有私钥来进行身份验证，该私钥存储在用户设备上，永远不会发送到网站。访问 passkeys 通过生物识别或 PIN 码保护。passkeys 可以在大科技生态系统中存储和同步，如 Apple 的 iCloud 钥匙串、Google 密码管理器或 Windows Hello。对于跨平台用户， 客户端到身份验证器协议 (CTAP) 使得 passkeys 可以存储在创建密钥或需要登录的设备之外的其他设备上。对 passkeys 最常见的反对意见是它对技术不太熟悉的用户来说是个挑战，而我们认为这种观点实际上是在自我否定。这类用户通常也不善于管理密码，因此他们最能从替代方法中受益。实际上，使用 passkeys 的系统在必要时可以回退到更传统的认证方式。
Passkeys(Apr 2023, 评估)
“密码的终结”可能终于要到来了。在 FIDO 联盟的指导和苹果、谷歌、微软的支持下， passkeys 的可用性正在接近其他主流身份验证方式。当用 passkeys 注册新的登录信息时，它会产生一对密钥：网站收到公钥而用户保留私钥。它使用非对称加密处理登录。用户需要证明他们拥有私钥，但与密码不同，私钥不会被发送到网站上。在用户的设备上，会使用生物识别技术或 PIN 码来保护对 passkeys 的访问。\nPasskeys 可以在各大软件生态中存储和同步，例如苹果的 iCloud 钥匙链、谷歌的密码管理器或微软的 Windows Hello。在大多数情况下，该功能只适用于最新的操作系统和浏览器版本。值得注意的是，Windows 10 并不支持在 Windows Hello 中存储密码。不过幸运的是，客户端到认证器协议 (CTAP)让 passkeys 可以被保存在创建密钥或需要密钥登录的设备之外的不同设备上。例如，一个用户在 Windows 10 上为一个网站创建了一个 passkeys，并通过扫描二维码将其存储在 iPhone 上。因为密钥是通过 iCloud 同步的，所以用户可以从他们的 MacBook等其他 Apple 生态设备上登录到该网站。Passkeys 也可以存储在硬件安全密钥上，在 iOS 和 Android 上也提供了对原生应用的支持。\n尽管仍有一些可用性问题——例如，登录时需要设备支持并开启蓝牙，因为扫描二维码时要检查设备是否接近—— passkeys 依然是值得考虑的。我们建议你在 passkeys.io 上试用，以了解它们的可用性。
Astronomer Cosmos(Oct 2024, 评估)
Astronomer Cosmos是一个为 Airflow 设计的插件，旨在为 dbt core 工作流提供更原生的支持。安装该插件后，当使用 DbtDag 包装 dbt 工作流时，它将 dbt 节点转换为 Airflow 任务/任务组，使工程师能够直接在 Airflow UI 中可视化 dbt 依赖图及其执行进度。它还支持使用 Airflow 连接代替 dbt 配置文件，从而可能减少配置扩散。我们正在试验该工具，探索它在 Airflow 中与 dbt 更无缝集成的潜力。
PGLite(Oct 2024, 评估)
PGLite 是一个构建于 WASM 的 PostgreSQL 数据库。与之前需要 Linux 虚拟机的尝试不同，PGLite 直接将 PostgreSQL 构建为 WASM，允许你完全在 web 浏览器中运行它。你可以在内存中创建一个临时数据库，或者通过 indexedDB 将其持久化到磁盘中。自从我们在 Radar 中上次提到 本地优先应用 以来，工具集已经有了显著发展。借助 Electric 和 PGLite，你现在可以基于 PostgreSQL 构建响应式的本地优先应用。
SOPS(Oct 2024, 采纳)
SOPS 是一个加密文件编辑器，支持多种文件格式的加密，并与密钥管理服务 (KMS) 兼容。我们在处理秘密管理时的建议一直是要将其与源代码解耦。然而，当面临在完全自动化（符合基础设施即代码) 的精神下）和一些手动步骤（使用像 vaults 这样的工具）之间进行选择以管理、种子和轮换种子机密时，团队常常需要权衡。例如，我们的团队使用 SOPS 来管理引导基础设施的种子凭证。然而，在某些情况下，无法从遗留代码库中移除 Secret。在这些情况下，我们使用 SOPS 来加密文本文件中的 Secret。SOPS 可以与云管理的密钥存储（如 AWS 和 GCP 密钥管理服务 (KMS) 或 Azure Key Vault）集成， 作为加密密钥的来源。它还支持跨平台使用，并支持 PGP 密钥。我们的几个团队在需要管理代码库中的秘密时默认使用 SOPS。
SOPS(Apr 2023, 试验)
当谈到密钥管理的时候，我们总是建议密钥与代码解耦。然而，团队却时常面临着取舍权衡，一种方式是基于基础设施即代码思想的全自动化，另一种方式是使用一些手动步骤和诸如 vaults 的工具去管理、生成、更新密钥。例如，我们的团队使用 SOPS 工具生成构建基础设施所需要的根密钥。然而在某些情况下，从遗留代码仓库中移除密钥并不现实。对于这类需求，我们发现 Mozilla SOPS 是一个很好的工具，可以用来加密文本文件中的密钥。SOPS 集成了诸如 AWS、KMS、Azure Key Vault 等密钥仓库作为待加密密钥源。它支持跨平台运行，也支持 PGP 密钥。
SOPS(Oct 2021, 评估)
把密钥当作普通文本放到版本控制（通常是 Github）中是开发者最常犯的错误之一。在某些难以将误提交的密钥内容从遗留代码库移除的情况下，我们认为 Mozilla Sops 工具所提供的加密文本文件中的密钥功能是很有用的。我们在过去也多次提到有类似功能的工具（Blackbox, git-crypt），而 Sops 因几项功能脱颖而出。比如，Sops 集成了 AWS KMS，GCP KMS，以及 Azure Key Vault 等全托管密钥存储服务，可将其作为加密密钥的来源。Sops 也支持跨平台使用，并且支持 PGP key。这使得用户可以在单个文件级别上对密钥进行细粒度的访问控制。同时，Sops 也以纯文本的方式留下了识别密钥，以便通过 git 来定位和比对文本中的原始密钥。我们始终支持能更容易确保开发者安全的事情。但是，也请记住，你并不需要在一开始就把密钥放到源码中。请参阅我们于 2007 年11 月发布的雷达内容 Decoupling secret management from source code。
检索增强生成（RAG）(Oct 2024, 采纳)
检索增强生成 (RAG)是我们团队提高 LLM 生成响应质量的首选模式。我们已经在多个项目中成功应用了该技术，包括 Jugalbandi AI 平台。在 RAG 技术中，相关且可信的文档信息存储在数据库中。在给定的提示词 (prompt) 下，系统会查询数据库，检索相关文档，并将这些文档的内容与提示词结合，从而为 LLM 提供更丰富的上下文。这不仅提高了输出质量，还大大减少了幻觉现象。虽然随着新模型的出现，LLM 的上下文窗口（即 LLM 输入的最大大小）已经显著增长，但选择最相关的文档仍然是至关重要的一步。我们的经验表明，精心构建的较小上下文有时能比广泛的大上下文产生更好的效果。并且使用大上下文也会导致速度变慢且成本更高。我们过去依赖存储在向量数据库中的向量嵌入(embedding)来识别额外的上下文，但现在我们看到了重排序和混合搜索的趋势：搜索工具如 Elasticsearch Relevance Engine 以及诸如 GraphRAG 等利用 LLM 创建的知识图谱的方法开始被使用。在我们利用 生成式 AI 理解遗留代码库 的工作中，基于图谱的方法表现得特别出色。
检索增强生成（RAG）(Apr 2024, 采纳)
检索增强生成（Retrieval-augmented generation, RAG） 是我们团队提高大语言模型（LLM）生成响应质量的首选模式。我们已经在包括 Jugalbandi AI Platform 在内的多个项目中成功使用了它。通过 RAG，相关且可信的文档（如 HTML 和 PDF 格式）的信息被存储在支持向量数据类型或高效文档搜索的数据库中，例如 pgvector、Qdrant 或 Elasticsearch Relevance Engine。在收到给定提示后，数据库会被调取以检索相关文档，然后这些文档会与提示结合在一起，为 LLM 提供更丰富的上下文。这样一来输出质量更高，且大大减少了幻觉现象。上下文窗口——决定了 LLM 输入的尺寸是有限的，这意味着需要选择最相关的文档。我们会通过重新排序来提升提示内容的相关性。文档如果太大而无法计算嵌入，这意味着它们必须被分割成更小的块。这通常是一个困难的问题，其中一种方法是让这些块在某种程度上重叠。
检索增强生成（RAG）(Sep 2023, 试验)
检索增强生成（RAG） 是一种结合预训练参数和非参数记忆的文本生成技术。它使你能够通过你的领域内特有的包含上下文的知识，来强化预训练模型中的现有知识。使用 RAG，你会先从非参数记忆中去检索相关文档集（一般是通过在向量数据库中的相似性搜索），再使用LLM中的参数记忆生成与检索出的文档一致的输出。我们发现 RAG 对各种需要大量知识的 NLP 任务十分有用，包括问答，总结和故事生成。
kotaemon(Oct 2024, 评估)
kotaemon 是一个基于检索增强生成（RAG）的开源工具和框架，用于构建针对知识库文档的问答应用程序。它可以理解多种文档格式，包括 PDF 和 DOC，并提供基于Gradio 的 Web 用户界面，用户可以通过聊天界面组织和互动知识库。kotaemon 具有内置的 RAG 流水线，并集成了向量存储，且可以通过 SDK 进行扩展。它的回答中还引用了来源文档，提供网页内联预览和相关性评分。对于想要构建基于 RAG 的文档问答应用程序的用户来说，这个可定制的框架是一个非常好的起点。
DeepEval(Oct 2024, 评估)
DeepEval 是一个基于 Python 的开源评估框架，用于评估大语言模型（LLM）的性能。你可以使用它评估使用流行框架（如LlamaIndex 或LangChain构建的检索增强生成（RAG）和其他类型的应用程序，也可以用于基准测试和对比不同模型，以满足你的需求。DeepEval 提供了一个全面的指标和功能套件，用于评估 LLM 的表现，包括幻觉检测、答案相关性和超参数优化。它支持与 pytest 的集成，结合其断言功能，你可以轻松地将测试套件集成到持续集成（CI）管道中。如果你正在使用 LLM，建议尝试 DeepEval 来改进测试流程，确保你的应用程序的可靠性。
Bruno(Oct 2024, 采纳)
Bruno是一个用于 API 测试、开发和调试的开源桌面工具，类似于 Postman 和 Insomnia 。它旨在通过简单的离线设计提供更卓越的协作、隐私和安全性。集合直接存储在您的文件系统中，采用自定义的纯文本标记语言 Bru Lang 编写，可以通过 Git 或您选择的版本控制工具进行共享以便协作。Bruno 既可作为桌面应用程序使用，也可作为 CLI tool。它还提供了官方的 VS Code 扩展，并计划支持其他 IDE。Bruno 已成为多支 Thoughtworks 团队的默认选择，但我们也建议团队在 VPN 和代理环境下工作时保持警惕，因为在这些情况下发出的请求 可能会意外失败。
Bruno(Apr 2024, 试验)
Bruno 是Postman 和Insomnia 的开源桌面替代品，用于 API 的测试、开发和调试。它将测试集合保存在本地，因此可以使用 Git 或其他版本控制工具来进行协作。目前有一些 Thoughtworks 团队正在使用 Bruno，他们喜欢它简单并且仅支持离线使用的设计。
Slint(Oct 2024, 评估)
Slint 是一个声明式的 GUI 框架，用于为 Rust、C++ 或 JavaScript 应用程序构建原生用户界面。尽管它是一个多平台的 UI 框架，拥有实时预览、响应式 UI 设计、VS Code 集成 和原生用户体验等重要特性，但我们特别想强调它在嵌入式系统中的实用性。开发嵌入式应用程序的团队经常会面临有限的 UI 开发选项，并且每个选项都有其权衡之处。Slint 在开发者体验和性能之间提供了完美的平衡，它使用类似 HTML 的易用标记语言，并可以直接编译为机器代码。在运行时，它还具有低资源占用的优势，这对于嵌入式系统至关重要。简而言之，我们喜欢 Slint，因为它将 web 和移动开发中经过验证的实践引入到了嵌入式生态系统中。
Databricks Asset Bundles(Oct 2024, 试验)
Databricks Asset Bundles (DABs)，于 2024 年 4 月 实现基本可用，正逐渐成为打包和部署 Databricks 资产的首选工具，帮助我们的数据团队应用软件工程实践。DABs 支持将工作流和任务的配置以及要在这些任务中执行的代码打包成一个 bundle，并通过 CI/CD 管道部署到多个环境中。它提供了常见资产类型的模板，并支持自定义模板，这使得能够为数据工程和机器学习项目创建定制服务模版。我们的团队越来越多地将其作为工程工作流中的关键部分。尽管 DABs 包含了针对 notebooks 的模板，并支持将 notebooks 部署到生产环境中，我们并不推荐 生产化 notebooks ，而是鼓励有意地编写符合生产标准的代码，以支持此类工作负载的可维护性、可靠性和可扩展性需求。
Databricks Asset Bundles(Apr 2024, 评估)
Databricks 最近发布了 Databricks Asset Bundles (DABs) 的 公开预览版，它包含在 Databricks CLI 0.205 及更高版本中，正成为打包 Databricks 资源进行源代码控制、测试和部署的官方推荐方式。DABs 在我们的团队中逐渐取代了 dbx。DABs 支持将工作流、作业和任务的配置以及要在这些任务中执行的代码打包成一个可以部署到多个环境的捆绑包。它附带了常见资产类型的模板，并支持自定义模板。虽然 DABs 包含笔记本模板并支持将它们部署到生产环境，但我们仍然建议不要将 笔记本用于生产环境，而是鼓励有意地编写生产代码，并采用支持此类工作负载的可维护性、弹性和可扩展性的工程实践。
Flutter for Web(Oct 2024, 评估)
Flutter 以其对 iOS 和 Android 应用程序的跨平台支持而闻名。现在，它已经扩展到更多的平台。我们之前评估过 Flutter for Web — 它允许我们从同一代码库构建适用于 iOS、Android 和浏览器的应用程序。并不是每个网页应用都适合使用 Flutter，但我们认为 Flutter 特别适合诸如 progressive web apps、single-page apps 和将现有 Flutter 移动应用转换为网页的情况。Flutter 已经支持 WebAssembly (WASM) 作为其实验性频道中的编译目标，这意味着它正在积极开发中。最近的版本已使其潜在漏洞和性能风险较为稳定。编译到 WASM 目标的 Flutter 网页应用的性能远超其 JavaScript 编译目标。不同平台上的近原生性能也是许多开发者最初选择 Flutter 的原因之一。
Flutter for Web(Apr 2021, 评估)
到目前为止，Flutter主要支持iOS和Android原生应用。但是Flutter团队的愿景是让Flutter支持在任何平台上构建应用。 Flutter for Web 朝此方向迈出了一步，让我们能够基于同一代码库构建适用于iOS、Android和浏览器的应用。它的测试版在一年前已处于可用状态，而随着最近Flutter 2.0版本的发布，Flutter for Web迎来了一个稳定的里程碑版本。在此版本中，Flutter团队专注于渐进式Web应用、单页面应用，以及将现有的移动应用扩展到Web平台。它的应用和框架代码（全部基于Dart）也被编译为JavaScript，而非用于移动应用的ARM机器码。 Flutter的Web引擎为我们提供了两种渲染器：使用HTML，CSS，Canvas和SVG的HTML渲染器，以及使用WebAssembly和WebGL将Skia绘制命令展现到浏览器canvas的CanvasKit渲染器。我们有一些团队已经开始使用Flutter for Web，并对试用结果表示满意。
Testcontainers(Oct 2024, 采纳)
在我们的经验中，Testcontainers 是创建可靠测试环境的一个有效默认选项。它是一个移植到多种语言的库，可以将常见的测试依赖项进行 Docker 化——包括各种类型的数据库、队列技术、云服务以及像网页浏览器这样的 UI 测试依赖项，并能够在需要时运行自定义 Dockerfile。最近发布了一个 桌面版本，允许对测试会话进行可视化管理，并能够处理更复杂的场景，这对我们的团队非常有用。
Testcontainers(Mar 2022, 采纳)
根据长期使用 Testcontainers 的经验，我们认为它是创建可靠的环境来运行自动化测试的默认选项。 Testcontainers 是一个拥有多种语言版本 的库，并且 docker 化了常见的测试依赖——包括了不同种类的数据库，队列技术，云服务和 UI 测试依赖（例如 web 浏览器），还具有按需运行自定义 Dockerfile 的能力。它与类似 JUnit 的测试框架兼容，而且足够灵活，可以让用户管理容器的生命周期和高级网络，并迅速建立一个集成测试环境。我们的团队一直认为这个可编程的、轻量级的、一次性的容器库可以使功能测试更加可靠。
Testcontainers(Nov 2019, 评估)
随着现代系统的组件依赖数量不断增加，如何创建可靠的环境来运行自动化测试成为了一个反复出现的问题。Testcontainers是一个Java库，它通过在测试中施行容器化的依赖管理来缓解这一问题。这对于扩展可重复的数据库实例或类似的基础结构特别有用，同时它也可以在Web浏览器中用于UI测试。我们的团队发现利用此库提供的可编程、轻量且一次性的容器，集成测试会变得更加可靠。
GCP Vertex AI Agent Builder(Oct 2024, 试验)
GCP Vertex AI Agent Builder 提供了一个灵活的平台，可以通过自然语言或代码优先的方式创建 AI 代理。该工具通过第三方连接器无缝集成企业数据，并且拥有构建、原型设计和部署 AI 代理所需的全部工具。随着对 AI 代理需求的增加，许多团队在理解其优势和实施上面临困难。GCP Vertex AI Agent Builder 使开发者能够更快地进行代理的原型设计，并以最小的设置处理复杂的数据任务。我们的开发者发现它特别适用于构建基于代理的系统，例如知识库或自动化支持系统，这些系统可以高效地管理结构化和非结构化数据。因此，这是一款开发 AI 驱动解决方案的有价值工具。
Spinnaker(Oct 2024, 试验)
Spinnaker 是由 Netflix 创建的一个开源持续交付平台。它将集群管理和云端烘焙镜像的部署作为核心功能。我们喜欢 Spinnaker 对微服务部署的特定做法。在之前的版本中，我们提到了缺乏将流水线配置为代码的能力，但这一问题已通过添加 spin CLI 得到解决。尽管我们不建议在简单的持续交付场景中使用 Spinnaker，但在复杂的情况和同样复杂的部署管道中，它已经成为许多人的首选工具。
Spinnaker(Nov 2017, 评估)
Netflix has open sourced Spinnaker, its microservices continuous delivery (CD) platform. Compared to other CI/CD platforms, Spinnaker implements cluster management and deployment of baked images to the cloud as first-class features. It supports out-of-the-box deployment and cluster management for multiple cloud providers such as Google Cloud Platform, AWS and Pivotal Cloud Foundry. You can integrate Spinnaker with Jenkins to run a Jenkins job build. We like Spinnaker's opinionated approach for deploying microservices to the cloud—with the exception that Spinnaker's pipelines are created via a user interface (UI) and cannot be configured as code.
Spinnaker(Mar 2017, 评估)
Netflix has open sourced Spinnaker, its microservices continuous delivery (CD) platform. Compared to other CI/CD platforms, Spinnaker implements cluster management and deployment of baked images to the cloud as first-class features. It supports out-of-the-box deployment and cluster management for multiple cloud providers such as Google Cloud Platform, AWS and Pivotal Cloud Foundry. You can integrate Spinnaker with Jenkins to run a Jenkins job build. We like Spinnaker's opinionated approach for deploying microservices to the cloud—with the exception that Spinnaker's pipelines are created via a user interface (UI) and cannot be configured as code.
AI 团队助手(Oct 2024, 评估)
AI 编码辅助工具通常是在帮助和增强个人贡献者的工作方面被讨论的。然而，软件交付始终是团队合作的过程，因此您应该寻找创建 AI 团队助手 的方法，以帮助形成 10 倍效能的团队，而不是一群 AI 辅助孤立的 10x 工程师。幸运的是，最近工具市场的发展让我们更接近于实现这一目标。 Unblocked 是一个将团队的所有知识来源汇聚在一起，并智能地整合到团队成员工具中的平台。而 Atlassian 的 Rovo 则将 AI 引入最广泛使用的团队协作平台，为团队提供新的搜索类型和访问其文档的方式，并通过 Rovo 代理解锁新的自动化和软件实践支持方式。在我们等待市场在这个领域进一步发展的同时，我们自己也在探索 AI 在知识增强和团队实践支持方面的潜力：我们开源了我们的 Haiven 团队助手，并开始收集与 非编码任务（如需求分析）相关的 AI 辅助 的学习经验。
AI 团队助手(Apr 2024, 评估)
像GitHub Copilot这样的 AI 编码辅助工具目前主要是在帮助和增强个人工作的背景下讨论的。然而，软件交付仍然是团队工作，并将始终是团队工作，因此你应该寻找创建 AI 团队助理 的方法来帮助创建“10 倍团队”，而不是一群孤立的 AI 辅助的10 倍工程师。我们已经开始使用一种团队辅助方法，通过结合提示和知识源来增强知识放大、技能提升和对齐。标准化的提示有助于在团队环境中使用已经达成共识的最佳实践，例如编写用户故事的技术和模板，或实施威胁建模等实践。除了提示之外，通过检索增强生成提供的知识源，可以从组织指南或行业特定的知识库中提供与上下文相关的信息。这种方法使团队成员能够及时获得他们需要的知识和资源。
语义路由(Oct 2024, 评估)
在构建基于 LLM 的应用时，将请求路由到特定代理或触发某一流程之前，确定用户意图是至关重要的。Semantic Router 充当 LLM 和代理之间的快速决策层，基于语义意义进行高效且可靠的请求路由。通过使用向量嵌入推断意图，Semantic Router 减少了不必要的 LLM 调用，提供了一种更加简洁、具有低成本的用户意图理解方式。它的潜力不仅限于意图推断，还可以作为各种语义任务的多功能构建模块。它的响应速度和灵活性使其在需要避免 LLM 带来的额外开销，快速实时决策的环境中成为强有力的竞争者。
JetBrains AI Assistant(Oct 2024, 评估)
JetBrains AI Assistant是一款为所有JetBrains IDE 提供支持的编码助手，旨在顺畅集成以支持代码补全、测试生成和风格指南遵循。它基于 OpenAI 和Google Gemini 等模型，因其能够记住编码风格并在后续会话中保持一致性输出而脱颖而出。我们的开发人员发现其测试生成功能特别有用，并指出它在处理较长输出时没有稳定性问题。然而，与一些竞争对手不同，JetBrains 没有托管自己的模型，这对于担心第三方数据处理的客户可能并不适用。尽管如此，该工具与 JetBrains IDE 的集成使其成为探索 AI 驱动编码助手的团队的一个有前景的选择。
pgvector(Oct 2024, 试验)
pgvector 是一个开源的 PostgreSQL 扩展，用于进行向量相似性搜索，允许将向量与结构化数据一起存储在单一且成熟的数据库中。虽然它缺少一些专用向量数据库的高级功能，但它受益于 PostgreSQL 的 ACID 合规性、时间点恢复等强大功能。随着生成式 AI 驱动的应用程序的兴起，我们看到越来越多的模式是存储并有效搜索嵌入向量以进行相似性匹配，pgvector 有效地解决了这一需求。pgvector 在生产环境中的使用日益增多，尤其是在团队已经使用云提供商管理的 PostgreSQL 时，它表现出能够满足常见向量搜索需求，而无需单独的向量存储库。我们的团队在对比结构化和非结构化数据的项目中发现了它的价值，展示了其广泛采用的潜力，因此我们将其移动到试验环（Trial ring）。
pgvector(Sep 2023, 评估)
随着生成式人工智能应用的兴起，我们观察了一种储存和有效搜索嵌入 (embeddings) 向量相似性的模式。pgvector 是一个用于 PostgreSQL 的开源向量相似性搜索插件。我们非常喜欢它，因为它能够让我们在 PostgreSQL 中搜索 embeddings，而无需仅为了相似性搜索而将数据转移到另一个存储中。尽管目前已有几个专门的向量搜索引擎，但我们还是希望你能评估一下 pgvector。
Devbox(Oct 2024, 试验)
尽管开发工具不断进步，保持一致的本地开发环境仍然是许多团队面临的挑战。为新工程师进行入职设置通常需要运行命令或自定义脚本，而这些操作可能会在不同机器上不可预测地失败，导致环境不一致。为了解决这个问题，我们的团队越来越依赖Devbox。Devbox 是一个命令行工具，提供了简洁的界面，用于创建可复现的、按项目定义的本地开发环境，它利用了 Nix 包管理器，但不使用虚拟机或容器。Devbox 极大地简化了团队的入职流程，因为一旦为代码库配置好环境，在新设备上只需一个 CLI 命令(devbox shell)就能复现已定义的环境。Devbox 支持 shell 钩子、自定义脚本以及生成 devcontainer.json，以便与 VSCode 集成。
Devbox(Sep 2023, 试验)
Devbox是一款基于终端的工具，具有便捷易用的界面，用于创建可重用，项目独立的开发环境，Devbox 利用 Nix 软件包管理器，而无需使用虚拟机或容器。我们的团队使用它消除不同项目的开发环境中 CLI 工具和自定义脚本的版本与配置不匹配的问题，以及标准化管理项目中不同语言包的提供。我们发现 Devbox 显著简化了项目入门流程，只要代码库配置了该工具，只需运行一个 CLI 命令（devbox shell）就能将开发环境配置到新机器上。Devbox 支持 shell 钩子、自定义脚本和生成便于集成 VSCode 的 devcontainer.json 。
Devbox(Apr 2023, 评估)
Devbox 提供了易上手的界面，它利用 Nix 包管理器为每个项目创建可重现的开发环境。我们的团队使用它来消除开发环境中的版本和配置不匹配的问题，同时团队成员也喜欢它的易用性。Devbox 支持 shell hooks、自定义脚本和 devcontainer.json 生成，以便与 VSCode 集成。
企业范围的集成测试环境(Oct 2024, 暂缓)
创建 企业范围的集成测试环境 是一种常见且浪费的做法，会拖慢整个开发流程。这些环境往往成为难以复制的珍贵资源，成为开发的瓶颈。由于不同环境之间不可避免的数据和配置开销差异，它们还会提供一种虚假的安全感。讽刺的是，常见的对替代方案（如临时环境或多个本地测试环境）的反对意见是成本问题。然而，这种观点未能考虑到企业级集成测试环境所造成的延迟成本，因为开发团队往往需要等待其他团队完成任务或等待依赖系统的新版本部署。相反，团队应使用临时环境，最好是开发团队拥有的一系列测试，这些测试可以快速创建和销毁，使用替身(fake stubs)而不是实际的副本。关于支持这种替代方案的其他技术，可以查看 契约测试、将部署和发布解耦、关注平均恢复时间 和在生产环境测试。
企业范围的集成测试环境(Nov 2017, 暂缓)
When the enterprise-wide quarterly or monthly releases were considered best practice, it was necessary to maintain a complete environment for performing testing cycles prior to deployment to production. These enterprise-wide integration test environments (often referred to as SIT or Staging) are a common bottleneck for continuous delivery today. The environments themselves are fragile and expensive to maintain, often with components that need manual configuration by a separate environment management team. Testing in the staging environment provides unreliable and slow feedback, and testing effort is duplicated with what can be performed on components in isolation. We recommend that organizations incrementally create an independent path to production for key components. Important techniques include contract testing, decoupling deployment from release, focus on mean time to recovery and testing in production.
企业范围的集成测试环境(Mar 2017, 暂缓)
When the enterprise-wide quarterly or monthly releases were considered best practice, it was necessary to maintain a complete environment for performing testing cycles prior to deployment to production. These enterprise-wide integration test environments (often referred to as SIT or Staging) are a common bottleneck for continuous delivery today. The environments themselves are fragile and expensive to maintain, often with components that need manual configuration by a separate environment management team. Testing in the staging environment provides unreliable and slow feedback, and testing effort is duplicated with what can be performed on components in isolation. We recommend that organizations incrementally create an independent path to production for key components. Important techniques include contract testing, decoupling deployment from release, focus on mean time to recovery and testing in production.
LLM Guardrails(Oct 2024, 试验)
LLM Guardrails 是一套用于防止大语言模型（LLMs）生成有害、使人误解或不相关内容的指南、政策或过滤器。Guardrails 也可用于保护 LLM 应用免受恶意用户通过操纵输入等技术对其滥用。它们通过为模型设定边界来作为安全网，确保内容的处理和生成在可控范围内。在这一领域中，诸如 NeMo Guardrails 、Guardrails AI 和 Aporia Guardrails 等框架已经逐渐崭露头角，并被我们的团队认为非常有用。我们建议每个 LLM 应用都应设置相应的安全护栏，并且不断改进其规则和政策。这对于构建负责任和值得信赖的 LLM 聊天应用至关重要。
Mockoon(Oct 2024, 评估)
Mockoon 是一个开源的 API 模拟工具。它具有直观的界面、可自定义的路由和动态响应功能，还可以自动创建模拟数据集。Mockoon 兼容 OpenAPI，允许生成不同的场景，能够在本地进行测试并与开发流水线集成。你还可以创建“部分模拟”，通过拦截请求，仅模拟 Mockoon 中定义的调用。这部分模拟有助于模拟特定的 API 路由或端点，并将其他请求转发到实际的服务器。部分模拟在某些场景下非常有用，但存在滥用风险，可能导致不必要的复杂性。除此之外，Mockoon 仍然是快速搭建模拟 API、改进和自动化开发流程的宝贵工具。
微调嵌入模型(Oct 2024, 试验)
在构建基于 检索增强生成（RAG）的大语言模型应用时，嵌入的质量直接影响到相关文档的检索和响应质量。 微调嵌入模型 可以提高特定任务或领域嵌入的准确性和相关性。我们的团队在开发领域特定的大语言模型应用时进行了嵌入微调，因为精确的信息提取至关重要。然而，当你 急于微调 嵌入模型之前，请仔细权衡这种方式。
SpinKube(Oct 2024, 评估)
SpinKube 是一个在 Kubernetes 上运行的开源无服务器（serverless）WebAssembly 运行时。虽然 Kubernetes 提供了强大的自动扩展能力，但容器的冷启动时间仍然可能需要预先配置以应对高峰负载。 我们认为，WebAssembly 的毫秒级启动时间为按需工作负载提供了更加动态和灵活的无服务器（serverless）解决方案。 自从我们上次讨论 Spin 以来， WebAssembly 生态系统已经取得了显著的进展。我们很高兴推荐 SpinKube 这一平台，它简化了在 Kubernetes 上基于 WebAssembly 工作负载的开发和部署过程。
Databricks Unity Catalog(Oct 2024, 试验)
Databricks Unity Catalog 是一种用于数据治理的解决方案，适用于在lakehouse 中的资产，例如文件、表或机器学习模型。它是开源 Unity Catalog的托管版本，可用于管理和查询存储在外部存储或由 Databricks 管理的数据。过去，我们的团队使用了多种数据管理解决方案，如 Hive metastore或 Microsoft Purview。然而，Unity Catalog 对治理、元数据存储管理和数据发现的综合支持，使其颇具吸引力，因为它减少了管理多个工具的需求。我们团队发现的一个问题是 Databricks 托管的 Unity Catalog 缺乏自动灾难恢复功能。虽然他们能够自行配置备份和恢复功能，但由 Databricks 提供的解决方案会更加便捷。需要注意的是，虽然这些治理平台通常会实施集中化的解决方案，以确保工作空间和工作负载之间的一致性，但可以通过让各个团队管理自己的资产，将治理责任下放，从而实现联邦化的治理模式。
Databricks Unity Catalog(Oct 2022, 评估)
Databricks Unity Catalog 是一种可以用于 lakehouse 中文件、表或者机器学习模型等资产的数据治理方案。尽管你可以在企业数据治理领域中找到很多平台，但如果你已经在使用其他 Databricks 解决方案，那你更应该了解一下 Unity Catalog。我们想强调的是，虽然这些治理平台通常会采用一个集中式的解决方案，以更好地维持不同工作空间和工作负载的一致性，但治理责任应该通过使各个团队分别治理自己的资产而统一起来。
Microsoft Autogen(Oct 2024, 评估)
Microsoft Autogen是一个开源框架，旨在简化 AI 代理的创建和编排，支持多个代理协作解决复杂任务。它支持自动化和人机协作的工作流程，并兼容多种大语言模型（LLMs）和代理交互工具。我们的一个团队曾在为客户构建的 AI 驱动平台中使用 Autogen，每个代理代表一种特定技能，如代码生成、代码审查或文档摘要。该框架使团队能够通过定义正确的模型和工作流程，轻松且一致地创建新代理。他们还利用LlamaIndex 编排工作流程，使代理能够有效管理产品搜索和代码建议等任务。尽管 Autogen 在生产环境中展示了潜力，尤其在代理的扩展性和复杂性管理上仍有待评估，以确保其在扩展代理系统时的长期可行性。
Kedro(Oct 2024, 试验)
Kedro 作为 MLOps 工具有了显著的改善，并始终保持对模块化和工程实践的关注，这一点是我们从一开始就非常喜欢的。突出其模块化的一步是推出了独立的 kedro-datasets 包，该包将代码与数据解耦。Kedro 在其命令行接口、起始项目模板和遥测功能方面进行了增强。 此外，最近发布的 VS Code 扩展对开发者体验也是一个很好的提升。
Kedro(Oct 2020, 评估)
过去我们讨论过在数据科学项目中应用好的工程实践的改进 工具 。Kedro 是另一个很好的补充。它是用于数据科学项目的开发工作流框架，为构建生产用数据和机器学习管道带来了标准化的方法。我们很欣赏其对软件工程实践和良好设计的关注，它强调测试驱动开发、模块化、版本控制以及良好的代码实践，比如将凭证排除在代码库之外。
Qdrant(Oct 2024, 试验)
Qdrant 是一个开源的向量相似度搜索引擎和数据库，使用Rust编写。它支持多重文本和多模态密集 向量嵌入模型。我们的团队使用了诸如MiniLM-v6 和 BGE 等开源嵌入模型,将其应用于多的产品知识库中。我们把 Qdrant 作为一个企业级 Vector Store 使用，利用多租户 技术将向量嵌入存储为独立的集合，从而隔离不同产品的知识库。用户访问策略则在应用层中进行管理。
Qdrant(Apr 2024, 评估)
Qdrant 是一个使用Rust 实现的开源向量数据库。 在 2023 年 9 月的数据雷达中, 我们提到过pgvector, 一个基于 PostgreSQL 的插件，可用于向量搜索。 然而，如果你需要在多个节点之间横向扩展向量数据库，我们建议考虑一下 Qdrant。 它内置的单指令/多数据 （SIMD）加速支持可提升搜索表现，它还能帮助你将 JSON 格式的负载（payload）与向量关联起来。
Mise(Oct 2024, 评估)
在多语言环境中工作的开发人员经常发现自己需要管理多个不同语言和工具的版本。 mise旨在解决这个问题，提供一个工具来替代 nvm, pyenv、pyenv、rbenv、rustup 等工具，并且可以作为 asdf的直接替代品。Mise 是用 Rust 编写的，以提高 shell 交互的速度；与使用基于 shell 的 shim 的 asdf 不同，mise 预先修改 PATH 环境变量，从而直接调用工具运行时。这也是 mise 比 asdf 更快的部分原因。对于那些已经熟悉 asdf 的开发人员，mise 提供了相同的功能，但有一些关键区别。由于是用 Rust 编写的，mise 更快，并且拥有一些 asdf 所没有的功能，例如能够同时安装同一工具的多个版本，以及更宽容的命令，包括模糊匹配。它还提供了一个集成的任务运行器，方便执行代码检查、测试、构建、服务器和其他与项目相关的任务。如果您厌倦了使用多个工具来管理开发环境，并且对其他工具有时笨拙的语法感到不满，那么 mise 绝对值得一试。
CAP(Oct 2024, 试验)
CAP 是一个实现了 Outbox 模式 的 .NET 库。 在使用 RabbitMQ 或 Kafka 等分布式消息系统时，我们经常面临确保数据库更新和事件发布按原子性执行的挑战。CAP 通过在引发事件的同一个数据库事务中记录事件发布的意图，解决了这一问题。我们发现 CAP 非常实用，它支持多种数据库和消息平台，并确保至少一次的消息投递。
视觉回归测试工具(Oct 2024, 采纳)
我们之前强调过 视觉回归测试工具 ，并观察到它们的算法从原始的像素级比较进化到更复杂的模式匹配和光学字符识别（OCR）。早期的视觉回归工具产生了很多误报，只有在界面稳定的后期开发阶段才有用。BackstopJS 通过配置选择器和视口来定位页面上的特定元素进行视觉测试，避免了这个问题。但机器学习使得检测和比较视觉元素更加准确，即使在这些元素移动或包含动态内容的情况下。这些工具变得越来越有用，并且具备利用 AI 和机器学习最新进展的优势。现在，几个商业工具，如 Applitools 和Percy ，声称在其视觉回归测试中使用了 AI。我们的一支团队广泛使用了 Applitools Eyes，并对结果感到满意。尽管视觉回归测试不能替代编写良好的端到端功能测试，但它们是测试工具箱中的一个宝贵补充。我们正积极推动它们的采用，因为它们已经成为全面 UI 测试策略中的一个安全默认选项。
视觉回归测试工具(May 2020, 试验)
自我们在2014年第一次提及 视觉回归测试工具 以来，这项技术已经得到了广泛的应用，工具的前景也得到了发展。BackstopJS 仍然是一个很好的选择，它会定期添加新特性，包括支持在 Docker 容器中运行。在上期技术雷达中我们精选出了 Loki。SaaS 解决方案则有 Applitools、CrossBrowserTesting 和 Percy。另一个值得一提的工具是 Resemble.js，一个图像比较库。尽管许多团队只是间接地把它作为 BackstopJS 的一部分来使用，我们的一些团队已经直接使用它来分析比较网页中的图片了。总之，我们的经验表明，在界面发生重大变化的早期阶段，视觉回归工具的用处不大，但是随着产品的成熟和界面的稳定，它们肯定会证明自己的价值。
视觉回归测试工具(Jul 2014, 试验)
Growing complexity in web applications has increased the awareness that appearance should be tested in addition to functionality. This has given rise to a variety of visual regression testing tools, including CSS Critic, dpxdt, Huxley, PhantomCSS, and Wraith. Techniques range from straightforward assertions of CSS values to actual screenshot comparison. While this is a field still in active development we believe that testing for visual regressions should be added to Continuous Delivery pipelines.
Raycast(Oct 2024, 评估)
Raycast 是一款适用于 macOS 的启动器，允许你通过键盘快速启动应用程序、运行命令、搜索文件并自动化任务。我们的团队认为其针对开发者的开箱即用功能非常有价值，并且它的扩展非常简单，允许与第三方应用和服务，如 VSCode、Slack、Jira 和 Google 等，进行交互。Raycast 专为提高生产力设计，减少上下文切换，是希望简化日常任务的用户的有用工具。专业版用户还可以使用 Raycast AI，这是一款专门的 AI 驱动搜索助手。
LLMLingua(Oct 2024, 评估)
LLMLingua 通过使用小型语言模型压缩提示，去除非必要的 token，从而提高大语言模型（LLM）的效率，并在性能损失最小的情况下实现这一目标。 这种方法使大语言模型（LLM）能够在有效处理较长提示的同时，保持推理和上下文学习能力，解决了成本效率、推理延迟和上下文处理等挑战。LLMLingua 与各种大语言模型兼容，无需额外训练，并支持如 LLamaIndex 等框架，它非常适合优化大语言模型的推理性能。
ROS 2(Oct 2024, 试验)
ROS 2是一个为开发机器人系统设计的开源框架。它提供了一套用于模块化实现应用程序的库和工具，涵盖了诸如进程间通信、多线程执行和服务质量等功能。ROS 2 在其前任的基础上进行了改进，提供了更好的实时性能、更高的模块化、对多种平台的支持以及合理的默认设置。ROS 2 在汽车行业正在获得越来越多的关注；它基于节点的架构和基于主题的通信模型，特别适合那些具有复杂且不断发展的车载应用（如自动驾驶功能）的制造商。
Instructor(Oct 2024, 试验)
当我们作为终端用户使用大语言模型（LLM）聊天机器人时，它们通常会返回给我们一个非结构化的自然语言答案。在构建超越聊天机器人的生成 AI 应用时，请求 LLM 以 JSON、YAML 或其他格式返回结构化答案并在应用中解析和使用该响应可能非常有用。然而，由于 LLM 是非确定性的，它们可能并不总是按照我们要求的方式执行。Instructor 是一个可以帮助我们请求 从 LLMs 获取结构化输出 的库。您可以定义预期的输出结构，并在 LLM 未返回您要求的结构时配置重试。由于与 LLM 进行交互时，最佳的终端用户体验往往是将结果流式传输给他们，而不是等待完整响应，Instructor 还可以处理从流中解析部分结构的任务。
Score(Oct 2024, 评估)
许多实施自己内部开发平台的组织倾向于创建自己的 平台编排 系统，以在开发人员与其平台托管团队之间强制执行组织标准。然而，针对安全、一致和合规地托管容器工作负载的铺路平台的基本功能在不同组织之间是相似的。如果我们有一种共享语言来指定这些要求，那该多好呢？Score在这一领域显示出了成为标准的潜力。它是一种以 YAML 形式编写的声明性语言，描述了容器化工作负载的部署方式，以及其运行所需的特定服务和参数。Score 最初由 Humanitec 开发，作为其 平台编排者 产品的配置语言，但现在作为一个开源项目由 云原生计算基金会 (CNCF) 进行管理。在 CNCF 的支持下，Score 有潜力在 Humanitec 产品之外得到更广泛的使用。它已经发布了两个参考实现：Kubernetes 和 Docker Compose。Score 的可扩展性希望能够促使社区对其他平台的贡献。Score 确实与 Kubevela 的开放应用模型 (OAM) 规范相似，但它更专注于容器工作负载的部署，而不是整个应用程序。与SST也有一些重叠，但 SSI 更关注直接部署到云基础设施，而不是内部工程平台。我们对 Score 的发展保持关注。
Iroh(Oct 2024, 评估)
Iroh 是一个相对较新的分布式文件存储和内容交付系统，旨在作为现有去中心化系统，如IPFS (InterPlanetary File System)的演进。Iroh 和 IPFS 都可以用来创建去中心化网络，以存储、共享和访问使用不透明内容标识符寻址的内容。然而，Iroh 去掉了 IPFS 的一些实现限制 ，例如没有最大区块大小，并通过对文档进行基于范围的集合重整 提供数据同步机制。该项目的路线图包括通过 WASM 将技术带入浏览器，这为在 Web 应用程序中构建去中心化带来了令人兴奋的可能性。如果您不想自己托管 Iroh 节点，可以使用其云服务 iroh.network。目前已经有多个 SDK 可供多种语言使用，其目标是比替代的 IPFS 系统更具用户友好性和易用性。尽管 Iroh 仍处于早期阶段，但值得关注，因为它有可能成为去中心化存储领域的重要参与者。
CocoaPods(Oct 2024, 暂缓)
CocoaPods 一直是 Swift 和 Objective-C Cocoa 项目中广受欢迎的依赖管理工具。然而，CocoaPods 团队宣布，该项目在作为 iOS 和 macOS 开发者关键工具超过十年后，进入了维护模式。尽管工具和其资源仍将继续可用，但将不再进行主动开发。其鼓励开发者们转向 Swift Package Manager，它与 Xcode 原生集成，并且获得了来自苹果的更好的长期支持。
1%金丝雀(Oct 2024, 采纳)
多年来，我们一直采用 金丝雀发布 的方法，鼓励用户对新软件版本提供早期反馈，同时通过逐步向选定用户推出更新来降低风险。 1% 金丝雀 是一种有效的技术，我们将新功能推出给一个非常小的用户群体（比如说 1%），这些用户是从不同类别中精心挑选的。这使团队能够快速获取用户反馈，并观察新版本对性能、稳定性等方面的影响，必要时进行学习和调整。这一技术在团队向移动应用程序或一系列设备（如边缘计算设备或软件定义汽车）推出软件更新时尤为重要。通过适当的可观察性和早期反馈，它能够在生产环境中遇到意外情况时限制影响范围。虽然金丝雀发布有助于更快地获取用户反馈，但我们认为从小部分用户开始测试是必要的，以降低大规模功能发布的风险并控制其影响。
1%金丝雀(Nov 2018, 试验)
Fast feedback is one of our core values for building software. For many years, we've used the canary release approach to encourage early feedback on new software versions, while reducing the risk through incremental rollout to selected users. One of the questions regarding this technique is how to segment users. Canary releases to a very small segment (say 1%) of users can be a catalyst for change. While starting with a very small segment of users enables teams to get comfortable with the technique, capturing fast user feedback enables diverse teams to observe the impact of new releases and learn and adjust course as necessary—a priceless change in engineering culture. We call this, the mighty 1% canary.
Azure AI Search(Oct 2024, 评估)
Azure AI Search，前称 Cognitive Search，是一个云端搜索服务，专为处理结构化和非结构化数据而设计，适用于知识库等应用场景，尤其适用于检索增强生成 (RAG) 设置。它支持多种搜索方式，包括关键字搜索、向量搜索和混合搜索，我们认为这些功能将变得越来越重要。该服务可以自动导入常见的非结构化数据格式，例如 PDF、DOC 和 PPT，从而简化创建可搜索内容的流程。此外，它还与其他 Azure 服务集成，如 Azure OpenAI，使用户能够以最少的手动集成工作构建应用程序。根据我们的经验，Azure AI Search 性能可靠，非常适合在 Azure 环境中托管的项目。通过其定制技能，用户还可以定义特定的数据处理步骤。总体而言，如果您在 Azure 生态系统中工作并需要为 RAG 应用构建强大的搜索解决方案，Azure AI Search 值得考虑。
Snapcraft 构建工具(Oct 2024, 试验)
Snapcraft 是一个开源的命令行工具，用于在 Ubuntu、其他 Linux 发行版和 macOS 上构建和打包名为 snaps 的自包含应用程序。Snaps 可以在包括 Linux 机器、虚拟环境和车辆车载计算机系统在内的硬件平台上轻松部署和维护。虽然 Snapcraft 提供了一个公共的 应用商店 用于发布 snaps，但我们的团队使用这个构建工具将自动驾驶系统打包为 snap，而不将其发布到公共应用商店。这使我们能够在本地构建、测试和调试嵌入式软件系统，同时将其发布到内部工件库。
ColPali(Oct 2024, 评估)
ColPali是一款新兴工具，利用 视觉语言模型实现 PDF 文档检索，旨在解决从包含图像、图表和表格的多媒体文档中提取数据的难题，这对于构建强大的检索增强生成 (RAG) 应用至关重要。与依赖文本嵌入或光学字符识别（OCR）技术的传统方法不同，ColPali 处理整页 PDF 文档，使用视觉 Transformer 创建嵌入，综合考虑文本和视觉内容。这种整体方法不仅提高了文档检索的效果，还增强了对为何检索到特定文档的推理能力，大大提升了 RAG 在数据丰富的 PDF 文档中的表现。我们已经在多个客户项目中测试了 ColPali，结果显示出很大的潜力，但该技术仍处于早期阶段。对于拥有复杂视觉文档数据的组织来说，值得考虑进行评估。
ReadySet(Oct 2024, 评估)
ReadySet 是一个适用于 MySQL 和 PostgreSQL 的缓存层。与依赖手动失效的传统缓存解决方案不同，ReadySet 利用数据库复制流来增量更新其缓存。通过部分视图物化，ReadySet 实现了比传统只读副本更低的尾延迟。ReadySet 与 MySQL 和 PostgreSQL 在协议上兼容，因此可以将其部署在数据库前，以横向扩展读取工作负载，而无需更改应用程序。
DSPy(Oct 2024, 评估)
如今，大多数基于语言模型的应用程序依赖于为特定任务手工调整的提示词模板。DSPy是一个用于开发此类应用程序的框架，采用了一种不同的方式，摒弃了直接的提示词工程。相反，它引入了围绕程序流程的更高级抽象（通过可以彼此叠加的 modules），以及优化的指标和用于训练/测试的数据。然后，它基于定义的指标优化提示和/或底层语言模型的权重。生成的代码库类似于使用PyTorch进行神经网络训练。我们认为这种方法很有新意，值得尝试。
可观察性 2.0(Oct 2024, 评估)
可观察性 2.0 代表了一种从传统的、分散的监控工具向统一方法的转变，它利用结构化的、高基数的事件数据存储在单一数据存储中。该模型捕捉丰富的、带有详细元数据的原始事件，为综合分析提供单一的真实来源。通过以原始形式存储事件，这种方法简化了关联性分析，支持实时和取证分析，并能够深入了解复杂的分布式系统。它允许高分辨率的监控和动态调查能力。可观察性 2.0 优先捕捉高基数和高维度数据，能够进行详细的检查而不会产生性能瓶颈。统一的数据存储减少了复杂性，提供了系统行为的连贯视图，并使可观察性实践与软件开发生命周期更加紧密地结合。
Langfuse(Oct 2024, 试验)
LLM（大型语言模型）像黑箱一样运作，非常难以确定它的行为。可观察性对于打开这个黑箱并理解 LLM 应用程序在生产环境中的运作至关重要。我们团队在使用 Langfuse 方面有过积极的体验，我们曾用它来观察、监控和评估基于 LLM 的应用程序。它的追踪、分析和评估能力使我们能够分析完成性能和准确性，管理成本和延迟，并理解生产使用模式，从而促进持续的数据驱动改进。仪器数据提供了请求-响应流和中间步骤的完整可追溯性，这可以作为测试数据，在部署新变更之前验证应用程序。我们已将 Langfuse 与 RAG（检索增强生成） 等 LLM 架构，以及 大语言模型驱动的自主代理 一起使用。 例如，在基于 RAG 的应用程序中，分析低评分的对话追踪有助于识别架构的哪个部分（如预检索、检索或生成）需要改进。当然，在这一领域，另一个值得考虑的选项是 Langsmith。
Langfuse(Apr 2024, 评估)
Langfuse 是一个用于观察、测试和监控大语言模型应用的工程平台。其 SDK 支持 Python、JavaScript 和 TypeScript，以及其他语言框架，如 OpenAI、LangChain和LiteLLM。用户可以自行托管开源版本，也可以将其用作付费云服务。我们的团队在使用它调试复杂的 LLM 链、分析完成情况以及跨用户、会话、地理、功能和模型版本监控关键指标（如成本和延迟）方面体验良好。如果你希望构建基于数据驱动的大语言模型应用程序，Langfuse 是一个值得考虑的好选择。
Ragas(Oct 2024, 评估)
Ragas 是一个框架，旨在评估 检索增强生成 (RAG) 流水线的性能，解决了评估这些系统中检索和生成组件的挑战。它提供了结构化的指标，如可靠性、答案相关性和上下文利用率，这些指标有助于评估基于 RAG 系统的有效性。我们的开发者发现，它在运行定期评估以微调参数（如 top-k 检索和嵌入模型）时非常有用。一些团队将 Ragas 集成到每天运行的流水线中，以便在提示模板或模型发生变化时进行评估。虽然它的指标提供了可靠的见解，但我们担心该框架可能无法捕捉复杂 RAG 流水线的所有细微差别和复杂交互，因此建议考虑额外的评估框架。尽管如此，Ragas 在生产环境中简化 RAG 评估的能力使其脱颖而出，为数据驱动的改进提供了宝贵的支持。
Medusa(Oct 2024, 试验)
根据我们的经验，大多数用于构建购物网站的电子商务解决方案通常会陷入 80/20 陷阱，即我们可以轻松构建出 80% 的需求，但对于剩下的 20% 却无能为力。Medusa 提供了一个良好的平衡。它是一个高度可定制的开源商业平台，允许开发人员创建独特且量身定制的购物体验，可以自我托管或运行在 Medusa 的平台上。Medusa 基于 Next.js 和 PostgreSQL 构建，通过提供从基本购物车和订单管理到高级功能（如礼品卡模块和不同地区的税收计算）的全面模块，加快了开发过程。我们发现 Medusa 是一个有价值的框架，并在几个项目中应用了它。
Pingora(Oct 2024, 评估)
Pingora 是一个 Rust 搭建框架，旨在构建快速可靠可编程的网络服务。它最开始由 Cloudflare 开发用以解决 Nginx 的不足，Pingora 已展现出巨大的潜力，像River 这样的新型代理正是以 Pingora 为基础构建的。虽然我们大多数人无需面对 Cloudflare 级别的规模，但我们确实会遇到需要灵活的应用层路由的网络服务的场景。Pingora 的架构可以让我们在这些场景下充分利用 Rust 的强大能力，同时不牺牲安全性或性能。
LLM as a judge(Oct 2024, 试验)
许多我们构建的系统具有两个关键特征：一是能够根据大量数据集中的问题提供答案， 二是几乎不可能追踪到该答案的得出过程。尽管这些系统具有不透明性，我们仍然希望评估并提高其响应质量。通过 大语言模型(LLM)作为评判者 的模式，我们可以使用一个 LLM 来评估另一个系统的响应，这个系统可能本身也是基于 LLM 的。我们看到这种模式用于评估产品目录中搜索结果的相关性，以及判断基于 LLM 的聊天机器人是否在合理地引导用户。当然，评估系统必须经过仔细设置和校准。这种方法能够显著提高效率，从而降低成本。这是一个正在进行的研究领域，其现状可以在这篇文章 中找到总结。
Vespa(Oct 2024, 试验)
Vespa 是一个开源搜索引擎和大数据处理平台。它特别适合于需要低延迟和高吞吐量的应用。我们的团队喜欢 Vespa 实现混合搜索的能力，能够使用多种检索技术高效过滤和排序多种类型的元数据，实施多阶段排名，针对每个文档索引多个向量（例如，对于每个数据块），而无需将所有元数据复制到单独索引的文档中，并能够同时从多个索引字段中检索数据。
SST(Oct 2024, 评估)
SST是一个框架，用于将应用程序部署到云环境中，并同时配置应用程序运行所需的所有服务。SST 不仅是一个基础设施即代码 工具，它还是一个提供 TypeScript API 的框架，可以定义应用程序环境，在 Git 推送时触发应用程序部署服务，还配备了一个 GUI 控制台，用于管理生成的应用程序并调用 SST 管理功能。虽然 SST 最初是基于 AWS Cloud Formation 和 CDK，但其最新版本已经在Terraform 和 Pulumi 之上实现，因此理论上它是云平台无关的。SST 原生支持部署几种标准的 Web 应用程序框架，包括Next.js 和 Remix，但也支持无界面 API 应用程序。SST 似乎处于一个独特的类别中。虽然它与 平台编排工具如 Kubevela 有一些相似之处，但它还为开发者提供了便利功能，如实时模式，将 AWS Lambda 调用代理回开发者本地运行的函数。目前，SST 仍然有些新颖，但随着它的演进，这个项目及其工具类别值得持续关注。
Lenis(Oct 2024, 评估)
Lenis 是一个为现代浏览器设计的轻量且强大的平滑滚动库。 它能够实现流畅的滚动体验，例如 WebGL 滚动同步和视差效果，这使其非常适合那些需要构建流畅、无缝滚动交互页面的团队。我们的开发人员发现 Lenis 的使用非常简单，它提供了一种精简高效的方式来创建平滑滚动效果。然而，该库在无障碍性方面可能存在一些问题，特别是在处理垂直和水平滚动交互时，可能会让残障用户感到困惑。虽然它在视觉上很吸引人，但在实现时仍然需要仔细考虑无障碍性。
Pkl(Oct 2024, 试验)
Pkl 是一种开源的配置语言及工具，最初由苹果公司内部使用而创建。它的主要特点是其类型和验证系统，能够在部署之前捕捉配置错误。Pkl 帮助我们的团队减少了代码重复（例如环境覆盖的情况），并且能够在配置更改应用到生产环境之前进行验证。它可以生成 JSON、PLIST、YAML 和 .properties 文件，并且具有包括代码生成在内的广泛集成开发环境（IDE）和语言支持，
Pkl(Apr 2024, 评估)
Pkl 是最初在苹果公司内部使用、现在已开源的配置语言和工具。Pkl 的关键特性是其类型和验证系统，允许在部署之前捕获配置错误。它生成 JSON、.plist、YAML 和 .properties 文件，并拥有广泛的 IDE 和语言集成，包括代码生成。
vLLM(Oct 2024, 试验)
vLLM 是一个高吞吐量、内存高效的 LLM 推理引擎，既可以在云环境中运行，也可以在本地部署。它无缝支持多种 模型架构 和流行的开源模型。我们的团队在 NVIDIA DGX 和 Intel HPC 等 GPU 平台上部署了容器化的 vLLM 工作节点，托管模型如 Llama 3.1(8B and 70B) 、Mistral 7B 和 Llama-SQL ，用于开发者编码辅助、知识搜索和自然语言数据库交互。vLLM 兼容 OpenAI SDK 标准，促进了一致的模型服务。Azure 的 AI 模型目录 使用自定义推理容器来提升模型服务性能，vLLM 由于其高吞吐量和高效的内存管理，成为默认的推理引擎。vLLM 框架正在成为大规模模型部署的默认选择。
vLLM(Apr 2024, 评估)
vLLM 是一个具有高吞吐量和高效内存的大语言模型（LLM）推理和服务引擎，其特别有效的原因在于它可以对传入请求进行连续批处理。它支持几种部署选项，包括使用Ray运行时进行分布式张量并行推理和服务部署，在云中使用SkyPilot、NVIDIA Triton、Docker和LangChain进行部署。我们团队的经验是在本地虚拟机中运行基于 docker 的 vLLM worker，集成了与 OpenAI 兼容的 API 服务器，并在此基础上被一系列应用所利用(包括用于编码辅助以及聊天机器人的 IDE 插件)。团队对此反馈良好。我们的团队利用 vLLM 运行诸如CodeLlama 70B、CodeLlama 7B和Mixtral等模型。引擎的另一个显著特点是其可扩展能力：只需进行一些配置更改，就可以从运行 7B 模型转换为 70B 模型。如果您希望将 LLMs 投入生产，那么 vLLM 值得进一步探索。
Difftastic(Oct 2024, 试验)
Difftastic 是一种用于在语法感知的基础上高亮显示代码文件差异的工具，和传统的文本 diff 工具（例如经典的 Unixdiff 命令）有很大不同。例如，在像 Java 或 TypeScript 这样的以分号分隔的语言中，Difftastic 会忽略为了分割长语句而插入的换行符。该工具仅突出显示对程序语法有影响的更改。它首先将文件解析为抽象语法树，然后使用 Dijkstra 算法计算它们之间的距离。我们发现，Difftastic 在审查大型代码库时特别有用。只要编程语言有解析器，它就可以用于任何编程语言，并且开箱即用地支持 50 多种编程语言以及 CSS、HTML 等结构化文本格式。尽管这不是一个新工具，但在大语言模型（LLM）代码助手时代，人工审查越来越庞大的代码库变得至关重要，我们认为有必要强调这一工具的价值。
LlamaIndex(Oct 2024, 试验)
LLamaIndex 包含能够设计特定领域、上下文增强的 LLM 应用程序的引擎，并支持数据摄取、向量索引和文档上的自然语言问答等任务。我们的团队使用 LlamaIndex 构建了一个 检索增强生成 (RAG) 流水线，自动化文档摄取，索引文档嵌入，并根据用户输入查询这些嵌入。使用 LlamaHub，您可以扩展或自定义 LlamaIndex 模块以满足您的需求，例如构建使用您首选的 LLM、嵌入和向量存储提供者的 LLM 应用程序。
LlamaIndex(Sep 2023, 评估)
LlamaIndex 是一个旨在促进私有或领域特定数据与大语言模型（LLMs）集成的数据框架。它提供了从各种数据源获取数据的工具，包括 API、数据库和 PDF，然后将这些数据结构化为 LLMs 能够轻松消费的格式。通过各种类型的“引擎”，LlamaIndex 使得对这些结构化数据进行自然语言交互变得可能，从而使其可用于从基于查询的检索到对话界面等各种应用。与 LangChain 类似，LlamaIndex 的目标是加速跟大语言模型应用的开发，但它更多地采用了数据框架的方法。
大型视觉模型(LVM)平台(Oct 2024, 评估)
大语言模型（LLMs）在当前吸引了如此多的关注，以至于我们往往忽略了大型视觉模型（LVMs）的持续发展。这些模型可用于分割、合成、重建和分析视频流和图像，有时还结合了扩散模型或标准卷积神经网络。尽管 LVMs 有潜力彻底改变我们处理视觉数据的方式，但在生产环境中适应和应用这些模型仍面临重大挑战。例如，视频数据在收集训练数据、分割和标注对象、微调模型以及部署和监控这些模型时，带来了独特的工程挑战。与 LLMs 更适合简单的聊天界面或纯文本 API 不同，计算机视觉工程师或数据科学家必须管理、版本化、注释和分析大量的视频流数据，这项工作需要一个可视化界面。大型视觉模型(LVM)平台是新兴的一类工具和服务，其中包括 V7、 Nvidia Deepstream SDK 和 Roboflow，这些平台正在解决这些挑战。Deepstream 和 Roboflow 对我们特别有吸引力，因为它们结合了用于管理和标注视频流的集成 GUI 开发环境，同时提供了 Python、C++或 REST API 以便从应用代码中调用模型。
dbt(Oct 2024, 采纳)
我们仍然认为 dbt是在 ELT 数据管道中实施数据转换的强大且合理的选择。我们喜欢它能够引入工程上的严谨性，并支持模块化、可测试性和 SQL 转换的可重用性等实践。dbt 集成了很多云数据仓库、数据湖仓和数据库，包括Snowflake、BigQuery、Redshift、Databricks 和 Postgres，并且拥有健康的社区包生态系统。最近在 dbt core 1.8+ 和全新的 dbt Cloud 无版本体验中引入的原生单元测试支持，进一步巩固了其在我们工具箱中的地位。我们的团队很欣赏这个新的单元测试功能，它使他们能够轻松定义静态测试数据，设置输出预期，并测试管道的增量和完全刷新模式。在许多情况下，这使得团队能够淘汰自制脚本，同时保持相同的质量水平。
dbt(Sep 2023, 采纳)
dbt 仍是我们在 ETL 工作流程中进行数据转换的首选工具。我们喜欢它的工程严谨性和它在 SQL 数据转换中实践模块化、可测试性、和可复用性的能力。 dbt 有开源和商业化 SaaS 产品两种版本和健康的生态，包括一个提供了许多用于单元测试、数据质量、数据可观测性等软件包的社区。这些包中尤为值得注意的是用于监测数据质量的 dbt-expectations 和用于构建数据转换的单元测试的 dbt-unit-testing。dbt 很好地集成了各种云数据仓库、数据湖和数据库，包括 Snowflake，BigQuery，Redshift，Databricks 和 Postgres。当需要处理结构化数据并且能使用 SQL 进行数据转换时，我们的团队们倾向于 dbt，因此我们将它移至采纳阶段。
dbt(Apr 2021, 试验)
自从上一次介绍dbt以来，我们在一些项目中使用了它。例如，我们倾向于使用dbt完成ELT管道中转换部分的工作，使其更容易被数据消费者访问，而不是仅由数据工程师构建ELT管道。dbt通过鼓励良好的工程实践，如版本控制、自动化测试和部署，来实现这一点。SQL仍然是数据世界(包括数据库、仓库、查询引擎、数据湖和分析平台)的通用语言，大多数系统都在一定程度上支持它。这就使得这些系统可以通过构建适配器来使用dbt进行转换。原生连接器的数量不断增长并囊括了Snowflake、BigQuery、Redshift和Postgres，社区插件的范围也在扩张。我们看到像dbt这样的工具正在帮助数据平台变得更加“自助”。
dbt(Nov 2019, 评估)
数据转换是数据处理工作流的重要组成部分：筛选、分组或组合多个数据源，将它们转换为适合分析数据或机器学习模型使用的格式。dbt既是一个开源工具，也是一个商业化的SaaS产品，为数据分析师提供了简单高效的转换功能。现有的数据转换框架和工具，要么过分专注于功能强大和灵活性，却也要求对编程模型及语言框架有深刻的理解，例如Apache Spark；要么就只提供一些死板的界面拖放工具，而无法使用可靠的工程实践，如自动化测试和部署。dbt填补了这个空白：它使用被广泛理解的接口，SQL，对简单的批处理转换进行建模。同时dbt也提供了命令行工具以支持版本控制、自动化测试和部署等良好的工程实践。实际上，dbt基于SQL实现了转换模型即代码。目前，dbt支持包括SnowflakeSnowflake和Postgres在内的多种数据源，并提供Airflow及Apache自己的云服务等多种运行方式。dbt的转换能力受限于SQL，在撰写本文时还不支持实时的流式转换。
CARLA(Oct 2024, 试验)
CARLA 是一个开源的自动驾驶模拟器，它可用于在生产部署之前测试自动驾驶系统。它在创建和重用车辆、地形、人类、动物等 3D 模型上具有很强的灵活性，这使得它可以用来模拟各种场景，比如模拟行人走上马路或遇到迎面而来的特定速度的车辆。那些待测试的自动驾驶系统必须能够识别这些动态参与者并采取适当的行动，例如刹车。我们的团队使用 CARLA 进行自动驾驶系统的持续开发和测试。
Golem(Oct 2024, 评估)
持久计算（Durable computing）是分布式计算中的一个新兴运动，它使用显式状态机的架构风格来持久化无服务器计算的内存，以提高容错性和恢复能力。Golem是推动这一运动的倡导者之一。该概念在某些场景下有效，例如长时间运行的微服务 saga 或 AI 代理的长时间工作流。在之前的雷达报告中，我们评估了Temporal以实现类似目的，而 Golem 是另一个选择。使用 Golem，您可以用除 Golem 之外的任何支持语言编写WebAssembly 组件，同时 Golem 具有确定性并支持快速启动时间。我们认为 Golem 是一个值得评估的令人兴奋的平台。
Apache XTable™(Oct 2024, 评估)
在可用的开放表格格式中，能够支持数据湖仓一体(lakehouses)架构——例如 Apache Iceberg、Delta和 Hudi——尚未出现明显的赢家。相反，我们看到了一些工具正在促进这些格式之间的互操作性。例如， Delta UniForm 通过允许 Hudi 和 Iceberg 客户端读取 Delta 表，实现了单向互操作性。另一个新进入这个领域的是Apache XTable™，这是一个 Apache 孵化器项目，旨在实现 Hudi、Delta 和 Iceberg 之间的全向互操作性。与 UniForm 类似，XTable 在不创建底层数据副本的情况下，能够在这些格式之间转换元数据。XTable 对于那些在多个表格格式之间进行实验的团队可能会很有用。然而，考虑到这些格式之间功能的差异，长期依赖全向互操作性可能会导致团队只能使用功能的“最小公倍数”。
持续部署(Oct 2024, 采纳)
我们认为，组织应该在可能的情况下采用 持续部署 实践。持续部署是指自动将每个通过自动化测试的更改部署到生产环境中的实践。这种做法是快速反馈循环的关键推动力，使组织能够更快速和高效地为客户提供价值。持续部署与持续交付的区别在于，它只要求代码“可以”在任何时候进行部署；并不要求每个更改“实际被”部署到生产环境中。我们过去一直犹豫将持续部署移入“采纳”环节，因为这是一种需要在软件交付其他领域具备高水平成熟度的实践，因此并不适合所有团队。然而，Thoughtwork 同事 Valentina Servile 最近出版的书籍<持续部署> 提供了在组织中实施这一实践的全面指南。它为组织提供了一条实现所需成熟度以采用持续部署实践的路线图。
持续部署(Jul 2011, 试验)
If you are wondering “What comes after agile?,” you should look towards continuous delivery. While your development processes may be fully optimized, it still might take your organization weeks or months to get a single change into production. Continuous delivery focuses on maximizing automation including infrastructure as code, environment management and deployment automation to ensure your system is always ready for production. It is about tightening your feedback loops and not putting off anything until the end. Continuous delivery is not the same as continuous deployment, which means deploying every change to production. Continuous delivery is not a cowboy show. It puts you in charge of your production environment. The business can pick and choose what and when to deploy. If you think you’ve nailed agile development, but aren’t considering how to achieve continuous delivery, you really haven’t even started.
持续部署(Jan 2011, 试验)
The past 2 years or more has seen a proliferation of continuous integration tools and platforms leading to substantial innovation in the build and release space. Distribution of builds is one such innovation and yet another is the way in which builds are now structured to make greater use of automation in various stages of the build. Build pipelines help to provide greater insight into the quality of each build and the environments to which they have been deployed. A natural expansion of the build pipeline meme is the adoption of continuous deployment techniques, where the intention is to extend the build pipeline into the production environment. This relies on automated deployment techniques and authorization mechanisms built into the continuous integration toolset. One of the key benefits is the ability to move new functionality into production rapidly and reliably.
Zed(Oct 2024, 评估)
在 Atom 文本编辑器项目关闭后，其创建者构建了一个名为 Zed 的新编辑器。Zed 使用 Rust 编写，并经过优化以充分利用现代硬件，给人感觉非常快速。它具备我们对现代编辑器的所有期望功能：支持多种编程语言、内置终端以及多缓冲编辑等。通过与多个 LLM 提供商的集成，Zed 还提供 AI 辅助编码功能。作为结对编程的热衷者，我们对 Zed 内置的远程 协作特性 很感兴趣。开发者可以通过他们的 GitHub ID 找到彼此，然后实时协作于同一工作区。虽然现在还无法判断开发团队是否能够并愿意摆脱 Visual Studio Code 生态系统的吸引，但 Zed 是一个值得探索的替代方案。
K9s(Oct 2024, 采纳)
K9s 通过集成更详细的图表和视图，显著地提升了其可视化能力。它现在提供了更友好的日志和指标展示功能，并更加灵活地支持自定义资源（CRDs）的显示。对于 Pods 的操作也得到了扩展，包括与调试工具（如 kubectl debug）更深入的集成，以及对多集群环境的增强支持。对于 CRD 的支持有显著地提升，现在提供了更好的资源导航和管理能力，并且可以更加流畅地与自定义资源进行交互。快捷键面板也得到了增强，以便于对 kubectl 不太熟悉的开发者使用。 K9s 最初主要专注于 DevOps 团队，所以这次改进可以看作是它一次重大的改进。
K9s(May 2020, 试验)
我们仍然是基础设施即代码的热心拥护者，并且我们始终坚信，一个健壮的监控解决方案是运营好一个分布式应用的前提。有时候，一个类似 AWS Web 控制台这样的交互式工具是很好的补充。这类工具使我们能够即兴地浏览各种资源，而无需记住每一个似是而非的命令。但是，使用交互式工具频繁地进行手动修改仍然是一个值得商榷的实践。 对于 Kubernetes，我们现在有了k9s，它为 kubectl 的所有功能都提供了一个交互界面。 此外，它并不是一个 Web 应用程序，而是运行在终端窗口中的，它的操作界面会唤起我们中的某些人关于Midnight Commander的美好回忆。
动态少样本提示(Oct 2024, 评估)
动态少样本提示 构建在少样本提示（few-shot prompting）的基础上，通过动态地在提示中包含特定的示例来引导模型的响应。 调整这些示例的数量和相关性可以优化上下文长度和相关性，从而提升模型的效率和性能。像 scikit-llm 这样的库实现了这一技术，它使用最近邻搜索来获取与用户查询最相关的示例。该 技术 可以更好地利用模型有限的上下文窗口，并减少 token 消耗。开源 SQL 生成器 vanna 就是利用动态少样本提示来提高响应的准确性的。
本地设备上的大语言模型推理(Oct 2024, 评估)
大语言模型（LLMs）现在可以在网络浏览器和智能手机、笔记本电脑等边缘设备上运行，这使得本地 AI 应用成为可能。这允许在不传输到云端的情况下安全处理敏感数据，为边缘计算、实时图像或视频处理等任务提供极低的延迟，通过本地计算降低成本，并在网络连接不稳定或不可用时依然能够正常工作。这是一个活跃的研究和开发领域。我们之前曾提到过 MLX，这是一个在 Apple Silicon 上高效执行机器学习的开源框架。其他新兴工具包括 Transformers.js 和 Chatty。 Transformers.js 允许你通过 ONNX Runtime 在浏览器中运行 transformers，支持从 PyTorch、TensorFlow 和 JAX 转换的模型。Chatty 利用 WebGPU 在浏览器中本地和私密地运行 LLMs，提供了功能丰富的浏览器内 AI 体验。
Iggy(Oct 2024, 评估)
Iggy 是一个用 Rust 编写的持久化消息流平台，虽然是一个相对较新的项目，但其功能非常出色。它已经支持多个流、主题和分区、至多一次投递、消息过期，另外它还通过 QUIC、TCP 和 HTTP 协议支持 TLS。 Iggy 以单服务器的方式运行， 目前在读写操作中都能实现高吞吐量。随着即将引入的集群和 io_uring 支持，Iggy 很有可能成为 Kafka 的一个替代方案。
用LLMs进行函数调用(Oct 2024, 试验)
用 LLMs 进行函数调用 是指通过根据给定查询和相关文档确定并调用适当的函数，将 LLM 与外部函数、API 或工具集成的能力。这将 LLM 的实用性扩展到文本生成之外，使它们能够执行特定任务，如信息检索、代码执行和 API 交互。通过触发外部函数或 API，LLM 可以执行之前超出其独立能力的操作。这一技术使 LLM 能够对其输出进行操作，有效地弥合了思想与行动之间的差距——就像人类使用工具来完成各种任务一样。通过引入函数调用，LLM 为生成过程增加了确定性和真实性，在创造力和逻辑之间达成了平衡。这种方法允许 LLM 连接到内部系统和数据库，甚至通过连接的浏览器进行互联网搜索。像 OpenAI 的 GPT 系列这样的模型支持函数调用，而像 Gorilla 这样的微调模型则专门针对从自然语言指令生成的可执行 API 调用，增强其准确性和一致性。作为一种技术，函数调用适用于检索增强生成 (RAG) 和代理架构。它应被视为一种抽象的使用模式，强调其作为多种实现中基础工具的潜力，而非特定解决方案。
LLM 驱动的自主代理(Oct 2024, 评估)
随着诸如 Autogen 和 CrewAI 等框架的出现， LLM 驱动的自主代理 正在超越单一代理和静态的多代理系统。这项技术允许开发人员将复杂的任务分解为多个小任务，再交由不同角色的代理完成。开发人员可以使用预配置的工具来执行任务，代理之间通过对话来协调任务流程。该技术仍处于早期开发阶段。在我们目前的实验中，团队遇到了一些问题，比如说代理陷入持续循环和行为失控。像 LangGraph 这样的库提供了更大的代理交互控制能力，能够以图的形式定义流程。如果你使用这项技术，我们建议实施一些安全机制，包括超时处理和人工监控。
LLM 驱动的自主代理(Apr 2024, 评估)
随着像 Autogen 和 CrewAI 这样的框架的出现， LLM（大型语言模型）驱动的自主代理 正在从单一代理和静态多代理系统发展到更先进的阶段。这些框架允许用户定义具有特定角色的代理，分配任务，并使代理通过委派或对话合作完成这些任务。类似于早期出现的单一代理系统，如 AutoGPT，单个代理可以分解任务，利用预配置的工具，并请求人工输入。尽管这一领域仍处于开发的早期阶段，但它发展迅速，并且拥有广阔的探索空间。
LLM 驱动的自主代理(Sep 2023, 评估)
随着大语言模型的持续发展，构建自主人工智能代理的兴趣日益浓厚。AutoGPT、GPT-Engineer 和 BabyAGI 都是 大语言模型驱动的自主代理 的示例，它们朝着底层大语言模型理解所获得的目标方向努力。这些代理会记住目标的进展程度，使用大语言模型来思考接下来该做什么，然后采取行动，并理解何时已经实现了目标。这通常被称为思维链推理，而且实际上是可行的。我们的团队实现了一个作为自主代理的客户服务聊天机器人。如果机器人无法达成客户的目标，它会认识到自己的限制并将客户引导到人工处理。这种方法显然仍处于早期发展阶段：自主代理通常存在高失败率和高昂的 AI 服务费用，至少有一家 AI 初创公司已经从代理为基础的方法转向其他方向。
用于测试和训练模型的合成数据(Oct 2024, 试验)
合成数据集创建涉及生成可以模拟现实世界场景的人工数据，而无需依赖敏感或有限访问的数据源。虽然合成数据在结构化数据集中的应用已得到广泛探索（例如，用于性能测试或隐私安全环境），但我们看到在非结构化数据中重新使用合成数据的趋势。企业通常面临领域特定数据缺乏标注的问题，尤其是在训练或微调大语言模型（LLMs）时。像Bonito和 Microsoft's AgentInstruct 这样的工具可以从原始数据源（如文本文档和代码文件）生成合成的指令调优数据。这有助于加速模型训练，同时降低成本和对手动数据管理的依赖。另一个重要的用例是生成合成数据来解决不平衡或稀疏数据的问题，这在欺诈检测或客户细分等任务中很常见。像SMOTE这样的技术通过人工创建少数类实例来帮助平衡数据集。同样，在金融等行业，生成对抗网络（GANs）用于模拟稀有交易，使模型在检测边缘案例方面更加稳健，从而提高整体性能。
Rspack(Oct 2024, 评估)
许多我们团队在开发基于 Web 的前端时，已经从旧的打包工具（比如 Webpack）转向了 Vite。该领域的新进者是 Rspack，经过 1.5 年的开发，刚刚发布了1.0 release。Rspack 被设计为 Webpack 的直接替代品，兼容 Webpack 生态系统中的插件和加载器。这在迁移复杂的 Webpack 设置时，相较于 Vite 可能具有一定优势。我们团队迁移到 Vite 和 Rspack 等新工具的主要原因是开发者体验，特别是速度。没有什么比在获取上次代码更改反馈前需要等待一两分钟更能打断开发流程的了。Rspack 使用 Rust 编写，提供的性能显著快于 Webpack，在许多情况下甚至比 Vite 更快。
CCMenu(Oct 2024, 试验)
对于实践持续集成（CI） 的团队来说，了解中央构建在 CI 中的状态非常重要。在疫情之前，团队会议室中的大屏幕仪表盘 可以让人一目了然地获取这些信息。随着远程工作成为常态，团队需要一种适用于开发者个体工作站的解决方案。在 Mac 上， CCMenu 就是一款这样的工具，这是一个由 Thoughtworks 员工编写的小应用程序。最初它是 CruiseControl 的一部分，适用于所有可以提供 cctray 格式信息的服务器，包括 Jenkins 和 TeamCity。最近的重写增加了对 GitHub Actions 的支持，并为更深入集成更多 CI 服务器和身份验证方式奠定了基础。
用于数据产品的 GraphQL(Oct 2024, 评估)
用于数据产品的 GraphQL 是指使用 GraphQL 作为数据产品的输出端口，供客户端消费产品的技术。我们之前讨论过 GraphQL 作为一种 API 协议，它使开发者能够创建一个统一的 API 层，抽象底层数据的复杂性，为客户端提供一个更加一致且易于管理的接口。将 GraphQL 用于数据产品，使得消费者可以通过 GraphQL 结构无缝地发现数据格式和关系，并使用熟悉的客户端工具进行各种操作。我们的团队正在探索将这一技术应用于特定场景，例如通过 talk-to-data 来探索和发现大数据洞察。在此场景下，GraphQL 查询由大语言模型（LLM）根据用户提示词构建，同时还可以在提示词中引入 GraphQL 结构以便于 LLM 参考以生成准确的查询语句。
Unleash(Oct 2024, 试验)
尽管我们仍然推荐使用最简特性开关，但随着团队的扩展和开发速度的加快，管理手工制作的开关变得更加复杂。现在我们团队广泛使用 Unleash，它能够应对这种复杂性并支持 CI/CD。它既可以作为服务使用，也可以自托管。Unleash 提供了多个语言的 SDK，拥有良好的开发者体验和友好的管理界面。尽管目前还没有对 OpenFeature 规范 的官方支持，但你可以找到由社区维护的 Go 和 Java providers。Unleash 既可以用于简单特性开关，也支持分组和渐进式发布，使其成为适合大规模功能管理的选择。
Warp(Oct 2024, 评估)
Warp是一款适用于 macOS 和 Linux 的终端工具，它将命令输出分割为块以提高可读性。Warp 提供了AI 驱动的能力，如智能命令建议和自然语言处理。它还包括笔记本功能，允许用户组织命令和输出，并添加注释和文档。你可以利用这些功能创建 README 文件或入职材料，以结构化和互动的方式呈现和管理终端工作流。Warp 还可以轻松集成 Starship，一个灵活的跨终端提示工具，允许你自定义终端体验，并检索有关正在运行的进程、所使用工具的特定版本、Git 详细信息或当前 Git 用户等信息。
FastChat(Oct 2024, 试验)
FastChat 是一个开放平台，用于训练、服务和评估大型语言模型。我们的团队利用其模型服务能力来托管多个模型 — Llama 3.1 (8B and 70B) 、Mistral 7B 和 Llama-SQL — 出于不同的目的，所有模型均以一致的 OpenAI API 格式运行。FastChat 采用控制器-工作者架构，允许多个工作者托管不同的模型。它支持不同类型的工作者，如 vLLM、LiteLLM 和 MLX。我们选择使用 vLLM 模型工作者，以利用其在高吞吐量的优势。根据使用案例的不同（比如延迟或吞吐量），可以创建和扩展不同类型的 FastChat 模型工作者。例如，用于开发者 IDE 中代码建议的模型需要低延迟，这就可以通过多个 FastChat 工作者进行扩展，以有效处理并发请求。相反，用于 Text-to-SQL 的模型由于需求较低或性能要求不同，则不需要多个工作者。我们的团队利用 FastChat 的扩展能力进行 A/B 测试。我们用相同的模型但不同的超参数（Hyperparameter）值配置 FastChat 工作者，并向每个工作者提出相同的问题，从而识别最佳的超参数（Hyperparameter）值。在在线服务中切换模型时，我们进行 A/B 测试以确保平滑迁移。 例如，我们最近将代码建议的模型从 CodeLlama 70B 迁移到 Llama 3.1 70B。通过同时运行这两个模型并比较输出，我们验证了新模型在性能上达到了或超过了之前的模型，同时没有打断开发者的使用体验。
shadcn(Oct 2024, 评估)
shadcn 通过提供可重用的、可直接复制粘贴的组件，挑战了传统组件库的概念。这种方法让团队拥有完整的控制权和所有权，更加容易进行定制和扩展，而这是更受欢迎的传统库如 MUI 和Chakra UI往往不足的地方。shadcn 使用 Radix UI 和 Tailwind CSS 构建，能够无缝集成到任何基于 React 的应用程序中，非常适合优先考虑控制和可扩展性的项目。它还提供一个 CLI，帮助将组件复制并粘贴到项目中。其优点还包括减少隐藏依赖关系，避免紧耦合的实现，因此对于寻求更加自主且可适应的前端开发方法的团队来说，shadcn 正在成为一个引人注目的替代方案。
ClickHouse(Oct 2024, 试验)
ClickHouse 是一个开源的列式在线分析处理（OLAP）数据库，用于实时分析。它于 2009 年作为一个实验项目启动，之后发展成为一个高性能且线性可扩展的分析数据库。其高效的查询处理引擎结合数据压缩，使其适合在不进行预聚合的情况下运行交互式查询。ClickHouse 也是 OpenTelemetry 数据的优秀存储选择。它与 Jaeger 的集成允许您存储大量的追踪数据并高效分析。
ClickHouse(Oct 2021, 试验)
ClickHouse 是用于实时分析的开源柱状在线分析处理（OLAP）数据库。它起始于2009年的一个实验项目。从那以后，它已经发展成一个高性能且可线性扩展的分析数据库。它兼备高效查询处理引擎和数据压缩功能，使其适合在不进行预聚合的情况下，运行交互式查询。我们已经使用过ClickHouse，并且对它的高性能印象深刻。
OpenBCI Galea(Oct 2024, 评估)
对脑机接口（BCI）及其在辅助技术中的潜在应用的兴趣正在不断增长。使用脑电图（EEG）和其他电生理信号的非侵入性技术为恢复中的患者提供了一种比脑植入物更低风险的替代方案。现在，研究人员和企业家可以在新兴的平台上构建创新应用，而不必担心低级信号处理和集成挑战。这样的平台的例子包括Emotive 和 OpenBCI，它们提供开源硬件和软件用于构建 BCI 应用程序。OpenBCI 的最新产品 OpenBCI Galea 将 BCI 与 VR 头显的功能结合在一起。它为开发人员提供了一系列时间锁定的生理数据流，以及空间定位传感器和眼动追踪。这些传感器数据可以用于控制各种物理和数字设备。该 SDK 支持多种语言，并在Unity 或 Unreal 中提供传感器数据。我们很高兴看到这一能力在开源平台上提供，这样研究人员就能获得他们在这一领域创新所需的工具和数据。
TypeScript OpenAPI(Oct 2024, 试验)
TypeScript OpenAPI （或称 tsoa）是 Swagger 生成 OpenAPI 规范的一个替代方案，用于从代码中直接生成 API 规范。它采用代码优先的方式，将 TypeScript 控制器和模型作为唯一的真实数据来源，并使用 TypeScript 注解或装饰器，而不像使用 OpenAPI 工具时需要复杂的文件和配置。它能够生成 2.0 和 3.0 的 API 规范，并且支持为 Express、Hapi 和 Koa 生成路由。如果你在使用 TypeScript 编写 API，值得看看这个项目。
Data Mesh Manager(Oct 2024, 评估)
Data Mesh Manager 提供了典型 data mesh 平台的元数据层。它特别关注数据产品的定义以及使用 OpenContract 倡议规范数据契约，并可以通过相关的 DataContract CLI 集成到构建管道中。该应用还提供了数据目录，用于发现和探索数据产品及其元数据，并允许进行联邦治理，包括定义数据质量指标和管理数据质量规则。作为该领域的首批原生工具之一，它不仅仅是试图将现有平台改造为数据网格范式。
seL4(Oct 2024, 试验)
在软件定义汽车 (SDV) 或其他安全关键场景中，操作系统的实时稳定性至关重要。由于该领域的高准入门槛，少数公司垄断了这一领域，因此像 seL4这样的开源解决方案显得尤为珍贵。seL4 是一个高保障、高性能的操作系统微内核。它使用 形式化验证 方法来“数学上”确保操作系统的行为符合规范。其微内核架构还将核心职责最小化，以确保系统的稳定性。我们已经看到像蔚来汽车 (NIO) 这样的电动汽车公司参与 seL4 生态系统，未来在这一领域可能会有更多的发展。
dbldatagen(Oct 2024, 评估)
为数据工程准备测试数据是一个重大挑战。从生产环境转移数据到测试环境存在风险，因此团队通常依赖于编造数据或合成数据。在本期雷达中，我们探讨了诸如 通过大模型生成合成数据等新方法。但大多数情况下，成本较低的程序生成已经足够用。dbldatagen (Databricks Labs Data Generator) 就是这样一个工具；它是一个用于在 Databricks 环境中生成合成数据的 Python 库，适用于测试、基准测试、演示等多种用途。dbldatagen 可以在短时间内生成规模达数十亿行的合成数据，支持多表、变更数据捕获和合并/连接操作等各种场景。它能够很好地处理 Spark SQL 的基本类型，生成范围和离散值，并应用指定的分布。在 Databricks 生态系统中创建合成数据时，dbldatagen 是一个值得评估的选项。
AWS Control Tower(Oct 2024, 试验)
AWS Control Tower 仍然是我们在多团队环境中管理 AWS 账户的首选工具。它提供了一个便捷的机制，可以预配置安全和合规控制，这些控制将自动应用于新的着陆区。这是 在变更点合规 的一个实例，因为这些控制在创建新基础设施时被应用和验证，消除了后续进行手动合规检查的需求。AWS Control Tower Account Factory for Terraform (AFT) 自我们上次使用以来不断发展，现在已在更多的 AWS 区域提供。AFT 允许通过基础设施即代码 流水线来创建 Control Tower 账户。我们喜欢 AFT 的定制化能力，它可以通过发送 webhooks 或采取特定操作，安全地与外部工具 GitHub Actions集成。我们的团队报告说使用 AWS Control Tower 管理账户效果很好，但我也希望 AWS 能接受社区对该项目的贡献，尤其是在我们发现改进机会时。
AWS Control Tower(Sep 2023, 试验)
在 AWS 中，多团队的账户管理是一项挑战，尤其是在设置和治理方面。AWS Control Tower 通过简化设置和自动化治理来应对这个挑战，并通过防护措施应对监管要求。AWS Control Tower 内置了一个账户工厂，帮助自动化账户的配置流程。您可以通过账户工厂来取消账户托管、更新和关闭创建与配置的账户。由于其缺乏自动化和定制化，亚马逊引入了 Terraform 的 AWS Control Tower 账户工厂 （AFT） 。AFT 允许配置定制化的 Webhook 或特定操作，以便与其他工具集成来启动账户创建流程。我们的团队通过整合一组开箱即用的账户配置项，一劳永逸地为 GitHub Actions 的角色做了基础设置和访问权限的配置。这可为开发者提供一个完全集成 VPC 安全基线、可用于 GitHub Actions 接收工作负载的账户。我们的团队报告说，使用 AWS Control Tower 和 AFT 统一管理多个团队的账户非常方便。
AWS Control Tower(Oct 2022, 试验)
多团队的账户管理在 AWS 中是一个挑战，特别是设置和管控方面；AWS Control Tower 试图解决这一挑战。据我们团队的报告，使用它在单一且集中的位置为组织中的多个团队进行账户管理和访问控制，取得了良好的效果。
组件测试(Oct 2024, 采纳)
自动化测试仍然是高效软件开发的基石。对于前端测试，我们可以讨论测试类型的分布是否应该采用经典的测试金字塔 模型，还是应该采用奖杯形状。然而，无论是哪种模型，团队都应专注于 组件测试 ，因为测试套件应该稳定且快速运行。相反，我们看到的是，团队放弃了对组件测试的掌握，而更倾向于端到端的基于浏览器的测试以及非常狭隘定义的单元测试。单元测试往往迫使组件暴露本应是纯内部的功能，而基于浏览器的测试则运行缓慢，更容易出错且更难调试。我们的建议是进行大量的组件测试，并使用类似jsdom这样的库在内存中运行组件测试。当然，像Playwright这样的浏览器工具仍然适用于端到端的测试，但不应用于组件测试。
SetFit(Oct 2024, 试验)
当前大多数基于 AI 的工具都是生成式的——它们生成文本和图像，使用生成式预训练模型（GPTs）来完成这些任务。而对于需要处理现有文本的用例——例如文本分类或意图识别——sentence transformers 是首选工具。在这个领域，SetFit是一个用于微调 sentence transformers 的框架。我们喜欢 SetFit 的原因是它使用对比学习来区分不同的意图类别，通常只需非常少量的样本（甚至少于 25 个）就能实现清晰的分类。sentence transformers 在生成式 AI 系统中也可以发挥作用。我们成功地在一个使用大语言模型（LLM）的客户聊天机器人系统中使用 SetFit 进行意图检测。尽管我们知晓 OpenAI 的内容审核 API，我们仍选择基于 SetFit 的分类器进行额外的微调，以实现更严格的过滤。
GitButler(Oct 2024, 评估)
尽管Git 的 功能强大且实用，但其命令行界面在管理多个分支和提交暂存方面以复杂性著称。GitButler 是一个 Git 客户端，它提供了图形界面，旨在简化这一过程。GitButler 通过独立于 Git 跟踪未提交的文件更改，并将这些更改暂存到虚拟分支中来实现这一目标。有人可能会认为这是对不应存在的问题的解决方案；如果你经常进行小规模更改并频繁推送到主干，就不需要多个分支。然而，当你的工作流程涉及 pull request（PR）时，分支结构可能会变得复杂，尤其是在 PR 合并之前有较长的审查周期时。为了解决这个问题，GitButler 还与 GitHub 集成，允许你选择性地将更改分组为 pull request，并直接从该工具发出。GitButler 是旨在管理 PR 流程中固有复杂性的工具中又一新增选项。
Elastisys Compliant Kubernetes(Oct 2024, 评估)
Elastisys Compliant Kubernetes 是一个专门设计的 Kubernetes 发行版，旨在满足严格的监管和合规要求，尤其适用于医疗、金融和政府等高度监管的行业。它自动化了安全流程，支持多云和本地部署，并建立在零信任安全架构之上。由于其内置符合 GDPR 和 HIPAA 等法律法规的要求，并具备 ISO27001 等控制措施，对于需要安全、合规且可靠的 Kubernetes 环境的公司来说，这是一个具有吸引力的选择。
适用于SSR网络应用程序的Web组件(Apr 2024, 暂缓)
随着Next.js和htmx等框架逐步被采纳，我们看到服务端渲染（SSR）的使用越来越多。作为一种浏览器技术，在服务器上使用web 组件并非易事。为了简化这一过程，许多框架应运而生，有时甚至使用浏览器引擎来执行操作，但复杂性依然存在。我们的开发人员发现他们需要绕过一些障碍并付出额外努力来整合前端组件和服务端组件。比开发者体验更糟糕的是用户体验：当自定义 web 组件需要在浏览器中加载和填充时，页面加载性能会受到影响，即使使用预渲染和谨慎调整组件，未样式化内容的闪现或一些布局移动几乎不可避免。正如我们在上一期技术雷达中提到的，我们的一个团队因为这些问题不得不将他们的设计系统从基于 web 组件的Stencil迁移出去。最近，我们从另一个团队收到报告，他们最终用浏览器端组件替换了服务器端生成的组件，其原因是开发的复杂性。我们建议谨慎使用 用于 SSR web 应用的 web 组件 ，即使框架支持。
适用于SSR网络应用程序的Web组件(Sep 2023, 暂缓)
自从我们在2014年首次提到它们以来，Web 组件已经变得流行起来，总体而言，我们对其的看法是积极的。同样地，我们通过对采用默认选择 SPA 发出警告以及将如 Next.js 和 htmx 等框架与传统的服务器端框架一起列入，来表达对在服务器上来渲染 HTML 的支持。然而，尽管可以将两者结合使用，也还是可能造成深层次的问题；这就是为什么我们建议避免在 服务器端渲染（SSR）的 Web 应用 中使用 Web 组件。作为一种浏览器技术，要在服务器上使用 Web 组件并不容易。已经出现了一些框架来简化这一过程，甚至一些框架中还使用了浏览器引擎，但复杂性仍然存在。比开发人员体验更糟糕的是用户体验：当必须在浏览器中加载和构建自定义 Web 组件时，页面加载性能会受到影响，即使在预渲染和精心调整组件的情况下，也几乎无法避免“无样式内容闪烁”或某些布局变化。放弃使用 Web 组件的决定可能会产生深远的影响，正如我们的一个团队曾经不得不将其基于 Web 组件的设计系统 Stencil 进行迁移。
Android 模拟器容器(Apr 2024, 试验)
Android Emulator Container 通过消除因操作系统兼容性问题和系统依赖，以及设置多个 Android 版本的模拟器所带来的复杂性，使得 Android 应用测试变得更为简便。传统上，这些复杂性会带来额外的工作量致使团队完全放弃自动化测试，进而导致开发和测试周期变慢。Android 模拟器容器简化了这个过程，使其可以无缝集成到 CI 流水线中进行自动化测试。我们的团队主要使用这些容器进行设备化测试，这些测试会在每次提交时自动执行，为开发者提供即时反馈。此外，我们还使用 Android 模拟器容器来运行夜间的端到端测试。
边缘函数(Apr 2024, 试验)
尽管不是一个新概念，我也注意到通过内容交付网络（CDNs）进行去中心化代码执行的可用性和使用量正在增长。诸如 Cloudflare Workers 或 Amazon CloudFront Edge Functions 这样的服务提供了一种机制，可以在靠近客户地理位置的地方执行无服务器代码片段。 边缘函数 不仅可以在边缘生成响应时提供更低的延迟，还可以在请求和响应从区域服务器出发和返回的途中，以特定位置的方式重写它们。例如，你可能会重写请求的 URL，以路由到一个特定服务器，该服务器拥有与请求正文中找到的字段相关的本地数据。这种方法最适合于短暂、快速运行的无状态处理，因为边缘的计算能力是有限的。
42Crunch API Conformance Scan(Apr 2024, 试验)
42Crunch API Conformance Scan 是一个动态测试工具，用于识别 API 文档中记录的行为与其实际实现之间的差异。此工具使用 OpenAPI 格式的 API 规格定义，概述了预期的功能和响应，并将其与 API 的实际行为进行比较。通过生成真实流量并与现场端点交互，该工具能够识别 API 承诺与其实际提供之间的任何差异。这为开发团队带来了很多好处。例如，它能在开发早期捕捉到不一致性，节省时间并防止问题进入生产环境。该工具还通过识别可能由于偏离记录行为而产生的潜在漏洞，帮助提高 API 的质量和安全性。总的来说，API Scan 能够通过识别诸如弱认证协议、不安全的数据处理实践和不充分的输入验证等问题，帮助评估 API 的安全态势。它能提供详细的报告，突出显示发现的问题以及修复建议。
DataHub(Apr 2024, 试验)
在使用 数据产品思维 构建产品时，数据血缘、数据可发现性、数据治理非常重要。我们的团队发现DataHub 在这些方面能提供非常有效的支持。DataHub 的早期版本在需要更新元数据模型时，要求用户手动复制管理来自主产品的同步。近期的更新引入了通过插件实现的元数据模型定制。DataHub 的另一个有用功能是从源头到处理再到消费的强大端到端数据脉络。DataHub 既支持基于推送的集成，也支持基于拉动的数据血缘提取，可自动抓取跨数据源、调度器、协调器（通过扫描 Airflow DAG）、处理管道任务和仪表板等元数据。作为完整数据目录的一个开源选项，DataHub 逐渐成为我们团队的默认选择。
DataHub(Oct 2022, 试验)
自从我们第一次在技术雷达中提及数据的可发现性以来，LinkedIn已经将 WhereHows 进化为 DataHub，一个通过可扩展的元数据系统实现数据可发现性的下一代平台。与爬取和拉取元数据不同，DataHub 采用了基于推送的模式。数据生态系统中各个组件，都可以通过 API 或者流（stream）向中心化的平台上发布元数据。这种基于推送的数据集成，将数据发现所有权从中心实体转移到各个团队，使他们对自己的元数据负责。因此，我们已成功将 DataHub 用于组织层面的元数据存储库和多种自维护的数据产品入口。当使用它时，请确保它足够轻量并避免让它滑坡成对共享资源的中心化控制系统。
DataHub(Apr 2021, 评估)
自从我们第一次在技术雷达中提及 data discoverability 以来，LinkedIn 已经将 WhereHows 进化为 DataHub，一个通过可扩展的元数据系统实现数据可发现性的下一代平台。与爬取和拉取元数据不同，DataHub 采用了基于推送的模式。数据生态系统中各个组件，都可以通过 API 或者流（stream）向中心化的平台上发布元数据。这种基于推送的数据集成，将数据发现所有权从中心实体转移到各个团队，使他们对自己的元数据负责。随着越来越多的公司试图成为数据驱动型企业，拥有一个有助于数据发现和理解数据质量与渊源的系统，是至关重要的。我们建议评估 DataHub 在这方面的能力。
Gradio(Apr 2024, 试验)
Gradio 是一个开源的 Python 库，它能帮助机器学习（ML）模型创建基于 web 的交互式界面。ML 模型上的图形 UI 能够帮助非技术受众更好地理解输入、约束和输出。Gradio 在生成式人工智能领域获得了大量关注，因为它让生成式模型更易于尝试和使用。通常，我们只有在生产环境中真正使用过才会将一个技术放在雷达的试验环。目前，我们团队已经多次使用它并在最近的一次大型活动中，帮助客户使用 Gradio 做了一次现场演示。我们对 Gradio 在这些用例中展现的效果非常满意，因此将其移入“试验”环。
Gradio(Sep 2023, 评估)
Gradio 是一个开源的 Python 库，它能够帮助我们快速简单地为机器学习模型创建基于Web的交互式界面。基于机器学习模型的图形化界面，使得非技术受众能够更好地理解输入、约束和输出。Gradio 支持多种输入和输出类型，从文本到图像再到语音，并且它已经成为了快速原型设计和模型评估的首选工具。 Gradio 可以让您轻松地将您的演示托管到Hugging Face ，或者在本地运行它，然后允许他人通过带有XXXXX.gradio.app”的 URL 来访问您的远程演示。例如，著名的 DALL-E mini 实验就利用了 Gradio 实现，并且托管在Hugging Face Spaces上。我们的团队在实验和原型设计中使用这个库的体验非常愉快，这也是我们将其放入评估的原因。
Continue(Apr 2024, 评估)
Continue 是一种用于 VS Code 和 JetBrains IDEs 的开源 AutoPilot 工具。我们非常喜欢它，因为它通过与 IDE 的直接集成，消除了从聊天界面复制/粘贴到大型语言模型的痛苦。它支持多个商业和开源 模型, 并且它能够帮助尝试不同的大语言模型 提供商, 包括 自托管的大语言模型 。甚至可以在 没有网络连接 时运行 Continue。
广泛集成测试(Apr 2024, 暂缓)
当我们对自动化测试表示赞扬时，也持续看到许多组织在我们认为无效的 广泛集成测试 上投入过多。“集成测试”这个术语在表述上有些模糊不清，我们尝试引用 Martin Fowler 在该主题上的bliki 条目描述——该分类指的是需要所有运行时依赖项的实时版本的测试。这样的测试显然是昂贵的，因为它需要具备所有必要基础设施、数据和服务的全功能测试环境。管理所有这些依赖项的正确版本需要大量的协调工作，这往往会拖慢发布周期。最后，测试本身通常是脆弱且无用的。例如，要确定测试失败是由于新代码、版本依赖性不匹配还是环境不足，而错误信息很少有助于挖掘问题源头。当然，这些批评并不意味着我们认为自动化的“黑盒”集成测试普遍存在问题，但我们的确发现了一种更有帮助的方法——就是平衡对信心的需求与发布频率。可以先假设对运行时依赖项的一组响应来验证被测试系统的行为，然后验证这些假设的两个阶段来完成。第一阶段使用服务虚拟化来创建运行时依赖项的测试替身，并验证被测试系统的行为。这简化了测试数据管理问题，并允许进行确定性测试。第二阶段可以使用契约测试来验证这些环境假设与真实依赖项。
基于大语言模型的 ChatOps(Apr 2024, 评估)
基于大语言模型的 ChatOps 是通过聊天平台（主要是 Slack）应用大语言模型的新兴方式，允许工程师通过自然语言来构建、部署和操作软件。这种方式有可能通过增强平台服务的可发现性和用户友好性来简化工程工作流程。截至撰写本文时，两个早期示例分别是 PromptOps 和 Kubiya。然而，考虑到生产环境需要的精细管理，组织在让这些工具接近生产环境前应该彻底评估它们。
Fern Docs(Apr 2024, 评估)
目前被广泛使用的 REST APIs 的一个特点是它们的合约会被彻底地记录在案。开发者更倾向于采纳和使用那些以结构化、有组织的方式准确描述其行为和语法的 API。随着合约的发展，保持这些文档的更新可能既耗时又容易被忽视。Fern Docs 通过减少编写和维护 API 文档的劳动强度来帮助解决这个问题。Fern 可以自动从规范文件生成一个具有吸引力、可用文档的网站，这个文件能与 API 代码一起版本化。我们对这个产品的初步印象是积极的，不过 Fern 要求用户在一个专有配置文件中维护 API 信息，尽管它提供了一种将 OpenAPI 规范转换为其自己的配置格式的方法，但我们更期待一个能够直接从带注释的源代码生成文档的工具。
Chronosphere(Apr 2024, 评估)
在管理分布式架构时，考虑排序、索引和访问数据的成本与可观测性同样重要。Chronosphere 使用了独特的方法来管理成本、跟踪可观测数据的使用情况，以便组织可以考虑并权衡各种指标的成本价值。借助 Metrics Usage Analyzer，作为 Chronosphere Control Plane 的一部分，团队可以识别并排除他们很少（或从未）使用的指标，进而通过减少组织必须梳理的数据量来节省大量成本。考虑到这些优势，以及 Chronosphere 与其他云托管解决方案的可观测性工具匹配的能力，我们认为它非常值得投入使用。
Pulumi(Apr 2024, 试验)
在基础设施即代码领域，工具仍在不断进化，我们很高兴地看到 Pulumi也不例外。该平台最近新增了对 Java 和 YAML 的支持，用于管理大规模基础设施，以及支持众多云配置和集成，使得该平台更加引人注目。对于我们的团队来说，它仍然是 Terraform 的主要替代品，用于开发多个云平台的代码。
Pulumi(Oct 2021, 试验)
我们已经看到在各种组织中，使用Pulumi的团队数量有所增加。尽管Terraform在基础设施编程世界中地位稳固，但Pulumi却填补了其中的一个空白。虽然Terraform是一个久经考验的常备选项，但其声明式的编程特质，却深受不足的抽象机制和有限的可测试性的困扰。如果基础设施完全是静态的，那么Terraform就够用了。但是动态基础设施的定义，则需要使用真正的编程语言。允许以 TypeScript/JavaScript、Python和Go语言编写配置信息（无需标记语言或模板）这一点，就使Pulumi脱颖而出。Pulumi专注于云原生架构，包括容器、无服务器函数和数据服务，并能良好支持Kubernetes。最近，虽然面临着AWS CDK的挑战，但Pulumi仍然是该领域唯一的能独立于任何云平台厂商的工具。
Pulumi(Apr 2021, 评估)
我们已经看到人们对 Pulumi 的兴趣正在缓慢且稳步地上升。虽然Terraform 在基础设施编程世界中地位稳固，但 Pulumi 却填补了其中的一个空白。尽管 Terraform 是一个久经考验的常备选项，但其声明式编程特质，深受抽象机制不足和可测试性有限的困扰。如果基础设施完全是静态的，那么 Terraform 就够用了。但是动态基础设施但定义，要求使用真正的编程语言。Pulumi 允许以 TypeScript/ JavaScript、Python和Go语言（无需标记语言或模板）编写配置信息，这使其脱颖而出。Pulumi 专注于原生云架构，包括容器、无服务器函数和数据服务，并为Kubernetes 提供了良好的支持。最近，AWS CDK 的推出对其形成了挑战，但 Pulumi 仍然是该领域唯一的能独立于任何云平台厂商的工具。我们期望将来人们能更广泛地采用 Pulumi，并期待出现能对其提供支持的可行的工具和知识生态系统。
Pulumi(Oct 2020, 评估)
我们已经看到人们对Pulumi的兴趣正在缓慢且稳步地上升。虽然Terraform 在基础设施编程世界中地位稳固，但 Pulumi 却填补了其中的一个空白。尽管 Terraform 是一个久经考验的常备选项，但其声明式编程特质，深受抽象机制不足和可测试性有限的困扰。如果基础设施完全是静态的，那么 Terraform 就够用了。但是动态基础设施但定义，要求使用真正的编程语言。Pulumi 允许以 TypeScript/ JavaScript、Python和Go语言（无需标记语言或模板）编写配置信息，这使其脱颖而出。Pulumi 专注于原生云架构，包括容器、无服务器函数和数据服务，并为Kubernetes 提供了良好的支持。最近，AWS CDK 的推出对其形成了挑战，但 Pulumi 仍然是该领域唯一的能独立于任何云平台厂商的工具。我们期望将来人们能更广泛地采用 Pulumi，并期待出现能对其提供支持的可行的工具和知识生态系统。
Pulumi(Nov 2018, 评估)
We're quite interested in Pulumi, a promising entrant in cloud infrastructure automation. Pulumi distinguishes itself by allowing configurations to be written in TypeScript/JavaScript, Python, and Go—no YAML required. Pulumi is tightly focused on cloud-native architectures—including containers, serverless functions and data services—and provides good support for Kubernetes.
Concrete ML(Apr 2024, 评估)
在此之前，我们曾经标记过允许在加密过的数据上进行计算的同态加密技术。Concrete MLl 就是这样一个允许在隐私保护的环境下进行机器学习的开源工具。作为一个基于Concrete 构建的工具，它帮助数据科学家们简化了完全同态加密(FHE)的使用，帮助他们将机器学习的模型自动转化为同态加密过的数据。此外，Concrete ML的内置模型中还有和他们的机器学习算法库几乎相同的API。你也可以通过Concrete ML的转换API将PyTorch 网络进行完全同态加密。然而，需要注意的是，若在没有调校过的硬件 中使用Concrete ML会导致完全同态加密的速度变慢。
Rancher Desktop(Apr 2024, 试验)
Docker Desktop 许可证的变更迫使我们寻找相关替代方案，以便开发时能够在本地笔记本电脑上运行一系列容器。最近我们在使用 Rancher Desktop 上取得了不错的成效。这款免费且开源的应用程序容易下载并能够安装在苹果、Windows 或 Linux 机器上，便捷地提供了一个带有图形界面配置和监控的本地 Kubernetes 集群。虽然 Colima 已成为我们 Docker Desktop 的首选替代品，但它主要是一个 CLI 工具。相比之下，Rancher Desktop 对那些不想放弃 Docker Desktop 提供的图形界面的用户很有吸引力。像 Colima 一样，Rancher Desktop 允许你选择 dockerd 或 containerd 作为底层容器运行时。选择直接使用 containerd 可以让你摆脱对 DockerCLI 的依赖，但 dockerd 选项也提供了与其他工具的兼容性，这样可以与运行时守护进程进行通信。
aws-nuke(Apr 2024, 试验)
aws-nuke 是一个开源工具，解决了开发和沙箱 AWS 账户中积累未使用资源导致成本效率低下的常见挑战。该工具可以识别并删除 AWS 账户或区域内所有可删除的资源，除了默认或 AWS 管理的资源，本质上是要将环境重置为第一天的状态。它还提供自定义排除策略，以确保关键资源得到保护。我们已经在成本优化的默认用例以及灾难恢复（DR）环境中成功使用了这个工具。通过自动化清理开发和沙箱环境，aws-nuke 帮助最小化不必要的资源开销。它还有助于在演习或练习后高效拆除临时 DR 基础设施。尽管稳定，aws-nuke 是一个非常具有破坏性的工具，不适用于生产环境。请始终进行试运行，以确认不会删除必要资源。
Philips's self-hosted GitHub runner(Apr 2024, 试验)
虽然 GitHub Actions runners 已经覆盖了最常见的运行时环境，并且是最早投入使用的，但有时团队还是需要管理自托管运行器，比如当组织政策只允许从组织内部的安全边界内部署到私有托管基础设施时。在这种情况下，团队可以使用 Philips's self-hosted GitHub runner，这是一个 Terraform 模块，可以在 AWS EC2 竞价实例(spot instance)上启动自定义运行器。该模块还创建了一组 Lambda 用于处理这些运行器的生命周期管理（扩展和缩减）。根据我们的经验，这个工具极大地简化了自托管 GitHub Actions runner 的配置和管理。对于使用 Kubernetes 的团队来说，另一种选择是 actions-runner-controller。
Philips's self-hosted GitHub runner(Apr 2023, 评估)
虽然 GitHub Actions 运行器涵盖了一系列最常见的运行时，但有时您需要一些更具体的东西来满足特定的使用场景，例如，一个不太常见的语言运行时，或者一个特定的硬件配置。这时您就需要一个自我托管的运行器。Philips 的自我托管 GitHub 运行器 是一个 Terraform 模块，可以让您在 AWS EC2 Spot 实例上启动自定义运行器。当您使用自我托管运行器时，您会失去 GitHub Actions 提供的一些生命周期管理特性，而该模块则创建了一整套 Lambda 来帮助解决这类问题。这些 Lambda 为运行器的按需扩缩容做了大量工作。这有助于管理成本，并允许您缩短运行器工作时长，这在提高可重复性和安全性方面是一个好的实践。当您确实需要自我托管的运行器时，如果自己从头开始构建，您可能会缺失很多东西。请寻找类似这样的工具来代替。
Dify(Apr 2024, 评估)
Dify 是一个 UI 驱动的用于开发大语言模型应用程序的平台，它使原型设计更加容易访问。它支持用户使用提示词模板开发聊天和文本生成应用。此外，Dify 支持使用导入数据集的检索增强生成（RAG），并且能够与多个模型协同工作。我们对这类应用很感兴趣。不过，从我们的使用经验来看，Dify 还没有完全准备好投入大范围使用，因为某些功能目前仍然存在缺陷或并不成熟。但目前，我们还没有发现更好的竞品。
Gradle Version Catalog(Apr 2024, 试验)
Gradle 版本目录是 Gradle 构建工具的一个有用的功能，它允许你集中管理构建文件中的依赖项。我们的团队发现它在Android 多模块项目中特别有用。你可以为这些依赖项创建一个中央版本目录，然后在 Android Studio 的帮助下以一种类型安全的方式引用它，而不是在单独的构建文件中硬编码依赖项名称和版本号并管理升级。
Text to SQL(Apr 2024, 试验)
Text to SQL 是一种用于将自然语言查询转换为可以由数据库执行的 SQL 查询的技术。尽管大语言模型能够理解和转换自然语言，但在你自己的 schema 中创建准确的 SQL 仍然存在很大的挑战。为此可以引入 Vanna，它是一个在 Python 中用于 SQL 生成的检索增强生成（RAG）开源框架。Vanna 分两步工作：首先你需要使用数据定义语言语句（DDLs）和示范 SQL 描述你的结构，并为它们创建嵌入向量，然后再用自然语言提出问题。尽管 Vanna 可以与任何大语言模型协作，我们还是推荐你评估 NSQL，它是一个用于 Text to SQL 任务的领域特定大语言模型。\n检索增强生成
Bun(Apr 2024, 评估)
Bun 是一个新的 JavaScript 运行时，类似于 Node.js 或 Deno。然而，与 Node.js 或 Deno 不同，Bun 是使用 WebKit 的 JavaScriptCore 而不是 Chrome 的 V8 引擎构建的。作为 Node.js 的替代品设计，Bun 是一个单一的二进制文件（用 Zig 编写），充当 JavaScript 和 TypeScript 应用程序的打包器、转译器和包管理器。自上一期技术雷达发布以来，Bun 已经从测试版发展到稳定的 1.0 版本。Bun 从头开始构建，并进行了几项优化——包括快速启动、改进的服务器端渲染和一个更快的替代包管理器——我们鼓励你评估它作为你的 JavaScript 运行时引擎。
Bun(Oct 2022, 评估)
Bun 是一个新的 JavaScript 运行时，与 Node.js 或 Deno 相似。然而不同于 Node.js 或 Deno 的是，Bun 使用 WebKit 的 JavaScriptCore 构建，而不是 Chrome 的 V8 引擎。 Bun 被设计为 Node.js 的直接替代品，它是一个单独的二进制文件（使用 Zig 编写），能够充当 JavaScript 和 TypeScript 的打包器、转译器 (transpiler) 与包管理器。 Bun 目前正在 beta 测试，所以我们可以预计有一些漏洞或是与一些 Node.js 库的兼容性问题。然而， Bun 是从头开始构建的并且带有一些优化，包括快速启动和改进的服务端渲染，我们认为它值得评估。
ZITADEL(Apr 2024, 评估)
ZITADEL 是一个开源的用户身份管理工具，也是 Keycloak 的替代品之一。它非常轻量级（用 Golang 编写），拥有灵活的部署选项，并且易于配置和管理。它还是多租户的，能够提供全面的功能以构建安全且可扩展的认证系统，特别是对于 B2B 应用程序，并且具有内置的安全功能，如多因素认证和审计追踪。通过使用 ZITADEL，开发者可以减少开发时间，增强应用程序的安全性，并为不断增长的用户基础进行扩容。如果你正在寻找一个用户友好、安全且开源的用户管理工具，ZITADEL 是一个不错的选择。
持续合规(Apr 2024, 试验)
持续合规 是一种实践，旨在确保软件开发过程以及相关技术一直遵守行业法规和安全标准，这一过程大量依赖自动化，人工操作可能会降低开发速度并引入错误。作为替代，组织可以自动化合规检查和审计。他们可以将工具集成到软件开发流水线中，使团队能够在开发过程的早期发现并处理合规问题。将合规规则和最佳实践编码化有助于在团队间执行一致的政策和标准。它使用户能够扫描代码变更中的漏洞、强制执行编码标准以及追踪基础设施配置变更，以确保它们满足合规要求。最后，以上内容的自动化报告简化了审计工作，并提供了清晰的合规证据。我们已经讨论过诸如发布软件物料清单（SBOMs）和应用软件供应链层级建议的技术 — 很适合在早期进行这样的尝试。这种技术的好处是多方面的。首先，自动化能够带来更安全的软件，可以在早期识别并处理漏洞，其次，随着手动任务的消除，开发速度也会加快。最后，还能够降低成本和提高一致性。对于像软件驱动汽车这样的安全关键行业，自动化持续合规可以提高认证过程的效率和可靠性，最终造就更安全、更可靠的车辆。
actions-runner-controller(Apr 2024, 试验)
actions-runner-controller 是一个 Kubernetes 控制器，用于操作 GitHub Actions 的自托管运行器。在需要访问 GitHub cloud runner 无法访问的资源，或具有与 GitHub 提供的不同的特定操作系统和环境要求的情况下，自托管运行器非常有帮助。这时如果团队使用 Kubernetes 集群，actions-runner-controller 将协调和扩展这些 runner。我们的团队非常赞赏它能够根据给定仓库、组织、企业或 Kubernetes 集群中运行的工作流数量来扩展 runner 的能力，以及它可以很好地处理 Linux 和 Windows runner。
actions-runner-controller(Mar 2022, 评估)
actions-runner-controller 是一种Kubernetes 控制器，它在 Kubernetes 集群上为 GitHub Actions 运行自托管运行器。这个工具可以在 Kubernetes 上创建一个运行器资源，它可以运行和操作自托管运行器。当你的 GitHub Actions 运行的作业需要访问 GitHub 云运行器主机无法访问的资源，或者依赖于某些特定的操作系统和环境而 GitHub 没有提供时，自托管运行器会很有帮助。当你有一个 Kubernetes 集群，你可以将自托管运行器作为一个 Kubernetes pod 运行，并根据 GitHub webhook 事件来伸缩。 actions-controller-runner 具有轻量级和可伸缩的特性。
Otter(Apr 2024, 评估)
Otter 是一个在 Go 语言中非竞争式的缓存库。虽然 Go 语言有几个类似的库，但我们想要强调 Otter 有两个原因：它具有出色的吞吐量并且能够巧妙地实现 S3-FIFO 算法，以获得良好的缓存命中率。Otter 还支持泛型，因此用户可以将任何可比较的类型用作键，并将任何类型用作值。
WGPU(Apr 2024, 评估)
wgpu 是一个基于 WebGPU API 的Rust图形库，它以能够高效处理 GPU 上通用图形和计算任务的能力而闻名。wgpu 旨在填补由于淘汰旧的图形标准（如 OpenGL 和 WebGL）而留下的空白。它引入了一种现代的图形开发方法，既适用于本地应用程序，也适用于基于 Web 的项目。它与WebAssembly的集成进一步使得图形和计算应用程序能够在浏览器中运行。wgpu 的出现是一种进步，使高级图形编程对 Web 开发人员更加可访问，应用范围更广泛，从游戏到创建复杂的 Web 动画，将 wgpu 定位为一种令人振奋的技术。
Tigerbeetle(Apr 2024, 评估)
Tigerbeetle 是一个用于财务会计的开源分布式数据库 。与其他数据库不同的是，它被设计成特定领域的状态机，以确保安全性和性能。集群中一个节点的状态通过 Viewstamped Replication 共识协议，以确定性顺序复制到其他节点。我们非常喜欢 Tigerbeetle 背后的 设计决策 ，使其实现具有严格可序列化保证的复式记账。
Ollama(Apr 2024, 评估)
Ollama是一个在本机上运行并管理大语言模型的工具。 我们之前讨论过自托管大语言模型我们很高兴这个生态逐渐成熟，产生了像 Ollama 的工具。Ollama 支持多种 流行的模型 的下载和本地运行——包括 LLaMA-2, CodeLLaMA, Falcon 和 Mistral。一经下载，你可以通过命令行、接口或者开发组件与模型交互执行任务。我们正在评估 Ollama，目前看起来不错，能通过在本机运行大语言模型提升开发者体验。
Zarf(Apr 2024, 评估)
Zarf是一个用于离线和半连接Kubernetes环境的声明式软件包管理器。使用 Zarf，可以在连接到互联网时构建和配置应用程序；一旦创建完成，可以将其打包并发送到断开连接的环境以进行部署。作为一个独立的工具，Zarf 提供了几个有用的功能，包括自动生成软件物料清单（SBOM）、内置的Docker注册表，Gitea 和 K9s 仪表板，可从终端管理集群。云原生应用程序的网闸软件交付面临着挑战，Zarf 解决了其中大部分的问题。
开放策略代理 (OPA)(Apr 2024, 试验)
Open Policy Agent (OPA)是一个统一的框架和 语言，用于声明、执行和控制策略。在我们团队，它已经成为定义分布式系统策略的一种常用方式，尤其是在我们需要实施变更点的合规时。OPA 使团队能够实现各种平台工程模式，例如控制部署到 Kubernetes 集群的内容、在服务网格 中跨服务强制访问控制以及实现细粒度的访问应用程序资源的 安全策略即代码。虽然 OPA 实现存在一定复杂性，但事实证明它是一种确保 DevOps 文化下的 合规性 的非常有价值的工具。我们还将继续关注 OPA 在运营系统之外扩展到大数据解决方案的成熟度。
开放策略代理 (OPA)(May 2020, 试验)
在我们为客户构建的许多分布式云原生解决方案中，Open Policy Agent (OPA) 已经迅速地展现了它的价值。OPA 提供了一套统一的框架和语言，用于声明，实施和控制云原生解决方案中各个组件的策略。它是实现安全策略即代码的工具中的一个很好的例子。无论是在K8s 集群中部署资源，还是在服务网格中跨服务执行访问控制，抑或是通过代码精准地控制应用资源访问，在很多场景中 OPA 都给我们提供了非常顺畅的体验。最近的一个商业产品 Styra 声明式授权服务（Styra's Declarative Authorization Service (DAS)），通过向 K8s 的 OPA 中添加管理工具（或者说控制平面），预先构建的策略库，策略影响分析和日志记录等功能，使企业采用 OPA 变得更加简单。我们期待 OPA 的成熟和扩展，希望它可以从一个可用的服务演变成一个（大型的）以数据为中心的解决方案。
开放策略代理 (OPA)(Nov 2019, 评估)
横跨多个技术领域统一定义和实施安全策略很有挑战。即使对于简单的应用程序，也必须使用其组件内置的安全策略配置和实施机制，来控制对容器编排器、保存服务状态的服务及数据存储等组件的访问。\n我们对开放策略代理（OPA）这个尝试解决此问题的开源技术感到非常兴奋。OPA可以使用Rego策略定义语言，以代码的方式进行细粒度的访问控制与灵活的策略定义。Rego在应用程序代码之外，以分布式且不干扰用户的方式实施策略。在撰写本文时，OPA以统一而灵活的策略定义及执行实现，确保了通过Envoy边车和Kafka访问Kubernetes API和微服务API的安全性。它也可以用作任何服务的边车，用以验证访问策略或过滤响应数据。OPA背后的公司Styra针对分布式策略的集中可见性提供提供商业化的解决方案。我们希望OPA可以通过CNCF孵化计划成熟起来，并继续为多样化的数据存储等更具挑战性的策略执行场景提供支持。
Microsoft SBOM 工具(Apr 2024, 试验)
Microsoft SBOM 工具 是一个开源工具，用于生成与 SPDX 兼容的软件物料清单（SBOM）。我们之前已经提到过软件物料清单，而这个工具其变得更加容易。SBOM 工具支持多种流行的包管理器（包括 npm、pip 和 Gradle），所以可以与许多项目兼容。它非常易于使用，可以集成到现有的开发工作流中，包括与 CI/CD 流水线的集成。借此开发者获得了多重优势，其中改善软件安全是一个关键好处，因为清晰的组件视图可以帮助识别漏洞和管理风险。许可证合规性也得到增强，因为开发者可以确保遵守所有相关协议。此外，SBOM 在软件供应链中促进透明度，帮助跟踪依赖性和缓解潜在风险。如果你正在寻求简化 SBOM 生成、提升软件安全性以及控制你的软件供应链，你应该尝试一下 Microsoft SBOM 工具。
安卓适应性(Apr 2024, 评估)
有些移动应用或者游戏非常消耗资源，他们可以在几分钟内导致散热过载。在这种情况下，设备会降低 CPU 和 GPU 的频率以降低温度，但游戏帧率也会随之降低。当散热情况有所改善时，设备的帧率会回升。如此循环往复，软件会变得非常不稳定。Android Adaptability 是一套允许移动程序开发者根据动态的设备性能和散热情况进行调校的新类库集。安卓动态性能框架( ADPF ) 集成了提供设备热量信息的 Thermal API、帮助安卓系统选择 CPU 的最佳运行点以及核心配置的 Hint API。Unity 的自适应性能包也同时支持这两种 API，使用 Unity 进行开发的团队应该会觉得这很有帮助。
Gemini Nano(Apr 2024, 评估)
Google 的 Gemini 是一系列基础性大语言模型，用于在从数据中心到手机等各种硬件上运行。其团队已经对 Gemini Nano 做了特别对优化和简化，以便在移动芯片加速器上运行。它可以实现高质量的文本摘要、上下文智能回复和高级语法纠正等功能。例如，Gemini Nano 的语言理解能力使得 Pixel 8 Pro 能够在录音机应用中总结内容。在设备上运行消除了许多来自云的系统相关的延迟和隐私问题，并且能够在没有网络连接的情况下工作。Android AICore 简化了将模型集成到 Android 应用中的过程，但在撰写本文时只支持少数设备。
Astro(Apr 2024, 试验)
Astro 框架在社区中越来越受欢迎。我们的团队已经使用 Astro 构建了诸如博客和营销网站之类的内容驱动型网站。Astro 是一个多页面应用程序框架，它在服务器上渲染 HTML 并最小化通过网络发送的 JavaScript 。我们认为不错的一点是，尽管 Astro 鼓励仅发送 HTML，但它支持在适当的情况下选择性地使用您选择的前端 JavaScript 框架编写的活动组件。它通过其岛屿架构实现这一点。岛屿是单页内的交互区域，在这里所需的 JavaScript 仅在需要时才被下载。通过这种方式，网站的大部分区域被转换为快速的静态 HTML，而 JavaScript 部分则优化为并行加载。我们的团队既喜欢其页面渲染性能，也喜欢其构建速度。Astro 组件语法是 HTML 的简单扩展，学习曲线相当平缓。
Astro(Oct 2022, 评估)
令人难以置信的是，即使到了2022年，开发者社区仍在持续推出有趣的，用于构建web应用程序的新框架，Astro 就是最新推出的开源，多页面响应的应用程序框架，它可以在服务器上渲染页面并尽可能减少通过网络发送的 JavaScript 数量。Astro 看起来非常适合那些从多种渠道获取资源的内容型网站。我们喜欢 Astro 的一点是，尽管 Astro 鼓励只发送 HTML，但它仍然支持——在适当的时候——选择用您选用的前端 JavaScript 框架编写的活动组件。它通过 island architecture 做到这一点。岛屿是单个页面中的交互区域，仅在需要时才下载必要的 JavaScript。Astro 是相对较新的技术并且看起来支持日益增加的开发者及代码生态系统。它的发展值得关注。
过度热衷使用大语言模型(Apr 2024, 暂缓)
在急于利用最新人工智能技术的过程中，许多组织正在试图将大语言模型（LLMs）应用于各种应用，从内容生成到复杂的决策过程。LLMs 的吸引力不可否认；它们提供了看似毫不费力的解决方案来处理复杂问题，开发人员通常可以快速创建此类解决方案，而无需多年深入的机器学习经验。当LLM-based的解决方案多少能够工作时，就迅速部署并转向下一个任务，这可能颇具诱惑力。尽管这些基于LLM的价值证明是有用的，但我们建议团队仔细考虑所使用的技术以及是否LLM真的是正确的最终阶段解决方案。许多LLM可以解决的问题——如情感分析或内容分类——传统的自然语言处理（NLP）可以更便宜、更容易地解决。分析LLM的作用，然后评估其他潜在解决方案，不仅可以减轻 过度热衷使用大语言模型 的风险，还可以促进对人工智能技术的更细致理解和应用。
CloudEvents(Apr 2024, 采纳)
事件是事件驱动架构或无服务器应用中的常见机制。然而，生产者或云提供商对它们的支持形式却存在很大差异，这阻碍了跨平台和基础设施的互操作性。CloudEvents 是一种规范，用于以通用格式描述事件数据，以实现跨服务、平台和系统的互操作性。它提供了多种语言的 SDK，因此你可以将该规范嵌入到你的应用程序或工具链中。我们的团队不仅将其用于跨云平台，还用于领域事件规范以及其他场景。CloudEvents 由云原生计算基金会 (CNCF) 托管，现已成为一个毕业项目。我们的团队默认使用 CloudEvents 构建事件驱动架构，因此我们正将其移入采纳状态。
CloudEvents(Sep 2023, 试验)
事件是事件驱动架构或无服务器应用中常见的机制。然而，生产者或云提供商通常以不同形式支持它们，这阻碍跨平台和基础架构的互操作性。CloudEvents 是一个描述事件数据的通用格式的规范，旨在提供服务、平台和系统之间的互操作性。它提供了多种编程语言的 SDK，因此您可以将规范嵌入到应用程序或工具链中。我们的团队不仅将其用于跨云平台的目的，还用于领域事件规范等其他场景。CloudEvents 由云原生计算基金会（CNCF）托管，现在作为孵化项目运行，已经获得了越来越多的行业关注。
CloudEvents(Apr 2019, 评估)
Outside the function code itself, applications written as serverless functions are tightly coupled to the cloud platform on which they're hosted. Although events are a common FaaS-triggering mechanism, and every cloud provider supports them in some form, the current proprietary specifications prevent interoperability across clouds. The CloudEvents specification is a burgeoning standard that has been accepted into the CNCF Sandbox. The standard is still in active development but several language bindings exist and Microsoft has announced first-class support in Azure. We're hoping other cloud providers will follow suit.
Winglang(Apr 2024, 评估)
我们正在基础设施即代码（IaC）领域看到许多新动态，像 Winglang 这样的工具正在出现。Winglang 采取了一种不同的方法来定义基础设施和运行时行为。它提供了高级抽象，覆盖了由 CloudFormation、Terraform、Pulumi 和 Kubernetes 等工具提供的平台特定功能。使用 Winglang，你可以编写在编译时运行的代码以生成基础设施配置，然后编写在运行时执行的代码以进行应用程序行为。它提供了一种在本地运行的模拟模式，并集成了测试框架。我们正在关注这个有趣的工具，它可能预示了 IaC 未来发展方向。
WebTransport(Apr 2024, 评估)
WebTransport 是一种建立在 HTTP/3 之上的协议，提供了服务器与应用之间的双向通信。与其前身 WebSocket 相比，WebTransport 具有很多优势，包括更快的连接、更低的延迟，以及能够处理可靠且有序的数据流以及无序数据流（例如 UDP）。它可以在同一连接中处理多个流，而不会造成队头阻塞(head-of-line blocking)，进而实现在复杂应用中更高效地通信。总体来说，WebTransport 适用于广泛的用例，包括实时网络应用、流媒体和物联网数据通信。尽管 WebTransport 还处于早期阶段——各浏览器的支持正逐渐成熟，流行的库如 socket.io 也增加了对 WebTransport 的支持——我们的团队目前正在评估其在实时物联网应用中的潜力。
VISS(Apr 2024, 评估)
Zoom 最近开源了其漏洞影响评分系统（Vulnerability Impact Scoring System）—— VISS。这个系统主要关注的是对安全措施的漏洞评分的优先级排序。VISS 与通用漏洞评分系统（CVSS）的不同之处在于，它不侧重于对最坏情况进行预测，而是试图从防御者的角度更客观地衡量漏洞的影响。为此，VISS 提供了一个基于网页的 UI，基于多个参数来计算漏洞分数 — 这些参数按照平台、基础设施和数据组进行分类 — 包括对平台的影响、影响的租户数量、数据影响等。尽管我们对这个特定工具还没有太多的实践经验，但我们认为这种基于行业上下文的优先级定制的评估方法是值得考虑的。
Conan(Apr 2024, 采纳)
Conan 是一个用于 C/C++ 应用程序的开源依赖管理工具。它提供了直观的界面来定义、获取和管理依赖，使开发人员能够轻松地将第三方库集成到他们的项目中。Conan 支持所有主要操作系统，并可以适用于多种平台，包括服务器和桌面、移动和嵌入式设备。它也可以用于构建和发布 C/C++ 库和包。这些包可以通过 JFrog Artifactory 服务器在团队间共享。通过利用预构建的二进制文件，它显著节省了构建时间，特别是对于庞大的依赖。Conan 与流行的构建系统如 CMake 进行了集成，并拥有 Python SDK 用于扩展构建系统，以执行诸如签名之类的任务。根据我们的经验，Conan 改善了环境间的构建可重复性并加速了开发周期。这让代码库更加清晰易维护，对于大规模 C 和 C++ 项目而言是一个重要进步。如果你在项目中苦于依赖管理，Conan 绝对是提升开发效率的必要工具。
Azure Container Apps(Apr 2024, 试验)
Azure Container Apps 是一个托管的 Kubernetes 应用平台，能够简化容器化工作负载的部署。与 Azure Kubernetes Service (AKS) 相比，运行容器化应用程序的操作和管理负担相对较少，但这是以牺牲一些灵活性和控制权为代价的，也是团队需要权衡的。这个领域的另一个产品，Azure Container Instances，通常不能满足生产环境的需求。我们的团队去年开始使用 Azure Container Apps，当时它还处于公开预览阶段，但那时它已经能在运行大容器时取得良好的结果。现在它已经普遍可用，我们正在考虑将其应用于更多用例。Dapr 和 KEDA Autoscaler 都是在其支持范围。
Azure Container Apps(Sep 2023, 评估)
Azure 容器应用是一种 Kubernetes 命名空间托管服务。该服务通过消除 Kubernetes 集群和底层基础架构组件的复杂维护需求来简化容器化工作负载的部署，从而减轻了运维和管理负担。然而，在考虑使用该工具时需要小心谨慎：当前处于开发阶段，它在 Azure 门户中展示的功能有些不一致；在与标准 Terraform Azure 插件集成时遇到了困难，该插件在匹配 Azure 容器应用的功能方面进展缓慢。综上所述，我们建议仔细评估这个工具。
LangChain(Apr 2024, 暂缓)
在上一期 Radar 中，我们提到了一些关于 LangChain 出现的批评言论。自那以后，我们愈发对其充满警惕。虽然这个框架为构建大语言模型应用提供了一套强大的功能，但我们发现它使用起来很困难且过于复杂。LangChain 在这个领域早期获得了人气和注意力，这使得它成为了许多人的默认选择。然而，随着 LangChain 试图发展并快速跟进最新变化，开发者越来越难以跟上这些概念和模式的变更。我们还发现其存在 API 设计不一致且冗长的情况。因此，它经常会掩盖底层实际发生的情况，使得开发者难以理解和控制 LLMs 及其周围的各种模式在背后实际是如何工作的。我们将 LangChain 移动到了“暂缓”环，以反映这一点。在我们的许多用例中，我们发现使用更轻量的的专门框架进行实现就足够了。根据用例，你还可以考虑其他框架，如 Semantic Kernel、Haystack 或 LiteLLM。
LangChain(Sep 2023, 评估)
LangChain 是一个利用大语言模型（LLM）构建应用程序的框架。要构建实用的 LLM 应用，需要将其与用户或领域的特定数据结合起来，这些数据不属于训练数据的一部分。LangChain 利用提示管理、链式、代理 和文档加载器等功能填补了这一空白。如提示模板和文档加载器等组件的好处是可以加快产品上市速度。尽管 LangChain 是实施检索增强生成（Retrieval-Augmented Generation） 应用程序和 ReAct 提示工程 模式的热门选择，但它也因难以使用和过于复杂被批评 。当您为 LLM 应用程序选择技术栈时，可能需要在这个快速发展的领域继续寻找类似的框架（如 Semantic Kernel ）
LangChain(Apr 2023, 评估)
LangChain 是一个用于构建基于大型语言模型(LLMs)应用的框架。这些模型已经引起了一场生成式人工智能在各种场景下的竞赛。 但是，单独使用这些 LLMs 可能是不够的——你必须将其与差异化的资产相结合去构建有影响力的产品。 LangChain 提供了一些方便的功能去填补了模型和应用之间的裂痕，这些功能包括提示管理，组件链式连接，生成增强数据及丰富的用于确定执行动作和顺序的代理 。我们期待基于 LLMs 演变出更多的工具和框架, 并且我们推荐对 LangChain 进行评估。
Tetragon(Apr 2024, 评估)
Tetragon 是一个基于 eBPF 的开源安全可观测性和运行时强制执行工具。我们一段时间前在 Radar 中提到了 Falco，用于检测安全威胁。Tetragon 通过利用 eBPF 在 Linux 内核中在运行时 执行安全策略，实现了不仅限于威胁检测的能力。你可以将 Tetragon 作为一个独立工具在裸机环境中使用，也可以在 Kubernetes 环境中使用。
Ray(Apr 2024, 试验)
机器学习（ML）的工作负载正在变得越来越计算密集型。尽管用笔记本电脑开发训练模型很便利，但这样的单节点开发环境很难适应扩展需求。Ray AI 和 Python 代码从笔记本电脑扩展到集群的统一框架。它本质上是一个封装良好的分布式计算框架，集成了一系列 AI 库以简化 ML 的工作。通过与其他框架（例如，PyTorch 和TensorFlow的集成，它可以用于构建大规模 ML 平台。像 OpenAI 和字节跳动这样的公司大量使用 Ray 进行模型训练和推理。我们还使用它的 AI 库帮助我们的项目进行分布式训练和超参数调优。我们推荐你在构建可扩展的 ML 项目时尝试使用 Ray。
Marimo(Apr 2024, 评估)
Marimo通过优先考虑复用性和交互性，为 python notebook 提供了新的体验。它解决了传统 notebook 如Jupyter中隐藏状态（hidden state）的挑战, 该问题可能导致不可预料的结果并阻碍可复用性。Marimo 通过将 notbook 存储为无隐藏状态的纯 python 文件和基于依赖关系（当变量改变时，所有受影响的 cell 会自动运行）的确定性执行顺序来解决这个问题。Marimo 还使用了类似的可以将 cell 值的改变传递给依赖于该 cell 的交互式 UI 元。它可以被部署为网页 app，也可以用于展示成果和进行原型设计。虽然我们对 Marimo 的潜力，尤其是数据探索和分析目标上的再现性潜力感到兴奋，我们依然谨慎对待生产化的笔记本。
Zig(Apr 2024, 评估)
Zig 是一种新的编程语言，它与 C 语言有许多共同点，但具有更强的类型系统、更容易的内存分配以及对命名空间的支持等，此外还有许多其他特性。Zig 的目标是提供一个非常简单的语言，具有直接明了的编译过程，最小化副作用，并提供可预测、易于追踪的执行。Zig 还简化了访问 LLVM 的跨平台编译能力。我们的一些开发者发现这个特性非常有价值，他们甚至在不编写 Zig 代码的情况下，也能使用 Zig 作为交叉编译器。我们看到行业中的团队使用 Zig 帮助构建 C/C++ 工具链。对于那些正在考虑或已经使用 C 的应用程序，Zig 是一种值得探索的新颖语言。
Zig(Mar 2022, 评估)
Zig 是一门新的语言，它与 C 语言共享了许多属性，但是具有更强的类型，更简便的内存分配，以及对命名空间和众多其他特性的支持。然而它的语法，比起 C 更容易让人想到 JavaScript，这点会引起一些人的反对。Zig 的目标是为大家提供一种非常简单的语言，可以直接编译以减少副作用，并且程序执行是可预测和易于追踪的。Zig 还提供了 LLVM 交叉编译功能的简化接口。我们的一些开发同事发现这一特性非常重要，以至于他们尽管没有使用 Zig 编程，但是仍然把它当做一个交叉编译器使用。Zig 是一种新颖的语言，对于正在考虑或者已经使用 C 语言的应用程序，以及需要显式内存操作的底层系统应用程序，值得一试。
AWS CUDOS(Apr 2024, 试验)
我们一如既往地认为应当将成本监控列为适应性函数。云服务商提供了各种监控云消费的服务，例如AWS Cost Explorer或Google Cloud FinOps Hub。在 AWS 生态系统中，我们的团队使用CUDOS（Cost and Usage Dashboards Operations Solution）来监控大型母公司下不同业务部门或法律实体在AWS Marketplace的消费。该仪表板提供了全面的成本和使用细节，具有资源级别的细粒度，有助于优化成本、跟踪使用目标并实现运营卓越。
Crabviz(Apr 2024, 评估)
Crabviz 是一个用于创建调用图的 Visual Studio Code 插件。这些图表是交互式的，这在使用中等规模的代码库（例如微服务）时起到了很大的作用。它们按文件分组显示类型、方法、函数和接口，并显示函数调用关系和接口实现关系。因为 Crabviz 基于语言服务器协议，只要安装了相应的语言服务器，就可以支持任意数量的语言。虽然这也意味着 Crabviz 仅限于静态代码分析，可能不足以满足某些用例。该插件是用 Rust 编写的，可在 Visual Studio Code Marketplace 上获取。
百川2(Apr 2024, 评估)
百川 2 是新一代开源大型语言模型。 它采用了 2.6 万亿 Tokens 的高质量语料进行训练，在中文、英文和多语言基准测试上表现出色。 值得注意的是百川在医疗和法律等领域特定的数据集进行了针对性训练，这让我们在相关垂直领域会优先考虑它。
Elasticsearch Relevance Engine(Apr 2024, 评估)
尽管向量数据库因 检索增强生成（RAG） 使用案例而日益流行，但研究和经验报告表明，将传统的全文搜索与向量搜索相结合（成为混合搜索）可以生成更完善的结果。可以借助 Elasticsearch Relevance Engine(ESRE)，成熟的全文搜索平台 Elasticsearch 支持了内置和自定义嵌入模型、向量搜索以及具有如倒数排序融合(Reciprocal Rank Fusion)等排名机制的混合搜索。尽管这个领域仍在发展中，但根据我们的经验，使用 ESRE 的这些功能以及 Elasticsearch 自带的传统过滤、排序和排名功能已经取得不错的结果，这表明支持语义搜索的搜索平台不应被忽视。
自动生成 Backstage 实体描述符(Apr 2024, 试验)
Spotify 推出的 Backstage 已成为我们客户托管开发者体验门户的首选平台。本身来说，Backstage 只是一个托管插件，在托管的同时提供管理构成平台生态系统资产目录的界面的 shell。任何由 Backstage 显示或管理的实体都在 catalog-info 文件中配置，其中包含状态、生命周期、依赖关系和 API 等其他细节的数据。默认情况下，单个实体描述符是手动编写的，并且通常由负责相应组件的团队进行维护和版本化。保持描述符的更新可能是乏味的，并且会成为开发者采用过程中的障碍。此外，总有可能忽视变更或完全错过某些组件。我们发现 自动生成 Backstage 实体描述符 更有效且不易出错。大多数组织有现有的信息源可以启动填充目录条目的过程。良好的开发实践，例如，在 AWS 资源上放置适当的标签或向源文件添加元数据，可以简化实体发现和描述符生成。这些自动化流程可以定期运行 —— 比如每天一次 —— 以保持目录的新鲜和更新。
DataComPy(Apr 2024, 试验)
对数据帧进行比较是数据工程中的常见任务，常用于确保两个数据转换方法间没有显著的偏差或不一致。 DataComPy 是一个用于比较 pandas, Spark 或其他格式 DataFrame 的工具。这个库不仅能比较 DataFrame 的一致性，还能在行和列上对不一致的地方给出细致的洞见。 DataComPy 还可以指定忽略掉无需展示的数值绝对/相对比较和已知差异。我们的一些团队将它用于了冒烟测试组件中，他们发现它能高效比对大数据量多字段的 DataFrame，与此同时它给出的报告也易于理解和应对。
LLaVA(Apr 2024, 评估)
LLaVA（Large Language and Vision Assistant） 是一个开源的大型多模态模型，它结合了视觉编码器和大语言模型，用于通用视觉和语言理解。LLaVA 在遵循指令方面的强大能力，使其成为多模态人工智能模型中的有力竞争者。最新版本，LLaVA-NeXT，能进一步提升问答能力。在开源的语言和视觉辅助模型中，与GPT-4 Vision相比，LLaVA 是一个很有前景的选择。我们的团队一直在使用它进行视觉问题解答。
Mojo(Apr 2024, 评估)
Mojo 是一种新的以人工智能为先的编程语言。它旨在通过将 Python 语法和生态系统与系统编程和元编程特性相结合，缩小研究和生产之间的差距。它是第一种利用新的MLIR编译器后端的语言，拥有零成本抽象、自动调优、及早销毁、尾调用优化和更好的单指令/多数据（SIMD）工学等炫酷功能。我们非常喜欢 Mojo，并鼓励您尝试一下。Mojo SDK 目前适用于 Ubuntu 和 macOS 操作系统。
云上 Arm(Apr 2024, 试验)
近年来，由于与传统基于 x86 的实例相比更具有成本和能源效率优势，云上的 Arm 计算实例变得越来越受欢迎。许多云服务提供商现在都提供基于 Arm 的实例，包括AWS、Azure和GCP。 云上 Arm 的成本优势对于运行大型工作负载或需要扩展的企业特别有利。我们看到许多团队将工作负载（如 JVM 服务甚至数据库（包括 RDS））迁移到 Arm 实例，无需更改代码，构建脚本的更改也很小。新的基于云的应用程序和系统越来越默认使用云中的 Arm。根据我们的经验，我们建议所有工作负载使用 Arm 计算实例，除非存在特定于架构的依赖。支持多架构的工具，如多架构 Docker 镜像，也简化了构建和部署工作流。
云上 Arm(Apr 2023, 试验)
云上 Arm 计算实例在过去几年中越来越受欢迎。因为与传统的基于 x86 的实例相比，其成本更低，能源效率也更高。如今 AWS、Azure 和 GCP 等许多云供应商都提供基于 Arm 的实例。_云上 Arm _的成本优势对于运行大型工作负载或需要扩容的企业来说特别有利。根据我们的经验，除非依赖于特定架构，建议所有工作负载都使用 Arm 计算实例。多架构 docker 镜像等很多支持多架构的工具也可以简化构建和部署的工作流。
Codium AI(Apr 2024, 评估)
在AI编程助手持续涌现的过程中，相较于孵化大而全的工具，一些产品选择聚焦于某些领域。Codium AI 正是如此，它聚焦于使用 AI 生成代码测试。可以用于所有编程语言，但是对常用技术栈如 JavaScript 和 Python 提供了更进阶的支持。 我们格外中意这个工具，因为它不只向开发者提供测试代码，同时还能对场景提供用于评审的自然语言描述。这能使开发者理解测试用例背后的用意，帮助开发者选择哪些要放入代码库。如果想要进一步提高对特定代码库和测试用例生成的测试质量，用户可以提供测试示例和一些提示，帮助 AI 获取更多高质量的信息。
DataOS(Apr 2024, 评估)
随着越多越多人开始使用data mesh，我们的团队一直在寻找将数据产品作为最高优先级对待的数据平台。DataOS 就是这样一款产品。它提供了从设计、构建、部署到演进数据产品的端到端生命周期管理。它提供标准化的声明式规范（用 YAML 编写），抽象了底层基础设施设置的复杂性，允许开发人员通过 CLI/API 轻松定义数据产品。它支持访问控制策略与ABAC以及数据策略用于过滤和脱敏数据。另一个值得注意的特性是它将数据联邦化到多种数据源的能力，这减少了数据重复和数据向中心地点的转移。DataOS 最适合于绿地场景，因为它提供了数据治理、数据可发现性、基础设施资源管理和可观测性的开箱即用解决方案。对于棕地场景，在 DataOS 外部编排资源（例如，像 Databricks 这样的数据堆栈）的能力还处于起步阶段，并且仍在不断发展中。如果你的生态系统能够接纳数据工具，DataOS 是加快你构建、部署和以端到端方式使用数据产品的不错选择。
Cargo Lambda(Apr 2024, 评估)
Rust的高效和性能很适合用于无服务器计算，再考虑到它还有函数无需运行时的优势，这些都使得它能快速启动工作。 但是使用 Rust 开发 lambda 函数的体验此前并不好，而这一情况被 Cargo Lambda的出现改变了。作为 cargo 的子命令，它能集成到典型的 Rust 工作流中并且能允许你在开发机上运行和测试 AWS Lambda 函数而无需借助Docker、虚拟机，或者其他工具。 使用 Zig 工具链，Cargo Lambda 可以在多种不同操作系统中的 Linux 沙盒中交叉编译并用于 AWS Lambda，这套工具链支持 ARM 和 Intel 作为目标架构。
基础设施编排平台(Apr 2024, 试验)
组织内部的基础设施编排代码库频繁地成为维护和排查故障的时间黑洞。 基础设施编排平台 应运而生，试图将基础设施代码交付和部署工作流的各个方面变得标准化和产品化。其中包括构建一些工具，例如Terragrunt、Terraspace；以及 IaC 工具供应商的服务，如Terraform Cloud和Pulumi Cloud，以及与工具无关的平台和服务，如env0和Spacelift。Terraform 特定的编排工具和服务有一个丰富的生态系统，通常被称为TACOS（Terraform Automation and Collaboration Software），包括Atlantis、Digger、Scalr、Terramate和Terrateam。每个平台支持不同的工作流程，包括GitOps、持续交付和代码合规性。我们很期待看到这一领域涌现出更多解决方案。我们建议基础设施和平台工程团队探索如何使用这些解决方案，从而减少他们开发和维护基础设施所需的差异不大的自定义代码量。基础设施代码的结构化、共享、交付和部署的标准化也能够为测试、度量和监控基础设施的兼容工具生态系统的出现创造机会。
Pinia(Apr 2024, 试验)
Pinia 是一个在Vue.js中使用的存储库和状态管理框架。它使用声明性语法并提供了自己的状态管理 API。与Vuex相比，Pinia 提供了一个更简单的 API，简化了使用流程，提供了组合式 API，并且在与TypeScript一起使用时具有可靠的类型推断支持。Vue.js 团队认可 Pinia 作为 Vuex 的可靠替代品，目前它是 Vue.js 的官方状态管理库。总的来说，我们认为 Pinia 的简单性和易用性是非常不错的。
OpenTofu(Apr 2024, 评估)
OpenTofu 是对 Terraform 的一个分支，作为对 HashiCorp 最近模糊不清的许可证更改的回应。它是开源的，并已被 Linux Foundation 接受。它得到了包括第三方供应商在内的几个组织的支持。当前版本与 Terraform 的最后一个开源版本兼容。1.7 版新增了客户端加密功能。OpenTofu 项目的未来尚不明确，包括它将如何紧密支持 Terraform 未来版本的兼容性，它能否得到当前支持者的长期支持也是一个未知项。我们建议持续关注它，但要谨慎使用。如果你们团队有非常强的风险管理能力，可以尝试使用，或许还能为代码库作出一些贡献。
Rust for UI(Apr 2024, 评估)
Rust 的影响力与日俱增，很多最近出现的构建工具和命令行工具都是由 Rust 编写的。我们现在观察到 Rust 有移植到 UI 开发领域的趋势。大部分偏向于在前后端使用统一代码语言的开发团队会选择 JavaScript 或者 TypeScript 作为后端语言。然而，开发者现在也可以通过WebAssembly在浏览器里使用 Rust 代码，而这正在变得越来越常见。另外，像 Leptos和sauron 这样的框架会更关注在网页应用开发上，同时Dioxus还有其他的一些框架在网页应用开发之外还提供了跨平台桌面以及移动应用开发的支持。
Develocity(Apr 2024, 试验)
Develocity （之前是 Gradle Enterprise） 解决了大型软件项目长时间的构建和测试周期的痛点。它采用构建缓存和预测试选择来提升性能从而缩短开发人员在本地和 CI/CD 环境中的反馈循环。我们的平台团队发现这对于加速构建和测试、分析命令以确定工作流程中哪些部分仍需优化、识别和解决不稳定的测试以及对运行测试的硬件进行分析非常有用。
Crux(Apr 2024, 评估)
Crux 是一个用 Rust 编写的开源跨平台应用开发框架。受到 Elm 架构的启发，Crux 将业务逻辑代码作为核心，UI 层则使用了原生框架（如SwiftUI、Jetpack Compose 以及 React/Vue），或者是基于 WebAssembly 的框架（如 Yew）。通过 Crux，你可以在 Rust 中编写无副作用的行为代码，并在 iOS、Android 和网页中共享。
GitHub Copilot(Apr 2024, 试验)
尽管 AI 编码辅助市场愈发壮大，GitHub Copilot仍然是我们的首选，且被许多团队广泛使用。自上次我们介绍 GitHub Copilot 以来，最有趣的改进来自于聊天功能。例如，不再需要用注释作为提示，这样会使代码变得混乱； 相反，内置聊天可以帮助提示用户，而无需撰写注释。内联聊天还可以更改代码，而不仅仅是编写新行。现在还可以通过使用@workspace标签，显著扩展聊天时询问有关代码问题的上下文。这使得用户可以询问有关整个代码库的问题，而不仅仅是打开的文件。你可以通过使用Copilot Enterprise版本进一步扩展此上下文，该版本会从你在 GitHub 上托管的所有存储库中提取上下文。最后，GitHub 已经开始将一些聊天请求路由到更强大的基于 GPT-4 的模型，并且在流行的 Jetbrains IDE 中即将推出聊天功能（尽管在撰写本文时仍处于内测阶段）。这些发布表明，这一领域的改进步伐并未减缓。如果你去年尝试过编码助手却最终放弃，我们建议你持续关注新发布的功能，并再次尝试。
GitHub Copilot(Sep 2023, 试验)
GitHub Copilot 被我们的许多团队用来帮助他们更快地编写代码，总体来说，我们的绝大多数开发人员认为这个工具非常有用，并且如果我们限制这个工具的使用，他们可能会感到失望。我们一直在通过生成式 AI 探索集 和Copilot 入门指南 整理和分享我们使用 Copilot 的经验。请注意，任何代码库都可以使用 Github Copilot，不局限于托管在 GitHub 上的代码库。\n我们还很高兴看到自上次在技术雷达中亮相以来，来自 Copilot X 路线图 的 Copilot 聊天功能已经变得更加的普及。这是 Copilot 内联辅助功能的一个强大的补充。应用在 IDE 内的聊天界面，提高了常见信息检索的可发现性，并且与开放式编辑器上下文的集成使得对错误的研究或请求聊天协助执行与焦点代码相关的任务变得轻而易举。
GitHub Copilot(Apr 2023, 评估)
GitHub Copilot 是一个由微软和 OpenAI 联合创建的人工智能编码助手。它根据开发者当前工作上下文，利用机器学习模型提供建议。它具有强大的 IDE 集成功能，可以根据现有的代码和编译器环境提供建议。尽管它被称为"您的人工智能结对编程程序员"，但我们不把它的工作称为"结对编程"——我们更倾向于称它为强化且上下文敏感的 Stack Overflow。当它正确地预测了开发人员将要做的事情时，它会是一个强大的可以帮助完成开发的工具。不过，像所有基于 LLM 的人工智能一样，它会试图使用一些看似合理，但不存在的 API，或者使用稍有问题的算法，导致系统故障。我们已经成功地在行、块和方法层面上生成了代码，同样成功地创建了测试和基础设施配置。有趣的是，当你命名良好时，它的工作效果最好，可以认为它鼓励写出可读性良好的代码。\n人工智能工具的功能正在迅速发展，我们认为企业尝试这些工具是明智的。一些 Copilot 的销售宣称该工具对开发人员效率提升显著，但我们仍然持怀疑态度：毕竟，写代码并不是开发人员花时间的唯一事情，而且衡量开发人员的生产力是众所周知的困难问题。即便如此，Copilot 依然是一个相当划算的工具；如果它能提供任何生产力的提高，也是值得一试的。Copilot X——截至本文撰写时尚处于预览阶段——提供了额外的功能，并在软件开发流程中进行了整合。Copilot 有一个"商业版"产品，解决了知识产权问题，并且增加了在整个组织中集中管理工具的能力。我们认为这些功能至关重要，值得企业采购。
RISC-V 用于嵌入式(Apr 2024, 评估)
随着 Arm 架构继续扩大其影响力 — 我们在本期雷达更新了对云上 Arm的评估 — 对更新但不那么成熟的 RISC-V 架构的兴趣也在增长。RISC-V 并没有在性能或效率方面带来突破 — 实际上，它的每瓦性能与 Arm 相似，且在绝对性能上无法与之竞争 — 但它是开源的、模块化的，且不依赖于单一公司。这使得它成为嵌入式系统中的一个有吸引力的选择，因为在这些系统中，架构的许可专有成本是一个重要的考虑因素。这也是为什么 RISC-V 用于嵌入式 领域日臻成熟，以及包括 SiFive 和 espressif 在内的几家公司正在为广泛的应用提供开发板和 SoCs。如今，能够运行 Linux 内核的微控制器和微处理器以及相应的软件栈和工具链都已可用。我们正在关注这一领域，并预计在未来几年内看到更多的采用。
追踪健康债务状况(Apr 2024, 试验)
通过将健康度评级与其他服务级目标（SLO）同等对待，并据此确定增强的优先级，而不是仅仅关注跟踪技术债务，我们不断体验到团队对其生态系统的改进。通过有效分配资源来解决与健康状况相关的最有影响的问题，团队和组织可以降低长期维护成本，更高效地发展产品。这种方法还能加强技术和非技术利益相关者之间的沟通，促进对系统状态的共同理解。尽管不同组织的衡量标准可能有所不同（请参阅本博文 中的示例），但它们最终都有助于实现长期可持续性，并确保软件保持适应性和竞争力。在瞬息万变的数字环境中，专注于 跟踪系统的健康状况与债务 ，可为维护和增强系统提供结构化的循证战略。
追踪健康债务状况(Sep 2023, 试验)
通过将健康度评级与其他服务级目标（SLO）同等对待，并据此确定增强的优先级，而不是仅仅关注跟踪技术债务，我们不断体验到团队对其生态系统的改进。通过有效分配资源来解决与健康状况相关的最有影响的问题，团队和组织可以降低长期维护成本，更高效地发展产品。这种方法还能加强技术和非技术利益相关者之间的沟通，促进对系统状态的共同理解。尽管不同组织的衡量标准可能有所不同（请参阅本博文 中的示例），但它们最终都有助于实现长期可持续性，并确保软件保持适应性和竞争力。在瞬息万变的数字环境中，专注于 跟踪系统的健康状况与债务 ，可为维护和增强系统提供结构化的循证战略。
追踪健康债务状况(Apr 2023, 评估)
在软件交付组织中，如何管理技术债务是一个经久不衰的话题。哪些是技术债务而哪些不是？如何确定它的优先级？最重要的是，如何向内部利益相关者展示偿还技术债务的价值？遵循敏捷宣言的推理方式——“尽管右项有其价值，我们更重视左项的价值”，我们喜欢“管理技术健康状况优先于技术债务”的想法。澳大利亚的 REA 团队分享了一个很好的案例，介绍了他们如何追踪管理开发、运维和架构三个方面的系统健康状况。\n将关注点放在技术健康状况而非技术债务上更有建设性。这样将团队与减少技术债务的最终价值联系起来，并帮助团队确定优先级。理想情况下，每个被解决的技术债务都应与某项已达成共识的期望相关联。团队应将技术健康状况评级与其他服务级别目标 (SLO) 一样对待，并在某个类别的健康评级跌出“安全区域”时优先进行改进。
QAnything(Apr 2024, 评估)
大语言模型（LLMs）和检索增强生成（RAG）技术极大地提高了我们整合和提取信息的能力。我们看到越来越多的工具利用了这一点，QAnything 就是其中之一。QAnything 是一个问答界面的知识管理引擎，能够从包括 PDF、DOCX、PPTX、XLSX 和 MD 文件等在内的多种文件格式中总结和提取信息。出于数据安全考虑，QAnything 还支持离线安装。我们的一些团队使用 QAnything 来构建他们的团队知识库。在具有更深行业深度的 GenAI 场景中（例如为投资报告生成摘要），我们也尝试使用这个工具进行概念验证，以在构建真正的产品之前展示 LLMs 和 RAG 的潜力。
HyperDX(Apr 2024, 评估)
HyperDX 是一个开源的可观测性平台，整合了可观测性的三大支柱：日志、指标和追踪。在它的帮助下，可以实现端到端的关联，并且只需几次点击就能从浏览器会话回放跳转到日志和追踪信息。该平台使用 ClickHouse 作为所有遥感数据的中心数据存储，能够扩展以聚合日志模式，并将数十亿事件压缩成独特的集群。虽然这并不是唯一可选的可观测性平台，但我们在这里想特别强调 HyperDX 统一的开发者体验。
LLaMA-Factory(Apr 2024, 评估)
我们一如既往地提醒大家，非必要情况下，不要着急对大语言模型进行微调 —— 这将增加显著的成本和专家资源负担。在必须微调的情况下，我们推荐LLaMA-Factory 。它是一个开源的、易于使用的 LLMs 微调和训练框架。支持LLaMA、BLOOM、Mistral、Baichuan、Qwen 和ChatGLM，它使微调等复杂概念相对容易理解。我们的团队成功地使用了LLaMA-Factory 的 LoRA 调优来训练 LLaMA 7B 模型。如果您需要进行微调，这个框架是值得评估的。
将传统NLP与LLMs相结合(Apr 2024, 试验)
大语言模型(LLMs)是自然语言处理(NLP)中的瑞士军刀。但它们往往比较昂贵，且并非总是最合适的 - 有时候使用一个螺丝刀会更合适。实际上，在 将传统NLP与LLMs相结合 ，或者在将多种NLP与LLMs相结合，以实现用例并利用LLMs的实际需求能力的步骤方面有很大的潜力。传统的数据科学和NLP方法，例如文档聚类、主题识别和分类，甚至摘要生成，成本更低且可能更有效地解决你的使用案例问题的一部分。然后，在需要生成和总结较长文本，或将多个大型文档合并时，我们使用LLMs，以利用其较高的注意力跨度和记忆力。例如，我们已经成功地将这些技术结合使用，从一个大型单个趋势文档语料库生成关于某一领域的全面趋势报告，同时结合传统聚类方法和LLMs的生成能力。
Kaniko(Apr 2024, 采纳)
我们在 2022 年 10 月的技术雷达中加入了Kaniko，就在Kubernetes 停止支持 Docker之后不久。当时我们强调了 Docker 作为构建基于容器流水线中容器镜像的默认工具的趋势。从那以后，我们在不同流水线的工具和配置上增加了对 Kaniko 的使用经验。我们团队欣赏它的灵活性和性能，这就是为什么我们要将其移到“采纳”阶段，以此来强调 Kaniko 应当成为这一领域的默认工具。
Kaniko(Oct 2022, 试验)
当前大多数的 CI/CD 流水线工具和平台都是以容器作为运行时构建的。而我们的许多团队正在使用 Kaniko 从这些基于容器的流水线中构建容器镜像。这是一种趋势的一部分，即不再将 Docker 容器运行时作为业界标准。有了 Kaniko，您可以在不使用 Docker 守护进程的情况下构建镜像。这有助于避免 Docker “特权”模式所带来的安全问题，而“特权”模式对任何“ 在 Docker 中运行 Docker ”的活动都是必要的。此外，您不必首先确保流水线可以访问 Docker 守护进程。通常这都需要额外的配置，而现在都不再是理所当然。
Mixtral(Apr 2024, 评估)
Mixtral 是 Mistral 发布的开放权重大语言模型家族的一部分，它采用了稀疏混合专家架构。这个模型家族以 7B 和 8x7B 参数大小的形式，提供原始预训练和微调版本。其大小、开放权重特性、基准测试中的性能以及 32,000 个 token 的上下文长度，使其成为自托管大语言模型中一个非常耀眼的选择。需要注意的是，这些开放权重模型并没有针对安全性进行优化调整，用户需要根据自己的用例进行精细调整。我们在开发与特定印度法律任务相关的数据上训练的精调 Mistral 7B 模型 Aalap方面有一定经验，该模型在有限成本的基础上表现相当好。
Terrascan(Apr 2024, 试验)
Terrascan 是一个用于基础设施即代码 (IaC) 的静态代码分析器，旨在云原生基础设施部署之前检测安全漏洞和合规问题。 它支持对Terraform, Kubernetes (JSON/YAML), Helm, AWS CloudFormation, Azure Resource Manager, Dockerfiles 和 GitHub 进行扫描。 默认策略包支持所有主流的云供应商, GitHub, Docker 和 Kubernetes. 我们团队在本地使用 Terrascan 作为预提交钩子(pre-commit hook) 并在 CI 流水线中集成 Terrascan 来检测 laC 漏洞和违规行为。
急于冲向大语言模型微调（fine-tune LLMs）(Apr 2024, 暂缓)
许多组织都在试图将大语言模型(LLMs)应用于他们的产品、领域或组织知识，我们看到了太多 急于冲向大语言模型微调（fine-tune LLMs） 的情况。虽然这种操作的确可以强大到对特定任务的用例进行优化，但在许多情况下对大语言模型进行微调并不是必需的。最常见误用是为了让 LLM 应用程序了解特定的知识、事实或组织的代码库进行微调。在绝大多数场景下，使用检索增强生成（RAG）可以提供更好的解决方案和更优的投入产出比。微调需要大量的计算资源和专家能力，并且比 RAG 面临更多敏感和专有数据挑战。此外当你没有足够的数据进行微调时，还有欠拟合(underfitting)的风险。又或者，当你拥有太多数据时(这倒不太常见)，出现过拟合(overfitting)风险。总之达到你所需要任务专业性的正确平衡是比较困难的。在你急于为应用场景进行大语言模型微调前，需要仔细考虑这些权衡和替代方案。
FOCUS(Apr 2024, 评估)
云和 SaaS 计费数据可能非常复杂，不同供应商之间存在许多不一致。 FinOps Open Cost and Usage Specification (FOCUS) 旨在通过提供包含一组专业术语的规范（和 FinOps framework对齐）、一个模式和一组最低要求的计费数据来减少此类问题。规范旨在支持各类 FinOps 从业者常见的用例。即便它目前仍然处于早期开发和采用阶段，也是值得关注的。随着行业采用的增长，FOCUS 将使平台和终端用户更容易、更全面地了解在云和 SaaS 供应商那里的长尾支出情况
Granted(Apr 2024, 评估)
鉴于组织在 AWS 环境中常常采用多账户策略，工程师经常需要在短时间内切换多个账户。而Granted作为一个命令行工具，简化了同时在浏览器中打开多个账户的操作，从而使账户切换变得更加流畅。它利用浏览器的原生功能来隔离多个身份，例如 Firefox 的 多账户容器 和 Chromium 的配置文件。如果指定了特定服务（如 S3）作为参数，Granted 会打开该服务的登录页面。目前，Granted 仅支持 AWS。值得注意的是，它将 AWS SSO 的临时凭证安全地存储在密钥链中，而不是以明文形式存储在磁盘上。
Akvorado(Apr 2024, 评估)
Akvorado 是一个开源的网络监控和分析工具。它可以捕获网络流量，支持 Netflow/IPFIX 和 sFlow 协议，为其添加接口名称和地理信息，然后将更新后的流量保存在ClickHouse中供未来分析使用。虽然OpenTelemetry在观测应用层流量方面越来越受欢迎，但我们通常会遇到在网络层面很难发现和解决的挑战。在这种情况下，像 Akvorado 这样的工具非常有用，它可以帮助你分析网络拓扑中各种设备之间的网络流量。
Pop(Apr 2024, 试验)
结对编程对于我们来说是一项必不可少的实践，因为它能帮助我们提高代码质量，在团队内传播知识。虽然结对编程最好发生在线下，面对面进行，但在不可避免要进行线上结对时，我们的团队成员也为此探索了很多工具，比如Tuple, Visual Studio Live Share, Code With Me ，和通用的聊天及会议工具。 Pop （前身为 Screen）作为这个领域最新的工具引起了我们的关注， 它来源于 Screenhero 的创建者，支持多人屏幕分享、编写注释和进行高质量音频/视频通话。我们有些团队正在频繁使用它来进行结对编程和远程工作会议，他们对该软件体验反馈非常正向。
安全标兵(Apr 2024, 试验)
安全标兵**指的是团队成员中对技术和非技术交付决策的安全后果持有批判性思维的人。他们会向团队领导提出这些问题和顾虑，并且对基本安全指南和要求有比较到位的理解。他们协助开发团队在软件交付的所有活动中都以安全意识进行思考，从而降低系统的整体安全风险。安全标兵不是一个单独的职位，而是分配给现有团队成员的责任，这些成员需要由安全从业者进行培训指导。通过这样的培训，安全标兵通过传播知识，并作为开发团队和安全团队之间的桥梁，提高团队的安全意识。安全标兵所做的事情中一个非常好的活动示例是威胁建模，它帮助团队从一开始就将安全风险考虑在内。在团队中任命和培训安全标兵是一个很好的开始，但仅仅依赖标兵而没有来自领导层的适当投入可能会导致问题。根据我们的经验，建立安全意识需要整个团队及管理者的投入。
Electric(Apr 2024, 评估)
Electric是一种用于移动和 Web 应用程序的本地优先同步框架。本地优先是一种开发范式，其中应用程序代码直接与嵌入式本地数据库对话，并通过双活数据库复制到中央数据库，在后台进行数据同步。使用 Electric，您可以将 SQLite 作为本地嵌入式选项，并将 PostgreSQL 作为中央存储。尽管本地优先极大地改善了用户体验，但它并非没有挑战，CRDT的发明者们已经在 Electric 框架上努力解决这些问题，以减轻困扰。
IcePanel(Apr 2024, 评估)
IcePanel 通过使用 C4 模型，促进了协作式的架构建模和图表绘制，使技术和业务利益相关者能够根据需要深入到所需的技术细节级别。它支持建模架构对象，这些对象的元数据和连接可以在多个图表中重用，并且能够将这些对象之间的交互 可视化出来。版本控制和标签使协作者能够模拟不同的架构状态（例如，现状与未来），并跟踪架构各部分的用户定义分类。我们正在关注 IcePanel，因为它有潜力改善架构协作，特别是对于拥有复杂架构的组织。如果你正在寻找更好的支持图表即代码的替代产品，请查看 Structurizr。
Voyager(Apr 2024, 评估)
Voyager 是为 Android 的 Jetpack Compose 构建的导航库。它支持多种导航类型，包括线性、底部表单、标签和嵌套，其屏幕模型与流行框架如 Koin 和 Hilt 集成。在多平台项目中使用 Jetpack Compose 时，Voyager 是实现跨所有支持平台的常见导航模式的优秀选择。近期，Voyager 的开发又重新活跃起来，并在 2023 年 12 月交付了 1.0 版本。
Velero(Apr 2024, 试验)
Velero 是一个用于备份和恢复 Kubernetes 资源和持久卷的开源工具。它通过启用按需和计划备份，简化了灾难恢复和集群迁移。Velero 还能更精细地控制哪些资源被备份，以及相关的备份/恢复流程。我们很赞赏它的易用性，以及它依赖的是 Kubernetes API 而非更低层次的 etcd 等。
Azure OpenAI Service(Apr 2024, 试验)
Azure OpenAI Service 通过 REST API、Python SDK 和基于 Web 的界面提供对 OpenAI 的 GPT-4、GPT-3.5-Turbo、Embeddings、DALL-E 模型等的访问。这些模型可以适用于内容生成、提取摘要、语义搜索和将自然语言转换为代码等任务。通过小样本学习(few-shot learning)和自定义超参数(hyperparameters)，还可以进行微调。与 OpenAI 自己的 API 相比，Azure OpenAI 服务受益于 Azure 的企业级安全性和合规性功能，可在更多地区使用（尽管在更多地理区域可用性有限），并支持私有网络、内容过滤和手动模型版本控制。基于上述特性以及我们在具体使用中的积极体验，我们推荐已经使用 Azure 的企业考虑使用 Azure OpenAI Service，而不是 OpenAI API。
Azure OpenAI Service(Sep 2023, 评估)
伴随对生成式 AI 的巨大关注，许多访问主流模型的解决方案应运而生。如果正在考虑或正在使用 Azure ，那么我们推荐评估 Azure OpenAI 服务。它通过 REST API 、Python SDK 以及基于 Web 的界面提供对 OpenAI 的 GPT-4、GPT-35-Turbo 和嵌入模型的访问。这些模型可以适应如内容生成、汇总、语义搜索和自然语言到代码的转换的任务，也可以通过少量学习和超参数的定制进行微调。与 OpenAI 自己的 API 相比，Azure OpenAI 服务受益于 Azure 企业级的安全性和合规性，同时也在更多的区域可用，哪怕每个较大的地理区域的可用性是有限的。
aider(Apr 2024, 评估)
aider 是一款开源的 AI 辅助编码工具。与该领域的许多开源工具一样，aider 并不直接与 IDE 集成，而是以 CLI 的形式在终端启动。目前许多辅助编码工具只能读取代码，或者一次只能更改一个文件，而 aider 的有趣之处在于，它提供了一个聊天界面，并且有写权限来对多个文件的代码库进行访问。这使得 aider 可以帮助实现跨越多个文件的概念（例如，在 HTML 中添加定位器，然后在功能测试中使用它们”），并在代码库中创建新的文件和文件夹结构（例如，创建一个与 X 文件夹中的组件类似的新组件）。由于 aider 是开源而非托管产品，因此需要提供 OpenAI 或 Azure OpenAI API 密钥才能使用。一方面，因为是按使用量计费，这非常适合轻度使用；但另一方面，aider 在与 AI API 交互时似乎很“健谈”，因此使用时要注意请求开销和费用限制。
OpenCost(Sep 2023, 评估)
OpenCost 是一个开源项目，用于监控基础设施成本，并以 Kubernetes 对象（Pod、容器、集群等）的粒度展示成本信息，涵盖各种集群内资源（CPU、GPU、RAM、存储、网络）的成本数据。它与多个云服务提供商的 API 进行集成，以获取计费数据，并可配置用于本地 Kubernetes 集群的定价策略。OpenCost 是最初由 Kubecost 构建并仍被其使用的成本分配引擎，但也可以单独使用。OpenCost 的成本分配数据可以导出为 CSV 文件或导入到 Prometheus 进行进一步分析和可视化。我们的团队正在密切关注像 OpenCost 和 Kubecost 这样的工具的发展，这些工具可以为采用 Kubernetes 的产品和平台团队提供成本可见性。然而在目前的阶段，我们发现 OpenCost 在某些工作负载（如数据管道中经常使用的短期 Spot 实例）上尚不完全适用。
ActivityPub 协议(Sep 2023, 评估)
随着微型博客平台领域的剧变，ActivityPub 协议 逐渐名声鹊起。ActivityPub 是一个用于分享诸如帖子、出版物和日期等信息的开放协议。它可以用来实现一个社交媒体平台，但其关键优势在于能够实现不同社交媒体平台之间的协同工作能力。我们预计 ActivityPub 将在社交媒体领域扮演重要角色，但更加对其在其他领域可能发挥的作用感到好奇。一个例子就是最近 GitLab 提出对合并请求增加 ActivityPub 支持。
Yalc(Sep 2023, 试验)
Yalc 是一个简易的本地 JavaScript 包管理库以及跨本地开发环境进行发布与包管理的工具。对于有一些限制的 npm link 指令来说，Yalc 是一个更可靠的替代品。在使用多个包的时候 Yalc 特别好用，尤其是当有些包使用 yarn，而有些包使用 npm 的时候。它同样能帮助在发布包到远端之前进行本地的测试。根据我们的经验，Yalc 在配置多个包和加速前端以及其他 JavaScript 应用开发的工作流方面非常有价值。
Snyk(Sep 2023, 采纳)
Snyk 提供静态应用程序安全测试（SAST）和软件组件分析（SCA）测试，以帮助您在软件开发生命周期中寻找、修复和监控安全问题。其广泛的功能旨在加快反馈循环，倾向于采用“左移”方法，而不是安全三明治反模式。作为今天可用的最佳安全平台之一，Snyk 之所以脱颖而出，是因为它能够识别更广泛的问题，而这主要得益于有专门的研究团队不断更新其漏洞数据库。 但是 Synk 仍有改进的空间：仪表板目前没有提供一个简便的方法从一个具体的可操作的信息中过滤一些多余繁杂的信息；根据语言生态系统的不同，基于 SCA 的集成可能与基于流水线的集成相比产生误报，因为 Snyk 必须猜测已解决的依赖关系；自动解决方案的成功性不一致；在高度监管的环境中，需要进行重大的集成投资，以实现适当的门控或建立软件物料清单。尽管存在这些缺点，我们的许多企业客户依然采用了 Snyk；我们自己也在 IT 部门中使用了它。
Snyk(Nov 2018, 试验)
Snyk helps you find, fix and monitor known vulnerabilities in npm, Ruby, Python, Scala, Golang, .NET, PHP, Java and Docker dependency trees. When added to your build pipeline, Snyk continuously monitors and tests the library dependency tree against a hosted vulnerability database and suggests the minimal direct dependency version upgrade needed for remediation.
Netflix DGS(Sep 2023, 试验)
我们大多时候将 GraphQL 用于服务端资源聚合 ，并且使用多种技术实现服务端。对于使用 Spring Boot 开发的服务，我们的团队使用了 Netflix DGS ，体验很好。Netflix DGS 基于 graphql-java 开发，并提供了许多 Spring Boot 编程模型的特性与抽象。因此使得开发 GraphQL 端点，以及与 Spring Security 等 Spring 特性集成就变得很容易。虽然 DGS 是用 Kotlin 编写的，但在 Java 上它也工作的很好。
开源编程大语言模型(Sep 2023, 评估)
GitHub Copilot 是软件开发时有价值的辅助编程工具。而在工具背后，大语言模型（LLMs）通过赋能内联代码助手、代码微调和 IDE 中的对话支持等方式，无缝提升开发人员的体验。 大多数这些模型都是专有的，只能通过订阅服务使用。好消息是，您可以使用几种开源的 LLMs 进行编码。如果您需要构建自己的编码辅助服务（比如受到高度监管的行业），可以考虑 StarCoder 和 WizardCoder。StarCoder 使用由 BigCode 维护的大型数据集 进行训练，而 Wizardcoder 是 Evol-Instruct 调整后的 StarCoder 模型。\n我们在实验中使用了 StarCoder，发现它对于生成诸如代码、YAML、SQL 和 JSON 等 结构化软件工程元素十分有用。根据我们的实验，我们发现这两个模型都可以使用提示词中的 小样本示例 进行上下文学习 。尽管如此，对于特定的下游任务（例如为 Postgres 等特定数据库生成 SQL），模型仍需要微调。最近，Meta 推出了 Code Llama，一款专用于编程的 Llama 2。使用这些开源模型时务必要小心谨慎。在选择任何这些编码 LLMs 供您的组织使用之前，请考虑它们的许可，包括代码的许可和用于训练模型的数据集的许可，仔细评估这些方面后再做决定。
Kubeconform(Sep 2023, 试验)
Kubeconform 是一个用来验证 Kubernetes 清单和自定义资源 (CRD) 的简化工具。它能很容易地在 CI/CD 流水线或本地机器中部署，通过在部署前验证资源，以减少潜在的错误。鉴于 Kubeconform 在加强运行保证方面有良好记录，特别是在跨团队共享模板资源方面，我们建议试用 Kubeconform 以提高资源验证流程的安全性和效率。
Cilium(Sep 2023, 试验)
eBPF 以其应用透明、高性能和低开销而闻名，因此云原生社区一直在探索其在无边车网格服务（service mesh without sidecar） 中的应用场景。Cilium 是一个为云原生环境如（Kubernetes 集群和其他容器编排平台）提供网络、安全性和可观察性的开源项目。Cilium 为路由或覆盖网络提供了一个简单的第三层网络，并且还支持 L7 协议。通过将安全性从寻址中解耦，Cilium 可以作为一种新的网络保护层发挥重要作用。我们已经看到一些云服务提供商采用了 Cilium，我们的一些项目中也使用了 Cilium。社区仍在讨论 eBPF 是否可以替代边车（sidecar），但似乎这已经达成共识，即某些网格功能不能或不应该在内核中执行。此外，使用 Cilium 还需要 eBPF 相关的经验。基于我们项目取得的良好成果，我们建议您亲自实践一下这项技术。
Cilium(Apr 2019, 评估)
Traditional Linux network security approaches, such as iptables, filter on IP address and TCP/UDP ports. However, these IP addresses frequently churn in dynamic microservices environments. By leveraging Linux eBPF, Cilium provides API-aware networking and security by transparently inserting security in a way that is based on service, pod or container identity in contrast to IP address identification. By decoupling security from addressing, Cilium could play a significant role as a new network protection layer and we recommend you to check it out.
AWS SAM(Sep 2023, 试验)
AWS Serverless Application Model (SAM) 是一款用于在 AWS 云基础设施上构建无服务器应用的开源框架。此前入选技术雷达条目的Serverless Framework作为一种在各个云服务商上部署无服务器服务的流行框架，主要用于基于AWS Lambda的服务。近来，AWS SAM 因其长足的发展而日益受到欢迎。我们的团队发现 AWS SAM 非常易于配置，并且我们还尝试将其用于测试和调试基于 AWS Lambda 的服务，包括开发时在本地执行 Lambda 函数。
设计系统(Sep 2023, 采纳)
随着应用开发变得越来越动态和复杂，交付风格一致且好用的产品成为了一项挑战，尤其是在有多个团队参与不同产品开发的大型组织中。设计系统定义了一系列的设计模式、组件库以及良好的设计和工程实践，以确保数字产品的一致性。设计系统从过去的企业风格指南演变而来，提供易于查找和使用的共享组件库和文档。通常，设计系统的风格指南以代码的形式记录并进行版本控制，比简单的文档记录更加清晰且易于维护。设计系统已经成为跨团队和学科进行产品开发时的标准方法，每当需要新的视觉组件时，团队不用重新发明轮子，因此能够集中精力，专注解决产品本身的种种挑战。\n我们的经验表明，团队在构建设计系统时很少采用产品为中心的思维方式。共享组件库和文档的主要消费者是产品开发团队。在使用产品为中心的思维方式时，设计系统所有者应该与消费者（开发团队）合作，建立共情。我们发现，许多组件库之所以受到批评，是因为所有者团队无法快速响应消费者的需求，并且无法接受来自外部的贡献。产品为中心的思维方式还要求组织思考是否应该允许和怎样向设计系统做出贡献，以及如何管理这些贡献——在这个话题上，我们推荐采用设计系统决策记录 。对我们来说，维护一个良好的设计系统或组件库不光是技术工作，也同样是社交工作。
设计系统(Apr 2021, 采纳)
随着应用程序开发变得越来越动态和复杂，以一致的风格交付可访问且可用的产品变成了一个挑战。在拥有多个团队从事不同产品开发的大型组织中，尤为如此。 设计体系 定义了一组设计模式，组件库，以及良好的设计和工程实践，以确保数字产品的一致性。在过去的公司风格指南基础上，设计体系提供了易于查找和使用的共享库和文档。通常指南是以代码的形式编写，并且受版本控制管理，所以相比简单的文档，它更明确且易于维护。设计体系已经成为跨团队和学科产品研发时的标准方法，因为它可以使团队更加专注于解决围绕产品本身的战略挑战，而无需在每次需要新的视觉组件时都重复造轮子。
设计系统(Nov 2019, 试验)
随着应用程序开发变得越来越动态和复杂，高效地交付风格一致可访问和可用的产品变成了一项挑战。设计系统定义了一套设计模式、组件库以及良好的设计和工程实践的集合，以确保数字产品开发的一致性。在跨团队和学科的产品开发中，我们发现设计系统是对工具箱的有用补充，因为它们让团队可以专注在产品本身更具战略性的挑战上，而无需在每次需要添加一个视觉组件时都不得不重新发明轮子。你用于创建设计系统的组件和工具的类型都可能存在很大的不同。
Ajv(Sep 2023, 试验)
Ajv 是一个流行的 JavaScript 库，用于根据使用 JSON Schema 定义的结构验证数据对象。对于验证复杂的数据类型，Ajv 既快速又灵活。它支持多种多样的 schema 特性，包括自定义关键字和格式。许多开源的 JavaScript 应用程序和库都使用它。 我们的团队使用 Ajv 在 CI 工作流中实现消费者驱动的契约测试，另外再配合其他工具一起通过 JSON Schema 生成模拟数据，功能非常强大。在 TypeScript 的世界中，Zod 是一种流行的替代方案，它可以用于定义 schema 和验证数据的声明式 API。
ChatGLM(Sep 2023, 评估)
在英语世界中，有许多新兴的大语言模型（LLM）。虽然这些模型通常经过多种语言的预训练，但它们在其他语言中的表现可能不如英语。清华大学开发的 ChatGLM 是一个开放的双语语言模型，基于通用语言模型架构，针对中文会话进行了优化。由于中文在词语划分和语法方面较英语更为复杂，因此拥有一个针对中文进行优化的 LLM 非常重要。我们的团队在为呼叫中心开发中文情感检测应用时发现，ChatGLM 在准确性和鲁棒性方面都优于其他 LLM。考虑到许多 LLM 因授权或地区限制而无法在中国使用，ChatGLM 成为了为数不多的开源选择之一。
使用 Terraform 创建监控和告警(Sep 2023, 试验)
基础设施及代码（IaC） 已经是一种被广泛采纳用于定义和创建托管环境的方法。尽管这个领域的工具和技术不断发展，但 Terraform 仍然是 IaC 方式管理云原生资源的主要工具。然而，当下大多数托管环境都是云供应商原生服务、第三方服务和自定义代码的复杂组合。在这些环境中，我们发现工程师通常会使用 Terraform 处理云资源，又使用自定义脚本处理其他资源。这可能导致资源创建过程缺乏一致性和可重复性。事实上，在托管环境中常用的许多第三方服务 Terraform 都提供了相应的支持程序，可以用来创建和配置这些服务，例如 Splunk、Datadog、PagerDuty 和 New Relic。因此，我们建议团队除了云资源外，还应 使用 Terraform 创建监控和告警 。这将实现更模块化的 IaC，更易于理解和维护。与所有 IaC 一样，同时使用多种方式进行配置变更，会带来不一致的风险。所以，我们建议禁用通过用户界面和 API 的方式处理配置变更，确保 Terraform 代码始终是唯一的真实生效的版本。
Pushpin(Sep 2023, 试验)
Pushpin 是一种反向代理工具，充当处理长连接（如 WebSockets 和服务器发送事件）的后端服务器与客户端之间的中介。它提供了一种终止来自客户端的长连接的方法，意味着系统的其他部分可以从这项复杂工作中解放出来。它能有效管理大量持久连接，并自动将其分配给多个后端服务器，从而优化性能和可靠性。我们在使用 Pushpin 来处理移动设备的 WebSockets 实时通信时获得了良好的体验，并且我们已经通过横向扩展成功使其服务于数百万台设备。
DataOps.live(Sep 2023, 试验)
DataOps.live 是一个自动化 Snowflake 环境的数据平台。受 DevOps 实践启发，DataOps.live 可以像在其他网络平台一样在数据平台中实施持续集成和持续交付 (CI/CD)，自动化测试, 可观测性和代码管理。我们的团队正在用它来管理数据产品的全生命周期，包括代码和数据的开发、分支、部署。通过它的自动化环境管理，能够轻易建立、修改、自动销毁基于特征分支的环境。它的声明式标准 (SOLE) 能力也值得关注，因其可以优化开发者体验。它能使团队构建数据产品的时间从几个月变为几天。我们的团队成功将 DataOps.live 用于生产环境, 这也是我们推荐在使用 Snowflake 时使用这一平台的原因。
DataOps.live(Oct 2022, 试验)
DataOps.live 是一个可在 Snowflake 中实现环境自动化的数据平台。受 DevOps 实践的启发，DataOps.live 通过采用持续集成和持续交付 (CI/CD)、自动化测试、可观测性和代码管理，让你可以像对待任何其他 web 平台一样对待数据平台。 你可以立即回滚更改而不会影响数据，或者从完全故障中恢复，并在几分钟或几小时而不是几天内重建新的 Snowflake 租户。 我们的团队在使用 DataOps.live 的过程中体验良好，因为它让我们能够在 Snowflake 之上构建数据产品时快速迭代。
Insomnia(Sep 2023, 试验)
自从 Postman 在2023年5月宣布 将逐渐淘汰具有离线功能的 Scratch Pad 模式以后，需要将 API 工作区数据从第三方服务器上隔离的团队不得不寻找替代方案。Insomnia 就是可选的替代方案之一：这是一款专为 API 测试、开发和调试而设计的开源桌面应用程序。虽然 Insomnia 支持在线同步，但它可以让你离线保存 API 工作区数据。我们的团队发现，从 Postman 到 Insomnia 进行人工 API 测试是无缝迁移的，因为它们功能相似，而且 Insomnia 允许导入 Postman 的集合。尽管我们的团队在 Insomnia 上获得了良好的体验，但我们仍在关注其他各种形式的开发替代方案——从 GUI工具（如即插即用的Insomnia），到 CLI 工具(如 HTTPie), 再到 IDE 插件(如 IntelliJ HTTP 客户端插件)
Mocks Server(Sep 2023, 试验)
Mocks Server 是一个基于 Node.js 的 API Mock工具，它能够复制复杂的 API 响应、响应头和状态码，因此受到了我们团队的重视。它的动态响应生成支持模拟多种场景，允许对 API 交互进行严格测试。Mock 可以描述为 YAML 或 JSON，并通过 CLI、REST API 或 JavaScript 代码进行管理。Mocks Server 的功能包括请求匹配、代理和录制重现功能，这些功能有助于模拟真实的 API 交互。我们特别喜欢将它与 Docker 容器集成，使其可以轻易地在不同环境之间一致地部署，因此它可以作为整个生态系统的一种构件进行版本控制和维护。它简单直接的方法与我们在开发过程中强调的简单性和效率相一致。随着我们的解决方案和测试策略的演进，我们期待更广泛地使用 Mocks Server。
忽略 OWASP 十大安全风险榜单(Sep 2023, 暂缓)
OWASP 十大安全风险榜单长期以来一直是 Web 应用程序最关键的安全风险参考。尽管众所周知，我们曾写过它在软件开发过程中未得到充分利用，并警告不要忽略 OWASP 十大安全风险榜单。\n但鲜为人知的是 OWASP 也在其他领域发布了类似的十大榜单。在八月初发表了第一个主要版本的 OWASP LLM 十大安全风险榜单 强调了提示注入、不安全的输出处理、训练数据投毒以及其他个人和团队构建 LLM 应用程序时最好注意的风险。OWASP 近期也发布了 OWASP API 十大安全风险榜单的第二版。鉴于 OWASP 十大安全风险榜单的覆盖范围（Web 应用程序、API、LLM 及其他）、质量以及与持续变化的安全形势的相关性，我们继续向团队警告 不要忽略 OWASP 十大安全风险榜单 。
Lokalise(Sep 2023, 试验)
Lokalise 是一个全自动的本地化平台，它支持特定上下文的翻译。我们的团队在ETL流程或开发工作流中使用Lokalise API来翻译可本地化的内容。 Lokalise支持多种文件格式的可本地化字符串。一个值得强调的方面是它支持上传整个文件，其中每个键-值对都被视为单独的记录并被翻译。在底层，我们利用了Lokalise与Google MT的集成来处理翻译。Lokalise 的Web界面提供了便捷的访问方式，供人工审阅员验证翻译结果，或者根据需要简化、重新表达翻译内容。在过去，我们曾介绍过类似的工具，例如Phrase。我们的团队在使用Lokalise方面有很好的体验，建议您评估该平台是否适用于协作翻译工作流程。
平台编排(Sep 2023, 评估)
随着平台工程的广泛采纳，我们看到了新一代的工具，它们超越了传统的平台即服务（PaaS）模型，为开发人员和平台团队之间提供了公开的合约。这个合约可能涉及在不同环境中提供云环境、数据库、监控、身份验证等功能。这些工具强制执行组织标准，同时允许开发人员通过配置自主访问多种环境。这些 平台编排 系统的案例包括 Kratix 和 Humanitec Platform Orchestrator。我们建议平台团队考虑这些工具，作为自己的脚本、本地工具和基础设施即代码（infrastructure as code，IaC）的独特集合替代方案。我们还注意到，与开放应用模型（OAM）及其参考编排器 KubeVela 有相似之处，尽管 OAM 声称更加面向应用程序而不是工作负载为中心。
Colima(Sep 2023, 采纳)
Colima 现在是我们在 macOS 上替代 Docker Desktop 的首选方案。我们持续在几个项目中使用它来提供 Docker 容器运行时的 Lima VM，在 macOS 上配置 Docker CLI，并处理端口转发和挂载卷。Colima 可以配置为使用 containerd 作为其运行时，这也是大多数托管的 Kubernetes 服务上的运行时，可以提高重要的开发到生产环境的一致性。
Colima(Oct 2022, 试验)
Colima 正在成为 Docker Desktop 的一个流行的开源替代方案。它通过 Lima VM 的方式提供 Docker 容器运行时，在 macOS 上配置Docker CLI 并处理端口转发和卷挂载。Colima 使用 containerd 作为容器运行时，这也是大多数托管 Kubernetes 服务采用的容器运行时——这一方案提升了开发与生产环境的一致性。通过 Colima ，你可以轻松地使用和测试 containerd 的最新特性，例如容器镜像的懒加载。我们在项目中使用 Colima 已经取得了不错的效果。在使用 Kubernetes 时，我们也使用 nerdctl，这是一个与 Docker 兼容的 containerd CLI。由于 Kubernetes 已经不再将 Docker 作为容器运行时，而且大多数托管服务（EKS、GKE等）都在追随它的脚步，因此更多的人将会使用 containerd 这类原生工具，使得像 nerdctl 这样的工具更加重要。在我们看来，Colima 有着强大的潜力，并会成为 Docker Desktop 的首选替代方案。
Colima(Mar 2022, 评估)
Colima 正成为 Docker 桌面版的一个热门开放替代方案。它通过在 Lima VM 中配置 Docker 容器运行时环境，可以在 macOS 上配置 Docker CLI 并处理端口转发和挂载存储。Colima 使用 containerd 作为容器运行时，这也是大多数托管 Kubernetes 服务采用的容器运行时（提升了开发与生产环境的一致性）。 您可以基于 Colima 轻松地使用和测试 containerd 的最新特性，例如容器镜像的惰性加载。凭借其良好的性能，我们期待 Colima 成为 Docker 桌面版的强有力开源替代方案。
通过依赖健康检查化解包幻觉风险(Sep 2023, 评估)
确保软件供应链的安全已成为交付团队普遍关心的问题，这也反映在该领域的工具和技术数量不断增加，而一些工具和技术我们在之前的雷达中也进行了介绍。在软件开发过程中使用基于 GenAI 的工具日益普及，这也引发了一种新的软件供应链攻击媒介：包幻觉。我们认为在开发过程中使用 GenAI 工具的团队需要重视这类风险。团队可以 通过对依赖进行健康检查化解包幻觉风险 ：在选择依赖之前查看它的创建日期、下载数量、GitHub 评论及星标数、贡献者数量、活动历史记录等。一些依赖健康检查可以在包存储仓库和 GitHub 上执行，而像 deps.dev 和 Snyk advisor 等工具也可以提供帮助。尽管依赖健康不是一项新技术，但随着团队在软件开发过程中越来越多地尝试 GenAI 工具，该实践正在获得新的关注。
htmx(Sep 2023, 评估)
htmx 是一款轻量简洁的 HTML UI 库，近期突然迅速走红。在技术雷达讨论期间，我们发现其前身 intercooler.js 早在十年前就已存在。与其他越来越复杂的预编译 JavaScript/TypeScript 框架不同，htmx 鼓励直接使用 HTML 属性来实现诸如 AJAX、CSS transitions、WebSockets 和服务器发送事件等操作。从技术角度来看，htmx 并不复杂，但它的流行让人想起早期网页中超文本的简洁风格。该项目的网站上还提供了一些关于超媒体和网页开发的深入（且有趣）的文章，这显示出 htmx 团队对其目标和理念进行过认真思考。
promptfoo(Sep 2023, 评估)
promptfoo 是一款测试驱动的 prompt engineering。在应用程序中集成 LLM 时，调整提示词为生成最佳回答并保证输出的一致性，往往会耗费大量时间。你可以将 promptfoo 作为 CLI 和库使用，根据预定义的测试用例对提示词进行系统测试。测试用例和结果断言则可通过简单的 YAML 配置文件完成设置。 这个配置文件包含需要测试的提示词、模型提供者、断言以及将会在提示词中被替换的变量值。promptfoo 支持多种断言，包括相等性、JSON 结构、相似性、自定义函数检查，甚至支持使用 LLM 对模型输出结果分级。如果你想对提示词和模型质量进行自动化反馈，请务必体验 promptfoo。
Ruff(Sep 2023, 采纳)
Ruff 是一个新的 Python linter 。使用 linter 是毋庸置疑的，只需要考虑具体要使用哪一个。Ruff 能够脱颖而出有两个原因：开箱即用的体验，以及性能。其中内置了500多条规则，可以轻松取代 Flake8 和它的许多插件。我们的经验证实了 Ruff 团队对其性能的说法。实际上，它的速度至少比其它 linter 快出一个数量级，这是一个巨大的优势，有助于减少大型代码库的构建时间。基于上述原因，Ruff 已成为我们实施 Python linter 的默认选择。
Ruff(Apr 2023, 试验)
Ruff 是一个新的 Python linter。我们认为，使用 linter 是毋庸置疑的，只需要考虑使用哪个 linter，因为 Python 提供了很多选择。Ruff 能够脱颖而出有两个原因：开箱即用的体验，以及性能。它内置了500多条规则，可以轻松取代 Flake8 和它的许多插件。我们的经验证实了 Ruff 团队对其性能的说法。它确实比其他 linter 快出至少一个数量级，这是一个巨大的优势，有助于减少大型代码库的构建时间。
设计系统决策记录(Sep 2023, 评估)
在迭代速度快、用户需求不断演进的产品开发环境中，设计是一个不断变化的领域。这意味着对设计决策输入的需求会一直持续下去。我们借鉴了用 ADR（架构决策记录）记录软件架构决策的思路，采用类似的格式，以 设计系统决策记录 来记录设计系统决策以及相应的依据、研究洞见和实验结果，这有效地传达设计系统决策似乎已成为产品开发团队新的需求。这种轻量级的方式也被 zeroheight 推荐。这一方法让我们减少了新人上手时间，推动了讨论的进行，并帮助拉通共用同一个设计系统的多个开发团队。
cdk-nag(Sep 2023, 试验)
cdk-nag 能够识别并报告 AWS CDK 应用程序或 CloudFormation 模板中的安全性和合规性问题。它附带了几个所谓的规则包：一个通用的 AWS 规则包，包括 AWS 认为的最佳实践检查，以及用于 HIPAA、NIST 和 PCI 合规性的规则包。您可以根据需要添加额外的规则。规则可以导致警告或错误，这两者都包含在工具生成的报告中。当存在错误时，cdk deploy 命令将无法进行部署。如果错误的原因无法及时修复，仍然可以在错误存在但已被抑制的情况下进行部署。显然，这应该只在特殊情况下执行
Kraftful(Sep 2023, 评估)
用户体验（UX）研究平台，比如Dovetail，为组织提供了一个工具，帮助他们了解和改善客户体验。通过这个工具，企业能够迅速、轻松地通过收集和分析来自客户反馈、调查、访谈等渠道的数据，深入洞察客户的需求、偏好和行为。情感分析、客户分割、市场研究、数据分析和洞见生成是产品开发中有价值的任务，而这些正好是大语言模型擅长的领域，因此我们看到了它在产品开发领域存在巨大的颠覆潜力。\nKraftful 是一个自诩为产品构建者副驾驶的工具，现在已经处于领先地位。它目前仅处于测试阶段，您需要提供邮箱才能访问其功能。我们已经试用过它并取得了很好的效果。您可以将30多种用户反馈来源连接到这个平台，它可以分析数据并识别功能请求、常见投诉、用户喜欢的产品特点，甚至列出您的竞争对手。为了获取更多细节，您可以像向 ChatGPT 或 Google Bard 提问一样，这里的好处是它针对您的数据进行了优化。一旦您确定了要从用户反馈中解决的问题，Kraftful 会基于所有基础数据（包括验收标准）为您生成用户故事，即使对经验丰富的产品经理和业务分析师来说它也是一个出色的助手。
Google Cloud Vertex AI(Sep 2023, 试验)
自从我们第一次提出 Google Cloud Vertex AI 以来，AI 领域已经发生了重大进展。自 2023 年 5 月以来，Google 推出了多项服务和功能来丰富这一领域。这些新增功能包括 Model Garden，一个拥有100多个预训练模型的仓库；Generative AI Studio，一个旨在快速探索和原型生成 AI 模型的控制台；以及 Vertex AI Extensions ，提供完全托管的开发人员工具，通过 API 连接 AI 模型和实时数据或操作。 该平台已经发展到提供 GenAI 模型和集成支持，我们非常期待能更广泛地使用它。
Google Cloud Vertex AI(Oct 2022, 评估)
GCP Vertex AI 是一个统一的人工智能平台，它让团队可以构建、部署、并扩缩机器学习（ML）模型。Vertex AI 中包含了可以被直接、微调后、或者结合 AutoML 使用的预训练模型，也包含了如特征存储和流水线等机器学习模型的基础设施。我们喜爱 Vertex AI 的集成能力，这有助于让它更像一个连贯的人工智能平台。
Orca(Sep 2023, 试验)
Orca 是一个专有的云安全平台，用于识别、优先级排序和修复安全风险和合规问题。它支持主流的云提供商和混合设置。Orca 拥有广泛的安全查询和规则，以持续监控已部署的工作负载，检测配置错误、漏洞和合规性问题。它支持云虚拟机、无服务器函数、容器以及已部署工作负载的 Kubernetes 上部署的应用。这些内置的安全规则会定期更新，以跟上不断演进的合规标准和威胁向量。由于 Orca 无需代理，因此提供了良好的开发者体验，并且易于设置。另一个显著的特点是它促进了安全的左移。我们的团队使用 Orca CLI 来扫描容器镜像和 IaC 模板，以检测漏洞和配置错误，作为预提交钩子或 CI/CD 工作流的一部分。它还持续监控和扫描容器仓库（如 AWS ECR），以查找已发布镜像中易受攻击的基础镜像或脆弱的操作系统依赖项。根据我们团队的经验，Orca 提供了从开发到生产的安全状态的统一视图，因此我们将其放入试验阶段。
攻击路径分析(Sep 2023, 试验)
攻击路径分析 是一种分析和评估潜在攻击路径的安全分析方式，黑客可能按照这些来自组织内系统网络的潜在攻击路径进行攻击。此前的多数安全分析策略或工具主要聚焦在特定分线领域，例如错误的配置，脆弱的容器，和常见漏洞上。这些孤立的方法意味着团队们不能看到这些风险与技术栈上其他层的弱点组合产生的危险攻击路径。尽管这一技术已提出一段时间，但是近期安全分析工具的进展能使安全团队更易使用这项技术。Orca 和 Wiz 是两个此类工具。我们建议管理复杂基础设施的团队在为组织设计安全策略或选择安全分析工具时考虑这项技术。
Pixie(Sep 2023, 评估)
Pixie 是一个用于 Kubernetes 原生应用程序的可观察性工具。它通过利用 eBPF 从多个 数据源 自动地采集遥测数据，以一种有趣的方式实现了可观察性。收集到的遥测数据被本地存储到每个节点上，并通过其控制平面 API 进行集中处理。总的来说，我们认为 Pixie 在 Kubernetes 生态系统中用于可观察性是值得评估的。
ReAct 提示工程(Sep 2023, 试验)
ReAct 提示工程 是一种用于提示大语言模型的方法，相较于思维链 (CoT)等竞争方法，ReAct 旨在提高大语言模型的响应准确性。这一方法在一份2022年的论文中首次提出，其原理是将推理和行动结合起来（因此称为ReAct）。这种方法有助于使大语言模型的响应更具解释性，相对于思维链减少了虚构性内容，从而提高了提示者获得他们想要的内容的机会。最初，LangChain 是为支持这种提示方式而开发的。基于 ReAct 的自主代理已被证明是我们团队构建的大语言模型应用中使用最广泛的一种。最近，OpenAI 在其 API 中引入了函数调用以使 ReAct 和类似的提示风格更容易实现，而无需依赖像 LangChain 这样的外部工具。我们仍然处于定义这一学科的早期阶段，但到目前为止，ReAct 及其后继方法已指引出大语言模型最令人兴奋的一些应用领域。
GitHub 合并队列(Sep 2023, 评估)
我们一直是短暂开发分支的倡导者，这些分支经常合并到主代码分支中，主代码分支始终准备好进行部署。这种主干开发的实践与持续集成密切相关，并且在条件允许的情况下，可以实现最快的反馈循环和最高效的开发流程。然而，并不是每个人都喜欢这种方法，我们经常根据客户的实践来调整我们的风格。有时，这包括长期存在的特性分支和拉取请求必须被手动审查和批准，然后才能将它们合并到主分支中。在这些情况下，我们使用新的 GitHub 合并队列功能 GitHub 合并队列功能。它允许我们自动排队接收的拉取请求，并将它们合并到特殊分支中，按接收顺序进行排序。然后，我们可以选择自动执行我们自己的“合并检查”，以防止不兼容的提交。这本质上是模拟主干开发（即使 PR 尚未合并到主代码分支中），允许开发人员在上下文中测试其功能，而无需等待批准拉取请求。使用 GitHub 合并队列，即使你不能直接提交到主干，也可以获得主干开发的好处。
Bloc(Sep 2023, 试验)
Bloc 是 Flutter 的一款响应式状态管理库。在 Flutter 可用的状态管理 选项中，我们想突出 Bloc，因为我们团队在使用该库构建复杂移动应用程序时体验很好。当 UI 组件通过流和事件接收器与业务逻辑进行通信时，围绕 BLoC 模式 结构化的组织代码实现了业务逻辑与表示层的完全分离。Bloc 在 IntelliJ 和 VSCode IDE 中都提供了良好的插件支持。
Immuta(Sep 2023, 试验)
自从我们上次介绍了 Immuta 以来，我们的团队在使用这个数据安全平台方面已经积累了丰富的经验。它的亮点包括能够将订阅和数据策略定义为代码、版本控制以及自动部署这些策略到更高的环境中。它基于属性的访问控制（ABAC） 允许我们将标签关联到数据源；如果用户与相同的标签关联，就会获得访问权限。通过利用 Immuta 和 Snowflake 的集成，我们已经能够以自助方式自动授权对数据产品或数据集的访问。当“用户”请求访问数据产品或数据集时，一旦获得批准，数据产品标签将被关联到“用户”作为属性。由于“用户”的属性与数据源上的标签匹配，因此根据 Immuta 的全局订阅策略，访问权限将自动授予。值得一提的是 Immuta 的数据掩码策略，它通过对个人身份信息（PII）进行掩码和限制来保护数据隐私。可以使用行级安全策略来定义对更细粒度的敏感信息的访问，以确保用户只能访问他们被授权查看的特定数据。我们对 Immuta 非常满意，这也是为什么我们将其列入“试验”的原因：它提供了良好的开发者体验，使大型组织更容易管理数据策略。
Immuta(Apr 2023, 评估)
Immuta是一个数据安全平台，它允许你安全地访问数据，自动发现敏感数据并审计数据在组织中的使用情况。在过去，当我们考虑安全风险时，我们已经谈到了自动化、工程实践和将安全策略代码化的重要性。数据安全也不例外。我们的团队一直在探索Immuta，它能将数据访问策略作为代码来管理，以实现精细化的访问控制，这超出了基于角色的访问控制（RBAC）所能提供的范围。基于版本控制的策略可以被测试，然后配置为CI/CD管道的一部分。在一个去中心化的数据生态系统中，比如由数据网格促成的生态系统，拥有特定领域的角色会导致身份认证系统中的角色或用户组扩散。Immuta的基于属性的访问控制（ABAC）的特性将访问授权简化为一个数学方程式，即把用户的 "属性 "与数据源的 "标签 "相匹配。这个平台虽然很新，但在满足数据安全需求方面绝对值得考虑。
Semantic Kernel(Sep 2023, 评估)
Semantic Kernel 是微软 Copilot 产品套件中的一个核心组件的开源版本。它是一个 Python 库，与 LangChain 类似，它可以帮助你在大语言模型（LLMs）之上构建应用程序。Semantic Kernel 的核心概念是计划器，它可以帮助你构建由 LLM 驱动的代理 ，这个代理可以为用户创建一个计划，然后在各种插件的帮助下逐步执行这个计划。
Checkov(Sep 2023, 试验)
Checkov 是一个专门用于基础设施即代码（laC）的静态安全扫描器。它支持多种基础设施语言，包括 Kubernetes 清单、Helm 图表、CloudFormation 模板和 Terraform。它可在 CI/CD 管道中轻松部署，防止各种云基础设施配置中出现潜在的安全漏洞。它利用一套默认规则，识别常见的安全情景，并在其网站上提供详细的修改建议。Checkov 支持自定义规则，并使用 YAML 进行简单的准则定义，或使用 Python 制作更复杂的准则定义。我们的团队已成功使用 Checkov 在基础架构部署过程中增强安全性，并对其在部署前提供的潜在问题表示欣赏。
Google Cloud 工作站(Sep 2023, 评估)
Google Cloud 工作站 是 GCP 提供的云端开发环境（Cloud Development Environment，CDE）。它提供了完全托管的容器化开发环境，可以通过SSH、HTTPS、VSCode、Jetbrains IDEs 等多种方式进行访问，使开发人员可以享受和连接本地环境一致的体验。Google Cloud 工作站允许管理员将容器化开发环境纳入私有网络，并可以选择使其对外公开或仅在内部访问。这种网络配置的灵活性，再加上支持使用自定义或预定义的镜像构建环境，使得Google Cloud工作站，在我们看来，值得那些在其GCP边界内寻找安全的CDE解决方案的组织将其纳入评估。如果您正在考虑使用Google Cloud 工作站，我们建议在广泛推广之前先测试网络配置，因为高延迟可能会对开发者在这些容器中的使用体验造成一定的影响。
自托管式大语言模型(Sep 2023, 评估)
大语言模型（LLMs）通常需要大量的 GPU 基础设施才能运行，但目前有强烈的推动力使它们可以在更简单的硬件上运行。对大语言模型进行量化可以减少内存需求，使高保真度模型可以在成本更低廉的硬件甚至是 CPU 上运行。像 llama.cpp 这样的工作使大语言模型可以在包括树莓派、笔记本电脑和通用服务器在内的硬件上运行成为可能。\n许多组织正在部署 自托管式大语言模型 。这往往是出于安全或隐私方面的考虑，有时是因为需要在边缘设备上运行模型。开源示例包括 GPT-J、GPT-JT 和 Llama。这种方法提供了更好的模型控制，以进行特定用途的微调，提高了安全性和隐私性，以及离线访问的可能性。尽管我们已经帮助一些客户自托管开源大语言模型用于代码生成，但我们建议在决定自托管之前仔细评估组织的能力和运行这类大语言模型的成本。
自托管式大语言模型(Apr 2023, 评估)
大型语言模型通常会运行在具有强大的 GPU 的基础设施上。我们如今可以看到一些大型语言模型的移植版本，比如 llama.cpp，这些模型能在不同的硬件上运行，包括 Raspberry Pi(树莓派)、笔记本电脑和通用服务器等。因此 自托管式大型语言模型 已经成为现实。目前，有许多开源的自托管式大型语言模型，如 GPT-J、GPT-JT 和 LLaMA。自托管这种方式有许多好处，比如可以更好地控制模型在一些特定使用场景的微调、提高安全性和隐私性，以及支持离线访问。不过在决定使用自托管这种方式之前，您应该仔细评估组织的能力和运行此类大型语言模型需要消耗的成本。
Pinecone(Sep 2023, 评估)
Pinecone 是一个完全托管的、对开发人员友好的、云原生的向量数据库。它提供了简单的API，而无需处理基础设施方面的繁琐工作。Pinecone 可在数十亿向量数据的规模上，提供过滤后的查询结果，且延迟较低。我们的团队发现，对于存储团队知识库或服务台门户内容等使用场景，相较于针对对复杂的 LLM 进行微调，使用数据库提供商，特别是 Pinecone 会更便利，且上手很快。
Kotlin Kover(Sep 2023, 评估)
Kotlin Kover 是一个专为 Kotlin 设计的代码覆盖率工具集。它支持 Kotlin JVM 、Multiplatform 和 Android 工程。代码覆盖率的重要性在于能够凸显未经测试的代码片段，从而增强软件的可靠性。随着 Kover 的发展，它因能够生成为 Kotlin 量身定做的、全面的 HTML 和 XML 报告而引人注目。对于深度使用 Kotlin 的团队，我们建议您评估 Kover ，以助力您提高代码质量。
KEDA(Sep 2023, 试验)
KEDA 全称 Kubernetes Event-Driven Autoscaler，正如名字所展示的，它可以根据需要处理的事件数量来伸缩 Kubernetes 集群。根据我们的经验，相比采用 CPU 使用率等滞后指标，更加推荐使用队列深度等领先指标。KEDA 能支持不同的事件源，并提供了一个包含50多种自动缩放器的工具箱，可用于各种云平台、数据库、消息系统、遥测系统、CI/CD 系统等。我们的团队报告称，KEDA 的易集成性使他们能够继续在 Kubernetes 中运行微服务的全部功能，否则可能会考虑将一些事件处理代码转移到无服务器函数中。
Dart(Sep 2023, 试验)
Dart 是由 Google 开发的编程语言，支持构建跨平台的应用程序，包括 Web 浏览器、WebAssembly、桌面和移动应用。它的采纳是由 Flutter 的主导地位推动的。在跨平台原生移动应用框架领域，Flutter 是一个流行的、使用 Dart 作为其核心语言的跨平台 UI 工具包。根据社区的反馈，Dart 从最初的版本开始不断演进，除了具备健壮的类型系统，还在3.0版本中添加了内置的 sound null safety。此外，Dart 的生态系统正在快速发展，拥有活跃的社区、丰富的可用库和工具，这使其对开发者非常具有吸引力。
Dart(Oct 2012, 暂缓)
Dart is Google’s attempt at creating a programming language to replace JavaScript due to JavaScript’s perceived flaws and inherent performance issues. Dart, in line with previous Google languages, provides Java-like syntax and semantics that are intended to be more appealing than JavaScript’s prototype-based nature. Reception within the browser-development community has been understandably cool and it remains to be seen if the language will become more widely accepted, though Chrome’s continued rise and the search for alternatives like CoffeeScript may yet shift that balance.
wazero(Sep 2023, 评估)
wazero 是使用 Go 编写的一个零依赖的 WebAssembly (WASM) 运行时。尽管运行时本身与语言无关，我们仍想对 Go 开发者们强调 wazero, 因为它提供了一种很方便的方式， 使用任何 符合标准的语言 编写的 wasm 模块来扩展你的 Go 应用程序。它不依赖于 CGO, 所以你可以很容易地将你的 Go 应用程序交叉编译到其他平台。 尽管在选择 WASM 运行时 的时候你有很多候选项, 但我们仍认为 wazero 值得评估.
具有可访问性意识的组件测试设计(Sep 2023, 试验)
在软件交付进程中，可访问性要求是 Web 组件测试阶段的一种考察指标。尽管诸如 chai-a11y-axe 的测试框架插件 API 已提供了基础的可访问性断言， 具有可访问性意识的组件测试设计 依然能够帮助测试进一步检验屏幕阅读器和其他辅助技术所需的全量语义元素。\n首先，在测试验证元素时，通过 ARIA 角色或者元素的其它语义化属性查找元素，而不采用元素的 test id 或 class 属性。像 Testing Library 的一些测试库甚至已经在文档中推荐了这一实践。其次，不要仅仅测试点击交互，还要考虑不能使用鼠标或看不到屏幕的人，并考虑增加针对键盘和其他交互方式的额外测试。在我们的团队中，上述测试设计实践已十分成熟，并且我们已在不久前将其纳入测试闭环中。
具有可访问性意识的组件测试设计(Apr 2023, 评估)
在软件交付过程中，需要提早考虑无障碍设计的地方有很多，Web 组件测试是其中环节之一。像 chai-a11y-axe 这样的测试框架插件在其 API 中提供了断言，以检查基本的无障碍设计。但是，除了使用测试框架所提供的功能外， 无障碍意识组件测试设计 进一步提供了屏幕阅读器和其他辅助技术所需的所有语义元素。\n首先，不要使用 test id 或 class 来寻找和选择你要验证的元素，而是使用通过 ARIA 角色或其他辅助技术使用的语义属性来识别元素。一些测试库，如 Testing Library ，甚至在文档中直接推荐这样做。其次，不要只测试点击交互，还要考虑不能使用鼠标或看不到屏幕的用户，并考虑增加对键盘和其他交互的测试。
GGML(Sep 2023, 评估)
GGML 是一个机器学习的 C 语言库，它支持 CPU 推理。它定义了一种分布式大语言模型（LLMs）的二进制格式。为此，GGML 采用了量化技术，这种技术可以使LLM在用户的硬件上运行有效的 CPU 推理。GGML 支持多种量化策略（例如 4 位、5位、以及 8 位量化），每种策略动都在效果和性能之间提供了不同的取舍。一种快捷地对使用这些量化模型的应用进行测试、运行和构建的方法是使用一个叫做 C Transformers 的 Python 绑定。它是一个 GGML 之上的 Python 封装，通过高级的 API 来消除推理的样板代码。我们已经在尝试使用这些库构建原型和实验。如果你正在考虑为你的组织搭建自托管式大语言模型, 请慎重选择这些社区支持的库。
.NET Minimal API(Sep 2023, 试验)
ASP.NET Core MVC 已经被证明是一种用于构建托管 APIs 的 Web 应用程序的强大而灵活的方法。然而，它的灵活性也带来了一定的复杂性，包括一些不明显的样板代码和约定。ASP.NET 提供的路由功能允许在单个应用程序中托管多个服务，但在当今的无服务器函数和可独立部署的微服务的世界中，这种灵活性可能会显得有些过剩。.NET Minimal APIs 在 .NET 生态系统中提供了一种简单的方法来实现 single-API 的 Web 应用程序。Minimal API 框架可以用仅仅几行代码就实现一个 API 端点。Minimal API 加入了新一代的 API 框架，包括 Micronaut、Quarkus 和 Helidon，这些框架针对轻量级部署和快速启动时间进行了优化。我们对 Minimal APIs 和 .NET 7 Native AOT 的结合很感兴趣，可以用于在无服务器函数中实现简单、轻量级的微服务。
GitOps(Sep 2023, 评估)
GitOps 是一项通过控制回路模式进行应用部署的技术。Operator 能够将已部署的应用和配置（通常是 Git 仓库）保持同步。当我们上次写到 GitOps 的时候，社区对此术语的定义未能形成共识。当时，我们对该技术的常见解读抱有疑虑，因为部分解读包含不恰当的做法。例如，使用“环境分支”就可能导致雪花即代码的出现。此外，“GitOps 是持续交付的一种替代方案”这个说法也令人困惑。在那之后，四个 GitOps 原则澄清了该技术的范围和性质。当拨开炒作和混乱的迷雾，你会发现 GitOps 是一项基于 Kubernetes 集群功能的有用技术，为分离介于配置应用和实施部署流程的关注点创造了机会。我们的一些团队在他们的持续交付设置中实施了 GitOps ，并取得了良好的体验。所以我们推荐大家去评估这项技术。
GitOps(Apr 2021, 暂缓)
我们建议在采用 GitOps 时一定要谨慎，尤其是在分支策略方面。GitOps可以被视作一种基础设施即代码的实现方式，这种方式持续地从Git同步基础设施代码，并将其部署到多个环境当中。在为每个环境创建一个分支的场景下，对基础设施的修改会通过合并代码的方式从一个环境应用到下一个环境。诚然，将代码作为基础设施修改的唯一来源，是一种合理的方式，但我们发现对每个环境创建分支会导致环境之间的不一致。最终，合并特定环境的配置代码带来了许多问题，甚至导致这种方式被废弃。这与我们之前在Gitflow的长期分支当中看到的情景非常相似。
容器结构测试(Sep 2023, 试验)
容器结构测试 (CST) 是由 Google 开发的一个工具，用于测试容器镜像的结构。CST 可以用于检查镜像文件系统中某个文件的存在或缺失，验证文件的内容，检查容器中发出的特定命令的输出或错误，并检查容器镜像的元数据（例如标签、入口点和命令），以确保符合 CIS Docker Benchmark 的规范。我们在使用 CST 方面有很好的经验，建议您可以试用一下。除了预防漏洞，检查容器是否暴露不必要的端口之外，我们还使用它来验证每个 Docker 容器是否满足在企业平台上部署和运行一个应用程序的所有必要要求。其中一个要求是镜像中安装了可观测性代理。需要注意的是，CST 并没有得到 Google 的官方支持，这可能会影响它的维护情况。
轻量级的 RFCs 方法(Sep 2023, 采纳)
Request for Comments (RFC) 是一种正式文档，其包含与上下文相关的设计和架构思想，以促进团队协作和决策。几乎所有数字原生和快速扩张的组织都使用 RFCs 来记录围绕设计、架构、技术和团队协作方式的决策。成熟的组织已经在自治团队中，特别是在跨团队相关的决策中使用 RFCs 来推动更好的沟通和协作。它通常被用作 架构决策记录 的审查和批准过程。即让受决策影响的人有机会在决策获得批准之前，参与讨论并提供意见，这一个透明的协作过程。快节奏的环境往往会导致设计决策的推理过程丢失，从而让负责实施决策的团队感到困惑。RFCs 提供了一个决策审计记录，有利于未来的团队成员查看，与此同时记录了组织技术和业务的演进过程。RFCs 可以成为促进 演化架构 的宝贵工具。不过，为了获得最佳效果，我们建议组织采用 轻量级的 RFCs 方法。如果不限定范围并明确要点，这些文件往往会随着时间的推移而变得越来越长，类似于传统的解决方案架构文件一样最终被归档和遗忘。
轻量级的 RFCs 方法(Apr 2021, 试验)
随着组织朝着演进式架构的方向发展，记录下围绕设计、架构、技术和团队工作方式的决策是非常重要的。收集和汇总那些会导致这些决策的反馈的过程从RFCs（Request for Comments )开始。RFCs 是一种用于收集上下文、设计和架构思想，并与团队协作，最终达成决策以及上下文和结果的技术。我们建议组织采用一种 轻量级的 RFCs 方法 ，通过在多个团队中使用简单的标准化模板和版本控制来获取 RFCs。\n当未来的团队成员回过头来重新审视这些决策时，掌握这些信息将使他们受益无穷，与此同时记录组织的技术和业务的发展也十分重要。成熟的组织已经在自治团队中，特别是在跨团队相关的决策中使用 RFCs 来推动更好的沟通和协作。
MobSF(Sep 2023, 试验)
MobSF 是一个开源的、自动化的静态和动态安全测试工具，用于检测 iOS 和 Android 移动应用程序中的安全漏洞。它扫描应用程序源代码和二进制文件，并提供有关漏洞的详细报告。MobSF 以 Docker 镜像的形式分发，并提供易于使用的 REST API，可以通过 mobsfscan 集成到持续集成/持续发布流水线中。我们使用 MobSF 对 Android 应用程序进行安全方面测试的体验是积极的，我们建议您尝试使用它来满足您对移动应用程序安全测试需求。
OIDC for GitHub Actions(Sep 2023, 试验)
推荐实现 CI/CD 的零信任安全的技术之一是通过使用 OpenID Connect (OIDC) 等联合身份机制对流水线进行身份验证，以访问云服务。这一重要的技术仍未被充分利用在 GitHub Actions 中，因此推荐 OIDC for GitHub Actions。通过这种方式，可以避免存储长期的访问令牌来访问云资源，同时确保流水线无法直接访问机密信息。然而，请务必谨慎地限制访问权限，以确保操作以最低权限运行。
Spring Modulith(Sep 2023, 评估)
尽管我们是微服务（microservices）的早期倡导者，并看到该模式在无数系统上取得了成功，但我们也看到微服务被误用和滥用，这通常是microservice-envy（microservice envy）导致的。与其从头开始构建一个由单独部署的进程组成的新系统，我们通常建议从一个精心设计的单体应用开始，并且仅当应用程序达到一定规模时，才将其分解为可单独部署的单元，此时微服务的好处才能超越分布式系统所固有的额外复杂性。最近，我们看到人们对这种方法重新产生了兴趣，以及对什么构成了精心分解的整体有了更详细的定义。Spring Modulith 是一个框架，它以一种使代码在适当时候更容易拆分成微服务的方式来组织代码。它提供了一种模块化代码的方法，使领域和限界上下文的逻辑概念与文件和包（package）结构的物理概念保持一致。这种对齐方式使得在必要时重构单体架构以及单独测试领域变得更加容易。Spring Modulith 提供了一种进程内事件机制，有助于进一步解耦单个应用程序中的模块。 最重要的是，它与 ArchUnit 和 jmolecules 集成，可以自动验证其领域驱动的设计规则。
Chromatic(Sep 2023, 试验)
Chromatic 是一款可视化回归测试工具，可帮助捕捉网络应用程序中的用户界面回归。它的工作原理是拍摄用户界面组件的快照，并在组件发生变化时将其与之前的快照进行比较。Chromatic 是一种托管服务，可与流行的云代码托管服务集成。它建立在 Storybook 之上，进行组件级可视化回归测试。它可以在不同的视口宽度下渲染组件，以进行响应式测试，并与 CI 工作流集成，为每次提交生成用户界面变更集，从而方便审查。我们的团队发现 Chromatic 与该领域其他工具的视觉差异要大得多；可视化高亮显示变更的功能让它非常实用。
fast-check(Sep 2023, 试验)
fast-check 是一个为 JavaScript 和 TypeScript 设计的基于属性的测试工具，它能够自动生成测试数据，从而无需创建不同的测试即可仔细检查各种输入，这使得它更容易发现边缘场景。 我们的团队在后端测试中使用 fast-check 取得了不错的结果，归功于它良好的文档、易用性以及与现有测试框架的无缝集成，单元测试的效率得到了明显提高。
Mockery(Sep 2023, 试验)
Mockery 是一个成熟的 Golang 库，它能够生成接口的 mock 实现，并模拟外部依赖的行为。通过类型安全的方法生成期望的调用，并通过灵活的方式 mock 返回值，它使得测试能够专注于业务逻辑，而无需担忧外部依赖的正确性。Mockery 使用了 Go 生成器，且简化了测试套件中的 mock 的生成与管理。
Armeria(Sep 2023, 试验)
Armeria 是一个用于构建微服务的开源框架。我们的团队使用它来构建异步 API，我们非常喜欢用它的服务装饰器来解决跨切面关注点，例如分布式跟踪或断路器。该框架支持 gRPC 和 REST 流量的端口复用以及其他巧妙的设计选择。借助 Armeria，我们可以在现有 REST 代码库之上逐步添加新的 gRPC 功能，或者反过来，在现有的 gRPC 代码库之上逐步增加新的 REST 功能。总的来说，我们发现 Armeria 是一个灵活的微服务框架，具有多个开箱即用的集成功能。
Polars(Sep 2023, 试验)
Polars 是 Rust 实现的一个内存运行的DataFrame库。 与其他 DataFrame 库（如Pandas）不同，Polars 是多线程、支持惰性求值、并且并行操作安全的。 Polars 使用 Apache Arrow 格式作为内存模型，以高效实现分析操作，并实现与其他工具的互用性。 如果您熟悉 Pandas ，就可以快速上手 Polars 的 Python 绑定。 基于 Rust 实现和 Python 绑定的 Polars 是一个高性能内存 DataFrame 库，可满足您的分析需求。 我们的团队在 Polars 方面继续拥有良好的体验，因此我们将其将其移至 “试验” 。
Polars(Oct 2021, 评估)
Polars 是在 Rust 中实现的一种内存 DataFrame 库。与其他 DataFrame 库（如Pandas）不同，Polars 是多线程、并行操作安全的。Polars 使用 Apache Arrow 格式作为内存模型，以高效实现分析操作，并实现与其他工具的互用性。如果您熟悉 Pandas ，就可以快速上手 Polars 的 Python 绑定。基于 Rust 实现和 Python 绑定的 Polars 是一个高性能内存 DataFrame 库，可满足您的分析需求。
mob(Sep 2023, 试验)
mob 是一个用于远程结对编程或集体编程中无缝进行git交接的命令行工具。它将所有版本控制工具隐藏在一个命令行界面背后，这使参与集体编程会话变得更加简单。它还提供了关于如何远程参与的具体建议，例如，在Zoom中“窃取屏幕共享”，而不是结束屏幕共享，以确保参与者的视频布局不发生变化。我们的一些团队强烈推荐mob，并且它已经成为我们在远程协作或集体编程中工具链的重要组成部分。
mob(Oct 2021, 评估)
有时候，你会遇到一个工具，但在意识到之前，你不会觉得有多需要它；mob 就是这样的工具。对很多团队来说，远程结对编程已是常态，生活在这样的世界当中，如果能拥有一个可以在结对或 远程集体编程 期间帮助无缝切换的工具会非常有效。mob 将所有版本控制的命令和工具隐藏在一个命令行界面后，这让人参与 集体编程更加容易。mob 也为如何远程加入提供了具体建议，例如在 Zoom 当中“偷偷接管屏幕共享”而不是中断屏幕共享，这能保证参与者的视频布局不会发生改变。这样一个有用的工具，这样周到的建议，还有什么不喜欢的？
Tabnine(Sep 2023, 评估)
Tabnine 是目前炙手可热的编程助手领域的有力竞争者之一。它提供了内嵌的代码补全建议，以及直接在 IDE (Integrated development environment, 集成开发环境) 中进行对话的能力。与 GitHub Copilot 类似，Tabnine 的出现远远早于现在这个各家纷纷大肆炒作的时期，也因此成为了该领域中最成熟的产品之一。与 Copilot 不同的是，Tabnine 使用的模型仅在获得授权的代码上进行训练，并提供了一个可以自行托管的版本，供担心其代码片段会被发送给其他第三方服务的组织使用。Tabnine 既提供有受限制的免费版本，也提供付费版本，后者会有更全面的建议，还提供了一种使用本地模型的模式（尽管功能较弱），供您在没有互联网连接的情况下使用。
Kotlin with Spring(Sep 2023, 试验)
五年前，我们将 Kotlin 移至了采纳阶段，如今我们的许多团队报告称，Kotlin 不仅成为了他们在 JVM 语言上的默认选择，而且已经几乎完全取代了 Java，成为他们编写软件的主要语言。与此同时，microservice envy 似乎正在减弱，我们注意到人们开始使用诸如 Spring Modulith 等框架，探索具有更大可部署单元的架构。我们已经知道有许多出色的 Kotlin 原生框架，并且在之前也提到过一些；然而在大部分情况下，Spring 框架的成熟度和功能丰富性是一个巨大的优势，并且我们已成功地结合使用 Kotlin与Spring ，而并未遇到很大的问题。
对告警规则的单元测试(Sep 2023, 试验)
可观测性和监控对于软件团队至关重要。鉴于特定事件的不可预测性，创建具有复杂规则的准确告警机制至关重要。然而，只有当事件真实出现时，这些规则才能得到真正的验证。 对告警规则的单元测试 让团队通过预先、主动地测试和完善规则，来更好地定义规则，从而增加对规则的信心。这有助于减少误报，并确保报告真正的事件。Prometheus 等工具支持对规则进行单元测试。 我们的团队报告它的确可以在现实环境中起到帮助作用。
CI/CD 的零信任保护(Sep 2023, 试验)
如果没有得到正确的安全配置，运行构建和交付流水线的基础设施和工具可能成为一个大隐患。流水线需要访问关键数据和系统，如源代码、凭据和机密数据，去构建和部署软件。这让这些系统对恶意攻击者充满了吸引力。因此，我们强烈推荐为 CI/CD 流水线和基础设施引入零信任 安全机制 ——尽可能少地信赖它们。这项机制包含一系列技术：如果可行，使用云供应商提供的联合身份校验机制，如 OIDC ，来验证流水线，而不是赋予它们直接访问机密数据的权限；实行最小权限原则去最小化个人用户和执行器账户的权限，而不是使用具有无限访问权限的万能账户；使用一次性执行器替代重复使用执行器，来减少暴露先前任务的机密数据或在受到攻击的运行器上运行任务的风险；将执行代理和执行器上的软件更新到最新版本，像监控你的生产软件一样去监控你的 CI/CD 系统的完整性、保密性和可用性。\n我们不断见到有团队忘记这些实践，特别是当他们使用在内部网络中自我管理的 CI/CD 基础设施的时候。所有这些实践不仅在内部网络中很重要，当使用托管服务时，因为扩大了攻击面和影响范围，这些实践会变得更加关键。
CI/CD 的零信任保护(Apr 2023, 评估)
如果没有得到正确的安全配置，运行构建和交付的流水线的基础设施和工具可能成为一个大麻烦。流水线需要访问关键数据和系统比如源代码，凭证和密码来构建和部署软件。这让这些系统非常容易吸引恶意攻击者。因此，我们强烈推荐引入零信任 安全机制来保障 CI/CD 流水线和基础设施 —— 尽可能少地信赖它们。这包含一系列技术： 如果可行，根据你的云供应商通过联合身份校验机制如 OIDC 来验证你的流水线，而不是直接给他们获取机密数据的权限。 实现最小特权原则，最小化个人用户和执行账户的权限，而不是创建一个拥有无限访问权限的全能账户。用临时的方式去使用任务执行器而不是复用他们，来减少暴露先前任务的秘密或在受到攻击的运行器上运行任务的风险。保证软件在你的代理服务器和任务执行器上是最新的。像监控你的生产环境软件一样监控你的 CI/CD 系统的完整性，保密性和可用性。 我们不断见到有团队会忘记这些实践，特别是当他们使用在内网自我管理的 CI/CD 基础设施的时候。所有这些实践在不仅在内网中都很重要，在使用托管服务时，因为扩大了攻击面和影响范围，这种实践会变得更加重要。
基准配置文件(Sep 2023, 评估)
不要与安卓基准配置文件相混淆，基准配置文件是指导提前编译的安卓运行时配置文件。基准配置文件会在发布前在开发机上创建，并随应用程序一起发布。因此，相较于依赖云配置文件（一种较早的相关技术），基准配置文件会更快可用。通过在应用或库中分发基准配置文件，安卓运行时可以优化重要的代码路径，从而在下载或更新应用程序时改善新老用户的使用体验。根据其文档所提到的，创建基准配置文件相对简单并可以显著提高性能（最多 30%）。
Playwright(Sep 2023, 采纳)
使用 Playwright，您可以编写在 Chrome、Firefox 和 WebKit 中运行的端到端测试。 通过使用 Chrome 开发者工具（DevTools）协议（CDP），Playwright 可以提供新功能并消除 WebDriver 中出现的许多问题。 基于 Chromium 的浏览器直接实现了 CDP。不过，为了支持 Firefox 和 Webkit，Playwright 团队不得不向这些浏览器提交补丁，这有时可能会限制框架。\nPlaywright 的功能包括：内置自动等待，这使得测试更可靠、更易于理解； 浏览器上下文，可让您测试跨标签页的持久会话是否正常工作；以及模拟通知、地理位置和黑暗模式设置的能力。 Playwright 为测试套件带来的稳定性给我们的团队留下了深刻印象，并且喜欢它可以并行运行测试以更快地获得反馈。 Playwright 的其他特色包括更好地支持懒加载和追踪。 尽管 Playwright 有一些局限性（例如，组件支持目前处于实验阶段），但我们的团队认为它是首选的测试框架，甚至在某些情况下会从Cypress 和 Puppeteer 上迁移过来。
Playwright(Apr 2021, 试验)
Playwright允许你使用同一套API，为Chromium，Firefox和WebKit编写Web UI测试。由于对所有主流浏览器引擎的支持（包括Firefox和WebKit的修复版本），这个工具已经引起了一些关注。我们持续听到关于Playwright积极的使用体验和反馈，尤其是它的稳定性。一些团队发现从Puppeteer迁移到Playwright也非常容易，因为它们的API非常相似。
Playwright(Oct 2020, 评估)
Web UI 测试一直是一片活跃的疆域。 Puppeteer 的部分缔造者在转向微软后，开始将所学投用在 Playwright。它可以让你通过相同的API，为Chromium、Firefox以及 WebKit 编写测试。因为对所有主流浏览器引擎的支持，Playwright 成功获得了一些关注，并作为补丁版本包含在 Firefox 和 Webkit 中。其他工具将如何赶上，让我们拭目以待，毕竟现在 Chrome DevTools Protocol 作为自动操作浏览器的通用 API，正在获得越来越多的支持。
DX DevEx 360(Sep 2023, 试验)
DX DevEx 360 是一款基于调查的工具，它通过聚焦开发人员在日常工作中面临的阻力点，如代码审查流程、代码质量、深度工作能力等，寻找提高开发人员生产力的关键指标。该调查由 Nicole Forsgren 和 Margaret-Anne Storey 制定，他们曾和其他专家一并主导了 DORA 和 SPACE 两个项目。\n我们的平台工程团队已成功使用 DX DevEx 360 来了解开发人员的观点并识别存在的阻力点，从而为平台发展路线提供参考。与类似调查工具不同，使用 DX DevEx 360，我们获得了90%以上的回应率，开发人员通常会就问题和改进想法进行详细评论。该工具令人赞赏之处还有：它将结果透明化给公司的工程师，而不仅仅是经理，此外它支持按团队进行分析，从而实现每个团队环境的持续改进。
GPTCache(Sep 2023, 评估)
GPTCache 是一个用于大型语言模型（LLM）的语义缓存库。我们认为需要在 LLM 前增设缓存层主要出于两种原因——通过减少外部 API 调用来提升整体性能，以及通过缓存近似响应来减少运营成本。不同于使用精确匹配的传统缓存方式, 基于 LLM 的缓存解决方案需要对输入进行相似或相关匹配。 GPTCache 通过使用嵌入算法将输入转化为嵌入，再通过向量数据库对这些嵌入进行相似性搜索。这种设计有一个缺点，可能会导致缓存命中时遇到假阳性结果，或缓存未命中时遇到假阴性结果，因此我们建议你在构建基于 LLM 应用时，仔细评估 GPTCache。
KWOK(Sep 2023, 评估)
KWOK (Kubernetes WithOut Kubelet) 是一个模拟虚拟节点和 pod 生命周期的工具，旨在测试Kubernetes 集群的控制面板。如果没有庞大的集群，很难对自定义 Kubernetes Controllers 和 Operators 进行压力测试。然而，通过 KWOK，你可以在笔记本电脑上轻松设置一个拥有数千个节点的集群，而无需消耗大量 CPU 或内存资源。这种模拟可以对节点类型和 pod 进行不同的不同配置，以测试各种场景和边缘情况。如果你需要一个真正的 Kubernetes 集群来测试 operators 和自定义资源定义 (CRDs)，我们推荐kind 或k3s ; 但如果你只需要模拟大量的虚拟节点，那么我们建议评估 KWOK。
大语言模型半结构化自然语言输入(Sep 2023, 试验)
在使用大语言模型的各种应用中，我们在 半结构化自然语言输入 方面取得了成功。结构化输入，如 JSON 文档，清晰而精确，为模型提供了所寻求响应类型的指示。以这种方式限制响应有助于缩小问题空间，并且可以产生更准确的响应，特别是当结构符合领域特定语言（DSL）的语法或模式情况下。我们还发现，将结构化输入与自然语言注释或标记结合使用，比仅使用自然语言或结构化输入产生更好的响应。通常，在构建提示时，自然语言会与结构化内容简单地交织在一起。与许多大语言模型行为一样，我们不知道为什么这样做有效，但我们的经验表明，在人工编写的代码中加入自然语言注释也会改善基于大语言模型的编码助手的输出质量。
语法性别API(Sep 2023, 评估)
在许多语言中，性别的表现都比英语更为明显，且词语会根据性别发生变化。例如，称呼用户时，可能需要对词语进行变形，但通常的做法是默认使用男性形式。有证据表明，这会对人的表现和态度产生负面影响 —— 当然，这也是不礼貌的。使用性别中立语言的变通办法往往显得笨拙。因此，正确地称呼用户是首选。借助 Android 14 中引入的语法性别 API，安卓开发者们现在可以更容易地做到这一点。
Prisma 运行时防护(Sep 2023, 试验)
Prisma 运行时防护是 Prisma 云套件的一部分，为容器安全提供了一种新方法。它采用一种机制来建立容器预期行为模型，然后在运行期间发现异常时检测并阻止异常活动。Prisma 运行时防护监控容器进程、网络活动和文件系统，查找表明可能正在进行攻击的模式和变化，并根据配置的规则进行阻止。学习构成“正常”行为的模型是通过对Docker镜像的静态分析和预先配置的时间段内的动态行为分析构建的。我们的团队从使用中发现了可喜的成果。
Google Bard(Sep 2023, 评估)
Google Bard 是由 Google AI 开发的生成式 AI 聊天机器人。 与 ChatGPT 非常相似，它能够通过生成类似人类的文本，会话式地对各种提示和问题提供回复。 Bard 由 Google 的 Pathways 语言模型 (PaLM 2) 提供支持，PaLM 2 是在海量文本和代码数据集上训练出的大语言模型(LLM)。Bard 能够生成文本、翻译语言、生成各种创意内容，以及详尽回答提出的问题。\nBard 还可以指导软件开发。我们的开发人员发现，Bard 有时可以针对不同场景提供一些编码建议、最佳实践或基础设施配置。我们还尝试使用 Bard 翻译技术雷达，可以得到不错的初稿。尽管该工具仍在开发中，与 ChatGPT 相比它可能会慢一些，但我们仍然鼓励开发人员探索使用这个工具，并评估其潜在优点。
Thanos(Sep 2023, 试验)
尽管 Prometheus 一直是自维护可观察性工具链中的一个可靠选择，但当监测指标在基数和总量上增长，以及开始需要高可用性设置时，许多管理现代云原生分布式系统的团队都会碰到其单节点的限制。Thanos 通过添加一些适用于大规模、长期和高可用性监控的功能来扩展 Prometheus 。例如，它引入了一些组件将从 Prometheus 实例中读取的数据存储到对象存储系统中，管理对象存储系统对数据的保留和压缩，并且横跨多个 Prometheus 实例做联合查询。我们的团队发现从 Prometheus 迁移到 Thanos 是无缝的，因为 Thanos 保持了与 Prometheus 查询 API 的兼容性。这意味着团队可以继续使用现有的仪表板、警报工具和其他与 Prometheus API 集成的工具。尽管我们的团队在使用 Thanos 上已经取得了成功，但我们也推荐关注另一种扩展 Prometheus 的方式 —— Cortex 。
OrbStack(Sep 2023, 评估)
OrbStack是在macOS上运行Docker容器的一种方式；我们的开发人员发现，与Docker Desktop和Colima相比，它更轻量、更快速并且更容易部署和使用。这个工具仍在开发阶段，所以目前功能较少，但其简洁和速度已经显示出了它的巨大潜力。您也可以使用OrbStack在macOS上创建和管理Linux虚拟机。
Mermaid(Sep 2023, 采纳)
Mermaid 通过使用类似 Markdown 的标记语言来生成图表。自从上次在技术雷达中介绍以来，Mermaid 添加了对更多图表和与源代码存储库、集成开发环境和知识管理工具集成 的支持。 值得注意的是，它在 GitHub 和 GitLab 等流行源代码存储库中得到原生支持，从而可以在 Markdown 文档中嵌入并轻松更新 Mermaid 图表。 我们的许多团队都倾向于使用 Mermaid 作为他们的图表即代码工具，因为它易于使用、集成广泛，且支持的图表类型不断增多。
Mermaid(Nov 2018, 试验)
Mermaid lets you generate diagrams from a markdown-like markup language. Born out of need to simplify documentation, Mermaid has grown into a larger ecosystem with plugins for Confluence, Visual Studio Code and Jekyll to name a few. To see how it works, you can use the Live Editor on GitHub. Mermaid also has a convenient command line interface that lets you generate SVG, PNG and PDF files as output from definition files. We've been using Mermaid in many projects and we like the simplicity of describing graphs and flowcharts with markdown and checking in the definition files with the code repository.
Llama 2(Sep 2023, 评估)
Llama 2 是一个来自 Meta 的强大的语言模型，可免费用于研究和商业用途。它既提供原始的预训练模型，也提供了经过微调的用于对话的 Llama-2-chat 和用于代码补全的 Code Llama 。Llama 2 提供了多种尺寸的模型 —— 7B、13B 和 70B ，因此如果您想控制自己的数据，Llama 2 是自托管式大型语言模型的一个好选择。\nMeta 声称 Llama 2 是“开源”的，但这一说法受到了一些批评。Meta 的许可证和适用策略对用户的商业用途以及对模型和软件的用途做了限制。Llama 2 的训练数据并不开放，这可能会阻碍理解和修改模型。尽管如此，至少在“半开放”的形式下，一个强大、能干的模型仍然是值得欢迎的。
基于风险的故障建模(Sep 2023, 试验)
基于风险的故障建模是一种用于了解系统发生故障的可能性、潜在影响和检测手段的方法。交付团队逐渐开始使用这种方法来设计和评估预防故障所需的控制措施。该方法源自故障模式与影响分析（FMEA）的实践。FMEA 是一种诞生于上世纪 40 年代的风险评分技术，成功运用于航空航天和汽车等建造复杂物理系统的行业中。与这些行业一样，软件故障也可能产生严重后果，例如危及人类健康和隐私。这就是为什么我们越来越需要对系统进行严格分析的原因。该方法首先识别可能的故障模式，然后对根本原因进行分析，并根据故障发生的可能性、影响的大小以及发现根本原因的概率给出评分。我们发现，当跨职能团队在系统演进过程中迭代使用该方法时效果最好。在安全方面，基于风险的故障建模可以作为威胁建模和攻击路径分析的有益补充。
Codeium(Sep 2023, 评估)
在 AI 编程辅助工具中，Codeium 是一款较为有前景的产品。类似于 Tabnine，Codeium 也尝试去解决公司使用编程辅助工具最担心的问题：通过不使用无授权代码训练自己的模型，他们消除了部分开源代码许可证带来的担忧。同时他们允许您自托管这个工具，所以无需向第三方发送代码片段。 Codeium 在广泛支持各种 IDE 和计算笔记本上表现突出， 并且虽然它的出现晚于 GitHub Copilot 和 Tabnine，但是我们对这一产品的第一印象非常正面。
自动合并依赖项更新 PR(Sep 2023, 试验)
软件供应链的复杂性是一个重大风险，我们已经在一些文章中进行过讨论，例如 SBOM 与 SLSA 。对于大多数团队来说，致命弱点仍然是依赖项中存在漏洞，通常是来自于多层的间接依赖项。Dependabot 等工具可以通过创建拉取请求 (PR) 来更新依赖项。不过，团队仍然需要制定工程纪律，以确保及时处理这些 PR，尤其是对长时间不活跃的应用程序或服务提交的 PR。\n如果系统具有广泛的测试覆盖范围——不仅有完善的单元测试，还包括有功能和性能测试，并且构建流水线必须运行所有这些测试以及安全扫描，我们更提倡自动合并依赖项更新 PR。 简而言之，团队必须完全相信，流水线运行成功后，软件就可以投入生产。在这种情况下，依赖项更新 PR，即使它们在间接依赖项中包含主要版本更新，也应该自动合并。
IntelliJ HTTP 客户端插件(Sep 2023, 试验)
IntelliJ HTTP 客户端插件允许开发人员在代码编辑器中创建、编辑和执行 HTTP 请求，从而简化了构建和使用 API 的开发流程。 它在我们的团队中越来越受欢迎，团队成员们喜欢它的用户友好性和便利性。它的显著特点包括支持私有文件（默认情况下将敏感密钥排除在 git 之外，从而保护这些密钥）、版本控制和使用变量的能力，这增强了开发者的体验。鉴于它能简化开发人员的工作流程并增强安全措施，我们建议您尝试使用这个工具。
Chroma(Sep 2023, 评估)
Chroma 是一个开源的向量存储和嵌入数据库，可用于增强由大语言模型（LLMs）驱动的应用程序。通过促进 LLMs 中的领域知识的存储和利用，Chroma 弥补了 LLMs 通常缺乏内部存储器的不足。特别是在文本到文本应用中，Chroma 可以自动生成单词嵌入并分析它们与查询嵌入之间的相似性，从而大大简化操作。它还提供了存储自定义嵌入的选项，促进了自动化和定制化的融合。鉴于 Chroma 能够增强由 LLM 驱动的应用程序的功能，我们建议团队对 Chroma 进行评估，挖掘其潜力，改进将领域知识集成到此类应用程序中的方式。
云服务的碳足迹(Sep 2023, 试验)
Cloud Carbon Footprint (CCF) 是一款估算主要云服务提供商的云工作负载碳排放量的开源工具。它通过云平台的 API 查询资源使用数据，并使用多种（数据）来源跟踪碳排放情况。CCF 遵循公开发布的方法，将这些数据合并为排放量估算值，并提供随时间变化的数据可视化。云提供商已经开始在其平台上添加类似产品，但是一些 企业 仍在部署 CCF，因为它具有以下所有功能：它是开源的，可扩展的，能跨多云工作，并且有一个透明公开的计算方法。此外，它还包括范围 2 和范围 3 排放的估算，分别针对电力使用和硬件生产。在我们的实验中，不同工具的估算结果不尽相同，这并不奇怪，因为该领域的所有工具都会进行估算，并将估算值相乘。然而，确定一种工具、设定基准线并在此基础上进行改进是我们遇到的主要使用场景，类似Kepler这样的工具可能会在未来减少对估算的需求。CCF 还提供基于 GCP 和 AWS 的优化建议，这不仅有助于减少云服务的碳足迹，还可以成为更广泛的云成本优化战略的一部分。Thoughtworks 是 CCF 的重要贡献者。
云服务的碳足迹(Mar 2022, 试验)
Cloud Carbon Footprint (CCF)是一款通过云 API来查看AWS、GCP、Azure云平台上碳排放的可视化工具。Thoughtworks的团队已经成功使用这个工具 与多个组织合作，其中包括能源科技公司、零售商、数字服务的供应商和使用人工智能的公司。云平台提供商意识到，帮助客户理解在使用云服务时产生的碳排放的影响是很重要的。所以他们开始自主构建类似的功能。 因为CCF是独立于云架构的，它允许使用者在一个位置查看多个不同云服务商的能源使用和碳排放情况，同时将碳足迹转化为对现实世界的影响，比如排放量相当于多少次航班， 或者多少棵树。 在最近的发布中，CCF已经开始包含针对Google云和AWS云上可能的节能与减少二氧化碳排放的优化建议，以及支持更多类型的云实例，比如GPU。考虑到现在这个工具已经备受关注和持续增加新功能， 我们对未来把它挪入试验状态充满信心。
云服务的碳足迹(Oct 2021, 评估)
利益相关者越来越希望企业考虑到其决策对外部环境的影响，正如环境、社会和公司治理 (ESG) 投资和员工围绕气候变化积极行动的兴起所证明的那样。迁移到云提供了更高效使用能源的潜力——云提供商有更大的规模来证明对绿色能源和研发的投资是合理的——但云用户的软件抽象的缺点是，这些抽象也隐藏了对能源的影响，因为真实的数据中心被隐藏起来，并且是由另一家公司提供的资金。 Cloud Carbon Footprint 是一款新的开源工具，它通过云 API 提供了基于 AWS、GCP 和 Azure 使用情况的碳排放估算的可视化。除了使用 Etsy 的 Cloud Jewels 等启发式方法来估算能源消耗，它还利用了像云区域所在地的基础能源网的碳强度（GCP 已经发布 了此数据）这样的公共数据源，将能源消耗换算为碳排放量。这种云区域与基础能源网碳强度的关联，为将高能耗工作负载转移到提供更绿色能源的区域提供了推动力。
Snowpark(Sep 2023, 试验)
Snowpark 是一个用于 Snowflake 大规模查询和处理数据的库。我们的团队使用它来编写可管理代码，用以与Snowflake中存储的数据进行交互 — 这类似于为 Snowflake 编写 Spark 代码。总的来说,它是一个引擎，能够将代码转换为 Snowflake 能够理解的 SQL。你在构建应用程序时无需将 Snowflake 中待处理的数据移动到代码运行的地方。一个缺陷：单元测试的支持仍待优化；我们的团队通过编写其它类型的测试来弥补这个缺陷。
ChatGPT(Sep 2023, 评估)
ChatGPT 继续引起关注。随着充满想象力的应用场景和创造性地提示词的涌现，它正在不断扩大其实用性。GPT4 这一驱动 ChatGPT 的大语言模型(LLMs)，现在也有能力与知识管理库、沙箱编程环境或网络搜索等外部工具进行集成。最近推出的 ChatGPT 企业版提供了使用情况记录和通过单点登录的用户管理等“企业版”功能，可能有助于缓解一些关于知识产权的担忧。\n尽管 ChatGPT “编写”代码的能力受到了诸多赞誉，但我们认为组织更应考虑在全软件生命周期范围内利用它来提高效率并减少错误。例如，ChatGPT 可以为需求分析、架构设计或对遗留系统进行逆向工程等任务提供额外的视角和建议。我们仍认为 ChatGPT 最好作为一个流程的输入—— 例如起草一个故事的初稿或给出某项编码任务的框架，而不是一个生成“成熟”结果的工具。话虽如此，ChatGPT 的能力还在持续增强，通过严谨地给出提示词，它已经可以完成很多编程任务。而 提示工程本身就是一门艺术。
ChatGPT(Apr 2023, 评估)
ChatGPT 是一个有趣的工具，它具有在软件开发的各个方面发挥作用的潜力。作为一个已经"阅读"了数十亿个网页的大型语言模型（LLM），ChatGPT 可以提供额外的视角，协助完成不同的任务，包括生成创意和需求、创建代码和测试等。它是一种多功能的工具，能够跨越软件生命周期的多个阶段，提高开发效率并减少错误。GPT-4，作为驱动 ChatGPT 的 LLM，现在也具备与外部工具集成的能力，如知识管理库、沙盒式编码环境以及网络搜索。目前，我们认为 ChatGPT 更适合作为流程的输入，如帮助完成用户故事的初稿或编码任务的模板，而不是一个能够产出"完美周全"结果的工具。\n使用这些人工智能工具可能会存在知识产权和数据隐私方面的担忧，包括一些尚未解决的法律问题，因此我们建议企业在使用前征求其法律团队的意见。我们的一些客户已经开始在软件生命周期的各个阶段尝试使用 ChatGPT，我们鼓励其他人探索这个工具并评估其潜在的作用。我们预计，像 GitHub Copilot 一样，ChatGPT 很快就会有一个"商业版"的产品，这可能会缓解知识产权方面的顾虑。
设计中的无障碍注解(Apr 2023, 试验)
在软件交付中越早考虑无障碍，就能越简单、更低成本的保证交付物对尽可能多的人可用。 设计中的无障碍注释工具 能促进沟通，帮助团队从工作的开始就考虑到文档结构、语义化的 HTML 和替代文本等重要的元素。这使得团队确保用户界面符合国际无障碍标准，并解决那些实际上很容易避免的常见无障碍问题。Figma 提供了一系列的无障碍性注释插件： The A11y Annotation Kit, Twitter 的 Accessibility Annotation Library 和 Axe 的工具集 Axe for Designers。
Directus(Apr 2023, 评估)
我们评估了 Directus 作为一种无头内容管理系统（content management system，CMS）。尽管无头 CMS 系统有很多可选项，但我们期望它是一个自托管解决方案，包含丰富的数字资产管理和内容创作工作流程。根据这些标准，我们发现 Directus 完全满足这些需求，特别是它通过 flows 实现的事件驱动数据处理和自动化功能。
Terraform Cloud Operator(Apr 2023, 试验)
越来越多的团队在使用 Kubernetes Operators 模式来管理 Kubernetes 集群。为此，我们曾推荐过 Crossplane，现在有了另外一种选择——Terraform Cloud Operator。该工具通过扩展 Kubernetes 控制平面来集成 Terraform Cloud 和 Kubernetes，以通过 Kubernetes manifest 对云和本地基础设施进行生命周期管理。我们的团队使用它来提供资源，不管是 Kubernetes namespace，RoleBindings，云数据库实例，还是其他 SaaS 资源。我们非常喜欢它，因为它利用我们更熟悉的抽象层 Terraform 模块来操作云资源。
Mend SCA(Apr 2023, 试验)
Mend SCA（之前称为 Whitesource）可以用于检测开源软件依赖项，以识别它们是否最新、是否含有安全漏洞，或存在特殊许可证需求。我们的团队在将 Mend SCA 集成到生产流程方面有着不错的经验。无论是从 IDE 集成还是从 CI/CD 流水线集成中识别问题并自动提出 PR，Mend SCA 都提供了出色的开发体验。其他一些流行的 SCA 工具，如 Snyk，也值得探索，以满足你的安全需求。
Kubernetes External Secrets Operator(Apr 2023, 评估)
Kubernetes External Secrets Operator(ESO) 让我们可以将外部的密钥提供程序与 Kubernetes 集成。ESO 通过外部提供程序的 API 来读取密钥，并将其注入到 Kubernetes Secret 中。它还可以与众多的密钥管理工具集成，包括一些我们在往期技术雷达中介绍过的工具。我们的团队发现在使用 Kubernetes 的过程中，ESO 让我们可以使用统一的存储来管理整个项目的密钥，从而方便了密钥的使用。
特征库(Apr 2023, 试验)
任何软件都需要正确表示其所应用的那一领域，并且应该始终了解关键的目标。机器学习项目也不例外。特征工程 是机器学习软件系统工程和设计的重要部分。特征库 是一个架构上的概念，能促进识别、发现和监测与给定领域或业务问题有关的特征。 实现这一概念需要结合架构设计，数据工程和基础设施管理，来创建一个可扩展的、高效的、可靠的机器学习系统。 从工具的角度看，您可以找到开源的和完全托管的方案，但这些只包含了这个概念的一部分。在端到端的机器学习系统设计中，实现特征库带来了以下能力：(1) 定义准确特征的能力；(2) 增强数据的可复用性并且让特征在不同模型中保持一致和可用的能力，其中还包括设置特征工程管道，以规划特征库中的数据的能力; (3) 帮助特征发现的能力和 (4) 提供特征服务的能力。我们的团队利用特征库获得了这些对端到端机器学习系统的便利。
特征库(Apr 2021, 评估)
Feature Store 是一个服务于机器学习的数据平台，可以解决当前我们在特征工程中所遇到的一些关键问题。它提供了三个基本功能：（1）使用托管的数据管道，以消除新数据与数据管道之间的冲突；（2）对特征数据进行编目和存储，从而促进跨模型的特征的可发现性和协同性；（3）在模型的训练和干扰过程中，持续提供特征数据。\n自从 Uber 公开了 Michelangelo 平台 以来，许多组织和初创企业都建立了自己的特征库；例如 Hopsworks、Feast 和 Tecton。 我们看到了 Feature Store 的潜力，并建议仔细对其进行评估。
PyTorch(Apr 2023, 采纳)
PyTorch 一直是我们选择的机器学习（ML）框架。相比于 TensorFlow，大多数团队更喜欢 PyTorch，因为它暴露了 TensorFlow 隐藏的 ML 内部工作原理，使其更易于调试。动态计算图使得模型优化比其他任何 ML 框架都更容易。State-of-the-Art (SOTA) 模型 的广泛可用性以及实现研究论文的便利性使 PyTorch 脱颖而出。在图 ML 领域，PyTorch Geometric 是一个更成熟的生态系统，我们的团队在使用中获得了良好的体验。PyTorch 在模型部署和扩展方面也逐渐弥合了缺失，例如，我们的团队已成功地在生产中使用 TorchServe 服务预训练模型。随着许多团队默认使用 PyTorch 来满足其端到端的深度学习需求，我们很高兴地建议采纳 PyTorch。
PyTorch(May 2020, 试验)
我们的团队一直在使用并且很认可 PyTorch 机器学习框架，并且有几支团队对 PyTorch 的喜爱甚于 TensorFlow。PyTorch 暴露了 TensorFlow 隐藏的 ML 内部工作原理，使其更易于调试，并包含了程序员熟悉的结构，例如循环和动作。PyTorch 最新版本提高了性能，我们已在生产项目中成功使用了它。
PyTorch(May 2018, 评估)
PyTorch is a complete rewrite of the Torch machine learning framework from Lua to Python. Although quite new and immature compared to Tensorflow, programmers find PyTorch much easier to work with. Because of its object-orientation and native Python implementation, models can be expressed more clearly and succinctly and debugged during execution. Although many of these frameworks have emerged recently, PyTorch has the backing of Facebook and broad range of partner organisations, including NVIDIA, which should ensure continuing support for CUDA architectures. ThoughtWorks teams find PyTorch useful for experimenting and developing models but still rely on TensorFlow’s performance for production-scale training and classification.
PyTorch(Nov 2017, 评估)
PyTorch is a complete rewrite of the Torch machine learning framework from Lua to Python. Although quite new and immature compared to Tensorflow, programmers find PyTorch much easier to work with. Because of its object-orientation and native Python implementation, models can be expressed more clearly and succinctly and debugged during execution. Although many of these frameworks have emerged recently, PyTorch has the backing of Facebook and broad range of partner organisations, including NVIDIA, which should ensure continuing support for CUDA architectures. ThoughtWorks teams find PyTorch useful for experimenting and developing models but still rely on TensorFlow’s performance for production-scale training and classification.
Evidently(Apr 2023, 评估)
Evidently 是一个开源的 Python 工具，旨在帮助构建对机器学习模型的监控，以确保它们的质量和在生产环境运行的稳定性。它可以用于模型生命周期的多个阶段：作为 notebook 中检查模型的仪表板，作为 pipeline 的一部分，或者作为部署后的监控。Evidently 特别关注模型漂移，同时也提供了模型质量检查、数据质量检查和目标漂变监测等功能。此外，它还提供了多种内置的指标、可视化图形和测试，可以轻松地放入报告、仪表板或测试驱动的 pipeline 中。
Mikro ORM(Apr 2023, 试验)
Mikro ORM 是一个基于 TypeScript 的对象关系映射（ORM）框架。全栈使用 TypeScript，能从浏览器到后端为开发人员提供一致的开发体验，让他们更容易编写和维护代码。另外值得注意的是，Mikro ORM 的性能非常出色，可以快速执行查询并将延迟降低到最小。虽然 Mikro ORM 提供了吸引人的功能，但仍然需提防 ORM 的常见使用问题。ORM 框架通常很复杂，而且为关系型数据存储只提供了一个“有漏洞风险”的抽象层，因此采用一个 ORM 框架前一定需要权衡利弊。
SolidJS(Apr 2023, 评估)
SolidJS 是一个用于创建用户界面的声明式 JavaScript 库。在过去的一年里，我们看到 SolidJS 在开发者中的出现次数和受欢迎程度有所提高，尤其是那些对创建更丰富的用户互动感兴趣的开发者。SolidJS 将其模板编译为真实的 DOM 节点（而不是使用 虚拟 DOM），并通过细粒度的反应来更新它们，这减少了不必要的 DOM 更新，从而获得更快的性能和更好的用户体验。它的 API 很简单，并且很好的支持了 TypeScript，这对开发过程中发现错误很有帮助。SolidJS 的另一个好处是它的组件包很小，这对于快速构建和轻量级的网络应用来说非常合适，特别是移动优先的场景。SolidJS 是一个相对较新的框架，它不像其他框架那样拥有庞大的社区或生态系统。然而，从越来越多的有用的库和工具来看，它似乎越来越受欢迎。它的反应式更新系统、功能性组件模型和模板系统使 SolidJS 成为一个有吸引力的选择，我们看到一些团队和社区对其感兴趣。
有限界的使用低代码平台(Apr 2023, 试验)
我们一直倡导写尽可能少的代码。简洁是我们在软件开发时笃信的核心价值之一。例如，我们尽量不预测未来的需求，只实现满足当前业务需求的代码，而不考虑其他内容。创建工程平台是一个在组织层面上实现这个目标的可能方法。\n这也是现在许多流行的低代码平台的既定目标。像 Mendix 或 Microsoft Power Apps 这些平台可以展示通用的业务流程以方便重复使用，并简化了部署新功能和交付给用户的问题。近年来，这些平台在可测试性和对良好工程实践的支持方面取得了巨大的进步。它们特别适用于简单的任务或事件触发的应用程序。然而，要求它们适应几乎无限的业务需求会带来复杂性。虽然开发人员可能会少写（或不写）代码，但他们也必须成为一个全面的商业平台的专家。我们建议企业考虑他们是否需要这些产品带来的所有功能，或者他们是否更应该追求 限界的低代码平台 ，无论是开发自己的作为内部产品的平台，还是通过谨慎限制商业低代码平台的使用范围，使其仅限完成于它们擅长的简单任务。
有限界的使用低代码平台(Apr 2021, 评估)
现在很多公司正在面临的一个最微妙的决定便是是否要采纳低代码平台或无代码平台，这些平台可以被用来在非常特定的领域里解决一些特定的问题。限界低代码平台这一领域的供应商也有如过江之鲫。现在看来，这类平台的一个突出的问题，便是很难应用一些诸如版本控制之类的优秀的工程实践。而且这类平台上的测试也非常的困难。然而我们还是注意到了这个市场里的一些有趣的新兵，例如 Amazon Honeycode 可以被用来创建一些简单的任务和事件管理应用，还有 IFTTT（类似于云工作流）领域的 Parabola，这也是为何我们会将 限界低代码平台 纳入这个部分的原因。但是我们仍然对它们更广泛的适用性深表怀疑，因为这些工具，如日本 Knotweed，非常容易超出它们原本的限界而被泛化用于其他场景，这也是为什么我们对采纳这种技术持强烈的谨慎态度。
有限界的使用低代码平台(Oct 2020, 评估)
现在很多公司正在面临的一个最微妙的决定便是是否要采纳低代码平台或无代码平台，这些平台可以被用来在非常特定的领域里解决一些特定的问题。限界低代码平台这一领域的供应商也有如过江之鲫。现在看来，这类平台的一个突出的问题，便是很难应用一些诸如版本控制之类的优秀的工程实践。而且这类平台上的测试也非常的困难。然而我们还是注意到了这个市场里的一些有趣的新兵，例如 Amazon Honeycode 可以被用来创建一些简单的任务和事件管理应用，还有 IFTTT（类似于云工作流）领域的 Parabola，这也是为何我们会将 限界低代码平台 纳入这个部分的原因。但是我们仍然对它们更广泛的适用性深表怀疑，因为这些工具，如日本 Knotweed，非常容易超出它们原本的限界而被泛化用于其他场景，这也是为什么我们对采纳这种技术持强烈的谨慎态度。
基于 AI 辅助的测试驱动开发(Apr 2023, 评估)
和软件行业的许多人一样，我们一直在探索快速演进的 AI 工具，以帮助我们编写代码。我们看到很多人通过将实现代码输入 ChatGPT，然后请求其生成测试代码。但作为 TDD（测试驱动开发）的坚定支持者，我们并不想经常将可能包含敏感信息的实现代码输入到外部模型中，因此我们尝试了基于 AI 辅助的测试驱动开发的技术。在这种方法中，我们让 ChatGPT 为我们生成测试代码，然后由开发人员来实现功能。具体而言，我们首先在一个可在多个用例中重复使用的提示“片段”中描述我们使用的技术栈和设计模式。然后，我们描述我们想要实现的具体功能，包括验收标准。基于这些信息，我们要求 ChatGPT 生成在我们的架构风格和技术栈中实现这一功能的实现计划。一旦我们对这个实现计划进行了合理性检查，我们就要求它为我们的验收标准生成测试代码。\n这种方法对我们来说效果出奇的好：它要求团队提供对其架构风格的简明描述，帮助初级开发人员和新团队成员编写符合团队现有风格的功能特性。这种方法的主要缺点是，尽管我们没有向模型提供源代码，但我们仍然向其输入了可能包含敏感信息的技术栈和功能描述。至少在这些AI工具的“商业版”面世之前，团队应确保与法律顾问合作，以避免任何知识产权问题。
领域特定的大语言模型(Apr 2023, 评估)
在之前的技术雷达中，我们已经提到过 BERT 和 ERNIE 之类的大型语言模型 (LLMs)；但是 领域特定的大型语言模型 是一个新兴的趋势。使用领域特定数据对通用大型语言模型进行微调能将它们用于各种各样的任务，包括信息查询，增强用户支持和内容创作。这种实践已经在法律和金融领域展现出现它的潜力，例如使用 OpenNyAI 进行法律文书分析。随着越来越多的组织开始对大型语言模型进行试验和越来越多像 GPT-4 这样的新模型的发布，我们预期大型语言模型在不久的将来会有更多领域特定的用例。 但是使用大型语言模型仍面临许多挑战和缺陷。首先，大型语言模型能”很自信地犯错”，所以需要构建一些机制来保证结果的准确性。其次，第三方大型语言模型可能保留或二次分享你的数据，这会对保密信息和数据的所有权带来风险。组织应当仔细审阅使用条款和供应商的可信度，或考虑在自己控制的基础设施上训练和运行大型语言模型。就像其他的新技术一样，在业务上使用大语言模型前需要保持谨慎，并理解采用大型语言模型带来的后果和风险。
Akeyless(Apr 2023, 试验)
随着越来越多的组织采用云计算，许多组织开始同时集成多个云提供商，以最大限度地提高灵活性并最小化供应商锁定。然而，跨多个云提供商的密钥管理和访问控制可能会导致复杂性和安全风险增加，从而成为一项重大挑战。Akeyless 是一个基于云的集中化平台，提供统一的密钥管理，在管理密钥和敏感数据方面具有一系列优势。它能够与不同的云提供商无缝集成，简化了密钥管理和访问控制，以监测和控制谁可以访问敏感数据；通过加密、访问控制、多因素身份验证和其他安全机制，确保只有授权用户才能访问敏感数据。此外，它还提供了一个直观的界面用于管理和监控，这为开发和管理人员带来了更简单且更可扩展的体验。
pandera(Apr 2023, 评估)
在之前的雷达中，我们介绍了例如 Great Expectations 的数据验证和测试平台，其可用于验证假设并测试用于培训或分类的输入数据的质量。但是有时候，只需要一个简单的代码库就可以直接在流水线中实现测试和质量检查。pandera 是一个 Python 库，用于测试和验证跨各种框架类型的数据，例如 pandas，Dask 或者 PySpark。 pandera 可以实现关于字段的简单断言或基于统计模型的假设验证。其广泛支持的框架库意味着只需编写一次测试就可以应用于各种底层数据格式。此外，pandera 还可以用于生成测试 ML 模型的合成数据 synthetic data to test ML models.
Flutter 嵌入式平台(Apr 2023, 评估)
Flutter 嵌入式平台 使得创建和维护现代 UI(modern UI) 变得相对容易，这种UI类似于移动应用程序却适用于嵌入式系统，如汽车、冰箱和其他消费类电器中的人机界面(HMI)。因为 Flutter 现在支持自定义嵌入器，从而使其移植到不同的平台成为可能。这些应用程序使用 Dart 编程语言编写，使用 Flutter SDK 及其生态系统。我们一直在用它构建原型 – 我们的开发人员喜欢这种开发体验，我们的客户喜欢它带来的灵活、速度和现代化的用户体验。
Galacean Engine(Apr 2023, 评估)
Galacean Engine 是一个 Web 和移动优先的交互引擎，旨在提供一种无缝的方式，以移动友好的方式渲染基于组件的架构和动画。凭借其对轻量级和高性能渲染的关注，它已成为开发者创建引人入胜的移动游戏时一个越来越受欢迎的选择。它是一个基于 TypeScript 的引擎，开发者称其性能优于其他引擎。
.NET MAUI(Apr 2023, 评估)
.NET MAUI 是一个使用 C# 和 XAML 创建原生移动端和桌面端应用程序的新的跨平台框架。它可以用同一份代码库构建可在 Android、iOS、macOS 和 Windows 上运行的应用程序。然而，作为一项新技术，MAUI 的生态系统仍不如 React Native 或其他跨系统平台的生态发达，并且它只支持 C#。此外，企业和组织在使用 MAUI 时可能也会面临过去使用 Xamarin 时遇到的挑战，包括糟糕的跨平台工具、移动端集成问题、开发人员难以招聘和不成熟的生态系统。\n尽管微软宣称他们致力于将 MAUI 打造为以移动端为主的开源移动开发框架，但 MAUI 尚未得到市场认可。如果您已经使用了 Xamarin ，可以尝试将 MAUI 作为潜在的技术升级方向进行评估。然而，如果 C# 或 Xamarin 目前不是您技术栈的一部分，在其可靠性得到验证和被市场广泛采用之前，建议您谨慎对待 MAUI 。
Kubeshark(Apr 2023, 评估)
Kubeshark 是一个 Kubernetes 的 API 流量监控工具，在2022年11月之前，它被称为 Mizu (日语“水”，象征着透明和流动性)，与其他工具不同的是，Kubeshark 不需要安装监测工具或改动代码，它作为DaemonSet 守护进程集在 Kubernetes 集群的节点层面上注入一个容器，并执行类似 tcpdump 的操作。 我们认为 Kubeshark 是一个很有用的调试工具，因为它可以实时地监控多种协议(REST，gRPC，Kafka，AMQP 和 Redis )之间的所有 API 通信。
Kubeshark(Oct 2022, 评估)
Mizu 是一个 Kubernetes 的 API 流量查看器。与其他工具不同的是，Mizu 不需要增加监测工具或改动代码，而是在 Kubernetes 集群的节点层面上注入一个容器作为 DaemonSet，做一些类似 tcpdump 的操作。我们发现 Mizu 可以实时监测多种协议（REST、gRPC、Kafka、AMQP 和 Redis）下的所有 API 通信，因此它可以作为一个调试工具来使用。
Neon(Apr 2023, 评估)
Neon 是 AWS Aurora PostgreSQL 的一款开源替代产品。云原生分析型数据库已经采用了将存储与计算节点分离的技术，以便根据需要弹性扩展。然而，在事务性数据库中进行相同的操作比较困难。Neon 通过其新的多租户存储引擎技术实现了这一点。它对主流 PostgreSQL 代码进行最小的更改，并利用 AWS S3 进行长期数据存储，在计算方面弹性扩缩容（包括缩放到零）。这种架构有几个好处，包括便宜和快速地克隆、写入时复制和分支。我们对基于 PostgreSQL 的创新非常兴奋。我们的团队正在评估 Neon，并建议您也对其进行评估。
OpenLineage(Apr 2023, 评估)
OpenLineage 是一个开放的数据管道沿袭元数据收集标准，旨在在作业运行时对其进行编整。它使用一致的命名约定定义了运行、作业和数据集实体的通用模型。沿袭模型的核心是可扩展的，可以通过定制切面来增加实体。OpenLineage 解决了生产者和消费者之间互通问题，否则大家不得不想各种办法实现互通。虽然存在它会成为另一个“中间标准”的风险，但作为 Linux 基金会 AI 和数据基金会项目，它获得被广泛采用的机会很大。OpenLineage 目前支持多个平台的数据采集，如 Spark 、Airflow 和 dbt，但用户需要自己配置监听器。OpenLineage 对数据消费者的支持目前较为有限。
Stencil(Apr 2023, 试验)
Stencil 是一个库，使开发人员能够使用 TypeScript、JSX 和 JSDoc 等成熟的工具构建可复用的 Web 组件。根据我们团队的经验，Stencil 是构建平台无关的设计系统的一个非常好的选择。对于少数不支持现代浏览器特性的浏览器，Stencil 通过按需 polyfilling 不支持的功能和 API 来确保兼容性。
Typesense(Apr 2023, 试验)
Typesense 是一款可容错的开源搜索引擎，它针对高性能和低延迟的搜索体验进行了优化。如果您正在构建对延迟有较高要求的搜索应用，而且索引的大小可以载入内存，Typesense 将是个很好的选择。我们团队在高可用的多节点集群里使用 Typesense 实现负载分布，并确保关键的搜索基础设施能自适应负载变化。在实际使用中 Typesense 表现良好，因此我们将其移动到试验环中。
Typesense(Mar 2022, 评估)
Typesense 是一个快速、容错的文本搜索引擎。在有大量数据的情形下，Elasticsearch 可能仍然是一个不错的选择，因为它提供了一个基于磁盘且可横向扩展的搜索解决方案。 然而如果你正在构建一个对延迟敏感的搜索应用，并且搜索索引的尺寸可以容纳在内存中，那么 Typesense 会是一个强大的替代方案，你也可以考虑与 Meilisearch 等工具一起评估。
Matter(Apr 2023, 评估)
Matter 是由亚马逊、苹果、谷歌、康卡斯特和Zigbee联盟（现已更名为Connectivity Standards Alliance，简称CSA）联合推出的智能家居技术的开放标准。它使设备能够与任何已通过Matter认证的生态系统配合使用，从而减少了不同供应商的设备和物联网平台之间的碎片化，促进了互操作性。它专注于在应用层面上的标准化、支持Wi-Fi和Thread作为通信媒介。与Zigbee等其他协议不同，Matter得到了主要科技公司的支持。尽管支持Matter的设备数量仍然相对较少，但它在物联网领域日益重要，因此对于那些希望构建智能家居和物联网解决方案的人来说，它是值得评估的。
竭尽全力的计划(Apr 2023, 暂缓)
虽然在产品管理社区中，应该预留一些交付能力余量是众所周知的，但我们发现仍然有许多团队会为团队制订 竭尽全力的计划 。在迭代计划中预留一定的产能，往往可以提高可预测性以及更好的质量。因为这不仅有助于增强团队应对意外事件（如疾病、生产问题、意外的产品请求和技术债务）的弹性，还让团队可以进行提升生产力的活动，比如团队建设和创意构思，从而推动产品创新。留有一定的交付余量，可以让团队更加专注于所生产的软件的健壮性，并更加关注正确的度量信息。我们的经验表明，就像高速公路的车辆过多就会导致缓慢而令人沮丧的交通一样，充分利用团队的能力往往会导致生产效率的崩溃。当我们的一个团队需要处理不可预测的支持请求时，他们只按照开发能力的2/3来计划功能交付的速度，从而增加了25%的交付量，并减少了50%的周期时间波动。
Ory Kratos(Apr 2023, 评估)
我们已经评估了 Ory Hydra 作为自托管的 OAuth2 解决方案，并收到了团队的正向反馈。这一次，我们转向 Ory Kratos，这是一个 API 优先的身份和用户管理系统，对开发人员友好，且易于定制。它已经提供了我们希望在身份管理系统中实现的常见功能，包括自助登录和注册、多因素身份验证(MFA/2FA)、账户验证和账户恢复。像 Hydra 一样，Kratos 是无头的（在希腊神话中， Hydra 意指九头蛇海德拉。即使斩断它的一颗头，也会生出新的头。——译者注），需要开发人员自己构建 UI，这给了团队更多的灵活性。开发人员还可以定制标识模式以适应不同的业务上下文。除了数据库，Kratos 没有外部依赖关系，并且很容易在不同的云环境中部署和扩展。如果您需要构建一个用户管理系统，我们建议试试 Kratos。
DataFusion(Apr 2023, 评估)
DataFusion 是数据社区将 Rust 的性能、内存安全、并发特征用于数据处理的新探索。它与 Polars 相似, 都提供了一套熟悉的 Rust 中的名为 DataFrame 的 API (包括 Python 绑定库)，使用了 Apache Arrow 并提供了 SQL 支持。尽管它主要为单进程设计，但是也支持使用 Ballista 进行分布式运算。我们认为包括 Data Fusion 在内的用于数据处理的 Rust 库正在持续进化，它们值得关注和探索。
River(Apr 2023, 试验)
许多机器学习方法的核心是从一组训练数据中创建模型。一旦创建了模型，它就可以一遍又一遍地使用。然而，世界并不是静止的，随着新数据的出现，模型往往需要更新。简单粗暴地重新训练模型可能会很慢，而且成本很高。增量学习的出现解决了这个问题，使得从数据流中不断学习成为可能，从而更快地对变化做出反应。其也有一些额外的好处：它对算力和内存的要求更低，而且可以预测。我们对 River 的实践体验仍然是正面的。Vowpal Wabbit 可以作为一个替代方案，但它的学习曲线更陡峭，而 River 提供的类似 Scikit 的 API 使 River 更容易被数据科学家所接受。
River(Apr 2021, 评估)
众多机器学习方法的核心皆在于从一组训练数据创建一个模型。一旦创建了模型，就可以反复使用它。然而世界并不是静止的，通常模型需要随着新数据的出现而改变。单纯地重新训练模型可能会非常缓慢和昂贵。增量学习解决了这个问题，它使从数据流中增量地学习成为可能，从而更快地对变化做出反应。作为额外的好处，计算和内存需求更低，而且是可预测的。我们在基于River框架的实现中积累了良好的经验，但到目前为止，我们需要在模型更新后增加校验，有时要手动进行。
Cozo(Apr 2023, 评估)
Cozo 是一个以 Datalog 作为查询语言的可嵌入关系型数据库。其对时间旅行 (time-travel) 查询及对在关系型数据模式中建模图数据的支持使我们非常感兴趣。我们很喜欢它将数据存储委托给现有的主流引擎，例如 SQLite, RocksDB, Sled 和 TiKV。尽管 Cozo 还处在早期开发阶段，我们仍认为它值得一试。
Kepler(Apr 2023, 评估)
衡量能源消耗是团队减少软件碳足迹的重要步骤。云碳足迹 (CCF) 通过从云 API 检索的账单和使用数据估计能源消耗。Kepler 是基于 Kubernetes 的高效功率级别导出器（Kubernetes-based Efficient Power Level Exporter）的缩写。它通过使用软件计数器（RAPL, ACPI 和 nvml）来测量硬件资源的功耗，并采用基于 eBPF 的方法来将功耗归因于进程、容器和 Kubernetes Pod。然后，使用自定义的 ML 模型和 SPEC Power 基准测试数据将功率使用转换为能量估算。最后，将 Pod 级别的能量消耗报告作为 Prometheus 度量标准公开。在 Kubernetes 运行在虚拟机上的情况下，例如不使用裸机实例时，Kepler 使用 cgroups 来估计能源消耗。我们对云碳足迹有着丰富的经验，并且可以证明其有用性，但我们对 Kepler 项目的方法感到好奇。
Jetpack DataStore(Apr 2023, 试验)
Jetpack DataStore 是一个新的数据存储解决方案，提供异步性、一致性和事务性的存储数据功能。它有两种实现方式： Preferences DataStore 用于无类型的键值对的存储，Proto DataStore 用于使用 Protobufs 的复杂数据类型的存储。默认情况下，它与 Kotlin 的 coroutines 和Flow 一起使用，但对 RXJava 2 和 3 也有额外支持。其文档建议，如果你目前正在使用 SharedPreferences，可以考虑迁移到 DataStore，我们认同这个建议。
GitHub Actions(Apr 2023, 采纳)
对于许多需要在新环境中快速启动和运行CI或CD的团队来说，GitHub Actions已经成为了默认选择。此外，它还能承载更复杂的工作流程，并且能够调用其他复合任务中的任务。尽管GitHub应用市场中的生态在不断发展，我们仍然强烈建议谨慎授予第三方GitHub Actions权限访问您的构建流水线。我们建议您遵循GitHub有关安全强化的建议，避免以不安全的方式共享机密信息。 但是，直接在托管源代码的GitHub上创建构建工作流的便利性，再加上能使用像act等开源工具在本地运行GitHub Actions，让其成为简化团队设置和新成员上手流程的一个引人注目的选项。
GitHub Actions(Mar 2022, 试验)
GitHub Actions 的使用量在去年大幅增长。之前的使用经历已经证明它可以处理更复杂的工作流程，并在复合操作中调用其他操作。但是，它仍存在一些缺点，例如无法重新触发工作流的单个作业。尽管 GitHub Marketplace 中的生态系统有其明显的优势，但让作为第三方的 GitHub Actions 访问你的构建流水线可能会以不安全的方式共享机密信息（我们建议遵循 GitHub 关于安全强化的建议）。尽管如此，GitHub Actions 以其在 GitHub 中的源代码旁直接创建构建工作流的便利性，结合使用 act 等开源工具在本地运行的能力，是一个利于团队刚开始开展工作以及新人上手的强有力选项。
GitHub Actions(Oct 2021, 试验)
虽然曾在技术雷达中提出慎用的建议，但我们依然看到了用户对于GitHub Actions的持续热情。尽管如此，之前的建议依然有效——对于复杂工作流来说，GitHub Actions还不算成熟的CI/CD工具。例如，它不能重新触发工作流中单独的一个job，不能在composite action中调用其他的action，也不支持共享库。另外，虽然GitHub Marketplace 生态圈具备显著的优势，但让第三方的Github Actions访问自己的构建流水线，会带来以不安全的方式共享机密的风险（我们建议遵循GitHub 的安全加固建议）。尽管有种种顾虑，但在GitHub源代码旁直接创建构建工作流的便利性，对很多团队还是有着不小的吸引力。另外，还可以使用act 在本地运行Github Actions。和以前一样，我们建议审慎地权衡Github Actions的优缺点。但我们的很多团队还是非常喜欢它的简单性。
GitHub Actions(Apr 2021, 评估)
在我们的工具箱中，CI服务器与构建工具最为古老，使用也最广泛。其工作范围包括简单的云托管服务，一直到复杂的、由代码定义的、支持大型构建机群的流水线服务。鉴于市面上已经有大量的同类产品，当另一个用于管理构建与集成工作流 GitHub Actions 出现时，基于经验我们起初抱有怀疑的态度。但是 GitHub Actions 为开发者提供了小步启动并可以轻松自定义的行为，并逐渐成为小型项目的默认选项。将构建工具直接集成到源代码库实在很方便，因此社区也很活跃。大量用户贡献了工具以及工作流，便于快速上手。工具供应商也可以通过 GitHub Marketplace 提供服务。但是，我们仍然建议你保持谨慎。因为尽管代码和 Git 历史记录可以导出到其他服务器中，但是基于 GitHub Actions 的开发工作流程却不能。另外，你也需要自行判断何时项目会变得足够大或足够复杂，而需要使用有独立支持的流水线工具。但对于初创而需要快速运行的、较小的项目，仍然值得考虑 GitHub Actions 及其不断发展的生态系统。
可验证凭证(Apr 2023, 试验)
三年前，当我们第一次在雷达中提及可验证凭证（VC）时， 它是一个引人注目的标准，有着一些潜在的应用前景，但在爱好者群体之外并没有广为人知。对于如州政府等负责实施该标准的证书授予机构，情况更是如此。三年疫情之后，随着加密安全、尊重隐私和机器可验证电子证书的需求增长，政府开始意识到可验证凭证的潜力。W3C 标准 以凭证持有者为中心，这与我们使用物理凭证时的体验相似：用户可以将他们可验证的凭证放到自己的数字钱包中，并在任何时候向任何人展示，而无需得到凭证发行者的许可。这种去中心化的方式有助于用户更好地管理和有选择地披露自己的信息，大大提高了数据隐私的保护。 在过去的 6 个月里，我们的一些团队参与了使用可验证凭证技术的项目。 毫不意外，不同国家和政府部门的情况并不相同。 我们的团队在多个项目上探索了去中心化标识、可验证凭证和可验证展示的不同组合。 这是一个仍在发展的领域，现在我们有了更多的经验，我们希望在雷达中持续跟踪它。
可验证凭证(Oct 2022, 评估)
当我们两年前第一次把它纳入雷达时，可验证凭证是一个有趣的标准，有着一些潜在的应用前景，但它并没有在爱好者群体之外广为人知。当涉及到将负责实施该标准的证书授予机构时，如州级政府等，情况更是如此。自疫情以来的两年后，随着对加密安全、尊重隐私和可由机器验证的电子凭证的需求的增长，政府开始意识到可验证凭证的潜力。我们现在开始看到可验证证书出现在我们与公共部门客户的合作中。W3C 标准以凭证持有者为中心，这与我们使用物理凭证时的经验相似：用户可以将其可验证凭证放在自己的数字钱包中，并在任何时候向任何人展示，而无需得到凭证发行者的许可。这种去中心化的方法也使用户能够更好地管理和有选择地披露自己的信息，这大大改善了数据隐私的保护。例如，在零知识证明技术的支持下，你可以在不透露你的生日情况下构建一个可验证凭证来证明你是一个成年人。值得注意的是，尽管许多基于可验证凭证的去中心化身份解决方案依赖于区块链技术，但区块链并不是所有可验证凭证实施的先决条件。
可验证凭证(Oct 2020, 评估)
凭证在我们生活中无处不在，例如护照、驾照和学历证书。但是，当今大多数数字凭证都是来自信息系统的简单数据记录，易于修改和伪造，并且经常暴露出不必要的信息。近年来，我们已经看到逐步成熟的可验证凭证解决了这一问题。 W3C 标准 将其定义为一种加密安全、尊重隐私和机器可验证的手段。与我们使用物理凭据时的经验类似，该模型以凭证持有者为中心：用户可以将可验证的凭证放入自己的数字钱包中，并在没有凭证发行人许可的情况下随时向其他人展示。这种去中心化的方法还使用户能够更好地管理自己的信息并有选择地公开，从而大大改善了数据隐私保护。例如，借助零知识证明技术，你可以构建可验证的凭证，无需透露自己的生日即可证明你是成年人。社区围绕可验证凭证开发了许多用例。我们已参考COVID-19 凭证计划（CCI) 实施了自己的 COVID 健康认证。尽管可验证凭证不依赖于区块链技术或去中心化身份，但该技术在实践中通常与 DID 结合使用，并将区块链用作可验证的数据注册表。许多去中心化身份的框架也嵌入了该技术。
Synthetic Data Vault(Apr 2023, 试验)
Synthetic Data Vault（SDV）是一个数据生成工具库，它通过学习数据集的分布，生成与源数据具有相同格式和统计属性的合成数据。在往期的技术雷达中，我们讨论过应用测试环境中的生产数据的弊端。然而，生产环境中数据分布的细微差别很难手工复制，这会导致合成数据中的一些缺陷和无法预知的情况。我们使用 SDV 来生成大数据进行性能测试时获得了很好的体验。SDV 在为单表建模时表现良好。然而，随着带有外键约束的表数量的增加，数据生成时间也大大增加。尽管如此，SDV 为本地性能测试提供了很大的希望。它是一个生成合成数据的好工具，值得考虑用于你的测试需求。
Synthetic Data Vault(Oct 2022, 评估)
合成数据保险库 是一个数据生成工具库，它可以学习数据集的分布，以生成与源数据具有相同格式和统计属性的合成数据。在往期的技术雷达中，我们讨论过下游应用 测试环境中的生产数据。然而，生产环境中数据分布的细微差别很难手工复制，这会导致合成数据中的一些缺陷和无法预知的情况。我们相信合成数据保险库和类似的工具可以通过合成类生产环境的单表，复合多表 和多变量时间序列 来填补这个差距。虽然合成数据保险库并非新鲜事物，我们仍然非常看好这项技术并推荐它。
nanoGPT(Apr 2023, 评估)
nanoGPT 是一个用于对中等规模的生成式预训练 Transformer（GPT）进行训练和调优的框架。其作者 Andrej Karpathy 基于注意力机制和 OpenAI 的 GPT-3 两篇论文的理论，使用 PyTorch 从零开始构建一个 GPT。在生成式人工智能火热的趋势下，我们想要强调 nanoGPT 的简洁性，并且注重对 GPT 架构的构建模块进行清晰呈现。
Kubeflow(Apr 2023, 试验)
Kubeflow 是一个Kubernetes 原生的机器学习（ML）平台，它能简化模型生命周期中在不同基础设施上的构建、训练和部署流程。 我们已经大量使用它的 Pipelines 来编码多个模型的包括实验、训练、服务用例的 ML 工作流。除 Pipelines 外, Kubeflow 还带有许多其他的组件, 我们发现其中用于超参数调优的 Katib 组件以及多租户组件都是非常有用的。
Kubeflow(Nov 2019, 评估)
Kubeflow之所以令人感兴趣，是因为两个原因。首先，它是Kubernetes Operators的创新应用，我们在2019年4月版的技术雷达中对Kubernetes Operators进行了重点介绍。其次，它提供了一种对机器学习工作流进行编码和版本控制的方法，使它可以更容易地从一个执行环境移植到另一个环境。Kubeflow由几个组件组成，包括Jupyter notebooks、数据流水线和控制工具。其中一些组件被打包成为Kubernetes Operators，以利用Kubernetes响应Pod产生的事件的能力，而Pod可以实现工作流的各个阶段。通过将程序和数据打包为容器，可以将整个工作流程从一个环境移植到另一个环境。这有利于将有用但是计算能力要求极高的工作流，从云上转移到自定义超级计算机或者张量处理器（TPU）集群中。
Gitleaks(Apr 2023, 试验)
Gitleaks 是一个开源 SAST（静态应用安全测试）命令行工具，用于检测 Git 仓库以防止把密码、API 密钥和访问令牌等机密信息硬编码到代码中。它可以用于 Git 的 pre-commit hook 和 CI/CD 流水线。我们团队发现，Gitleaks 比其他一些密码扫描工具更灵敏。Gitleaks 使用正则表达式和 entropy coding 字符串编码检测机密信息。在我们的经验中，entropy coding 提供了灵活的自定义正则表达式，允许团队基于他们的需求对机密信息进行更好的分类。例如，相较于把所有的API密钥笼统地归类为“通用型 API 密钥”，entropy coding 允许把密钥归类到“云服务提供商密钥”这种特定分类中。
对仅提供 API 的产品的演示前端(Apr 2023, 试验)
捕捉并传达 API 的业务价值是开发 API 时的一大挑战。就其本质而言，API 是一种技术产品。尽管开发人员可以轻松理解 JSON 数据、OpenAPI (Swagger) 规范和 Postman 演示，但业务利益相关者会更倾向于可交互的 API 产品演示。通常当我们能够实际看到并亲身体验产品时，产品的价值会更加清晰地表达出来。也正是因为这样，我们有时会认为投资 对仅提供API的产品的演示前端 是值得的。当定制化界面 UI 与 API 产品一起构建时，业务利益相关者可以将产品与他们可能更熟悉的纸质表格或报告进行类比。随着交互模型和 UI 演示的丰富性不断发展，业务利益相关者可以对 API 产品的发展方向做出更明智的决策。基于 UI 工作也有额外的益处，它可以增加开发人员对业务用户的同理心。虽然 API 产品的演示前端 并不是一项新技术——当 API 产品出现时，我们就能在必要时构建演示前端 。然而，由于这项技术并不广为人知，我们仍然认为该技术值得关注。
Apache Hudi(Apr 2023, 试验)
Apache Hudi 是一款开源数据湖平台，它将 ACID 事务保障引入了数据湖中。我们尝试了在大数据量高吞吐量场景下使用 Hudi 进行实时写入和更新数据，取得了非常理想的效果。特别令人满意的是，Hudi 对定制压缩算法的支持很灵活，这有助于解决“小文件”读写的问题。Apache Hudi 和 Delta Lake 以及 Apache Iceberg 都是同类的工具，它们提供相似的功能，但是在底层的实现方式和功能细节上又各有千秋。
设计令牌翻译工具(Apr 2023, 评估)
设计令牌是定义设计体系中标准元素的有用机制。但是，在移动应用程序或 Web 应用等媒介上保持这些设计元素的一致性是一项愈发艰巨的任务。设计令牌翻译工具通过整理和自动化地将（在 YAML 或 JSON 中的）令牌描述转换为在指定媒介中控制渲染的代码（如 CSS、React 组件或 HTML），从而简化了这个问题。Style Dictionary 是一个广泛使用的开源示例，很好地集成了自动化构建流水线，但它也有商业替代品，例如 Specify。
FOSSA(Apr 2023, 试验)
FOSSA 是一个开源合规性工具，可以帮助开发人员和团队确定他们的代码依赖哪些开源组件，以及这些组件是根据哪些许可发布的。这些信息对于确保遵守各种开源许可证和维护软件物料清单十分重要。FOSSA 可以与各种技术栈的依赖管理工具集成，以识别项目中使用了哪些开源组件。还可以根据组织的政策突出显示任何许可证问题，并生成对应的报告。此外，FOSSA 的一些关键特性还包括与开发工作流（如 CI）集成，以及实时监控合规性。我们的许多团队和客户都认为 FOSSA 是一个有用且高效的工具。
dbt-expectations(Apr 2023, 评估)
dbt-expectations 是一个用于 dbt 的拓展包，它产生的灵感来自于 Great Expectations。数据质量是数据治理的宗旨, 所以当提及自动数据治理时, 在数据管道中加入内建的管控来标记异常和质量问题很重要。就像在构建流水线中的单元测试，dbt-expectations 在数据管道运行时进行断言。在 dbt 中, 你可以直接编写 Great Expectations 风格的测试对你的数据仓库数据质量测试。我们的团队已经开始探索它，并强调其是有意义的。
按应用设定的语言偏好设置(Apr 2023, 试验)
很多人都可以使用多种语言，并且会在不同的情境下使用不同的语言。运行应用程序的设备和平台通常会要求用户选择一种系统语言，然后要求应用程序也使用这个系统语言。但手机用户有时会希望某些应用能够使用与系统语言不同的语言。苹果公司早些时候在 iOS 中提供了按应用设定的语言偏好设置功能。然而在 Android 13 之前，如果安卓应用程序开发者想要提供此选项，就只能在应用程序中自行实现。Android 13 提供了一项新的系统设置：按应用设定的语言偏好设置和一个公共 API，使开发者能够更容易地提供此功能。为了向后兼容，AndroidX 还通过 AppCompatDelegate 提供了相应的 API。我们建议开发者们使用这项新功能替换之前的自定义解决方案。
Qwik(Apr 2023, 评估)
创建一个丰富、交互式的基于浏览器的体验的挑战之一就是尽量缩短从第一次请求到用户可以进行完整交互的时间。在网页刚打开时，应用程序可能需要下载大量的 JavaScript 到浏览器中，或者在服务器上执行一个漫长的过程来恢复应用程序状态。Qwik 是一个新的前端框架，它通过序列化应用程序状态，使其可以在服务端渲染而无需重新激活和重现程序的状态。这是通过“可恢复性”来实现的，应用程序的执行可以在服务器上暂停，并在需要时在客户端上恢复。与其他较新的前端框架（如 Astro 或 Svelte）一样，Qwik 也通过减少需要加载的 JavaScript 的数量来加速初始页面的加载。但 Qwik 在应用程序初始化时会只下载基本 HTML，大多数 JavaScript 在需要时动态地从本地缓存中加载（如果可能的话）。
Gradle Kotlin DSL(Apr 2023, 采纳)
现在，相比 Groovy，我们的团队在使用 Gradle 启动新项目时更倾向于将 Gradle Kotlin DSL（Domain-Specific Language，领域专用语言） 视作默认选项。已经在使用 Groovy 的团队应考虑迁移。Kotlin 为 IDE（Integrated Development Environment，集成开发环境）中的重构与更简便的编辑提供更好的支持，而且我们的团队报告称，其产出的代码更易阅读与维护。鉴于一些 IDE 现在支持迁移，尝试替换现有的 Groovy 应该相对较快。在某些情况下，Kotlin 可能会比 Groovy 慢；然而，对于许多项目而言，这不太可能会影响到团队。
Gradle Kotlin DSL(Oct 2022, 试验)
之前，我们介绍过 Android Gradle 插件 Kotlin DSL，或 Gradle Kotlin DSL ，它为使用 Gradle 构建脚本的 Android 工程增加了对 Kotlin 脚本的支持，以替代 Groovy。用 Kotlin 替换 Groovy 的目的是在 IDE 中为重构与更简便地编辑提供更好的支持，以及最终产出更易于阅读和维护的代码。对已经正在使用 Kotlin 的团队而言，这也意味着使用一门熟悉的语言处理构建。一般来说，我们现在建议在 Gradle 工程中试用 Kotlin DSL 作为 Groovy 的替代语言，尤其是当您有庞大或复杂的 Gradle 构建脚本时。许多 IDE 现在都支持迁移现有工程。仍然存在一些警告，我们建议检查文档以获取包括前置条件在内的最新细节。我们有一个团队把至少有七年历史的、 450 行的构建脚本在几天之内成功地迁移了。
Gradle Kotlin DSL(Mar 2022, 评估)
Android Gradle 插件 Kotlin DSL 增加了 Gradle 构建脚本对 Kotlin Script 的支持，让它成为除 Groovy 之外的另一种选择。用 Kotlin 代替 Groovy 的目的在于 Kotlin 能更好得支持重构，并且在IDE里编写它更加简便，最终能够产出更易于阅读和维护的代码。对于已经在使用 Kotlin 的团队来说，这还意味着可以用更熟悉的语言编写构建脚本。我们曾经有一个团队在几天之内就对一份至少有七年、长达 450 行的构建脚本完成了迁移。如果你有一份庞大或者复杂的 Gradle 构建脚本，那么 Kotlin Script 值得一试，看看它是否会对你的团队产生帮助。
将产品管理思维应用于内部平台(Apr 2023, 采纳)
我们持续从那些 将产品管理思维应用于内部平台 的团队获得良好的反馈。 不过，要记住一个关键特征：这不只是关于团队结构或重命名已有的平台团队； 它还涉及到在团队中应用以产品为中心的工作实践。 具体来说，我们收到的反馈表明，除非团队具有以产品为中心的思维方式，否则他们在使用此技术时将面临挑战。 这可能意味着需要额外的角色，比如产品经理，以及对其他领域的改变，比如需求收集和对成功的衡量。 以这种方式工作意味着与内部消费者（开发团队）建立同理心并且在设计上与他们合作。 平台产品经理制定路线图并确保平台为业务带来价值和增强开发人员的体验。 我们会继续将这项技术视为构建内部平台的关键，以求快速而高效地推出新数字解决方案。
将产品管理思维应用于内部平台(May 2020, 采纳)
越来越多的公司正在构建内部平台，借此快速有效地推出新型数字化解决方案。成功实施这一战略的企业正 将产品管理思维应用于内部平台 。这意味着与内部消费者（开发团队）建立共情，并在设计上彼此协作。平台的产品经理要建立路线图，确保平台为业务交付价值，为开发者改善体验。不幸的是，我们也见到了一些不太成功的方式，团队在未经验证的假设、没有内部客户的情况下，打造出的平台犹如空中楼阁。这些平台尽管采用了激进的内部策略，但往往无法充分利用，还耗尽了组织的交付能力。和其他产品一样，好的产品管理就是为消费者创造喜爱的产品。
将产品管理思维应用于内部平台(May 2018, 试验)
We've seen a steep increase in interest in the topic of digital platforms over the past 12 months. Companies looking to roll out new digital solutions quickly and efficiently are building internal platforms, which offer teams self-service access to the business APIs, tools, knowledge and support necessary to build and operate their own solutions. We find that these platforms are most effective when they're given the same respect as an external product offering. Applying product management to internal platforms means establishing empathy with internal consumers (read: developers) and collaborating with them on the design. Platform product managers establish roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Some owners even create a brand identity for the internal platform and use that to market the benefits to their colleagues. Platform product managers look after the quality of the platform, gather usage metrics, and continuously improve it over time. Treating the platform as a product helps to create a thriving ecosystem and avoids the pitfall of building yet another stagnant, underutilized service-oriented architecture.
将产品管理思维应用于内部平台(Nov 2017, 试验)
We've seen a steep increase in interest in the topic of digital platforms over the past 12 months. Companies looking to roll out new digital solutions quickly and efficiently are building internal platforms, which offer teams self-service access to the business APIs, tools, knowledge and support necessary to build and operate their own solutions. We find that these platforms are most effective when they're given the same respect as an external product offering. Applying product management to internal platforms means establishing empathy with internal consumers (read: developers) and collaborating with them on the design. Platform product managers establish roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Some owners even create a brand identity for the internal platform and use that to market the benefits to their colleagues. Platform product managers look after the quality of the platform, gather usage metrics, and continuously improve it over time. Treating the platform as a product helps to create a thriving ecosystem and avoids the pitfall of building yet another stagnant, underutilized service-oriented architecture.
DuckDB(Apr 2023, 试验)
DuckDB 是一个用于数据科学与数据分析的嵌入式列式数据库。数据分析师通常会在本地将数据加载进诸如 pandas 或 data.table 这些工具中，从而可以在于服务器内扩展解决方案前就做到快速分析模式和形成假设。 然而，我们现在使用DuckDB来处理这些用例，因为它释放出了比内存分析更大的潜力。 DuckDB 支持庞大事务的 range joins，向量化执行和多版本并发控制 (MVCC) ，我们的团队对此表示非常满意。
DuckDB(Oct 2020, 评估)
DuckDB 是一个嵌入式列式数据库，可用于数据科学与数据分析。 在将数据转移到服务器之前，分析师花费大量时间在本地清洗数据和可视化数据。 尽管数据库已经存在了几十年，但大多数数据库都是为客户端-服务器用例设计的，因此不适合本地交互式查询。 为了解决这一问题，分析人员通常会使用内存数据处理工具，例如：Pandas 或 data.table。 尽管这些工具是有效的，但它们能分析的范围只限于内存恰好能容纳的数据量大小。 我们认为DuckDB 用嵌入式列式引擎巧妙地填补了工具方面的空白，该引擎针对本地、大于内存的数据集进行了优化。
TruffleHog(Apr 2023, 试验)
TruffleHog 是一款开源的静态应用程序安全测试工具（static application security testing，SAST），用于在各类源码中检测密钥信息。除了对 GitHub 和 GitLab 等最为常见的代码仓库进行扫描，TruffleHog 还能扫描 S3 和 GCS 等云存储桶、本地文件、本地目录以及 CircleCI 日志。开发人员可以将 TruffleHog 配置为 pre-commit hook 脚本，也可以直接使用它扫描一个 GitHub 组织的全部代码仓库历史记录。TruffleHog 支持自定义的正则语句模版，即使在当前的 alpha 阶段，该功能也十分易用。虽然 TruffleHog 有企业版本，但是我们发现开源版本的 TruffleHog 更易于配置和使用，并且覆盖了绝大多数的常见场景。TruffleHog 拥有一个非常活跃的社区，时不时就会有新的功能更新。
Autoware(Apr 2023, 评估)
Autoware 是一个基于 ROS (机器人操作系统)开发的，开源的自动驾驶软件栈。它可以用于为各种各样的车辆，如汽车和卡车等，开发和部署先进辅助驾驶系统(ADAS)。它不仅为自动驾驶的各个组成方面提供了一套开发工具与算法，譬如车身感知，驾驶决策和控制；而且它也内置有路线规划和控制的模块，可以基于周围环境和目的地的信息为车辆提供路线信息。它的出现促进了自动驾驶技术的开放式创新。我们在 Autoware 上构建自动驾驶原型去验证新产品构想，并发现它卓有成效。
Lambda 弹球(Apr 2023, 暂缓)
虽然无服务器架构对解决一些问题非常有用，但它们确实有一定的复杂性，尤其是当它们涉及到复杂执行和跨多个相互依赖的 Lambdas 的数据流时--这有时会导致所谓的 Lambda 弹球架构。我们团队发现维护和测试 Lambda 弹球架构可能非常有挑战：理解基础设施、部署、诊断和调试都会变得困难。在代码层面上，根本不可能将领域概念和所涉及的多个 Lambdas 之间做简单映射，这使得任何改变和添加都具有挑战。尽管我们相信无服务器是适合某些问题和领域的，但它并不是每个问题的 "万能解法"，这就是为什么你应该尽量避免陷入 Lambda 弹球。一种有助于解决这个问题的方法，就是区分公共接口（public interface）和已发布接口（published interface），并在它们之间应用带有已发布接口的领域边界。
Lambda 弹球(Nov 2019, 暂缓)
在项目中构建无服务器架构的这几年，我们注意到落入一个分布式单体应用的陷阱是一件很容易的事情。当请求在日益复杂的云服务中不断跳转时，深陷Lambda、存储桶与队列中的Lambda弹球架构明显无法看清重要的领域逻辑，通常只能对应用整体进行集成测试，而很难进行单元测试。为了避免陷入弹球架构，我们可以明确区分公共与发布的接口，沿用良好的领域边界，并在其间使用已发布的接口。
将 CI/CD 基础设施作为一种服务(Apr 2023, 采纳)
将 CI/CD 基础设施作为一种服务 已经是很多元化以及成熟的方案，以至于需要自己管理整个 CI 基础设施的情况变得非常少见。使用 GitHub Actions、Azure DevOps 或 Gitlab CI/CD 等管理服务，具有托管云服务的所有常见优势（和权衡）。您不需要花时间、精力和硬件成本来维护和运营这个通常很复杂的基础设施。对于自己托管 CI 设施的公司，虽然团队可以受益于弹性和自助服务，然而往往在配置更多合适的代理或获得新的插件或功能时遇到瓶颈。即使是需要在自己的硬件上运行构建和验证的用例，现在也大多可以用自我托管的运行器来满足需求（我们已经写过一些关于 GitHub Actions 的文章，actions-runner-controller 和 Philips 的自我托管 GitHub 运行器）。然而，请注意，使用托管服务并不意味着您可以轻易获得安全保障；虽然成熟的服务提供了所需要的所有安全功能，但仍然需要实施对 CI/CD 基础架构的零信任安全。
Quarto(Apr 2023, 试验)
Quarto 是一个开源的科技出版系统，它允许我们使用 markdown 方式编写文档来构建计算笔记本(notebooks)，在最终的文档中插入代码及其输出。它可用于创建可重复和可定制的数据分析报告，并轻松地以各种格式进行共享。我们的数据科学团队使用 Quarto 共享包含可视化(图表)和表格的数据分析报告。他们喜欢能使用 R 和 Python 来生成这些动态报告，然后导出为 HTML 与相关人员共享。如果你希望在组织内部或外部分享你的研究和分析，我们建议评估 Quarto。
dbt 单元测试(Apr 2023, 试验)
dbt 单元测试是一个 dbt 的软件包，它可以为编写数据处理模型和其逻辑的单元测试提供对依赖项的模拟。这为数据处理领域带来了更加准确的快速开发反馈。尽管它只能应用于简单的数据转换，我们的团队在 Snowflake 上依然使用该软件包实践了测试驱动开发 (TDD) 。虽然该软件包对失败测试的调试支持还有很大提升空间，但它依然能为编写数据转换器的单元测试提供一个优雅的开发体验。
K3s(Apr 2023, 采纳)
K3s 仍是我们在边缘计算和资源受限环境下的默认Kubernetes 发行版。它轻量，完全兼容 Kubernetes ， 且操作开销较少。它使用 sqlite3 作为默认存储引擎， 而不是 etcd。 由于它在一个进程中运行所有相关组件，因此具有减少内存占用的优点。我们已将 K3s 用于工控系统和 POS 机环境中，我们对自己的决定非常满意。K3s 的运行时 containerd 已经支持 wasm, 因此 K3s 可以直接运行和管理WebAssembly 负载，进一步减少了运行时开销。
K3s(Oct 2021, 试验)
K3s 是一个轻量级的用于物联网和边缘计算的 Kubernetes 发行版。它可以带来与 Kubernetes 相当的优势，同时又降低了运营的开销。它的增强部分包括轻量级的存储后端（ K3s 默认使用 sqlite3 作为存储后端，而非 etcd ）和一个单一且具有最少的操作系统依赖的二进制包，这些都使得 K3s 适用于资源受限的环境。我们已经在POS机中应用了 K3s 并对它十分满意。
K3s(Oct 2020, 评估)
K3s 是一个轻量级的用于物联网和边缘计算的 Kubernetes 发行版。K3s 被打包成一个单独的二进制文件，对于操作系统的依赖性微乎其微，这使得它非常易于运维和使用。K3s 使用 sqlite3 而非 etcd 作为默认的存储后端。由于所有相关的组件都运行在同一个进程里，这使得 K3s 的内存占用非常低。通过剥离不相关的第三方存储驱动和云提供商，K3s 的二进制文件得以控制得非常小。在资源受限的环境中，K3s 是一个值得考虑的非常不错的选择。
axe Linter(Apr 2023, 评估)
对于开发者来说，在开发过程的早期发现无障碍问题变得越来越容易。像 axe-core 这样的工具可以在流水线中扫描代码来寻找无障碍问题，而VSCode 扩展工具 axe Linter 甚至可以在这之前，例如在编写代码时就能发现它们。绝大部分无障碍问题都属于可以通过自动化测试和使用上述提到的实时反馈的提示工具(linter)来预防的类别。
Vitest(Apr 2023, 试验)
Vitest 是一款 JavaScript 的单元测试框架。迄今为止，许多团队一直依赖 Jest，但 Jest 与现代前端构建工具 Vite 不兼容。同时使用 Jest 和 Vite 强制团队创建两个流程管道，一个用于构建和开发，另一个用于单元测试，这需要繁琐的管道配置和重复的设置。这些问题都可以通过 Vitest 解决。它专门为 Vite 设计，并使用 Vite 作为打包工具。此外，Vitest 还具有 Jest 兼容的 API，这使得在各种构建设置中可以使用 Vitest 作为 Jest 的替代品。 Vite 和 Vitest 结合使用提供了更好的开发者体验，Vitest 也很快，但以我们的实际经验来看，它未必比使用 Jest 更快。
Ax(Apr 2023, 试验)
在面对探索大型配置空间的挑战时，可能需要大量的时间来评估给定配置，团队可以转向自适应实验，这是一种机器引导的迭代过程，以资源高效的方式找到最佳解决方案。Ax 是一个用来管理和自动化自适应实验的平台，它包括机器学习实验，A/B 测试和模拟。目前，它支持两种优化策略，一种是使用 BoTorch 的贝叶斯优化，它是建立在 PyTorch 基础上的，以及 contextual bandits。 Facebook 在 发布 Ax 和 BoTorch 时描述了例如提高后端基础设施的效率，调整排名模型和优化机器学习平台的超参数搜索的用例。我们已经在多种用例中有了丰富的 Ax 应用经验，虽然超参数调整工具是存在的，我们尚未发现有能提供与 Ax 在一定范围上具有相似功能的平台。
Jetpack CameraViewfinder(Apr 2023, 试验)
在为 Android 应用程序添加相机功能时，开发人员必须注意潜在的风险。最近推出的 Jetpack CameraViewfinder API 在显著改善了开发人员在这方面的体验。它内部使用了 TextureView 或 SurfaceView 来显示相机的视频流，并对其进行必要的转换以正确显示取景器，比如修正宽高比、缩放和旋转方向。此外，还提供了针对可折叠设备优化的布局。虽然不是一个主要的功能，但我们在这里强调它的存在，以确保团队意识到有这个选项。
对 Webhooks 的管理不够严谨(Apr 2023, 暂缓)
随着远程工作的增加，聊天协作平台和 ChatOps 的采用也在增加。这些平台通常提供Webhook(网络挂钩)作为自动发送消息和通知的简单方式，但我们关注到一个令人担忧的趋势： 对Webhooks的管理不够严谨 —将它们视为配置而不是秘密或凭据。这可能会导致钓鱼攻击和内部信息泄露。\nWebhook 是提供对内部空间的特权访问的凭据，可能包含可以轻松提取和直接使用的 API 密钥。不将它们视为密钥会导致钓鱼攻击的发生。在 Git 仓库中的Webhook可以轻松提取并用于发送有效的欺诈信息，用户可能没有任何身份验证的方式。为了缓解这种威胁，处理Webhook的团队需要改变他们的习惯，并将Webhook视为敏感凭据。软件开发人员与 ChatOps 平台构建集成必须注意到这种风险，确保这些Webhook具备适当的安全措施。
Modal(Apr 2023, 评估)
Modal 是一种平台即服务（PaaS），您无需自己的基础设施即可按需计算。Modal 让您可以部署机器学习模型、大规模并行计算作业、任务队列和 Web 应用程序。它提供了容器抽象，使得从本地部署到云端部署无缝切换，在本地和云端都可以热重载。它甚至可以自动删除部署，避免了手动清理的需要，但也可以使其持久化。\nModal 由为 Spotify 开发第一个推荐引擎的同一个团队编写。它负责端到端的 人工智能（AI）/ML 栈，并能提供按需的GPU资源，如果您有特别密集的计算需求，这将非常有用。无论您是在笔记本电脑上还是在云端工作，Modal 都能发挥作用，为运行和部署您的项目提供了一种简单高效的方式。
使用 Logseq 构建团队知识库(Apr 2023, 评估)
团队知识管理是一个熟悉的概念，团队使用诸如维基（wikis）等工具来存储信息和培训新团队成员。我们的一些团队现在更倾向于将 Logseq 作为团队知识库。Logseq 是一种开源的知识管理系统，由图形数据库驱动，帮助用户组织想法、笔记和创意，并可以通过基于 Git 的存储方式适应团队使用。Logseq 允许团队构建一个公开透明的知识库，为每个成员提供个性化的学习路径，促进高效的启动培训。然而，与任何知识管理工具一样，团队需要对他们的知识库进行良好的归纳整理，以避免信息过载或组织混乱。\n虽然类似的功能也可以在像 Obsidian 这样的工具中找到，但 Logseq 的关键区别在于其注重于知识的使用，基于段落的链接使团队成员能够快速找到相关的上下文，而无需阅读整篇文章。
Ferrocene(Apr 2023, 评估)
近年来 Rust 语言因其安全性、性能和并发特性而越来越受欢迎，然而，在汽车等安全攸关市场仍缺少经过认证的 Rust 工具链。目前这个缺口正在由 Ferrocene 这一 Rust 编译器工具链所填补。 Ferrocene 承诺符合道路车辆电子系统的 ISO26262 功能安全标准，同时它也正在努力使该领域中使用的语言和工具链也符合条件。这部分工作也在加速推进中，我们对此感到兴奋，可以使用此类符合安全标准的工具肯定会加速 Rust 在汽车行业的应用。
Denodo 作为主要的数据转换工具(Apr 2023, 暂缓)
Denodo 是一款数据虚拟化工具，可以从单个平台将来自多个底层数据源和各种接口、经过转换后对使用者友好的数据方便地进行展示和保护。在 Denodo 中，可以使用类似于 SQL 的语言 VQL 创建虚拟数据库和视图，来实现数据转换。这些视图和虚拟数据库会在用户查询虚拟数据库时执行。在底层，Denodo 可以将虚拟数据库的查询委托给一个或多个底层数据库。\n尽管 Denodo 可以简化展示消费者友好的数据的工作，但随着视图和虚拟数据库层的叠加，特别当查询需要连接多个底层数据库时，性能会受到影响。只有对产品行为和性能调优方案有相当深入的了解，才能解决这些问题。由于这些缺点，以及对单元测试支持有限，我们不建议使用 Denodo 作为主要数据转换工具 ，而应使用 Spark 或 SQL(通过dbt) 等工具做数据转换。
Obsidian(Apr 2023, 评估)
知识管理对于技术工作者来说是至关重要的，因为我们需要不断地学习，并与最新的技术发展保持同步。最近，涌现出了一些笔记工具，如 Obsidian 和 Logseq，它们支持将笔记连接起来形成知识图谱，同时将文件以 markdown 格式存储在本地目录中，从而让用户拥有完全的所有权。这些工具帮助用户以一种灵活、非线性的方式组织和连接他们的笔记。\nObsidian 有一个丰富的社区插件库。其中特别引起我们注意的是 Canvas （类似于本地版的 Miro 或 Mural），以及 Dataview，它可以有效地将你的笔记作为数据库处理，并提供了一种查询语言来过滤、分类和提取 markdown 笔记中的数据。
Ktlint(Apr 2023, 试验)
随着 Kotlin 生态系统的持续发展，我们的团队报告了使用 Ktlint 的良好体验：这是一个用于 Kotlin 代码，简单且易于配置的 linter 和 formatter。我们喜欢有态度的代码格式化工具(Opinionated and automated code formatting)，因为这能让开发者更关注代码的行为，而不是它的外观；这个工具使开发团队能够高效的维护代码库的一致性和可读性，减少因格式问题而导致的混乱合并的可能性。Ktlint 可以很容易地配置在 pre-commit hook 中，它只针对有变化的文件，从而使集成过程更快。
TypeDB(Apr 2023, 试验)
TypeDB是一个知识图谱数据库，设计用于处理复杂的数据关系，从而简化查询和分析大型数据集。TypeDB的TypeQL查询语言类似于SQL语法，它可以简化模式定义、查询和探索的学习曲线。TypeDB带有各种工具，包括一个命令行界面和一个图形用户界面，这使其更容易与数据库集成，TypeDB Studio提供了一些集成TypeDB的功能，如管理模式，查询数据，可视化关系，甚至与他人合作。它有大量的文档，并且有一个活跃的支持社区。我们的团队用它来建立跨不同数据库的分类学概念知识图谱，并通过增加新的推理规则来利用其强大的推理能力来提高效率、减少工作量。凭借其友好的开发者体验和有帮助的社区，TypeDB是一个很好的候选者，任何团队，如果在实施依赖复杂数据关系的解决方案，都可以考虑这个工具，包括自然语言数据、推荐引擎和知识图谱。
Deepchecks(Apr 2023, 评估)
随着机器学习成为主流，模型测试、训练数据验证和生产模型性能监测这些实践的自动化也日渐成熟。这些自动检查越来越多地被集成进持续交付流水线或针对生产模型运行，以检测模型漂移和模型性能。已经出现了一些具有相同或类似功能的工具，以处理这个过程中的各个步骤（比如同样出现在本期技术雷达中的Giskard 和 Evidently ）。Deepchecks 是另一个此类工具，它是一个开源的 Python 库，提供了一组丰富的 API 以供流水线使用。它的一个独特的功能是，能够通过语言数据模块来处理表格或图像数据，该模块目前还在 alpha 版本。目前，没有一个单独的工具可以处理整个机器学习流水线中的各种测试和防护措施。我们建议在特定应用范围内评估 Deepchecks。
Steampipe(Apr 2023, 试验)
Steampipe 是一个可以让你使用 SQL 实时查询AWS，Azure，以及 GCP 等云服务的开源工具。Steampipe 拥有100多个插件以及内置的创建仪表板功能，使连接实时云配置数据和内外部数据集以及创建安全合规的仪表板变得非常简单。我们非常喜欢Steampipe，并已经使用AWS云配置创建了几个此类仪表板。
Apicurio Registry(Apr 2023, 试验)
在任何组织中，API 的生产者和使用者都需要就他们之间通信所使用的模式保持同步。特别是随着 API 数量以及相关生产者和使用者人数在组织中的增长，最初在团队间传递模式的简单做法将面临挑战。面对这个问题，我们的一些团队使用了 Apicurio Registry，这是一个开源的、集中式的注册表，可以存储各种类型的模式和 API 文档，包括 OpenAPI 规范，Protobuf 和 Avro 模式。Apicurio Registry 允许用户通过 UI，REST API 和 Maven 插件等方式进行交互。它还有规定模式演进限制的选项，比如说向后兼容性。此外，当使用 Kafka 客户端时，Apicurio Registry 能与 Confluent Schema Registry 兼容。虽然我们的团队发现 Confluent Schema Registry 的文档更有帮助，但 Apicurio Registry 满足了对各种模式的真实来源的需求。
精简软件依赖项(Apr 2023, 采纳)
初始工具包和模板被广泛用于软件项目以加快初始设置，但它们可能会为项目引入许多不必要的依赖项。实践 依赖裁剪 很重要——定期仔细检查这些依赖并剔除未使用的依赖，这有助于减少构建和部署时间，并且可以通过移除潜在漏洞来降低项目受攻击的风险。尽管这不是一项新技术，但鉴于对软件上下游的攻击频率越来越高，我们提倡重新关注它。
mljar-supervised(Apr 2023, 评估)
mljar-supervised 是一个 AutoML Python 包，协助理解和解释表格式数据。我们的数据科学团队很喜欢它，并已开始使用它进行自动探索性数据分析。为了找到最佳模型它抽象了如下常用方法：预处理数据、构建机器学习（ML）模型和执行超参数调整。可解释性和透明度是重要的原则，而这正是 mljar-supervised 的亮点。它会为每个 ML 模型都生成一个详细的 Markdown 报告，让你清晰地看到 ML 管道是如何构建的。这绝对是一个有趣的 AutoML 包，值得你在 ML 需求中尝试。
Strapi(Apr 2023, 试验)
Strapi 是一个基于Node.js的开源无头内容管理系统(CMS)，它类似于Contentful。它已经出现了一段时间，我们也成功将其用于部分项目。Strapi 提供了 REST 和 GraphQL 两种类型的 API，具有丰富的文档，易用的数据模型 API，并且支持界面和逻辑的定制化。
iamlive(Apr 2023, 评估)
按照最小权限原则来创建我们想要的最小可行 AWS IAM 策略（Policy）可能需要经历一段很长的试错过程。而 iamlive 可以在很大程度上缩短这一过程，它监控机器上执行过的 AWS CLI 调用，并确定执行这些调用所需的策略。该工具会生成一个包含了语句（Statement），动作（Actions），主体（Principals）以及资源（Resources）的策略文档，这可以为我们提供一个很好的开始。我们发现，iamlive对创建用于提供基础架构的 CI/CD 流水线所需的策略特别有用，也减少了 IAM 角色策略不足导致 Terraform 运行失败后的反复尝试。
Spin(Apr 2023, 评估)
Spin 是一个开源平台, 用于在 WebAssembly(/cn/radar/languages-and-frameworks/webassembly) (WASM) 中构建和运行微服务。在技术雷达以前的版本中，我们曾谈论过在浏览器中使用 WebAssembly，但现在由于它在细粒度的沙盒功能、跨语言互操作性和热重载的能力，我们正在目睹其在服务器端的渗透。通过使用 Spin CLI，您可以创建和分发基于 Rust(/cn/radar/languages-and-frameworks/rust)、TypeScript(/cn/radar/languages-and-frameworks/typescript)、Python 和 TinyGo 的WebAssembly 微服务。我们对 Spin 充满期待，并建议您仔细评估它，因为它正在退出早期预览阶段。
Helmfile(Apr 2023, 试验)
Helmfile 是一款开源命令行工具和声明式的标准，用于安装和管理多个 Helm chart，帮助您进行 Helm 配置文件、使用的 chart 等变更的版本管理。它使 Helm chart 能用于 CI/CD 工作流，有助于创建可重现环境。我们已经在使用 Helmfile 来管理那些包含大量 Helm chart 的复杂部署，并且发现它简化了我们的部署工作流。
测试基础设施时的可达性分析(Apr 2023, 评估)
在部署基础设施代码时，我们发现很多时间会花费在诊断和修复因系统之间无法相互通信导致的生产问题上。由于它们之间的网络拓扑结构可能非常复杂，即使已经正确配置了单个端口和端点，整个路由也可能无法完全遍历。基础设施测试实践通常包括验证正确的端口是开放还是关闭，或者某个端点是否可以被访问，但我们最近才开始在 测试基础设施时进行可达性分析 。该分析通常涉及比简单的是/否判断更多的内容。例如，工具可能会遍历并报告通过中转网关的多个路由。此技术得到了所有主要云供应商工具的支持。Azure 有一个名为网络观察程序的服务，可以在自动化测试中进行脚本编写，而 GCP 则支持连通性测试。而现在，在 AWS 中，您可以测试同一组织内跨账户的可达性。
将运行成本作为架构健康度的考量(Apr 2023, 采纳)
自动估算、跟踪和预测云基础设施运行成本对于今天的组织至关重要。云服务商精心设计的定价模型，加上价格参数的不断增多以及持续变化的架构，可能会导致运行成本超出预算。尽管这种技术已经在2019年后被采用，我们仍然想强调考虑 将运行成本作为架构健康度的考量 的重要性，特别是在云服务被广泛采用和 FinOps 实践越来越受到关注的今天。许多商业平台提供了工具来协助企业的负责人人整合并说明云服务的成本。其中一些旨在向财务机构或原始业务单位显示云服务运行成本。 然而，云服务消费决策通常是在系统设计时做出。因此在做出设计决策时使用一些方法来预测其架构决策对成本产生的影响就显得很重要。一些团队会在开发进程的初期通过自动化方式预算成本。像 Infracost 这样的工具可以帮助团队在考虑更改“基础设施即代码”时预测成本影响，这种计算可以自动化执行，并纳入持续集成（CD）流程中。请注意，成本将受架构决策和实际使用水平的影响；要做到这一点，您需要对期望使用水平进行审慎地预测。及早和频繁地反馈运行成本可以防止其失控。当预测成本偏离了预期或可接受的范围时，团队可以讨论是否是时候进一步调整架构了。
将运行成本作为架构健康度的考量(Oct 2020, 采纳)
对于今天的组织来说，自动化评估、跟踪和预测云基础设施的运行成本是必要的。云供应商精明的定价模型，以及基于定价参数的费用激增，再加上现代架构的动态本质，常常导致让人吃惊的运行成本。例如，无服务架构 基于API访问量的费用，事件流方案中基于流量的费用，以及数据处理集群中基于运行任务数量的费用，它们都具有动态的本质，会随着架构演进而产生改变。当我们的团队在云平台上管理基础设施时， 将运行成本实现为架构适应度函数 是他们的早期活动之一。这意味着我们的团队可以观察运行服务的费用，并同交付的价值进行对比；当看到与期望或可接受的结果之间存在偏差时，他们就会探讨架构是否应该继续演进了。对运行成本的观察和计算需要被实现为自动化的函数。
将运行成本作为架构健康度的考量(Nov 2019, 采纳)
对于今天的组织来说，自动化评估、跟踪和预测云基础设施的运行成本是必要的。云供应商精明的定价模型，以及基于定价参数的费用激增，再加上现代架构的动态本质，常常导致让人吃惊的运行成本。例如，无服务架构基于API访问量的费用，事件流方案中基于流量的费用，以及数据处理集群中基于运行任务数量的费用，它们都具有动态的本质，会随着架构演进而产生改变。当我们的团队在云平台上管理基础设施时，将运行成本实现为架构适应度函数是他们的早期活动之一。这意味着我们的团队可以观察运行服务的费用，并同交付的价值进行对比；当看到与期望或可接受的结果之间存在偏差时，他们就会探讨架构是否应该继续演进了。对运行成本的观察和计算需要被实现为自动化的函数。
将运行成本作为架构健康度的考量(Nov 2018, 试验)
We still see teams who aren't tracking the cost of running their applications as closely as they should as their software architecture or usage evolves. This is particularly true when they're using serverless, which developers assume will provide lower costs since you're not paying for unused server cycles. However, the major cloud providers are pretty savvy at setting their pricing models, and heavily used serverless functions, although very useful for rapid iteration, can get expensive quickly when compared with dedicated cloud (or on-premise) servers. We advise teams to frame a system's run cost as architecture fitness function , which means: track the cost of running your services against the value delivered; when you see deviations from what was expected or acceptable, have a discussion about whether it's time to evolve your architecture.
智能引导无障碍测试(Apr 2023, 评估)
对于从未使用过辅助技术，并且觉得对像 Web内容无障碍指南 (WCAG) 这样的标准仍然一无所知的人来说，使网页应用程序兼容辅助技术可能会有些困难。 智能辅助无障碍测试 是这样一类可以帮助测试已正确实现无障碍设计的工具，而无需成为无障碍技术专家。这些工具是浏览器扩展，它们会扫描网站，总结辅助技术会如何解释网页，然后通过一组问题以确认您创建的结构和元素是否符合预期。我们已经在一些项目中使用过 axe DevTools、Accessibility Insights for Web 或 ARC Toolkit 等工具。
Lakehouse架构(Apr 2023, 试验)
Lakehouse（数据湖仓一体）架构 是一种数据湖的可扩展性与数据仓库可靠性和性能相结合的架构风格，它使得组织能在一个平台上使用类似于 SQL 的工具和技术，储存分析大量不同的数据，而不是将他们放在单独的在数据湖和数据仓库层中。尽管这个术语(LakeHouse)经常与作为供应商的 Databricks 之类的厂商有关，像 Delta Lake， Apache Iceberg 和 Apache Hudi 之类的开源方案也值得考虑。Lakehouse 架构可以补充 数据网格 的实现。自治的数据产品团队可以在他们的数据产品选择使用 Lakehouse。
DVC(Apr 2023, 采纳)
DVC 一直是我们在数据科学项目中管理实验的首选工具。由于 DVC 是基于 Git 的，因此对于软件开发人员来说，DVC 无疑是一个备感熟悉的环境，他们可以很容易地将以往的工程实践应用于数据科学生态中。DVC 使用其特有的模型检查点视图对训练数据集、测试数据集、模型的超参数和代码进行了精心的封装。通过把可再现性作为首要关注点，它允许团队在不同版本的模型之间进行“时间旅行”。我们的团队已经成功地将 DVC 用于生产环境，实现了机器学习的持续交付(CD4ML)。DVC 可以与任何类型的存储进行集成（包含但不限于 AWS S3、Google Cloud Storage、MinIO 和 Google Drive）。然而，随着数据集变得越来越大，基于文件系统的快照可能会变得特别昂贵。当底层数据发生快速变化时，DVC 借由其良好的版本化存储特性可以追踪一段时间内的模型漂移。我们的团队已经成功地将 DVC 应用于像 Delta Lake 这样的数据存储格式，利用它优化了写入时复制（COW）的版本控制。我们大多数的数据科学团队会把 DVC 加入到项目的“Day 0”任务列表中。因此，我们很高兴将 DVC 移至采纳。
DVC(May 2020, 试验)
在2018年，我们在可重复分析的版本化数据中提到了 DVC。时至今日，它已成为机器学习（ML）项目中管理实验的热门工具。由于 DVC 是基于 Git 的，因此对于软件开发人员来说，DVC 无疑是一个备感熟悉的环境，他们可以很容易地将以往的工程实践应用于 ML 实践中。由于 DVC 实现了对处理数据的代码以及数据本身的版本管理，而且还实现了对流水线的各个阶段的追踪，因此能在建立建模活动秩序的同时可以不扰乱分析师的工作流程。
Soda Core(Apr 2023, 试验)
Soda Core 是一个开源数据质量与可观测性工具。我们的团队已经使用它来验证数据在到达系统之前和之后的转换，并设置自动化监测检查以检测异常情况。我们对 Soda Core 中用于编写数据检查的 DSL —— SodaCL 非常满意. SodaCL 能帮助除了数据工程师以外的其他团队成员来编写质量检查。总的来说，我们在解决大规模数据问题时使用 Soda Core 的体验非常好。
Soda Core(Oct 2022, 评估)
Soda Core 是一个开源数据质量与可观测性工具。我们在之前的技术雷达上讨论过 Great Expectations，而 Soda Core 作为另一种解决方案，其关键区别在于数据校验可以通过一种称为 SodaCL （之前称为 Soda SQL）的 DSL 来表示，而非 Python 函数。数据校验一旦被写好就可以作为数据流水线 的一部分被执行，也可以通过编程方式调度运行。随着我们越来越多地受数据驱动，数据质量的维护变得至关重要，因此我们建议你评估 Soda Core。
EventCatalog(Apr 2023, 试验)
现在企业通常使用事件流作为真实数据的来源，并在微服务架构中作为信息共享机制。这就需要标准化事件类型并在企业范围内共享这些标准。通常企业会部署事件模式注册表，但现有的解决方案往往只适用于单个代理，比如 Apache Kafka 或 Azure Event Hub。此外，这些现有解决方案并不能提供超出简单模式定义的关于事件类型的详细文档。EventCatalog 是一个开源项目，为企业提供了一种广泛可访问的文档库，用于描述事件在业务种扮演的角色，它们在业务领域模型中的位置，以及哪些服务订阅和发布这些事件。如果您正在寻找一种向组织发布事件文档的方式，那么使用 EventCatalog 工具可能会避免您自己构建文档库的麻烦。
Fugue(Apr 2023, 评估)
在数据工程领域，可选用工具和技术数量之多，让人眼花缭乱。 对于经验较少的工程师，借助一个抽象层来接触这些工具未尝不是一种合理的对策。这让他们能够专注于手头的任务，而不必分心去学习各个技术专用的 API，并且可以不费力地配置不同的底层实现技术。 Fugue 就是这样一个抽象层。 它为分布式计算提供统一的接口，使得在 Spark、Dask、Ray 和 DuckDB 经过较少的修改就能运行Python、pandas 和 SQL 代码。 不过，如果团队已经决定采用某一组确定的技术，并且熟悉这些技术的 API，能够对工具的系统底层做深入的调整和设置，那么这样的抽象层提供的价值就会降低。
.NET 7 Native AOT(Apr 2023, 评估)
.NET 7 Native AOT 在一众原生部署 .NET 应用程序的方法中迈出了一大步。它完全摒弃了运行时的中间语言（IL）和实时编译（JIT）。这项在 .NET 7 中引入的改进，对于在无服务器函数（Serverless Functions）中运行 .NET 应用程序意义重大。这种新的部署方式解决了一直以来在 AWS Lambda 或 Azure Functions 等无服务器平台上运行 .Net 程序的冷启动问题。相比其它部署方法，使用 Native AOT，可以生成更小的可部署二进制文件，从而缩短冷启动所需的时间。AWS 已通过 Amazon Lambda Tools 正式支持 Native AOT 。这种新的部署方式令 .NET 7 的冷启动时间降低到与 TypeScript/JavaScript 一致的水平，使它成为大规模采用 .NET 基础架构的组织的可用部署方式。
Contentful(Apr 2023, 采纳)
无头内容管理系统已经成为数字平台的常见组成部分， Contentful 仍然是我们在这个领域的首选，但像 Strapi 这样的新进入者也给我们留下了深刻的印象。 我们尤为喜欢 Contentful 的 API 优先的工作方式以及实现了 CMS as code 。它支持强大的代码化内容模型原语和内容模型演化脚本，这使得它可以像其他数据存储模式一样被处理，并演进式数据库设计实践可以应用于 CMS 开发。最近，Contentful 发布了 应用程序框架 来编写应用，以便更容易地将 Contentful 适应个人业务流程并与其他服务集成。这些应用程序可以由特定组织建立，也可以为特定组织构建，与此同时市场上的应用也在快速增多。
Contentful(Apr 2019, 采纳)
Headless content management systems (CMSes) are becoming a common component of digital platforms. Contentful is a modern headless CMS that our teams have successfully integrated into their development workflows. We particularly like its API-first approach and implementation of CMS as code. It supports powerful content modeling primitives as code and content model evolution scripts, which allow it to be treated like other data store schemas and enable evolutionary database design practices to be applied to CMS development. Its robustness and a stream of new features, including a sandbox environment, have impressed our teams further and made Contentful our default choice in this space.
Contentful(Nov 2018, 试验)
Headless content management systems (CMSes) are becoming a common component of digital platforms. Contentful is a modern headless CMS that our teams have successfully integrated into their development workflows. We particularly like its API-first approach and implementing CMS as code. It supports powerful content modeling primitives as code and content model evolution scripts, which allow treating it as other data store schemas and applying evolutionary database design practices to CMS development. Other notable features that we've liked include inclusion of two CDNs to deliver media assets and JSON documents, good support for localization and the ability—albeit with some effort—to integrate with Auth0.
Contentful(May 2018, 试验)
Headless Content Management Systems (CMSes) are becoming a common component of digital platforms. Contentful is a modern headless CMS that our teams have successfully integrated into their development workflows. We particularly like its API-first approach and implementing CMS as Code. It supports powerful content modelling primitives as code and content model evolution scripts, which allow treating it as other data store schemas and applying evolutionary database design practices to CMS development. Other notable features that we’ve liked include inclusion of two CDNs by default to deliver media assets and JSON documents, good support for localization, and the ability — albeit with some effort — to integrate with Auth0.
IBM Equal Access Accessibility Checker(Apr 2023, 试验)
缺陷发现得越早，修复成本更小。这就是为什么我们总是试图以静态分析、单元测试或在本地环境中运行的端到端测试等方式，尽可能快地向开发者提供反馈。无障碍设计也不例外，这就是我们过去介绍 Lighthouse、axe-core 和 axe Linter 等工具的原因。当涉及到已经部署在生产环境中的网页时，我们的一个团队选择了 IBM Equal Access Accessibility Checker 来进行直接的比较。虽然我们还在评估结果，但我们可以说，它提供了一种有效的方法来测试已经发布了的网页。我们想要强调的是，这个工具应该用来增强而不是取代开发者的早期自动测试。该工具是在创作共用许可证（Creative Commons license）下发布的，在符合协议规定时可以免费使用。
RudderStack(Apr 2023, 试验)
RudderStack 是一个可以轻松存储数据至数据仓库或数据湖的客户数据平台（CDP）。 这种方法越来越多地被称为无头 CDP（Headless CDP），它将CDP的功能和用户界面分离，强调可通过API灵活配置，同时强调数据仓库/数据湖为主要存储方式。正如人们对此类产品所期望的那样，RudderStack既拥有丰富的类库支持与第三方服务集成（可同时作为源和接收器），也能够接受自定义事件。RudderStack 既有商业产品，也有部分功能受限的自托管 OSS 版本。
WebXR 设备 API(Apr 2023, 评估)
在使用具有实验性的 WebVR API 时，明显可以发现将 VR 和 AR 合并到一个 API 中更加合理。为此，诞生了一个新的规范：WebXR，以避免大幅改变原有的 WebVR API。WebXR 的核心是 WebXR 设备 API，它为在网页浏览器中编写 VR 和 AR 应用提供了关键的能力。这个 API 用途广泛，但在写下该评论时，它还未被所有的浏览器完全支持 。我们的团队在一些场景中使用了 WebXR，并在其中发现了 Immersive Web Working Group 所描述的好处 。对于原型，我们特别喜欢的是用户可以立即在网页浏览器中进行体验。开发团队不需要到应用商店完成上架流程，用户也可以无需安装应用就可以尝试体验。考虑到 API 的现状以及它在某些浏览器中还是一个需要手动打开的隐藏功能的实际情况，我们还没有发现它在概念验证和原型之外的用途。
Giskard(Apr 2023, 评估)
Giskard 是一个开源工具，旨在通过聚焦于可解释性和公平性来保证质量，帮助组织构建更加强大、更符合道德的 AI 模型。它促进技术和非技术利益相关者之间的合作，使他们可以共同评估模型，并建立基于避免偏见和其他必要质量指标的验收标准。Giskard 确保模型结果更好地与业务目标保持一致，并帮助解决生产部署前的质量问题。
Aleph.js(Oct 2022, 评估)
目前并不缺少通过 JavaScript/TypeScript 去创建网络应用的架构。我们在技术雷达中已经介绍了很多种，但真正让 Aleph.js 从中脱颖而出的是它最初就是建立在 Deno 上的。考虑到 Deno 是由 Node 原本的开发者所创建的新的服务器端运行时，这意味着 Aleph.js 处在一个更先进的平台上，能够解决 Node 相关的很多缺陷和问题。虽然 Aleph.js 很新，至截稿时仍然在准备1.0版本的发布，但它已经能够为我们提供稳定的开发体验，包括组件的热插拔等。鉴于 Deno 早已完成 1.0 的发布，对于那些能够承担风险的项目来说，Aleph.js 无疑是一个现代化的选择。
Kusto 查询语言(Oct 2022, 试验)
当数据相关工作变得越来越常见，我们不断见到尝试对SQL语言进行改进的工具；Kusto 查询语言 (KQL)是其中的一种。KQL是由Azure创建的语言，它给关系型查询语言带来了模块、封装、组合、复用、扩展、和动态化的能力。我们的团队格外喜欢它的交互性：你可以将一个查询语句导入渲染操作符并立刻看到生成的图表。你也可以组合这些图表到仪表盘上，同时从分钟级的运行日志上获得洞见。尽管KQL目前只能在Azure Data Explorer中使用，我们预计对SQL进行改进以实现更好的数据操作性的步伐不会停止。
git-together(Oct 2022, 评估)
我们对于 git-together 的出现感到十分激动，因为我们一直在消除由结对编程带来的不便。git-together 使用 Rust 编写，简化了结对编程时代码提交的属性配置。通过将 git-together 设置为 git 的别名，git-together 允许您在 git config 中添加扩展配置以捕获提交者的信息，并以每个提交者的首字母为别名。更改结对对象或者切换到单人编程或暴徒式编程（Mob Programming）时，需要您运行 git with命令，并以 pair 对象名称的首字母收尾（例如：git with bb cc），这将便于您此后恢复到常规的 git 工作流。每次提交时，git-together 都会在 git 存储的结对对象信息中轮换作者身份，并且它会自动将任何其他作者添加到提交消息的底部。相关的配置可以和代码仓库一起 check in，从而使 git-together 可以在克隆代码仓库后自动生效。
指标库(Oct 2022, 评估)
指标库，有时也被称作无头商业智能(BI)，是一种将指标的定义与其在报表和可视化中的使用相解耦的中间层。在传统意义上讲，指标定义在商业智能(BI)工具的上下文中。但是这样的做法会导致重复与不一致，因为不同的项目组可能将指标用于不同的上下文中。通过指标库解耦指标的定义，便可以清晰且一致地在多个报表、可视化甚至嵌入式分析中复用指标。这并不是一项新技术；例如，Airbnb 在几年前就引入了 Minerva 。不过，随着越来越多的工具开箱即用地支持指标库，指标库在数据和分析生态的影响力越来越大。
io-ts(Oct 2022, 采纳)
我们使用 TypeScript 开发的团队发现 io-ts 非常有价值，特别是在与最终导致创建具有特定类型的对象的 API 交互时。在使用 TypeScript 时，将数据输入到类型系统的范围内（比如来自上述 API）可能会导致运行时错误，而这些错误可能很难发现和调试。io-ts 通过提供编码和解码函数，在编译时类型检查和运行时消耗外部数据之间架起桥梁。鉴于我们团队的经验和其方法的优雅性，我们认为 io-ts 值得采纳。
io-ts(Apr 2021, 试验)
一直以来我们都很享受使用TypeScript的体验，喜欢它的强类型带来的安全性。然而，当获取的数据（如调用后端服务返回的数据）与TypeScript类型定义不一致时，却可能会导致运行时错误。一个叫做 io-ts 的库可以帮我们解决这个问题。它通过提供编码和解码的功能，帮我们弥补了外部数据在编译期类型检查和运行时数据消费之间的鸿沟。它也可以用作自定义类型保护。随着在工作中获得越来越多使用 io-ts 的经验，我们对它最初的好印象得到验证，并且现在仍然喜欢这种优雅的方式。
io-ts(Oct 2020, 评估)
我们在使用 TypeScript 时，很喜欢强类型带来的安全性。但是，将数据带入类型系统（比如调用后端服务读取数据）时，可能会引发运行时错误。io-ts 可以解决这个问题。io-ts 的编码和解码函数，将编译时类型检查与运行时消费外部数据结合在一起。同时，io-ts 也可以用作自定义的类型守卫。我们认为这是一个绝妙的解决方案。
Cypress组件测试(Oct 2022, 评估)
Cypress组件测试 提供了一个组件测试工作台，以快速构建和测试 UI 组件。你可以用编写端到端（E2E）UI 测试的相同 API 来编写组件视觉回归测试。尽管仍处于测试阶段，但组件测试将成为 Cypress 第十版中最重要的功能。
OpenMetadata(Oct 2022, 评估)
毫无疑问，数据的可发现性已变成各个公司重要的关注点，因为它使得不同人群之间的数据共享和使用变成可能，在之前的版本中技术雷达已经包括了 DataHub，Collibra 等平台，但是我们仍在评估这个领域的其他选项，并且最近我们对 OpenMetadata 产生了兴趣。OpenMetadata 是一个致力于使用开放标准进行元数据管理的平台。我们的团队喜欢这个开源平台，因为它简单的架构、聚焦于自动化的部署、和在数据可发现性的重点关注能提升开发体验。
模型测试的合成数据(Oct 2022, 评估)
在我们本期技术雷达的讨论中，出现了几个用于生成合成数据的工具和应用。我们发现，随着工具的成熟， 模型测试的合成数据 成了一项强大而且有广泛应用的技巧。在验证机器学习模型判别能力的过程里，合成数据虽然尚不能取代真实数据，但也有相当广泛的使用场景。例如，合成数据可以用于预防小概率事件下模型彻底失效，或者在不暴露个人隐私信息的前提下对数据流水线进行测试。在探索缺乏真实数据的边缘场景以及确认模型偏差时，合成数据也很有用处。有一些有助于生成数据的工具，例如 Faker 和 Synth 可以生成服从预期统计特性的数据，Synthetic Data Vault 等工具可以依照输入数据集特性来生成数据。
Keptn(Oct 2022, 评估)
Keptn 是用于交付和运维的控制平台，它依赖于CloudEvents 进行插桩。就像我们在 CI/CD 流水线观测技术中提到的，Keptn 将其编排可视化为 traces。交付流水线旨在将 SRE 意图与底层实现分离，依靠其他可观测性、流水线和部署工具来响应适当的事件。我们对 Keptn 将服务级别目标 (service-level objective，SLO) 验证作为架构适应度函数添加到 CI/CD 流水线的想法感到特别兴奋：Keptn 允许你将服务水平指标（service-level indicators，SLI） 定义为键值对，它的值表示对观测性基础设施的查询方法。之后，Keptn 将根据定义的 SLO 评估结果作为交付质量关口。例如，Keptn 对自动化操作采用相同处理，允许使用声明式定义来指定扩展 ReplicaSet 的意图，以降低平均响应时间。作为由 Dynatrace 创建的产品，Keptn 还可以与 Prometheus 和 Datadog 进行集成。
Carbon Aware SDK(Oct 2022, 评估)
当我们着眼于减少一款应用程序的碳足迹——运行软件间接导致的二氧化碳排放——时，注意力通常被导向让软件更加高效上。思路很明确：更高效的软件只需要更少的电力和服务器，从而减少发电与制造服务器所带来的碳排放。另一个策略是使应用程序具有碳意识。这是因为同样的工作负载并不总是具有相同的碳足迹。例如：在较冷气候的数据中心运行时，用于空调的电力需求会减少；或者，在能够使用更多的可再生能源（更多的阳光，更强的风力）时，碳基来源的电力需求会减少。借助 Carbon Aware SDK，软件工程师们可以查询数据源来发现对于给定的工作负载而言碳密集度更低的选项，然后将它移动到不同的位置或是在不同的时间运行它。这对那些对于时间和延迟都不敏感的大型工作负载来说是有意义的，例如训练机器学习模型。虽然这个 SDK 和可获取的数据源还不是很全面，但是我们相信是时候开始探索如何能让我们的系统具有碳意识了。
NestJS(Oct 2022, 采纳)
过去，我们警告过 Node 泛滥 的问题，即使现在，在选择 Node 时，我们仍然持谨慎态度。然而，据我们团队报告，在需要使用 Node.js 构建后端应用程序的某些场景下，NestJS 是一个很好的选择。它使开发人员能够创建可测试、可扩展、松耦合且易于维护的企业级应用程序。 NestJS 是一个 TypeScript 优先的框架，它使 Node.js 应用程序的开发更安全，更不容易出错。 NestJS 采用了面向对象的编程思想，遵循 SOLID 原则，同时受到 Angular 启发，采用了开箱即用的架构。
NestJS(May 2020, 试验)
随着Node.js越来越流行，诸如Node滥用等趋势逐渐显现，这导致了许多开发者使用Node.js开发业务系统。我们经常看到大型JavaScript系统在可伸缩性、可维护性方面出现各种问题。NestJS是一个让Node.js应用开发更安全、更不易出错的基于TypeScript优先风格的框架。NestJS是一个有态度的框架。它的架构直接受Angular启发，符合SOLID原则。我们的团队常用NestJS构建Node.js微服务，它给开发者赋能，能让他们编写出可测试、可伸缩、低耦合、易维护的应用。
NestJS(Nov 2019, 评估)
NestJS是使用TypeScript编写的服务器端框架。通过集成Node.js社区的丰富生态，NestJS提供了一种开箱即用的应用程序架构。开发NestJS的思维模型类似于Angular的服务器端版本或Spring Boot的TypeScript版本，因此开发人员的学习曲线很低。NestJS支持诸如GraphQL，Websocket和ORM库之类的协议。
监视项目构建的 xbar(Oct 2022, 试验)
在远程团队中，我们非常缺乏一个专用的项目构建监视器；不幸的是，新兴的持续集成（CI）工具缺乏对旧 CCTray 格式的支持。其结果是，失败的构建并不能及时地被团队发现。为了解决这个问题，我们的许多团队已经开始使用*监视项目构建的 xbar *。xbar 可以执行脚本来轮询构建状态，并将其显示在电脑的菜单栏上。也可以编写复杂脚本来跟踪其他团队指标，例如检查凭证到期，或生产版本落后于用户验收测试 (UAT) 版本的差距等。当然，xbar 的功能远不止这些，但它解决了远程工作中直接和紧急的问题。Rumps 等工具同样也可以解决这些问题。
Styra Declarative Authorization Service(Oct 2022, 试验)
Styra Declarative Authorization Service (DAS 声明式授权服务) 是一个用来规模化管理 Open Policy Agent (OPA) 的治理和自动化工具。该工具由 OPA 的开发者建立，它允许我们在不同“系统”中部署策略，包括 Kubernetes 集群、基础设施代码仓库、命名空间以及其他。最重要的是，它能对 OPA agent 做出的决定进行实时分析，以及具有调试和调查假设性策略变更场景的回放能力。 它还带有审计日志，可以帮助安全团队进行历史报告。
没有 "使用原生的远程工作方法 "的卫星式工人(Oct 2022, 暂缓)
术语 "远程团队配置 "并不只是描述一种配置；它包含了多种模式和口味。许多团队最近都在改变模式。他们正从新冠疫情下被迫采取的 "每个人总是远程 "的工作模式中走出来，转而采用（通常是轮流）卫星式工人的模式，即部分团队在同一地点办公，部分团队远程工作。我们看到他们中的许多人没有正确考虑这对工作方式意味着什么。 没有“使用原生的远程工作方法” 的卫星式工人回到了优先考虑同地办公的工作方式。在有卫星式工人的配置中，重要的是仍然默认使用“原生的远程工作方法”。例如，如果团队中在同一地点工作的人一起参加会议，他们仍然应该在各自的笔记本电脑上参与数字协作或会议聊天。 团队需要意识到排斥他们的卫星工人和创造孤岛和排斥感的风险。如果你知道总是有至少一个卫星团队成员，那么默认的工作方式应该假定是远程的。
服务器端驱动 UI(Oct 2022, 评估)
服务器端驱动 UI 仍然是移动开发圈的一个热议话题，因为这项技术允许移动端开发者利用更快的变更周期，而不违反应用商店关于重新验证移动应用的任何政策。服务器端驱动 UI 将渲染分离到移动应用程序的一个通用容器中，而每个视图的结构和数据由服务器提供。这意味着对于过去那些需要经历一次应用商店发布之旅的修改，现在只需要简单改变服务器发送的响应数据即可实现。虽然一些非常大的移动应用团队已经利用这种技术取得了巨大的成功，但它也需要大量的投入来建立和维护一个复杂的私有框架。这样的投入需要一个令人信服的商业案例。在此之前，最好谨慎行事。我们的确陷入过某种过度配置的可怕困境，并没有真的获得预期的收益。但在 Airbnb 和 Lyft 等巨头的背书下，我们很可能会看到一些有用的框架出现，有助于降低这种复杂度。这一领域值得关注。
服务器端驱动 UI(Mar 2022, 试验)
当汇总新一期技术雷达的时候，我们时常被一种似曾相识的感觉所倾倒。随着开发框架的涌现， 服务器端驱动 UI 技术引发了一个热议话题。这项技术允许移动端开发者利用更快的变更周期，而不违反应用商店关于重新验证移动应用的任何政策。我们在之前的雷达中从赋能移动开发跨团队扩展的角度介绍过这项技术。服务器端驱动 UI 将渲染分离到移动应用程序的一个通用容器中，而每个视图的结构和数据由服务器提供。这意味着对于过去那些需要经历一次应用商店发布之旅的修改，现在只需要简单改变服务器发送的响应数据即可实现。需要说明的是，我们不推荐对所有 UI 开发都使用这种方式。我们的确陷入过一些可怕的过度配置的困境，但是在 AirBnB 和 Lyft 这样巨头的背书下，我们怀疑不只是我们 Thoughtworks 厌倦了一切交给客户端。这一领域值得关注。
Kotest(Oct 2022, 采纳)
Kotest （原名 KotlinTest）是 Kotlin 生态中的一个独立测试工具，它在我们的团队各式各样的 Kotlin 实现（原生、 JVM 或 JavaScript）中越来越受到关注。Kotest的主要优点是它提供了丰富的测试风格来搭建测试套件，其中还有一套全面的匹配器，可以帮助你使用优雅的内部领域专用语言（DSL）编写表达式测试用例。Kotest 除了支持基于属性的测试 之外，我们团队也看好它可靠的 IntelliJ 插件和支持社区。我们的许多开发者将它列为首选并推荐那些仍在 Kotlin 中使用 JUnit 的开发者考虑切换到 Kotest。
Kotest(Mar 2022, 试验)
Kotest（原名 KotlinTest ）是 Kotlin 生态中的一个独立测试工具，它在我们团队各式各样的 Kotlin实现（原生、JVM 或 JavaScript）中越来越受到关注。Kotest 的主要优点在于它提供了丰富的测试风格来构建测试套件，其中还有一套全面的匹配器，可以帮助你使用优雅的内部领域专用语言（DSL）编写表达式测试用例。Kotest 除了支持基于属性的测试（一项我们在以前的技术雷达中提到过的技术）之外，我们团队还看好它可靠的 IntelliJ 插件以及来自于社区的持续支持。
Kotest(Nov 2019, 评估)
在Kotlin生态系统中，KotlinTest是我们团队喜爱的独立测试工具。它提供了我们在之前的雷达中强调的技术——基于属性的测试。它的关键优势在于提供了多种测试方法以构建测试套件。同时，它内置了一组全面的匹配器，使我们能用优雅的内部DSL编写富有表现力的测试。
eBPF(Oct 2022, 试验)
Linux 内核在多年前就内置了扩展的伯克利数据包过滤器（eBPF），它是一个可以将过滤器附加到特定套接字能力的虚拟机。但是 eBPF 的能力远远超出了包过滤的范围，它允许在内核中的不同点位触发自定义脚本，并且开销非常小。通过在操作系统内核中运行沙箱程序，开发人员可以通过 eBPF 程序给操作系统运行时添加额外的功能。在一些项目需要进行系统调用层的故障排除和剖析时，我们的团队发现像 bcc 和 bpftrace 这样的工具会简化工作。eBPF 也可用于可观测性和网络基础设施，例如 Cilium 项目可以在 Kubernetes 中以 无 sidecar 开销 的方式实现流量负载平衡和可观察性，Hubble 项目在其基础上加强了安全和流量可观察性。Falco 项目使用eBPF进行安全监控，Katran 项目使用 eBPF 建立更有效的 L4 负载平衡。eBPF 社区正在迅速发展，并且我们看到了与可观察性领域越来越多的协同作用。
eBPF(Mar 2022, 试验)
近些年来，Linux 内核已经包括了扩展的伯克利数据包过滤器（eBPF），一个提供了将过滤器附加到特定套接字能力的虚拟机。但是，eBPF 远远超出了包过滤的范围，它允许在内核的不同点位上触发自定义脚本，而且开销非常小。虽然这项技术并不新鲜，但随着越来越多的微服务通过容器编排来部署，eBPF逐渐自成一体。Kubernetes 和服务网格技术（如 Istio ）被普遍使用，它们采用“边车” （sidecars） 来实现控制功能。有了诸如 Bumblebee 这样使 eBPF 程序的构建、运行和发布变得更加容易的新工具， eBPF 可以被看作是传统边车的替代品。Cilium 的维护者甚至宣布了边车的消亡。基于 eBPF 的方法减少了一些由边车带来的性能和运维上的开销，但它不支持如本地终结 SSL 会话这样的常见功能。
eBPF(May 2020, 试验)
几年来，Linux 内核已经内置 eBPF （extended Berkeley Packet Filter）虚拟机，并提供将eBPF 过滤器挂载到特定套接字（socket）的功能。但是 eBPF 能做的远不止包过滤。它允许以很少的开销，在内核中不同的地方，触发自定义脚本。尽管这不是新技术，但随着容器化部署微服务的流行，其价值逐渐显露出来。在这些系统中，服务到服务的通信可能很复杂，因此很难将延迟或性能问题与 API 调用关联起来。现在一些工具会内置eBPF脚本，用于收集和可视化数据包流量，或报告 CPU 利用率。随着 Kubernetes的兴起， 出现了基于 eBPF 脚本的新一代安全实施和检测工具，以降低大规模微服务部署的复杂性。
本地优先应用程序(Oct 2022, 评估)
在集中式应用程序中，服务器上的数据是可信单一数据源——对数据的任何修改都必须经由服务器完成，本地数据只是服务器数据的副本。 这似乎是实现软件的多人协作自然且必然的选择。 本地优先应用程序 ，或 本地优先软件，是一组即能够实现多人协作，且可以使数据所有权本地化的软件设计原则。 它优先使用本地存储和本地网络，而不是远程数据中心或云服务器。 无冲突复制数据类型 (CRDT) 和点对点 (P2P) 网络等技术有可能成为实现本地优先软件的基础技术。
Delta Lake(Oct 2022, 采纳)
Delta Lake 是由 Databricks 实现的开源存储层，旨在将 ACID 事务处理引入到大数据处理中。在使用了 Databricks 的 data lake 或 data mesh 的项目中，我们的团队更喜欢使用 Delta Lake 存储，而不是直接使用 AWS S3 或 ADLS 等文件存储类型。 Delta Lake 此前一直是 Databricks 的闭源项目，最近成为了开源项目，并且可以在 Databricks 之外的平台使用。但是，我们只建议使用 Parquet 文件格式的 Databricks 项目将 Delta Lake 作为默认选择。Delta Lake 促进了需要文件级事务机制的并发数据读/写用例的发展。我们发现 Delta Lake 与 Apache Spark batch 和 micro-batch的无缝集成API 非常有用，尤其是其中诸如时间旅行（在特定时间点访问数据或还原提交）以及模式演变支持写入等功能，尽管这些功能有一些限制。
Delta Lake(Apr 2021, 试验)
Delta Lake是由Databricks实现的开源存储层，旨在将ACID事务处理引入到大数据处理中。在使用了Databricks的data lake或data mesh的项目中，我们的团队更喜欢使用Delta lake存储，而不是直接使用S3或ADLS等文件存储类型。当然，这仅限于那些使用了支持Delta Lake的存储平台的项目，并且使用了Parquet文件格式。当需要实现文件级事务完整性时，Delta Lake 能实现并发数据读写。尽管还存在一些限制，但Delta Lake 与 Apache Spark batch以及micro-batch接口的无缝集成，对我们非常有用。尤其有用的是诸如时间旅行（在特定时间点访问数据或进行提交回滚）和对写操作的schema演进的支持。
Delta Lake(Nov 2019, 评估)
Delta Lake是一个由Databricks开发的开源存储层，用于在大数据场景中引入事务处理。我们在使用Apache Spark时经常遇到的一个问题是缺少ACID事务。Delta Lake通过与Spark的API集成，使用事务日志和版本化的Parquet文件解决了这个问题。由于其可序列化的隔离性，它允许读取器和写入器对Parquet文件进行并发的操作。它的另一个广受好评的特性是对写操作和版本控制的模式强制，它允许我们在必要时可以查询和恢复到旧版本的数据。Delta Lake已经在我们的一些项目中得到了应用，并收获了极好的用户评价。
肤浅的云原生(Oct 2022, 暂缓)
“云原生”一词最初用于描述最大限度利用公有云托管的架构。例如由许多小型、无状态和协作流程组成的分布式架构，以及具有高度自动化的构建、测试和部署能力的系统。然而，我们注意到越来越多 肤浅的云原生 设计，简单地大量使用云供应商提供的专有服务，而没有注意到应用程序其实是大单体、脆弱且笨重的。要注意的是，无服务函数本身并不能使应用程序更具弹性或更易于维护。云原生实际上是架构设计，而非对于实现方式的选择。
SLSA(Oct 2022, 试验)
随着软件复杂性的不断增加，软件依赖项的威胁路径变得越来越难以守护。软件工件供应链层级，又称 SLSA（读作 “salsa”），是一个由联盟组织策划的，为组织机构提供防范供应链攻击的指南集。该框架衍生于一个 Google 多年来一直使用的内部指南。值得称赞的是，SLSA 并没有承诺提供“银弹”，即仅使用工具确保供应链安全的方法，而是提供了一个基于成熟度模型的具体威胁和实践的清单。这个威胁模型是很容易理解的，其中包含了真实世界发生的攻击实例，并且要求文档中也提供了指南，帮助组织基于日渐增强的稳健性水平为其行动措施排定优先级，以改善他们供应链的安全态势。自我们第一次在技术雷达中提到 SLSA 以来，它已经通过示例，围绕软件认证增添了很多细节，以跟踪如构建出处等问题。我们的团队发现 SLSA 在具体执行指导和更高层次对供应链威胁的认知之间取得了良好的平衡。
SLSA(Mar 2022, 评估)
随着软件复杂性的不断增加，软件依赖项的威胁路径变得越来越难以守护。最近的 Log4J 漏洞表明了解这些依赖关系有多困难——许多没有直接使用 Log4J 的公司在不知不觉中就变得脆弱，因其生态系统中的其他软件依赖于 Log4J。软件工件供应链层级，又称 SLSA（读作 “salsa”），是一个由联盟组织策划的，为组织机构提供防范供应链攻击的指南集。该框架衍生于一个 Google 多年来一直使用的内部指南。值得称赞的是，SLSA 并没有承诺提供“银弹”，即仅使用工具确保供应链安全的方法，而是提供了一个基于成熟度模型的具体威胁和实践的清单。这个威胁模型 是很容易理解的，其中包含了真实世界发生的攻击实例，并且要求文档中也提供了指南，帮助组织基于日渐增强的稳健性水平为其行动措施排定优先级，以改善他们供应链的安全态势。我们认为 SLSA 提供了适用的建议，并期待更多组织机构从中学习。
Jetpack Media3(Oct 2022, 试验)
现如今安卓拥有多个媒体 API：Jetpack Media（也被称为 MediaCompat ），Jetpack Media2 和 ExoPlayer。然而，这些库都是分别开发的，它们的目的不同但是功能重叠。这就导致安卓开发者在编码的时候不仅需要斟酌类库的选型，当使用的特性来自于多个库的时候，还需要编写适配器或者兼容代码。 Jetpack Media3 是从现有 API 中选取通用的功能——包括 UI、播放和媒体会话处理，然后将它们合并和改进成一个新的 API。ExoPlayer 的播放器界面也进行了更新、增强和简化，被用作 Media3 的通用播放器界面。在早期访问阶段之后， Media3 目前仍处于早期开发版本。虽然它的第一个正式版本即将发布，但我们已经在应用程序中使用 Media3 得到了积极的体验。
Jetpack Media3(Mar 2022, 评估)
现如今安卓拥有多个媒体 API：Jetpack Media（也被称为 MediaCompat ），Jetpack Media2 和 ExoPlayer。然而，这些库都是分别开发的，它们的目的不同但是功能重叠。这就导致安卓开发者在编码的时候不仅需要斟酌类库的选型，当使用的特性来自于多个库的时候，还需要编写适配器或者兼容代码。Jetpack Media3 尝试去解决上述情况。它是从现有 API 中选取通用的功能——包括 UI、播放和媒体会话处理，然后将它们合并和改进成一个新的 API。 Mediia3 目前仍处于早期开发版本。此外，ExoPlayer 的播放器界面也进行了更新、增强和简化，被用作 Media3 的通用播放器界面。
AWS Backup 文件库锁定(Oct 2022, 试验)
保证备份在失效前无法被恶意或意外地删除、修改，在实现稳健、安全且可靠的灾难恢复时是十分必要的。在之前使用 AWS Backup 时，这些策略和保证只能通过手动实现。最近，AWS 添加了文件库锁定这一功能，以确保备份不可变且不可修改。AWS Backup 文件库锁定 强制应用保留和删除策略，甚至防止包括拥有管理员权限的用户修改或删除备份文件。该功能的加入非常有价值，填补了之前在这一需求上的空白。
Cloudscape(Oct 2022, 评估)
Cloudscape 是一款开源的设计系统，它不仅有一套丰富的组件集，还有35 种交互和内容展示模式。与此同时，它使用设计令牌来进行主题化，并提供元素包装器给所有组件，这极大地简化了单元测试。这几点让它从众多设计系统中脱颖而出。
CUPID(Oct 2022, 评估)
你应该如何编写好的代码？如何判断自己是否写了好的代码？作为软件开发者，我们总是在寻找一些自然易记的规则、原则和模式，以便在讨论如何编写简单的、易修改的代码时，我们有统一的语言和价值观。\nDaniel Terhorst-North最近尝试为好代码创建了一个类似于检查表的东西。他认为与其拘泥于像 SOLID 这样一套规则，不如使用一组特性作为目标。他设计出了名为 CUPID 的特性组，来描述为了写出"令人愉悦"的代码，我们需要做出哪些努力：在该特性指导下的代码应该是可组合的，遵循 Unix 哲学的，可预测的，风格自然的以及基于领域的。
CUPID(Mar 2022, 评估)
你应该如何编写好的代码？如何判断自己是否写了好的代码？作为软件开发者，我们总是在寻找一些自然易记的规则、原则和模式，以便在讨论如何编写简单的、易修改的代码时，我们有统一的语言和价值观。\nDaniel Terhorst-North最近尝试为好代码创建了一个类似于检查表的东西。他认为与其拘泥于像SOLID这样一套规则，不如使用一组特性作为目标。他设计出了名为CUPID的特性组，来描述为了写出"令人愉悦"的代码，我们需要做出哪些努力：在该特性指导下的代码应该是可组合的，遵循Unix哲学的，可预测的，风格自然的以及基于领域的。
Connect(Oct 2022, 评估)
Connect 是一系列用于构建与浏览器和 gRPC 兼容的 HTTP API 的库。 与 gRPC 类似，您编写协议缓冲区的架构并实现其应用程序逻辑，然后 Connect 生成代码来处理编组、路由、压缩和内容类型协商。 但是，Connect 尝试以多种方式去改进 gRPC。 包括在没有翻译代理的情况下对 gRPC-Web 的原生支持； 与第三方路由器或中间件的互操作性，因为 connect-go 构建在 net/http 之上（与 grpc-go 不同）； 以及完全生成的类型安全的，具有手工代码的人体工程学的客户端。 我们大多更喜欢 REST，而不喜欢使用 RPC 方法去构建 API。 也就是说，Connect 似乎解决了我们对 RPC 的一些担忧，我们鼓励您对其进行尝试。
组件视觉回归测试(Oct 2022, 试验)
视觉回归测试是很有用的强大工具，值得被您收进工具箱。但是在整个页面上使用视觉回归测试的成本非常高。我们看到随着 React 和 Vue 等基于组件的框架逐渐兴起， 组件视觉回归测试 也越来越流行。这项技术能确保在应用程序中不会引入非必要的视觉元素，从而很好的维持了投入和产出之间的平衡。在我们的实践里，组件视觉回归测试很少误测，而且有助于改善架构风格，通过和 Vite 以及 webpack 的 模块热替换 (HMR) 功能共同使用，还可以视之为测试驱动开发应用于前端开发领域的范式转变。
Moshi(Oct 2022, 试验)
听说很多使用 Kotlin 语言的团队在寻找可以替代 GSON 这样基于 Java 的 JSON 处理工具。刚出现不久的 Moshi 已经成为了许多此类团队的首选方案。从 GSON 迁移到 Moshi 非常简单，且后者原生支持 Kotlin 语言中的非空类型和默认参数特性，使得处理 JSON 的工作变得更加高效便捷。如果你正在 Kotlin 中使用基于 Java 的 JSON 处理工具，我们建议你尝试一下 Moshi。
VictoriaMetrics(Oct 2022, 试验)
现代可观察性依赖于收集和汇总一组详尽的细粒度指标，以充分理解、预测和分析系统行为。但面对由大量冗余，协作进程和主机组成的云原生系统时，由于基数（唯一时间序列数）会随着每个额外的服务、容器、节点、集群等呈指数增长，现代可观察性的应用显得相对笨重。对于这些高基数的数据，我们发现 VictoriaMetrics 表现出众。VictoriaMetrics 尤其适用于运行由 Kubernetes 托管的微服务架构，它的 operator 使团队可以轻松地以自助服务的方式实现自我监控。我们还喜欢它的组件化架构以及即使在中央服务器不可用时也能继续收集指标的能力。虽然我们的团队对 VictoriaMetrics 很满意，但云原生的可观察性是一个快速发展的领域，我们建议也同时关注其他高性能的、Prometheus 兼容的时间序列数据库，例如 Cortex 或 Thanos。
Retool(Oct 2022, 试验)
在之前的技术雷达中，我们曾建议评估限界低代码平台，将其作为一种将低代码解决方案应用于极少数领域的特定用例的方法。我们已经看到这个方向越来越受欢迎，特别是低代码平台 Retool，我们的团队用它来为内部用户构建解决方案，主要用于数据的查询和可视化。它使得内部用户可以更快地制作非关键业务的只读解决方案。据报告显示，Retool 的主要优势在于它的用户界面组件，以及与公共数据源快速便捷集成的能力。
设计令牌(Oct 2022, 试验)
当面临如何跨多种尺寸设备和平台一致地使用设计系统的挑战时，Salesforce 的团队提出了设计令牌这个概念。令牌将诸如颜色和字体等值存储在一个中心位置。这使得将选项与决策分开成为可能，并且显著改善了团队之间的协作。设计令牌并不是新事物，但随着 Tailwind CSS 和 Style Dictionary 等工具的引入，我们看到设计令牌被更频繁地使用。
GitHub 推送保护(Oct 2022, 评估)
意外泄露机密似乎是一个老生常谈的事故，也出现了像 Talisman 这样的工具来帮助解决这个问题。在此之前，拥有高级安全许可证的 GitHub Enterprise Cloud 用户可以对其帐户启用安全扫描，意外提交和推送的任何机密（API 密钥、访问令牌、凭据等）都会触发警报。GitHub 推送保护更深入了一步，并将其提前到了开发工作流程中，如果更改被推送的时候检测到有机密，则直接拒绝这次推送。 这需要为组织进行配置，当然仅适用于许可证持有者，但欢迎提供额外的保护以防止泄露机密。
Carbon(Oct 2022, 暂缓)
我们看到了一些对 Carbon 编程语言产生的兴趣。这一点也不令人惊讶：它有 Google 的背书，而且它被展现为 C++ 的天生继承者。在我们看来，C++ 不会以足够快的速度被取代，正如在过去几十年的时间里软件工程师们所表现的那样，写出安全且没有错误的 C++ 代码是一件极其困难且耗时的事情。虽然 Carbon 是一个有意思的概念，它专注于从 C++ 移植，但是在没有一个可工作的编译器的情况下，很明显它离可以使用还有很长的路要走，而且如果你想从 C++ 移植，也有其他现代的编程语言可以作为不错的选择。现在谈 Carbon 是否会成为 C++ 的天生继承者还太早了，不过，以今天的视角来看，我们推荐项目组去关注一下 Rust 和 Go 而不是等着 Carbon 的到来而推迟移植项目。
Svelte(Oct 2022, 试验)
在 Web 组件框架中，Svelte 通过将反应性从浏览器中转移到编译器中而脱颖而出。Svelte 不是通过使用虚拟 DOM 和浏览器优化技巧来优化 DOM 更新，而是将你的代码编译成无框架的 JavaScript 代码，像做外科手术一样更新 DOM。除了运行时的性能优势之外，这也让 Svelte 在不牺牲开发者功能的情况下优化浏览器必须下载的代码量；此外，事实证明，由于在浏览器中执行的代码较少，它对移动网络应用的性能和电池需求更加友好。除了性能优势之外，我们团队还欣赏它友好的学习曲线和来自于编写更少代码 的维护优势。Svelte 本身只是组件框架，但 SvelteKit 增加了可以构建完整 Web 应用程序的功能。
Svelte(Oct 2020, 评估)
我们不断看到新的前端 JavaScript 框架出现，其中 Svelte 作为一个前途无量的新组件框架脱颖而出。与其他使用虚拟 DOM 的框架不同，Svelte 将代码编译为单纯的无框架 JavaScript 代码，这些代码可以直接操作更新 DOM。不过，它只是一个组件框架；如果你打算构建功能丰富的应用程序，可以考虑将 Sapper 与 Svelte 一起进行评估。
Camunda(Oct 2022, 试验)
自从我们上次提到 Camunda 以来，我们已经看到了我们的许多团队和客户在使用该平台，使其在适合引入工作流引擎的领域里，成为我们的首选工作流引擎之一。 Camunda 提供的工作流和决策引擎可以作为库集成到用户的 Java 代码中。 这使得测试、版本化和重构工作流变得更容易，缓解了其他低代码工作流引擎的一些缺点。 我们甚至已经看到 Camunda 在具有高性能要求的环境中被使用。 一些团队还很喜欢它可以很容易与 Spring Boot 做集成及它漂亮的用户界面。
Camunda(Nov 2018, 评估)
We tend to be quite skeptical of business process model and notation (BPMN) tools in general as they're often associated with low-code environments and their downsides. Although the OSS BPMN framework Camunda provides some of this whizziness, it also offers workflow and decision engines that can be directly integrated as a library in your Java code. This makes it easy to test, version and refactor workflows. Camunda also integrates with Spring and Spring Boot, among other frameworks, making it a solid choice.
SLI 和 SLO 定义为代码(Oct 2022, 评估)
自从谷歌首次将服务质量指标（SLIs）和服务质量目标（SLO）作为其网站可靠性工程（SRE）实践的一部分推广以来，Datadog 、Honeycomb 和 Dynatrace 等观察性工具开始将 SLO 监控纳入其工具链。OpenSLO 是一个基于 Kubernetes 使用的 YAML 格式声明式、中立的规范语言新兴的，且允许将 SLI 和 SLO 定义为代码 的标准。虽然该标准仍然很新，但我们看到了一些令人鼓舞的势头，比如 Sumo Logic 公司贡献了 slogen 工具来生成监控和仪表盘。我们对在代码中对 SLI 和 SLO 定义进行版本化的承诺，和将可观察性工具作为所部署服务的 CI/CD 流水线一部分这一更新感到兴奋。
Spectral(Oct 2022, 试验)
Spectral 是一个强调 OpenAPI 和 AsyncAPI 的 JSON/YAML 代码静态检查工具（linter）。在设计和实现 API 或进行事件驱动的协作时，它所提供的全面且开箱即用的规则可以帮助开发者省去很多麻烦。 这些规则可以用于检查 API 参数规范或规范中存在的许可声明等。其 CLI 能够让本地开发和 CI/CD 流水线中更容易地引入 Spectral，而 JavaScript API 则支持更高级的使用场景。它的 GitHub 页面 链接了一些公开的真实公司（比如 Adidas）正在使用的规则集，这使得团队在采用他们自己的检查规则时有了一个良好的开始。
Spectral(Apr 2021, 评估)
我们在本期技术雷达中反复看到的一种模式是，当一种新的语言变得流行以后，静态错误和样式检查工具会迅速浮现出来。这些工具通常被称作linters——以经典且深受欢迎的可以静态分析C代码的Unix工具 lint命名。我们喜欢这些工具，因为它们会更早捕获异常，甚至在代码未编译之前。这个模式最新的例子是关于YAML和JSON的linter Spectral。尽管Spectral可用作这些文件格式的通用检查工具，但它的主要目标是OpenAPI（Swagger和AsyncAPI的演化版本）。Spectral为这些规范提供了全面的开箱即用的规则，帮助开发者们在设计和实现API或事件驱动协作中避免麻烦。这些规则可以检查API参数规范或者规范中存在的许可声明等。虽然这个工具成为API开发工作流中广受欢迎的补充，它仍然提出了一个问题：即非执行文件的规范是否应该如此复杂，以至于需要为编程语言设计专门的错误检查技术。也许开发者们应该写的是代码而非规范？
Excalidraw(Oct 2022, 试验)
我们不断地从我们的团队中听到关于 Excalidraw 的热心报告，但我们先前关于安全的警告仍然存在。Excalidraw 是一个简单却强大的在线绘图工具。有些时候团队只是需要一张快速的图片而不是正式的图表；对于远程团队而言，Excalidraw 提供了一种快速创建和分享图表的方式。我们的团队还喜欢它可以产出低保真样式的图表，这让人想起他们在同地协作时绘制的白板图表。至于安全性，在撰写本文时，任何拥有链接的人都可以查看您的图表；但请注意，付费版 Excalidraw 提供了进一步的身份验证功能并且拥有部署本地化服务器的选项。
Excalidraw(Mar 2022, 评估)
Excalidraw 是我们团队喜欢使用的简单但功能强大的绘图工具。有时候团队只是需要一张草图而不是正式的图表，Excalidraw 为远程团队提供了一种可以快速创建和共享图表的方式。我们团队也喜欢它生成的低保真图表样式，这让人联想到团队在同地协作时绘制的白板图表。提醒一点：你需要注意它默认的安全性，在你进行绘制时，任何拥有链接的人都可以看见图表。付费版本则提供了进一步的身份验证功能。
OrioleDB(Oct 2022, 评估)
OrioleDB 是一个为 PostgreSQL 打造的全新存储引擎。我们团队在大量使用 PostgreSQL 的过程中发现，尽管其现有多个选项用来适应现代硬件，但因其存储引擎最初是为机械硬盘设计，达成优化目标的过程可能困难并且繁琐。OrioleDB 为了解决这些问题，实现了显式支持固态硬盘和非易失性随机存取存储器(NVRAM)的云原生存储引擎。想要试用该引擎，用户首先需要给当前的表访问方法安装增强补丁，然后以 PostgreSQL 扩展的形式安装 OrioleDB。我们相信 OrioleDB 有很大的潜力去解决某些 PostgreSQL 中的长期遗留问题，因此，我们鼓励你仔细地对该引擎进行评估。
联邦学习(Oct 2022, 试验)
我们看到许多客户项目正在使用 联邦学习 (ML)。传统上机器学习模型训练时需将数据放在集中运行模型训练算法的地址。在隐私角度上，这存在问题，特别是当训练数据包括敏感或者可用于身份识别信息时；用户也许不愿意分享数据，当地的数据保护法律也可能不允许我们将数据转移至一个中心化的位置。联邦学习是一个去中心化的技术，它使模型可以在大量不同来源的数据集上训练，并让数据保持在远端，例如用户的设备上。尽管网络带宽和设备的算力限制目前仍是这项技术重大的挑战，但是我们喜欢联邦学习的思路，让用户可以完全控制自己的个人信息。
联邦学习(Nov 2019, 评估)
模型训练通常需要从数据源收集大量的数据，并将这些数据传输到集中运行模型训练算法的服务器上。但是如果训练数据集中包括个人身份信息，这就会成为问题。而联邦学习这项技术的出现让我们备受鼓舞。联邦学习是一种隐私保护方法，用于训练大量的，与个人信息相关的各种数据集。联邦学习技术可以让数据保留在用户的设备上，并完全控制在用户的手中，但最终会仍然可以组合成一个整体的训练数据集。在联邦学习中，每个用户设备独立地更新模型。然后将模型的参数（而不是数据本身）组合成一个集中式的视图。尽管网络带宽和设备算力限制会给这项技术带来一些重大的技术挑战，但是我们喜欢联邦学习的思路，让用户可以完全控制自己的个人信息。
Databricks Overwatch(Oct 2022, 评估)
Databricks Overwatch 是 Databricks 实验室的项目，它让团队能分析 Databricks 负载运行时的各种包括成本、治理、和性能在内的多种运营指标，并且支持运行假设性的试验。 它本质上是一系列在 Databricks 中填充数据表格的数据流水线，这使得它可以被例如计算笔记本（Notebooks）这类工具分析。Overwatch 是一个非常强大的工具，但仍处于试验阶段，并且它需要一定的时间成本进行配置。在使用中我们发现，Overwatch 需要 Databricks 解决方案架构师帮助建立并填充一个用于成本计算的价格参考表——但是我们预计使用它会变得日益轻松。Overwatch 提供了相对于云提供商的成本分析工具进行更深入分析的可能性。例如，我们能分析任务失败的成本——认识到快速失败比在接近最后一步时才失败的任务更省钱——并且将成本划分为各种组别（工作区，集群，任务，计算笔记本，团队）。我们也喜欢它提高的操作可见性，这使得我们可以轻松审计集群设置的访问控制并分析运营指标，例如找到长时间工作的计算笔记本或者是最大的读写卷。Overwatch 可以分析历史数据，但它的实时数据也允许设置警报，这能帮助你对 Databricks 负载添加合适的控制。
Backstage(Oct 2022, 采纳)
在一个日渐数字化的世界里，大型组织怎样提高开发者的效率往往是资深领导们的核心关注点。总的来说我们已经足够意识到了开发者门户的价值，特别是 Backstage 的价值，我们非常愿意在采纳环中推荐它。Backstage 是由 Spotify 开发的一款能提升整个组织内的软件资产发现的开源开发者门户平台。它使用了存放在代码库中的 Markdown TechDocs 来追踪每个服务，这很好地平衡了中心化发现和分布式资产所有权的需求。Backstage 支持软件模版，这可以加速新项目的开发。它还支持插件架构，能够增强组织基础设施生态系统的可扩展性和适应性。Backstage 服务目录 使用 YAML 文件来追踪组织生态系统中所有软件的所有权和元数据；它甚至可以让你追踪第三方的 SaaS 软件，通常来说这么做需要追踪的权限。
Backstage(Oct 2021, 试验)
随着各个组织持续关注改善开发人员体验和效率，我们看到Backstage越来越受欢迎，且组织开始采纳开发者门户。这些组织正在寻求支持和简化其开发环境。随着各种工具和技术数量的增加，某种形式的标准化，对于保持一致性变得越来越重要。这样开发人员可以专注于创新和产品开发，而不是陷入重新造轮子的泥潭。Backstage 是一个由 Spotify 创建的开源开发者门户平台。它基于软件模板、统一的基础设施工具和一致且集中的技术文档。其插件式架构，使其在组织的基础设施生态系统中，具有可扩展性和适应性。我们将持续关注新的 Backstage Service Catalog 。它目前正处于alpha测试阶段，可以用来追踪组织生态系统中所有软件的所有权和元数据。
Backstage(Apr 2021, 试验)
随着组织在寻求支持和简化其开发环境时，开始采用开发者门户，我们看到人们对Backstage的兴趣和使用量在不断增长。随着工具和技术数量的增加，采用某种形式的标准化，对于保持开发的一致性变得越来越重要。因为一旦实现了一致性，开发人员就可以专注于创新和产品开发，而不是陷入重复发明轮子的泥淖。Backstage 是由 Spotify 创建的开源开发者门户平台。它由软件模板、统一的基础设施工具和一致且集中的技术文档所构成。插件式架构为组织的基础设施生态系统，提供了可扩展性和适应性。
Backstage(Oct 2020, 评估)
组织正在寻求通过开发人员门户或平台来支持和简化开发环境。随着工具和技术数量的增加，为了让开发人员能够专注于创新和产品开发而不必为重新发明轮子陷入困境，某种形式的标准化对于保持一致性来说越来越重要。集中的开发人员门户可以轻松提供服务发现和最佳实践。 Backstage 是一个由 Spotify 提供的创建开发人员门户的开源平台。它基于软件模板、统一的基础设施工具以及一致且集中的技术文档。它的插件化架构允许对组织的基础设施生态系统进行扩展和适配。
默认选择 SPA(Oct 2022, 暂缓)
团队搭建网站时会默认选择单页面应用 (SPA) 的普遍现象让我们担心人们甚至没意识到 SPA 原本只是一种架构风格时，就立即进行了项目的框架选型。SPA 会招致传统基于服务器的网站所不具备的复杂性：譬如搜索引擎优化，浏览历史管理，网站分析，首页加载时间等。我们需要适当地分析和考虑，来确定这种复杂性是出于业务需求还是用户体验，以此做出权衡。我们通常看不到团队去进行这种权衡分析，即使是在业务需求不能证明这种使用是合理的情况下，也盲目地接受了 默认使用 SPA 的复杂性。事实上，我们已经开始注意到许多新的开发人员甚至都不知道有替代的方法，因为他们整个职业生涯都是在类似 React 这样的框架中度过的。我们相信，许多网站都会受益于服务端逻辑的简洁性，并且我们从例如 Hotwire 这种有助于减少用户体验差异的技术中受到了鼓励。
默认选择 SPA(Mar 2022, 暂缓)
通常来说，我们会避免将建议过于浅显的条目放在暂缓状态中，包括那些盲目地遵循一种架构风格却没有注意权衡利弊的条目。然而，团队搭建网站时会默认选择单页面应用(SPA)的普遍现象让我们担心人们甚至没意识到 SPA 原本只是一种架构风格时，就立即进行了项目的框架选型。SPA 会招致传统基于服务器的网站所不具备的复杂性：譬如搜索引擎优化，浏览历史管理，网站分析，首页加载时间等。这些复杂性通常是为了确保用户体验，并且工具的持续发展也使得这些问题更容易解决 (尽管 React 社区有关于状态管理的混乱透露出想要得到一个普适的解决方案是多么的困难)。然而，我们通常看不到团队去进行这种权衡分析，即使是在业务需求不能证明这种使用是合理的情况下，也盲目地接受了 默认选择 SPA 的复杂性。事实上，我们已经开始注意到许多新的开发人员甚至都不知道有替代的方法，因为他们整个职业生涯都是在类似 React 这样的框架中度过的。我们相信，许多网站都会受益于服务端逻辑的简洁性，并且我们从例如 Hotwire 这种有助于减少用户体验差异的技术中受到了鼓励。
IAM Roles Anywhere(Oct 2022, 评估)
IAM Roles Anywhere 是 AWS 的一项新服务，可让你在 IAM 中为运行在 AWS 之外的服务器、容器和应用程序等工作负载获取临时的安全凭证。我们发现它对工作负载分散在 AWS 和非 AWS 资源之间的混合云中特别有用。借助 IAM Roles Anywhere，现在你可以使用 X.509 数字证书创建短期凭证以此来访问 AWS 资源，而不用创建长期凭证。我们相信这种方法简化了整个混合云的访问模式，建议你可以了解看看。
React Query(Oct 2022, 采纳)
React Query 通常被描述为 React 缺失的数据获取库。获取，缓存，同步和更新服务器状态是许多 React 应用程序常见的需求，尽管这些需求易于理解，但众所周知，正确地实现这些需求非常困难。React Query 提供了一种基于 hooks 的更直接的方式。它与现有的基于 promise 机制的异步数据获取库协同工作，如 axios、Fetch 和 GraphQL。作为应用程序开发人员，你只需要传递一个解析数据的函数，其余的事情可以留给框架完成。该工具开箱即用，但也可以按需进行配置。它的开发者工具也能帮助刚接触此框架的开发人员理解其工作原理，遗憾的是，其开发者工具尚不支持 React Native。对于 React Native，你可以使用第三方开发者工具插件 Flipper。基于我们的经验，React Query 的第三版为我们的客户提供了生产环境所需的稳定性。
React Query(Oct 2021, 试验)
React Query 通常被描述为 React 缺失的数据获取库。数据获取，缓存，同步和服务器状态更新是很多 React 应用中非常普遍的需求，虽然这些需求很容易理解，但在程序中正确的实现却是众所周知的困难。React Query 提供了一种基于React Hooks 的简便直接的方案。作为应用的开发者，只需要传入一个解析数据的函数，然后把其他的工作都交给这个框架即可。我们喜欢它能开箱即用，又能在需要时进行多样化配置。它的开发工具可以帮助新接触 React Query 的开发人员理解该框架的工作原理，但遗憾的是，它还无法在 React Native 中使用。根据我们的经验，该框架的第三版拥有了线上产品所需要的稳定性。
AWS数据库迁移服务(Oct 2022, 试验)
我们的许多团队已成功使用 AWS数据库迁移服务 (DMS) 将数据迁移到 AWS 或从 AWS 迁移数据。在我们的一项数字化转型项目中，当我们将数据从 Microsoft SQL 服务迁移到 AWS 关系数据库服务 (RDS) PostgreSQL 实例时，我们以几乎零宕机时间切换到了新系统。这次转型涉及许多部分，需要跨多专业团队进行规划和协调，然而对于数据迁移来说，我们对 DMS 非常满意。它自动管理所有必需资源的部署、管理和监控。经过多年的发展，DMS 已经很成熟，可以支持多种来源和目标数据库，我们也会继续支持它。
Clasp(Oct 2022, 评估)
不幸的是，电子表格（spreadsheet）在这个世界依然大行其道，而且在可见的未来也仍会如此。电子表格是人们构建符合他们特定需求的自定义小工具的终极武器。然而，当你试图使用一些需要“真正的”代码逻辑来增强这些小工具的时候，电子表格的低代码属性就会变得非常有局限性。如果你在一个类似 Thoughtworks 这样使用 Google 的 G-Suite 的公司，Clasp 使你至少可以在 Apps Script 代码里应用一些 Continuous Delivery 的实践。它可以让你在 Apps Script 项目之外编写代码，这样就有了测试、版本控制和构建流水线，甚至使用 TypeScript 的可能性。Clasp 已经存在一段时间了，你不应期待它提供一个常规的舒适编程环境，但它确实能极大地提升使用 Apps Script 的体验。
Hadolint(Oct 2022, 试验)
我们乐于传播有关代码静态检查工具的讯息，这些工具实际上可以帮助您发现问题而不仅仅是处理团队中缩写风格的争议。 Hadolint 是一个这样的工具，它有助于发现 Dockerfile 中的常见问题。 我们发现它可以快速、准确地发现问题且具有良好的使用文档。 它会在第一时间解释如何解决问题以及为什么它是一个问题，从而促使 Dockerfile 作者趋向好的实践。 顺便一提，Hadolint 是基于我们推荐使用于检查 shell 脚本的 ShellCheck 工具构建的。
JobRunr(Oct 2022, 评估)
JobRunr 是一个可以替代 Quartz 调度器的 Java 后台任务执行库。它内置的用于监控和调度后台任务的仪表盘操作简便，深受我们团队喜爱。JobRunr 是开源且免费商用的，但任务迁移和恢复等功能需要付费使用。
BentoML(Oct 2022, 评估)
BentoML 是一个 Python 优先的框架，用于在生产环境中规模化部署机器学习模型。它提供的模型与环境无关； 所有模型属性、源代码和依赖包都封装在称为 Bento 的自包含格式中。这就像“模型即服务”一样。您可以将 BentoML 视为机器学习模型的 Docker ：它使用预编程 API 生成可立即部署的虚拟机镜像并包含相应的功能使测试这些映像变得十分简单。BentoML 可以通过简化项目初始阶段的任务加速项目的开发，这是我们将其归纳在评估环中的原因。
Monte Carlo(Oct 2022, 试验)
Monte Carlo 是一个数据可观测性平台。它使用机器学习模型，可以推断和学习数据，识别问题并在出现问题时通知用户。它使我们的团队能够跨 ETL 流水线、数据湖、数据仓库和商业智能 (BI) 报告维护数据质量。凭借监控仪表板即代码、中央数据目录和字段级沿袭等功能，我们的团队发现 Monte Carlo 是整体数据治理的宝贵工具。
Yjs(Oct 2022, 采纳)
无冲突复制数据类型 (CRDT) 算法被证明能够在对等节点中自动地分发与合并修改而不产生冲突。但是在实践中，即使对于足够小的数据，这些算法通常也需要大量内存来追踪由不同对等节点做出的所有修改，从而变得不切实际。 Yjs 是一个精心优化的 CRDT 实现，能够在面对大型数据集和数百万个修改时将内存开销保持在合理的水平。它也能绑定到流行的文本编辑器上，这一点显著地降低了构建协作工具的成本。
Harness 云服务成本管理(Oct 2022, 评估)
Harness 云服务成本管理 是一款为三个主要的云服务提供商及其托管的 Kubernetes集群提供服务的商业工具，用来帮助其可视化及管理云服务成本。该产品通过查看空闲资源以及未分配给任何工作负载的资源来计算成本效率分数，并使用历史变化趋势来帮助其优化资源分配。 仪表盘突出显示成本峰值，并允许用户注册未按照预期发生的意外现象，然后为他们围绕异常检测的强化学习算法提供素材。云成本管理可以提供调整内存和 CPU 使用限制的建议，并提供优化成本或性能的选项。 “Perspectives”允许您根据按照组织结构定义的过滤器（可能对应于业务部门、团队或产品）对成本进行分组，并自动分发报告以可视化云服务支出。 我们相信 Harness 云服务成本管理提供了一个有说服力的功能集，来帮助组织使他们的 FinOps 实践变得更加成熟。
Dragonfly(Oct 2022, 评估)
Dragonfly 是一个可兼容 Redis 和 Memcached API 的新型内存数据库。它利用 Linux 新有的 io_uring API 实现 I/O，并在多线程、无共享架构的基础上实现 新型的算法和数据结构 。因为这些明智的实现方案选择，Dragonfly 在性能方面取得了令人印象深刻的结果。尽管 Redis 仍然是我们对内存数据库解决方案的默认选项，但我们认为 Dragonfly 是一个值得评估的选项。
Azure Bicep(Oct 2022, 试验)
Azure Bicep 是一种使用声明式语法的领域特定语言（DSL），主要面向那些喜欢使用比 JSON 更自然的语言来编写基础设施代码的人。它支持可重用参数化模板来实现模块化资源定义。它有 Visual Studio Code extension 插件为其提供实时类型安全、智能感知和语法检查的功能，并且它的编译器允许双向转换 Azure Resource Manager (ARM) 模板。Bicep 面向资源的 DSL 以及与 Azure 生态系统的原生集成使其成为 Azure 基础设施开发人员的不二之选。
Azure Bicep(Mar 2022, 评估)
Azure Bicep 是一种使用声明式语法的领域特定语言 (DSL)，主要面向那些喜欢使用比 JSON 更自然的语言来编写基础设施代码的人。 它支持可重用参数化模板来实现模块化资源定义。 它有 Visual Studio Code 插件 为其提供实时类型安全、智能感知和语法检查的功能，并且它的编译器允许双向转换 ARM 模板。 Bicep 面向资源的 DSL 以及与 Azure 生态系统的原生集成使其成为 Azure 基础设施开发人员的不二之选。
TinyML(Oct 2022, 评估)
我们仍旧为 TinyML 这项技术和它在构建可以运行在低功耗和移动设备上的机器学习（ML）模型的能力而感到兴奋。时至今日，运行机器学习（ML）模型仍然需要高昂的计算成本，并且在某些情况下还需要使用专用硬件。虽然模型的创建仍然大致属于上述情况，但可以通过一种方式创建模型，使它们能够在小型、低成本和低功耗设备上运行。如果你一直在考虑使用 ML 但苦于计算能力或网络环境的限制而放弃，那么这种技术值得你去评估。
TinyML(Mar 2022, 评估)
时至今日，在人们眼中，运行机器学习（ML）模型仍然需要高昂的计算成本，并且在某些情况下还需要使用专用硬件。虽然模型的创建仍然大致属于上述情况，但可以通过一种方式创建模型，使它们能够在小型、低成本和低功耗设备上运行。这种技术被称作 TinyML，它为在看上去不可行的情况下运行 ML 模型开辟了新的可能性。例如，在由电池供电的设备上，或者在受限或不稳定的网络环境中，TinyML 能够使模型运行在本地且不需要高昂的成本。如果你一直在考虑使用 ML 但苦于计算能力或网络环境的限制而放弃，那么这种技术值得你去评估。
在线格式化或代码解析服务(Oct 2022, 暂缓)
我们之前提到了测试环境中的生产数据，现在想强调另一个需要小心处理甚至完全停止的常见实践： 在线格式化代码解析服务 。有许多有用的网站提供格式化或解析格式(如 JSON 和 YAML )的服务，还有许多评估代码教程或在线生成代码衡量指标的网站。使用这些产品时需要非常小心。将 JavaScript、JSON 或类似代码片段粘贴到一个未知的网站很容易造成安全和隐私问题，并可能在不知不觉中将个人数据导出到不同的信息管辖区。这些站点不应该与生产数据一起使用，并且在任何其他情况下都应该谨慎对待。
Gradient(Oct 2022, 评估)
Gradient 是一个用于构建、部署和运行机器学习应用的平台，它非常类似于谷歌的 Colab。用户可以从模板创建 Notebook，以快速搭建 PyTorch 或 TensorFlow 或像 Stable Diffusion 这样的应用。根据我们的经验，Gradient 非常适合用于构建 GPU 密集型的模型，而且我们喜爱它的 Web 环境能够持久化保存的特点。
Great Expectations(Oct 2022, 采纳)
Great Expectations 已经成为了我们的团队在数据质量领域的默认选择，这也是为什么我们建议采纳它 — 不仅仅是因为没有更好的替代方案，更多的是因为我们的团队在几个客户项目中都报告了它非常好的表现。 Great Expectations 作为框架，允许用户搭建用于标记数据流水线中的异常或质量问题的内置控件。正如单元测试在构建流水线中运行一样，Great Expectations 在数据流水线的执行过程中进行断言。我们喜欢它的简单性和易用性 — 无需数据工程技能，保存在 JSON 里面的规则都可以被我们的数据领域专家修改。
Great Expectations(Apr 2021, 试验)
在之前的技术雷达中，我们就关注到了Great Expectations，我们继续看好它，并在本期技术雷达中将它挪入试验阶段。Great Expectations这个框架可以搭建内置控件，来标记数据流水线中的异常或质量问题。正如单元测试在构建流水线中运行一样，Great Expectations在执行数据流水线时也会进行断言。它的简单性和易用性深得我们喜爱——断言的规则用JSON文件存储，可以由我们的数据科学家来修改，所以不需要数据工程技能。
Great Expectations(Oct 2020, 评估)
随着 CD4ML 的兴起，数据工程和数据科学的运维方面获得了更多的关注。自动化数据治理是发展的结果之一。Great Expectations 是一款可以帮助你在数据流水线中，编制内建控件用于标记异常和质量问题的框架。就像运行在构建流水线中的单元测试，Great Expectations 在数据流水线的执行过程中作出断言。这不仅对于为数据流水线实现某种 Andon，或是确保基于模型的算法保持在训练数据决定的操作范围内，都有帮助。像这样的自动化控件可以帮助分发以及民主化数据访问和保管。Great Expectations 还配有一个探查工具，帮助理解特定数据集的质量，并设置合适的约束。
Clumio Protect(Oct 2022, 试验)
我们成功地用 Clumio Protect 备份了 AWS 数据，特别是针对 S3 。作为一个商业 SaaS 解决方案，Clumio Protect 还可以备份一系列其他 AWS 服务，并在无法通过互联网访问的地方离线存储数据。我们负责处理大规模数据保护和恢复的团队发现 Clumio Protect 很容易设置和维护；当 S3 存储桶特别大的情况下，其性能远远超过原生的 AWS 备份服务。
用于测试收发邮件的虚拟邮箱服务(Oct 2022, 试验)
使用真实电子邮箱的测试账户，或使用 SMTP（简单邮件传输协议）服务器进行测试仍然是较为常见的软件测试方法。 然而，使用真实的服务进行测试会带来测试邮件将被发送到真实的人的风险，也常常会使自动集成测试变得复杂。 我们完全可以使用 虚拟 SMTP 服务器来测试邮件发送 ，它记录了发送电子邮件的请求，但并没有实际发送。 在这个领域存在多个开源工具，比如 fake-smtp-server，它提供了 Web UI 来展示邮件，便于可视化测试；以及 mountebank，它提供了 REST API 来获取已发送的邮件，便于集成测试。 我们建议探索这种技术，以减少风险，提高测试效率。
Swift Package Manager(Oct 2022, 采纳)
当 Swift 在2014年推出时，并没有发布相应的包管理器。后来，Swift Package Manager 作为苹果官方开源项目创建,该项目在之后的时间中不断发展和成熟。现如今，我们的团队越来越依赖 SwiftPM，因为大多数的依赖包都可以通过它进行管理，并且通过 SwiftPM，依赖包的创建者和使用者的操作流程都得到了极大的简化。在之前的技术雷达中，我们建议大家可以尝试使用该项目进行包管理，但如今，我们认为应该在启动新项目时将其作为首选。对于那些使用 CocoaPods 或 Carthage 等工具的现有项目，进行一个快速试验，来衡量迁移的难易程度，并检查所有依赖项是否都可用是值得的。
Swift Package Manager(Mar 2022, 试验)
一些编程语言，尤其是较新的编程语言，内置了包和依赖管理解决方案。当 Swift 在 2014 年被推出的时候，它并没有附带包管理器，所以 macOS 和 iOS 开发者社区只能继续使用为 Objective-C 创建的第三方解决方案 CocoaPods 和 Carthage。几年后， Swift Package Manager（SwiftPM）作为一个苹果的官方开源项目被推出。那之后又过了几年，苹果才在 Xcode 中添加了对它的支持。尽管如此，在那时，许多开发团队仍在继续使用 CocoaPods 和 Carthage，主要是因为许多软件包根本无法通过 SwiftPM 获得。既然现在大多数包已经被添加在了 SwiftPM 中，并且对于包的创建者和使用者来说，流程都被进一步地简化了，我们的团队也自然地越来越依赖 SwiftPM。
Seldon Core(Oct 2022, 试验)
Seldon Core 是一个在 Kubernetes 集群上打包、部署、监控和管理机器学习模型的开源平台。它针对一些机器学习框架提供开箱即用的支持，你可以很容易的通过各种预打包的推理服务器、定制的推理服务器、以及语言包装器将你的模型容器化。同时，借助 Jaeger 的分布式追踪能力，并通过 Alibi 实现模型可解释性，Seldon Core 解决了阻碍机器学习部署阶段某些最后一公里的难题，因此我们的数据团队非常喜欢它。
跨设备 SDK(Oct 2022, 评估)
随着智能设备持续融入我们的生活，我们开始看到跨越多个设备的新用例出现。典型的例子是我们在手机上开始阅读一则文本但是更喜欢在平板电脑上读完它。其它例子包括在笔记本电脑上绘制骑行路线，然后把数据传输到自行车电脑上以便于导航，或是使用移动手机作为网络摄像头。这些使用场景需要非常特定类型的功能，例如发现附近设备、安全通信以及多设备会话。Apple 不久前已经开始将此类功能引入到它自己的 SDK 中了，现在 Google 也发布了其 跨设备 SDK 的首个预览版本。尽管该预览版本有一些限制——例如，仅支持手机与平板，并且一次仅支持两个设备——但是这项技术还是令人兴奋，在其推出后我们可以随着时间的推移而采用它。
Teleport(Oct 2022, 试验)
Teleport 是访问零信任网络基础设施的工具。传统的设置需要复杂的策略或跳板机来限制对关键资源的访问，然而，Teleport通过统一的访问平面和取代了跳板机、VPN 或共享凭证的细粒度授权控制来简化了这些设置。Teleport 被实现为单个二进制文件，并且开箱即用地支持多种协议（包括 SSH、RDP、Kubernetes API、MySQL、MongoDB 和 PostgreSQL 连接协议），使用户可以轻松设置和管理跨 Linux、Windows 或 Kubernetes 环境的安全访问。自从我们第一次在技术雷达中提到它以来，已经有一些团队使用了 Teleport，整体的积极体验促使我们强调这一平台。
Teleport(Nov 2019, 评估)
Teleport是用于远程访问云原生基础架构的安全网关。其吸引人的功能，是除了用作网关以外，还可以兼作基础设施的证书颁发机构（Certificate Authority，CA）。它可以颁发短期证书，并为Kubernetes基础设施（或仅为SSH）构建更丰富的基于角色的访问控制（role-based access control，RBAC）。随着人们越来越关注基础设施的安全性，更改的跟踪变得非常重要。但是，并非所有事件都需要相同级别的审计。使用Teleport，就可以对于大多数事件仅做记录，而对于拥有更多权限的root会话，则可进一步记录用户的屏幕操作。
Edge Impulse(Oct 2022, 评估)
在往期的技术雷达中，我们写过 TinyML 。TinyML 是在带有板载传感器的小型设备上运行经过训练的模型，在不经过云端的情况下做出决策或提取特征的实践。Edge Impulse 是一个端到端托管平台，用于开发运行在如微控制器等小型边缘设备上的优化模型。该平台指导开发人员完成整个流程，包括收集并给训练数据打标签的任务。你可以轻松地上手，先在手机上进行数据收集和运行分类器，而在更强大的云托管环境中进行模型训练和优化。由此产生的识别算法还可以优化、编译并上传到广泛的微控制器架构中。虽然 Edge Impulse 是一家商业公司，但该平台对开发人员是免费的，即使对那些刚接触机器学习的人来说，整个过程也十分有趣并具有吸引力。创建工作应用程序的低门槛意味着我们将看到更多内置智能决策的边缘设备。
Million(Oct 2022, 评估)
Million 是一个新的虚拟 DOM JS 库。与 Svelte 类似，它使用编译器 Vite, 来创建具有卓越渲染性能的小型JS库。 Million 库作为单个 NPM 包提供，其中包含了多个模块——包括 router , jsx-runtime 和一个用于保证 React 兼容性的模块以创建单页应用程序。尽管 React 在十年前就普及了虚拟 DOM，但在这个领域看到新的创新还是很吸引人的。
Ladle(Oct 2022, 试验)
随着 Storybook 变得受欢迎，它变得越来越像一个庞然大物。如果你真正关心的是隔离和测试你的 React UI 组件，那么 Ladle 是一个替代品。Ladle 支持大多数的 Storybook API （ MDX 文件暂时不支持），且可以作为 Storybook 的替代品。它是轻量级的，与 Vite 有更好的集成。 并且它还提供了简单整洁的能轻易地与其他测试框架集成的 APIs。
移动微前端(Oct 2022, 试验)
自从 2016 年在技术雷达中介绍微前端以来，我们已经看到 Web UI 广泛地采用它们。然而，最近我们看到一些项目把这种架构风格也拓展到了 移动微前端 。当应用程序变得足够庞大与复杂时，就有必要将开发工作分配给多个团队。这提出了围绕团队自治、仓库结构与集成框架的许多挑战。过去，我们提到过 Atlas 与 BeeHive，但是这些框架未能获取关注而且也不再处于活跃开发状态。最近的方法包括用于将多个团队的工作集成到单个应用程序中的 Tuist 或 Swift 包管理器。但根据我们的经验，团队最终经常会实现自己的集成框架。虽然我们毫无疑问看到了在扩充移动开发团队规模时对模块化的需求，但是对微前端的需求却不太确定。这是因为尽管微前端意味着团队与页面或组件之间的直接对应关系，但是这种结构却有可能最终导致业务领域上下文的职责模糊，由此增加团队认知负载。我们的建议是遵循良好、整洁的应用程序设计，当规模扩大为多个团队时采纳模块化，仅当模块与业务领域高度对齐时才采用微前端架构。
移动微前端(Oct 2021, 试验)
自2016年雷达介绍了微前端以来，我们已经看到其在 Web UI 中得到了广泛应用。然而，最近我们发现不少项目也将这种架构风格扩展到了移动应用程序中，亦可称其为移动微前端。当应用程序变得足够庞大且复杂时，有必要将其开发分布在多个团队中。如此一来，在保证团队自治的同时，还要将他们的工作集成到单个应用中是很有挑战的。 有的团队在编写自己的框架来支持这种开发风格，过去我们提到过 Atlas 和 Beehive 可以作为可行框架以简化多团队应用开发的集成问题。最近我们看到有的团队亦使用 React Native 达成了此目标。各个 React Native 微前端在各自的代码仓库中保存，以支持独立的编译、测试和部署。负责整体应用的团队则将各个团队构建的微前端统一集成到发布版本中。
移动微前端(May 2020, 试验)
自2016年雷达对其进行介绍以来，我们已经看到微前端在 Web UI 中得到了广泛应用。 然而，最近我们发现不少项目也将这种架构风格扩展到了移动应用程序中，亦可称其为 移动微前端 。当应用程序变得足够大且复杂时，有必要将其开发分布在多个团队中。如此一来，在保证团队自治的同时，还要将他们的工作集成到单个应用中是很有挑战的。 尽管我们已经看到有的团队在编写自己的框架来支持这种开发风格，但是现有的模块化框架（例如 Atlas 和 Beehive）也可以简化多团队应用开发的集成问题。
生产路径图(Oct 2022, 采纳)
尽管 生产路径图 自从持续交付被编著时在Thoughtworks就是一种近乎普遍的实践，但是我们经常会遇到一些不熟悉生产路径图实践的组织。这一活动经常由一群跨功能团队的人——包括参与设计、开发、发布与运营软件的所有人——在工作坊中完成，他们围在同一张白板前面（或者是一个虚拟的等价物）。首先，按照顺序把流程的步骤罗列出来，从开发阶段一直到发布上产的所有路径。然后，主持一个会议来获取更多的信息和痛点。我们最常见的技术是基于价值流图，尽管有很多具有同等价值的流程图变种。这项活动经常会让参与者眼界大开，因为他们识别出了延迟，风险和不一致的地方，并且可以用可视化的陈述来持续改进构建和部署的流程。我们认为这是一项很基本的技术，所以当我们发现在之前的技术雷达中我们没有提到它的时候，我们感到非常惊讶。
团队的认知负载(Oct 2022, 采纳)
在为组织重新设计业务敏捷性和交付速度时，团队交互是一个关键概念。这些交互将反映在正在构建的软件中（参见康威定律)，并表明团队可以如何有效地自主为客户提供价值。我们的建议是关注团队的设计和互动方式。因为我们相信组织设计和团队交互会随着时间而发展，所以我们认为衡量和跟踪 团队的认知负载 尤为重要，这可以让你理解团队构建、测试和维护其服务的难易程度。我们一直在使用一个模板来评估团队的认知负载，该模板基于高效能团队模式（Team Topologies）作者的想法。\n在与客户沟通和重新设计组织时，应用本书的概念所产生的积极影响给我们留下了深刻的印象。作者推荐了一种简单但强大的组织设计方法，仅确定四种类型的团队和三种交互模式；这有助于减少组织内的歧义，并为团队、利益相关者和领导层提供一个通用词汇来描述和设计团队的工作。为了实施组织设计变更，我们设计了理想的未来团队拓扑结构，应用任何技术/人员限制（即员工不足），然后形成最终的结构。这使我们能够更好地为客户提供建议，并通过比较现有/未来的团队结构来预测我们是否确实在改善认知负载。
团队的认知负载(Mar 2022, 试验)
系统的架构反映了组织架构和沟通机制。我们应当有意识地关注团队如何互动，这并不是什么大新闻，正如康威逆定律 ( Inverse Conway Maneuver )所描述的那样。团队的交互是影响团队向客户交付价值的速度和容易程度的重要因素。我们很高兴找到一种方法来度量这些交互。我们使用高效能团队模式 ( Team Topologies )的作者提供的评估方法，这种评估方法可以让你理解团队构建、测试和维护其服务的难易程度。通过衡量 团队的认知负载 ，我们能够为客户提供更好的建议，帮助他们改变团队架构，改进团队的互动方式。
团队的认知负载(Oct 2021, 试验)
系统的架构反映了组织架构和沟通机制。我们应当有意识地关注团队如何互动，这并不是什么大新闻，正如康威逆定律 ( Inverse Conway Maneuver )所描述的那样。团队的交互是影响团队向客户交付价值的速度和容易程度的重要因素。我们很高兴找到一种方法来度量这些交互。我们使用高效能团队模式 ( Team Topologies )的作者提供的评估方法，这种评估方法可以让你理解团队构建、测试和维护其服务的难易程度。通过衡量 团队的认知负载 ，我们能够为客户提供更好的建议，帮助他们改变团队架构，改进团队的互动方式。
团队的认知负载(Apr 2021, 试验)
系统的架构反映了组织架构和沟通机制。我们应当有意识地关注团队如何互动，这并不是什么大新闻，正如康威逆定律 (Inverse Conway Maneuver)所描述的那样，团队的互动是影响团队向客户交付价值的速度和容易程度的重要因素。我们很高兴找到一种方法来衡量这些互动。我们使用组织架构和高效团队 (Team Topologies)的作者提供的评估方法。这种评估方法可以让你理解团队构建、测试和维护其服务的难易程度。通过衡量 团队的认知负担 ，我们能够为客户提供更好的建议，帮助他们改变团队架构，改进团队的互动方式。
Cruft(Oct 2022, 试验)
自从我们第一次定义微服务 以来，我们就一直在谈论定制化服务模板。如果组织着手创建一个可以独立但一致地开发、构建、部署和操作的微服务集合，那么为团队提供一个符合标准的坚实起点是有意义的。然而，这种方法一个持久的问题是，随着时间的推移，模板会随着技术和业务需求的变化而发展，基于旧版本模板的项目就会过时了。改造模版从而改进已建立的项目成为一个重大的痛点。Cruft 试图通过提供工具来解决这个问题，以识别和修补本地项目与主模板库的当前版本之间的差异。它将 Cookiecutter 模板引擎与git 哈希值相结合，以识别和应用模板的变化。可以把它看作是项目模板的一个包管理器。保持模板的更新是一个众所周知并长期存在的难题，因此对我们来说，Cruft 提供的解决方案听起来好得令人难以置信。然而，根据我们团队先前的反馈，Cruft 确实是有效的，并使服务构建者和维护者的工作更轻松。我们急切地想看看它的长期表现如何，但现在这个可能有用的工具也值得尝试。
Xcode Cloud(Oct 2022, 评估)
Xcode Cloud 是一个集成在 Xcode 中的 CI/CD 工具，用于开发、测试和部署苹果应用程序。它为熟悉 Xcode、App Store Connect 和 Test Flight 的苹果开发人员提供了一体化的体验。根据我们团队的经验，它的优势在于简化流水线配置和创建配置文件和证书。这个工具面世不久，我们大多数的移动端开发团队仍然在使用更为成熟的 Bitrise 。尽管如此，它仍然值得我们去评估和追踪它的发展。
Infracost(Oct 2022, 评估)
我们不断地看到有企业在没有恰当理解如何持续监控云上运营成本的时候向云服务迁移。我们之前提过 将运行成本实现为架构适应度函数 ， 而 Infracost 是一个旨在在 Terraform pull request 中可视化成本权衡的工具。它是一个开源软件，在 macOS、Linux、Windows 和 Docker 均可访问，开箱即用支持 AWS、GCP 和微软 Azure 的定价。它还提供了一个公共 API，可以查询到当前的成本数据。 我们仍然对它的潜力感到兴奋，特别是它还将支持在 IDE 中提供更好的成本可见性。
Infracost(Mar 2022, 评估)
迁移到云端的一个常被提及的优势是将基础设施开销透明化。但根据我们的经验，情况却往往相反。团队并不总是从财务成本的角度来考虑他们围绕基础设施所做的决定，这就是为什么我们之前提到了将运行成本实现为架构适应度函数。我们对一个名为 Infracost 的新工具感到好奇，该工具可以在 Terraform pull request 中可视化成本权衡。它是一个开源软件, 在 macOS、Linux、Windows 和 Docker 均可访问，开箱即用支持 AWS 、 GCP 和微软 Azure 的定价。它还提供了一个公共 API ，可以查询到当前的成本数据。我们的团队对它的潜力感到兴奋，特别是它还将支持在IDE中提供更好的成本可见性。
Teller(Oct 2022, 评估)
Teller 是一款面向开发人员的开源通用密钥管理器，可确保应用程序启动时，环境变量可以被正确地配置。 然而，它本身并非一个存放私密信息的保险库 (vault) ，而是一个可连接多种源的 CLI 工具，从云密钥提供者到诸如 HashiCorp Vault 的第三方解决方案再到本地环境文件。 Teller 还具有如下的额外功能：扫描代码中保存在 vault 中的密钥、编辑日志中的密钥、检测各密钥提供者之间的变化并进行同步。鉴于访问密钥访问行为的敏感性，无论如何强调对开源依赖供应链安全保障的必要性都不为过，但我们依然欣赏 Teller 作为一款 CLI 工具在本地开发环境、 CI/CD 流水线和部署自动化中的使用便捷性。
Databricks Photon(Oct 2022, 试验)
自 Databricks 9.1 LTS （长期支持版）开始，新运行时 Databricks Photon 开始可用，它是一个使用 C++ 重新从底层构建的替代品。现在我们的许多团队在生产中使用了 Photon，并对它的性能提升和因此带来的成本节约感到满意。实际使用中的提升和成本变化受到包括数据集大小和事务类型在内的多种因素影响，所以我们推荐在决定使用 Photon 前进行试验以获得数据进行比较，而非直接用于真实的工作负载。
Soketi(Oct 2022, 评估)
Soketi 是一个开源的WebSockets服务器。如果你的应用程序兼容Pusher协议，你可以直接接入Soketi，因为它完全遵循了 Pusher协议版本7。我们发现由 Cloudflare Workers 提供的 beta 支持 非常有趣，因为它打开了在网络边缘使用 WebSockets 的大门。
dbtvault(Oct 2022, 评估)
Data Vault 2.0 是一种数据建模方法和设计模式，相对于其他流行的建模方法，它的目的是进一步提高数据仓库的灵活性。Data Vault 2.0可以应用于任何数据存储中，例如 Snowflake 或 Databricks。当实现 Data Vault 仓库时，我们发现 dbt 的 dbtvault 包是一个有用的工具。dbtvault 提供了一组 jinja 模版，用于生成和执行填充 Data Vault 仓库所需的 ETL 脚本。尽管 dbtvault 存在一些小缺陷，如它缺乏对强制隐含惟一性和增量加载的支持。但总的来说，它填充了市场空白并且只需最小配置即可开始使用。
BERT(Oct 2022, 试验)
自我们上次在技术雷达中谈到 BERT （来自变换器的双向编码器表征量）之后, 我们团队已经成功地在一些自然语言处理 (NLP) 项目中使用了它。在其中一个项目里，当我们把默认的 BERT 分词器换成一个经过领域训练的词块 (word-piece) 分词器，再去处理那些含有品牌名称或者维度之类名词的查询任务时，我们看到了显著的改进。虽然 NLP 有一些新的转换模型，但 BERT 凭借优秀的文档以及活跃的社区支持，更加通俗易懂，而且我们也一直发现它在企业级 NLP 背景下非常有效。
BERT(Nov 2019, 评估)
BERT代表来自变换器的双向编码器表征量。它是Google在2018年十月份提出的一种新的预训练表示方法。BERT通过获得各种自然语言处理（NLP）任务的最高水平结果，极大地改变了自然语言处理（NLP）的格局。基于转换器架构，它在训练期间从令牌的左右预警中学习。Google还发布了经过预训练的通用BERT模型，该模型已针对包括Wikipedia在内的大量未标记文本进行了训练。开发人员可以在其特定于任务的数据上，使用和微调这些经过预训练的模型，并获得出色的结果。我们已经在2019年四月份的技术雷达上讨论过NLP的迁移学习；BERT以及它的后继者会继续使NLP的迁移学习成为一个令人兴奋的领域，NLP的迁移学习可以大大减少处理文本分类的用户工作量。
碳效能作为软件架构的特性(Oct 2022, 评估)
可持续发展是一个需要企业持续关注的话题。在软件开发领域，可持续发展的重要性日益显著，并且我们也可以看到出现了很多不同的达成途径。 例如，在构建软件碳足迹方面，我们建议对 碳效能作为软件架构的特性 进行评估。一个重视碳效能的架构会将碳效率作为架构设计和基础设施选型的考虑因素，以最大限度地减少能源消耗，进而实现减少碳排放。该领域的测量工具和开发建议也日趋成熟，使得开发团队可以将碳效能与性能、可扩展性、财务成本和安全性等其他因素一起进行考量。就像软件架构中的所有因素一样，碳效能应该被视为一种权衡。我们建议将碳效能视为构成架构的一整套质量属性中的一个附加特性。因为这类特性应由组织目标驱动并划分优先级，而不应该留给一小部分专家孤立地思考。
Feast(Oct 2022, 试验)
Feast 是一个用于机器学习的开源 Feature Store 。它具有几个有用的特性，包括生成时间点 (point-in-time) 正确的特征集——以避免在训练时将容易出错的未来特征值泄露给模型——以及支持流数据源与批数据源。然而，它目前仅支持具有时间戳的结构化数据，因此，如果你在模型中处理非结构化数据，那么 Feast 可能并不适用。我们已成功地大规模采用 Feast 作为模型训练时的离线存储与预测时的在线存储。
CI/CD 流水线的可观测性(Oct 2022, 试验)
可观测性实践已经将对话从监测通俗易懂的问题转换为帮助解决分布式系统中的未知问题。通过应用 CI/CD 流水线的可观测性 ，我们已经看到在传统生产环境之外采纳这种立场以帮助优化测试与部署瓶颈的成功。复杂的流水线会在运行太慢或遭受非确定性影响时给开发者带来摩擦，进而减少关键反馈循环并且阻碍开发者效率。此外，它们作为关键部署基础设施的角色在快速部署周期中产生了压力点，就像一些组织在应对最近的 log4shell 漏洞时所发生的那样。追踪的概念能够很好地转移到流水线上：子跨度抓取构建每个阶段的信息，而不是抓取服务调用级联。在分布式架构中用于分析调用流的瀑布图同样可以有效地帮助我们识别流水线瓶颈，甚至是那些扇入扇出的复杂流水线。这使得针对性大幅提高的优化工作成为可能。 尽管此项技术适用于任何追踪工具，但是 Honeycomb 支持一个名为 buildevents 的工具，其有助于抓取流水线追踪信息。一种替代方案，即抓取已经由 CI/CD 平台暴露的信息，由 buildviz （由一位 Thoughtworker 构建并维护）采纳，允许在不更改步骤配置文件自身的情况下进行相似的调查。
增量开发人员平台(Oct 2022, 试验)
自从2017年以来，我们几乎每一期技术雷达都写过关于开发人员平台以及如何构建它们的内容。与此同时，团队拓扑学这本书还很好地描述了一个理想的平台，即用“自服务的 API、工具、服务和知识”来支持开发人员。然而，我们经常看到团队对于实现这种平台的愿景操之过急。事实上，构建一个 增量开发平台 才是关键所在。\n团队拓扑学建议在任何特定阶段，都努力去实现一个所谓的“最小可行平台”，这个平台的第一版甚至可以是一系列的 wiki 文档。下一个增量可以通过提供模版或允许成员创建请求来提高服务水平。进一步的增量可以引入自服务 API，但前提是有价值。简而言之，尽管我们小心地反对全量工单驱动的平台运营模式，但从零到自服务是另一个极端。调整你自己的步调，将产品管理思维应用于内部平台 并逐步增量地建立它。
k6(Oct 2022, 采纳)
自从我们第一次在技术雷达中提及k6 以来，它正逐渐成为性能测试的首选工具。我们非常喜欢它。因为它很容易为测试编写 JavaScript 代码，此外 k6 也有一个低代码测试生成器，使它更易于使用。文档显示 k6 可以很容易地在多种CI/CD流水线中添加性能测试。我们的团队发现，k6 很容易与可视化工具集成，如Grafana和New Relic，这有助于调试基础设施和应用程序。当需要测试系统在重负荷下的行为时，k6 对开发者友好的特性及其生态系统，让它成为了不二之选。
k6(Apr 2021, 试验)
自从第一次将k6放入技术雷达中，我们对使用k6进行性能测试有了更多经验，使用结果也很不错。我们的团队很喜欢这种关注开发人员体验并且很灵活的工具，虽然k6很容易上手，但它真正的亮点在于很容易集成到开发人员的生态系统当中。比如 Datadog 适配器，团队能快速可视化分布式系统中的性能，并在将系统发布到生产环境之前识别重大的问题。再比如另一个团队使用k6的商业版本，可以使用Azure流水线插件商店将性能测试集成进他们的持续交付流水线中，并可以轻松获得Azure DevOps报告。由于k6支持允许自动化测试断言的阈值，因此在流水线中添加一个阶段来检测新增代码是否会导致性能下降会变得更轻松，从而为开发人员添加强大的反馈机制。
k6(Oct 2020, 评估)
我们对 k6 的出现感到很兴奋，它是性能测试生态环境中比较新的一款工具，尤其注重开发者体验。k6 命令行运行器执行 JavaScript 编写的脚本，并让你配置执行时间和虚拟用户的数目。它的命令行有一系列高级特性，比如可以在测试执行完成前，让你看到当前的统计数据，动态伸缩最初定义的虚拟用户数量，甚至暂停和继续一个运行中的测试。命令行输出提供了一套带有转换器的可定制指标，能让你在 Datadog 和其他观察工具中可视化结果。为你的脚本添加 checks，可以很容易将性能测试集成到你的CI/CD流水线中去。如果要加速性能测试，可以看看它的商业版本 k6 Cloud，它提供了云伸缩以及额外的可视化能力。
数据网格(Mar 2022, 试验)
数据网格 是一种面向分析和机器学习的技术方法，以去中心化的组织和技术方式分享、访问和管理数据。当前数据组织架构日渐复杂，数据使用案例激增以及数据源愈加多样化，面对当前的数据环境，数据网格希望创建一种社会技术方法，旨在规模化的获取数据中的价值。从本质上讲，它创建了一个可靠的数据共享模式，与组织同步发展并持续拥抱变化。据我们所知，业界对数据网格的兴趣正在显著增长。这种方法已经激发了许多组织去拥抱它所提倡的内容，技术供应商也使用现有技术为数据网格找到了新的部署方式。尽管业界对数据网格颇有兴趣，并且也越来越有经验，但是其实施却面临着高昂的整合成本。此外，它所提倡的内容仍旧局限于那些依据数据网格的硬性社会层面进行组织拆分的大型机构以及技术供应商——去中心化的数据所有权和联合治理的运作模式。\n这些想法在 Data Mesh: Delivering Data-Driven Value at Scale 一书中被探讨，用于指导从业人员、架构师、技术领导以及决策者从传统大数据架构到数据网格的转型。该书完整地介绍了数据网格的原理及其构成要素；涵盖了如何设计数据网格架构、指导和执行数据网格战略以及引导组织设计向去中心化的数据所有权模式发展。本书的目标是为更深层次的对话创造一个新的框架，并引导数据网格到成熟的下一阶段。
数据网格(Oct 2021, 试验)
我们越来越多地看到数据驱动的组织想要实现的目标，与当前数据架构和组织结构所允许的目标是不匹配的。组织希望将数据驱动决策、机器学习和分析嵌入到其产品和服务以及内部运营的许多方面中；从本质上讲，他们希望通过数据驱动的智能来增强其运营环境的各个方面。然而，在我们可以嵌入分析数据、访问并在业务领域和运营中管理这些数据之前，还有很长的路要走。现在，管理分析数据的各个方面，都被外部化到运营业务领域之外的数据团队和数据管理单体：数据湖和数据仓库。数据网格 用于消除分析数据和业务运营的二分法，是一种去中心化的社会技术方法。其目标是将分析数据的共享和使用嵌入运营业务的各个领域，并缩小运营和分析平台之间的差距。它建立在四个原则之上: 域数据所有权、数据即产品、自助数据平台和计算联合治理。\n我们的团队一直在实施数据网格架构；他们创建了新的架构抽象，例如数据产品量子，可以将代码、数据和策略作为分析数据共享的自治单元进行封装，嵌入到运营域中；他们还构建了自助数据平台功能，以声明方式管理数据产品量子的生命周期，如数据网格。尽管我们的技术取得了进步，但仍然在数据网格拓扑中使用现有技术时遇到了阻力，更不用说在某些组织中，将共享和使用数据作为业务领域的首要职责时所遭遇的抵抗。
数据网格(Oct 2020, 试验)
在管理大量分析数据方面，Data mesh 标志着架构和组织范式的一种可喜转变。该范式建立在四个原则之上：(1)数据所有权和架构的面向领域去中心化;(2)将面向领域的数据视为产品;(3)将自助数据基础设施作为平台，支持自治且面向领域的数据团队;(4)联合控制以实现生态系统和互操作性。尽管这些原则很直观，并且只是试图解决以前集中分析数据管理的许多已知挑战，它们仍胜过了现有的分析数据技术。在现有工具之上为多个客户端构建数据网格后,我们学到了两件事:(a)要加速数据网格的实现，在开源或商业工具上仍存在着巨大的差距（例如,我们目前为客户自定义构建的基于时间的多语言数据，实现通用访问模型）；(b)尽管存在差距,使用现有技术作为基本构建块仍是可行的。\n自然，技术匹配是实现企业基于数据网格的数据策略的主要组成部分。不过，要想成功，就需要进行组织结构调整，将数据平台团队分离开来，为每个领域创建数据产品负责人的角色，并引入必要的奖励机制，让领域将其分析数据作为产品，对其负责，并分享出去。
数据网格(May 2020, 评估)
数据网格是一种架构和组织范式，它挑战了我们的传统观念 , 即必须将大量的可分析数据集中起来才能使用，将数据放在一起或让专门的数据团队来维护。数据网格声称，为了让大数据推动创新，数据的所有权必须和将数据作为产品提供服务的领域数据所有者联合起来（在自助数据平台的支持下，抽象数据产品服务所涉及的技术复杂性）；它还必须通过自动化的方式实现一种新的联合治理形式，以支持面向领域的数据产品间的互操作性。去中心化、互操作性以及数据消费者体验，是数据创新民主化的关键。\n如果你的组织有大量的领域，包括大量产生数据的系统和团队，或者多种数据驱动的用户场景和访问模式，我们建议你评估数据网格。构建数据网格需要的投资包括构建自服务的数据平台、支持对领域进行组织结构变更以长期维护其数据产品，以及一个激励机制，来奖励将数据作为产品提供和使用的领域团队。
数据网格(Nov 2019, 评估)
数据网格是一种可以解锁大规模数据分析的架构范式；快速解锁对越来越多的分布领域数据集的访问，从而支撑跨组织的大量数据的使用场景，如机器学习、分析或数据密集型应用程序。数据网格解决了传统集中式数据湖或数据平台体系结构的常见故障模式，它改变了数据湖及其前身数据仓库的集中式范式。数据网格的范式借 鉴了现代分布式体系结构：将领域作为首要关注点，应用平台思维来创建自服务的数据基础设施，将数据视为产品，并应用开放标准化，从而实现可交互的分布式数据产品生态系统。
CircleCI(Mar 2022, 试验)
我们的许多团队选择 CircleCI 来满足他们的持续集成需求，他们很欣赏它高效运行复杂流水线的能力。CircleCI 的开发人员在持续增加 CircleCI 的新功能，现在是3.0版本。我们的团队认为其中 Orbs 和 executors 非常有用。Orbs 是可重复使用的代码片段，可用来自动化重复的流程，进而加快项目的配置，并使其易于与第三方工具集成。多种多样的 executor 为在 Docker、Linux、macOS 或 Windows 虚拟机中配置作业提供了灵活性。
CircleCI(May 2018, 试验)
CircleCI is a continuous integration engine offered as SaaS and on premise. CircleCI has been the go-to SaaS CI tool for many of our development teams, who needed a low-friction and easy-to-setup build and deployment pipeline. CircleCI version 2.0 supports workflows of build jobs, with fan-in and fan-out flows and manual gates, as well as mobile development. It allows developers to run the pipelines locally and easily integrates with Slack and other notification and alerting systems. We recommend you take a closer look at the security practices of CircleCI, just as you would with any other SaaS product that hosts your company’s assets.
CircleCI(Nov 2017, 试验)
CircleCI is a continuous integration engine offered as SaaS and on premise. CircleCI has been the go-to SaaS CI tool for many of our development teams, who needed a low-friction and easy-to-setup build and deployment pipeline. CircleCI version 2.0 supports workflows of build jobs, with fan-in and fan-out flows and manual gates, as well as mobile development. It allows developers to run the pipelines locally and easily integrates with Slack and other notification and alerting systems. We recommend you take a closer look at the security practices of CircleCI, just as you would with any other SaaS product that hosts your company’s assets.
Terraform Validator(Mar 2022, 评估)
一些已经采用了基础设施即代码和自服务基础设施平台的组织，正在寻找在执行良好安全实践和组织政策的同时，能给予团队最大限度自主权的方法。我们之前已经着重强调过 tfsec，并在这一期技术雷达中将它挪到了采纳中。对于使用谷歌云平台（GCP）的团队来说，可以使用 Terraform Validator构建策略库，作为检查 Terraform 配置的约束条件。
测试环境中的生产数据(Mar 2022, 暂缓)
我们一直认为 测试环境中的生产数据 是值得关注的领域。首先，它引发了许多最终导致了声誉受损的案例，例如从测试系统向整个客户群发送了不正确的警报。其次，测试系统的安全级别往往较低，尤其是围绕隐私数据的保护。当每个开发和测试人员都可以访问测试数据库中的生产数据副本时，对生产数据访问的精心控制就失去意义了。尽管您可以混淆数据，但这往往仅适用于特定字段，例如信用卡号。最后一点，当从不同国家或地区托管或访问测试系统时，将生产数据复制到测试系统可能会违反隐私法，这在复杂的云部署中尤其麻烦。为解决这些问题，使用假数据是一种更安全的策略。现存的工具也能帮我们创建假数据。在某些场景，例如重现错误或训练特定的机器学习模型时，我们承认确实有复制生产数据特定元素的必要。但我们建议此时一定要谨慎行事。
测试环境中的生产数据(Oct 2021, 暂缓)
我们一直认为 测试环境中的生产数据 是值得关注的领域。首先，它引发了许多最终导致了声誉受损的案例，例如从测试系统向整个客户群发送了不正确的警报。其次，测试系统的安全级别往往较低，尤其是围绕隐私数据的保护。当每个开发和测试人员都可以访问测试数据库中的生产数据副本时，对生产数据访问的精心控制就失去意义了。尽管您可以混淆数据，但这往往仅适用于特定字段，例如信用卡号。最后一点，当从不同国家或地区托管或访问测试系统时，将生产数据复制到测试系统可能会违反隐私法，这在复杂的云部署中尤其麻烦。为解决这些问题，使用假数据是一种更安全的策略。现存的工具也能帮我们创建假数据。在某些场景，例如重现错误或训练特定的机器学习模型时，我们承认确实有复制生产数据特定元素的必要。但我们建议此时一定要谨慎行事。
可组合架构(Mar 2022, 评估)
随着时间的推移， iOS 应用程序开发变得越来越顺畅， SwiftUI 进入采纳环就是一个标志。作为应用构建工具库与架构风格的集合体，可组合架构 (TCA) 在 SwiftUI 和其他常见框架之上更进了一步。TCA 是在一系列视频课程的基础上设计的。作者表示，他们在 The Elm Architecture 和 Redux 的基础上考虑了构图、测试和人体工程学。正如预期的那样，“适用面窄”和“有态度性 (opinionatedness)”既是 TCA 的优势也是劣势。我们认为，对于需要维护多种不同技术栈代码库的团队来说，如果他们对编写 iOS 应用没有太多专业知识时，他们就能从使用像 TCA 这样的“有态度”的框架中获取最大收益。我们很喜欢 TCA 表现出的这种“态度”。
Java 17(Mar 2022, 评估)
我们通常不会专门介绍某一语言的新版本，但我们还是想关注一下 Java 新的长期支持 (LTS) 版本—— Java 17。尽管出现了前景不错的新特性，比如模式匹配等预览特性，但其实向新 LTS 版本升级的方案更应该吸引各个组织的兴趣。我们建议各个组织在 Java 有新的发布时对其进行评估，确保能够恰当地适配这些新特性和版本。尽管定期更新有利于简化开发并且方便管理，但许多组织却意外地并不经常更新语言的版本。希望通过 LTS 版本的升级以及开发团队对语言的定期更新，能够使生产软件免于因为“更新成本太高”而一直困在 Java 的过时版本上。
Conftest(Mar 2022, 试验)
Conftest 是一款针对结构化配置数据编写测试的工具。它依赖于开放策略代理中的 Rego 语言，能够为 Kubernetes 配置、Tekton 的流水线定义、甚至 Terraform 计划编写测试。在我们的实际使用中，Conftest 的体验一直都非常棒，这也得益于它平缓的学习曲线。借助测试的快速反馈，我们的团队可以又快又安全地迭代变更 Kubernetes 的配置。
Conftest(Oct 2021, 评估)
Conftest 是一款为结构化配置数据编写测试的工具。它使用开放策略代理 (OPA)中的策略定义语言 Rego ，来为 Kubernetes 的配置文件、 Tekton 的 pipeline 定义文件、甚至是 Terraform 的计划文件编写测试。配置是基础设施的的关键部分，我们推荐您评估使用 Conftest 来进行假设验证并得到快速反馈。
jc(Mar 2022, 评估)
在之前的技术雷达中，我们将 现代 Unix 命令 放在了评估状态。在该工具集中， jq 命令实际上是一个支持 JSON 的 sed。而 jc 命令执行的是与之相关的任务：它获取常见 Unix 命令的输出，并将输出解析为 JSON。jq 和 jc 这两个命令一起为 Unix CLI 世界以及大量基于 JSON 工作的库和工具之间架起了一座桥梁。当编写一些像软件部署或者故障诊断信息收集的简单脚本时，将五花八门的 Unix 命令输出格式映射到定义明确的 JSON，可以为我们节省大量的时间和精力。与 jq 命令一样，你需要确保该命令可用。它可以通过许多著名的软件库进行安装。
Apache Iceberg(Mar 2022, 评估)
Apache Iceberg 是一个面向超大的分析数据集的开放表格格式。Iceberg 支持现代数据分析操作，如条目级的插入、更新、删除、时间旅行查询、ACID 事务、隐藏式分区和完整模式演化。它支持多种底层文件存储格式，如 Apache Parquet、Apache ORC 和 Apache Avro。已有许多数据处理引擎支持 Apache Iceberg，包括一些 SQL 引擎，如 Dremio 和 Trino，以及（结构化）流处理引擎，如 Apache Spark 和 Apache Flink。
无边车服务网格(Mar 2022, 评估)
服务网格的通常实现形式为与每个服务实例一并部署的反向代理进程，即“边车 (Sidecar)”。尽管这些“边车”属于轻量级进程，但每个新服务实例的创建都意味着一个“边车”的新增，采用服务网格的整体开销和运维复杂度也会随之增加。然而，随着 eBPF 的发展，我们发现一种被称为无边车服务网格的模式能够将网格的功能安全地下沉到操作系统内核层，从而使得相同节点上的服务可以通过套接字透明地通信，而无需额外的代理。您可以通过Cilium 服务网格对上述模式进行尝试，并从“每个服务一个代理”的部署模式简化为“每个节点一个代理”。我们对 eBPF 的能力十分感兴趣，并发现这一服务网格的演进十分重要且值得评估。
文档象限(Mar 2022, 试验)
在软件开发中，撰写良好的文档总是被忽视的一环，它经常被留到最后被随意地完成。 我们的团队发现文档象限是一种确保生成正确文档的便捷方式。 该技术沿两个轴对文档进行分类：第一个轴与文档信息的性质有关——实践的或是理论的； 第二个轴描述了文档的使用情境——学习或是工作。 这样定义的四个象限中就可以放置和帮助人们理解诸如教程、操作指南或参考页面之类的文档。该分类系统不仅可以确保关键文档不会被遗漏，而且还可以指导内容的呈现方式。 我们发现这十分有助于创建入门文档，可以让开发人员在加入新团队时快速上手。
GoReleaser(Mar 2022, 评估)
GoReleaser 是一个通过多个库和通道来支持不同架构的 Go 项目自动化构建和发布的工具，这是面向不同平台 Go 项目的常见需求。你可以在本地机器或者 CI 上运行该工具，它支持在多种 CI 服务上运行，从而最大限度降低安装和维护成本。GoReleaser 能够用于每个发布版本的构建、打包、发布和声明，并且支持不同的包格式、包库和源代码控制的组合。虽然它已经出现好几年了，但我们惊讶并没有多少团队使用它。如果你经常发布 Go 代码库，这个工具值得一试。
AKHQ(Mar 2022, 试验)
AKHQ 是 Apache Kafka 的图形用户界面(GUI)，可以帮助你管理主题、主题数据、消费者组等。我们的一些团队发现 AKHQ 是用来监控 Kafka 集群实时状态的有效工具。比如，你可以浏览集群上的主题，对于每个主题，你都能可视化它的名称、存储的消息数量、使用的磁盘空间、最后一条记录的时间、分区数、同步数量的复制因子和消费者组。通过 Avro 和 Protobuf 的反序列化，AKHQ 可以帮助你了解 Kafka 环境中的数据流。
Google Cloud Dataflow(Mar 2022, 试验)
Google Cloud Dataflow 是一个基于云平台的数据处理服务，适用于批量处理和实时流数据处理的应用。我们团队正在使用 Dataflow 来创建用于集成、准备和分析大数据集的数据处理流水线，在这之上使用 Apache Beam 的统一编程模型来方便管理。我们在2018年首次介绍了 Dataflow，它的稳定性、性能和丰富的功能让我们有信心在这一次的技术雷达中将它移动到试验环。
Google Cloud Dataflow(Nov 2018, 评估)
Google Cloud Dataflow is useful in traditional ETL scenarios for reading data from a source, transforming it and then storing it to a sink, with configurations and scaling being managed by dataflow. Dataflow supports Java, Python and Scala and provides wrappers for connections to various types of data sources. However, the current version won’t let you add additional libraries, which may make it unsuitable for certain data manipulations. You also can’t change the dataflow DAG dynamically. Hence, if your ETL has conditional execution flows based on parameters, you may not be able to use dataflow without workarounds.
CycloneDX(Mar 2022, 评估)
CycloneDX 是一个用来描述机器可读的软件物料清单 (SBOM) 的标准。随着软件和计算架构日渐复杂，软件变得越来越难以定义。CycloneDX 起源于 OWASP，它对旧的 SPDX 标准进行了改进，提供了更广泛的定义，不仅包含了本地机器依赖，还包含运行时服务依赖。你还会发现它提供了一个用于集成的生态系统，包括多种编程语言的实现，以及允许你通过适当的签名和验证来分析和更改 SBOM 的命令行工具]。
SwiftUI(Mar 2022, 采纳)
对于在苹果生产的各种设备上实现用户界面来说，苹果在几年前推出SwiftUI是一个很大的进步。从一开始，我们就喜欢Combine提供的声明式的、以代码为中心的方法和反应式编程模型。但我们注意到，在苹果提供的XCUITest自动化框架下，仍需使用模型-视图-视图模型（MVVM）模式编写大量的视图测试，并不是非常合理。这个缺陷已经被ViewInspector所弥补。最后一个障碍是所需的最低操作系统版本。在发布时，只有最新版本的iOS和macOS可以运行用SwiftUI编写的应用程序，但由于苹果的定期更新，SwiftUI应用程序现在几乎可以在所有接受安全更新的macOS和iOS版本上运行。
SwiftUI(May 2020, 试验)
苹果已在其新的 SwiftUI 框架上迈出了一大步，该框架用于在 macOS 和 iOS 平台上实现用户界面。我们很高兴 SwiftUI 跨越了 Interface Builder 和 XCode 之间略显混乱的关系，并采用了一致的、声明性的以及以代码为中心的方式。现在，你可以在 XCode 11 中并排查看代码和生成的可视化界面，从而获得更好的开发人员体验。 SwiftUI 框架还从近年来主导Web开发的 React.js 世界汲取了灵感，它利用视图模型的不可变值和异步更新机制，构成了统一的反应式编程模型。这为开发人员提供了一个完全原生的替代品，以替代类似 React Native 或 Flutter 这样的反应式框架。 SwiftUI 无疑代表了 Apple UI 开发的未来，尽管很新，但它已经显示出优势。它和它平缓的学习曲线给予我们非常棒的体验。值得注意的是，鉴于它不支持iOS 12以及更低版本，因此在使用SwiftUI之前，你应该首先了解客户的使用场景。
SwiftUI(Nov 2019, 评估)
苹果在其新的SwiftUI框架上迈出了一大步，该框架用于在macOS和iOS平台上实现用户界面。我们很高兴SwiftUI跨越了Interface Builder和XCode之间略显混乱的关系，并采用了一致的、声明性的和以代码为中心的方式。现在，你可以在XCode 11中并排查看代码和生成的可视化界面，从而获得更好的开发人员体验。SwiftUI框架还从近年来主导Web开发的React.js的世界中汲取了灵感，它利用视图模型中的不可变值和异步更新机制，构成了统一的反应式编程模型。这为开发人员提供了一个完全原生的替代品，以替代类似React Native或Flutter之类的反应式框架。尽管SwiftUI确实代表了Apple UI开发的未来，但它是一个相当新的事物，还需要花费一些时间来打磨。我们期待改进的文档，和一个可以为测试与其他工程化问题建立一套实践的开发者社区。
Azure Pipeline模板(Mar 2022, 试验)
Azure Pipeline模板提供了两种机制来对 Azure Pipeline定义去重。通过 "includes" 模板，你可以引用一个模板使其像参数化的 C++ 宏一样内联展开，从而以一种简单的方式将各个阶段、任务和步骤的公共配置分解出来。通过 "extends" 模板，你可以定义一个具有公共流水线配置的外壳，结合所需模板检查机制，如果流水线没有扩展特定的模板，你可以拒绝构建以防止对流水线配置本身的恶意攻击。Azure Pipeline模板、CircleCI Orbs 以及刚崭露头角的GitHub Actions 可复用工作流，是流水线设计模块化趋势在不同平台上的体现，我们从多个团队收到了好的反馈。
Github Actions 中的可复用工作流(Mar 2022, 试验)
自从在两期技术雷达之前首次发布了GitHub Actions后，我们关注到业界对于 GitHub Actions 的兴趣在持续上升。GitHub 一直在持续迭代演进该产品，可复用工作流的发布解决了一些早期的缺陷。 Github Actions 中的可复用工作流 将流水线设计模块化，只要工作流依赖的代码仓库是public状态，你甚至可以跨代码仓库进行参数化复用。可复用工作流不但支持将机密值作为秘钥显示传递，也支持将输出结果传递给调用任务。无需离开GitHub这个平台，只需配置几行 YAML 文件，GitHub Actions就能为你提供CircleCI Orbs或Azure Pipeline Templates在 CI 方面的灵活性。
NUKE(Mar 2022, 试验)
NUKE 是一个面向 .NET 的构建系统，也是传统的 MSBuild、Cake 以及 Fake 等自动化构建系统的替代品，我们曾在之前的技术雷达中介绍过它们。NUKE 以 C# 领域特定语言（DSL）的形式表达构建指令，不但降低了学习成本，而且 IDE 支持性也很好。在我们的实际体验中，使用 NUKE 进行 .NET 项目的自动化构建十分便捷。我们喜欢 NUKE 提供的精准代码静态检查和提示功能，并且它支持无缝使用各种 NuGet 包，这样可以编译自动化代码，避免运行时发生错误。尽管 NUKE 已不是新技术，但它采用 C# DSL 的全新方法，以及使用 NUKE 时全方位的良好体验，促使我们一定要将它收录在技术雷达里。
MistQL(Mar 2022, 评估)
MistQL 是一个在类 JSON 结构上执行计算的小型领域特定语言。MistQL 最初的设计是用于在前端手动提取机器学习模型的特征，而如今它有了能够运行在浏览器端的 JavaScript 实现版本以及能够运行在服务器端的 Python 实现版本。我们非常喜欢 MistQL 的简洁组合函数式语法，并建议你根据需要进行试用。
Lighthouse(Mar 2022, 试验)
Lighthouse 是一个由 Google 编写的工具，可以评估 Web 应用和页面，以及从出色的开发实践中收集性能指标和洞见等信息。我们一直主张性能测试乃第一公民, 五年前技术雷达中提到的对 Lighthouse 的补充内容对此也有帮助。我们关于适应度函数的思考，也为在构建流水线中运行 Lighthouse 这样的工具创造了强烈的动机。随着 Lighthouse CI 的引入，将 Lighthouse 纳入由不同工具管理的流水线，会变得比以往任何时候都容易。
Lighthouse(Nov 2017, 评估)
Lighthouse is a tool written by Google to assess web applications for adherence to Progressive Web App standards. This year's Lighthouse 2.0 release adds performance metrics and accessibility checks to the basic toolset. This added functionality has now been incorporated into the standard Chrome developer tools under the audit tab. Lighthouse 2.0 is yet another beneficiary of Chrome's headless mode. This provides an alternative to Pa11y and similar tools for running accessibility checks in a continuous integration pipeline, since the tool can be run from the command line or standalone as a Node.js application.
生产就绪的定义(Mar 2022, 试验)
在一个实践“谁构建，谁运行”原则的组织中， 生产就绪的定义 （definition of production readiness DPR）是一个可以支持团队评估和准备新服务上线运营就绪情况的有用技术。DPR 以清单或者模板的形式实现，为团队在新服务投入生产前应该考虑的内容提供指导。尽管 DPR 没有定义要实现的特定服务级别的目标（service-level objectives SLOs）（这些目标很难被一刀切地定义），但它们提醒团队要考虑哪些类别的 SLO ，要遵守哪些组织标准，还有需要哪些文档。DPR 提供了一个输入源，团队将这个输入源转换为各自产品特定的需求，以注入到他们的产品待开发项中例如可观察性和可靠性。\nDPR 和 Google 的 生产就绪审查 production readiness review (PRR) 密切相关。因组织太小而无法拥有专门的网站可靠性工程团队，或者是担心评审过程可能会给团队上线的流程带来负面影响时，DPR 至少可以为组织提供一些指导，并记录商定好的准则。对于非常关键的新服务，可以在需要时通过 PRR 来添加额外的审查来实现 DPR。
Pactflow(Mar 2022, 试验)
在长时间使用 Pact 进行契约测试的过程中，我们目睹了规模化带来的复杂性。我们的一些团队已经使用 Pactflow 成功减少了这种复杂性引发的后果。 Pactflow 既可以作为 SaaS 运行，也可以部署在本地，并提供与 SaaS 产品相同的功能，它在开源产品 Pact Broker 的基础上，提升了可用性、安全性以及审计体验。到目前为止，我们很满意 Pactflow 的使用体验，并且很高兴看到它在持续致力于降低管理大规模契约测试所带来的开销。
Pactflow(Oct 2021, 评估)
我们认为对于那些拥有大型复杂API生态系统的组织，特别是当他们已经在使用 Pact 的情况下，非常值得评估一下 Pactflow 。Pactflow 可以管理那些使用 Pact 编写的工作流程和持续部署测试代码，从而降低通往 消费者驱动的契约测试 的门槛。多个生产者和大量不同的消费者之间协作的复杂性往往会让人望而却步。很多团队投入了大量的精力，尝试通过手动的方式来解决这个问题，因此我们认为很值得评估一下 Pactflow，看它是否可以帮我们解决这个问题。
Embeddinghub(Mar 2022, 评估)
Embeddinghub 是一个与 Milvus 十分类似的，面向机器学习嵌入领域的向量数据库。不同的是，它提供了开箱即用的近似最邻近运算、表分区、版本及访问控制等功能，我们建议你根据你的嵌入向量化场景对Embeddinghub进行评估。
tfsec(Mar 2022, 采纳)
对于那些我们正在使用Terraform的项目来说，在需要检测潜在安全风险时，tfsec已经迅速成为默认的静态分析工具。它很容易被集成到CI流水线，而且拥有一个持续增长的检查库，可以用来检查所有主要的云供应商和诸如Kunernetes的平台。鉴于它的易用性，我们相信对任何Terraform项目而言，tfsec都会是一个非常好的补充。
tfsec(Oct 2020, 试验)
安全是每个人都关心的问题，而防微杜渐永远都好过亡羊补牢。在基础设施即代码 领域，Terraform 已经成为管理云环境的不二之选，而且我们现在还有了 tfsec，一个可以用来扫描 Terraform 模板并发现潜在安全问题的静态分析工具。我们的团队在 tfsec 的使用上已经积累了非常成功的经验。tfsec 非常易于安装和使用，这使得它对于任何决心通过规避安全风险避免漏洞产生的开发团队而言，都是最佳的选择。针对不同的云提供商 tfsec 都预设了扫描规则，包括AWS 和 Azure。对使用 Terraform 的团队而言，tfsec 实在是一个福音。
tfsec(May 2020, 评估)
安全是所有人都关心的问题，尽早捕获风险总好过于后面再去面对由此导致的各种问题。在基础设施即代码领域，Terraform 是管理云环境时一个显而易见的选择。现在我们又有了 tfsec。它是一个静态分析工具，可以用来扫描 Terraform 模板并查找潜在的安全问题。它针对不同的云提供商（包括 AWS 和 Azure）都预设了安全规则。我们一直都很喜欢那些有助于降低安全风险的工具，而 tfsec 不仅擅长识别安全风险，安装和使用也非常简单。
Web Test Runner(Mar 2022, 试验)
Web Test Runner 是 Modern Web 项目中的一个套件，该项目为现代 Web 开发提供了若干高质量的工具，支持像 ES 模块之类的 Web 标准。Web Test Runner 是一个针对 Web 应用的测试运行器。与其他现有测试运行器相比，它的一个优势是可以在浏览器中运行测试（也可以无图形界面运行）。它支持多种浏览器启动器——包括 Puppeteer ， Playwright 和 Selenium ，并且使用 Mocha 作为默认测试框架。Web Test Runner 运行测试的速度非常快，我们很喜欢在调试的时候能打开一个带 devtools 的浏览器窗口。它在内部采用了 Web Dev Server ，这意味着我们可以利用其出色的插件 API，为测试套件添加自定义插件。Modern Web 项目的工具看起来是一套非常有前景的开发者工具链，我们已经在一些项目中使用它。
交付核心四指标(Mar 2022, 采纳)
为了度量软件交付的效能，越来越多的组织默认采用由DORA 研究 项目定义的 交付核心四指标 ，即：更改前置时间、部署频率、平均恢复时间(MTTR)和变更失败率。这项研究及其统计分析展示了高效能交付团队和这些指标的高度相关性，它们为衡量整个交付组织的表现提供了极佳的领先指标。\n虽然我们依然是这些指标的坚定拥护者，但我们也吸取了一些教训。我们持续看到被误导的度量方式，这些方式使用的工具单纯基于持续交付(CD)流水线。尤其在衡量稳定性指标（MTTR和变更失败率）时，仅依赖CD流水线数据提供的信息并不足以确定部署失败对实际用户的影响。只有包含真实事故，如用户服务降级，稳定性指标才有意义。\n我们建议始终牢记度量指标背后的终极目的，并使用它们来思考和学习。比如，在花费数周时间构建复杂仪表板工具之前，可以考虑定期在团队回顾会议上进行DORA快速检查 。这能够使团队有机会思考他们应该在哪些能力 上努力以提升他们的指标，这会远比过于详细的开箱即用工具更有效。需要牢记这四个核心指标源于对高效能交付团队的组织级研究，在团队级别使用这些指标应该作为团队反思自身行为的一种方式，而不仅仅是添加到仪表板上的另一组度量标准。
交付核心四指标(Oct 2021, 采纳)
为了度量软件交付的效能，越来越多的组织开始采用由DORA 研究项目定义的 交付核心四指标 ，即：更改前置时间、部署频率、平均修复时间（ MTTR ）和变更失败率。这项研究及其统计分析展示了高效能交付团队和这些指标的高度相关性，它们为衡量一个团队、甚至整个交付组织的表现提供了极佳的领先指标。\n虽然我们仍是这些指标的支持者，但自从我们最早开始监控它们以来，也得到了一些教训。我们也持续看到被误导的度量方式，这些方式使用的工具仅基于持续交付（ CD ）流水线。在衡量稳定性指标（ MTTR 和更改失败百分比）时，仅依赖 CD 流水线数据提供的信息并不足以确定部署失败对真实用户的影响。 只有包含真实事故（如用户服务降级）的数据时，稳定性指标才有意义。\n与其它所有指标一样，我们建议始终牢记度量这些指标的终极目的，并使用它们反复思考和学习。例如，在花费数周时间构建复杂仪表板工具之前，可以考虑定期在团队回顾会议当中进行 DORA 快速检查。这样的做法能够使团队有机会思考哪些能力应被提升以改进这些指标，这比过于详细的开箱即用工具更有效。
交付核心四指标(Apr 2019, 采纳)
The thorough State of DevOps reports have focused on data-driven and statistical analysis of high-performing organizations. The result of this multiyear research, published in Accelerate, demonstrates a direct link between organizational performance and software delivery performance. The researchers have determined that only four key metrics differentiate between low, medium and high performers: lead time, deployment frequency, mean time to restore (MTTR) and change fail percentage. Indeed, we've found that these four key metrics are a simple and yet powerful tool to help leaders and teams focus on measuring and improving what matters. A good place to start is to instrument the build pipelines so you can capture the four key metrics and make the software delivery value stream visible. GoCD pipelines, for example, provide the ability to measure these four key metrics as a first-class citizen of the GoCD analytics.
交付核心四指标(Nov 2018, 试验)
The State of DevOps report, first published in 2014, states that high-performing teams create high-performing organizations. Recently, the team behind the report released Accelerate, which describes the scientific method they've used in the report. A key takeaway of both are the four key metrics to support software delivery performance: lead time, deployment frequency, mean time to restore (MTTR), and change fail percentage. As a consultancy that has helped many organizations transform, these metrics have come up time and time again as a way to help organizations determine whether they're improving the overall performance. Each metric creates a virtuous cycle and focuses the teams on continuous improvement: to reduce lead time, you reduce wasteful activities which, in turn, lets you deploy more frequently; deployment frequency forces your teams to improve their practices and automation; your speed to recover from failure is improved by better practices, automation and monitoring which reduces the frequency of failures.
cert-manager(Mar 2022, 试验)
cert-manager 是一款在 Kubernetes 集群里管理 X.509 证书的工具。它将证书和签发者建模为一等资源类型，并将证书作为服务安全地提供给工作在 Kubernetes 集群上的开发人员和应用程序。在使用 Kubernetes 默认 ingress 控制器时，cert-manager 是个显而易见的选择，但也推荐用在其他的控制器上，尤其在你不应该手动管理自己的证书的时候。我们的几个团队一直在广泛使用 cert-manager，而且发现它的可用性在过去几个月里有了很大的提升。
cert-manager(Oct 2021, 评估)
cert-manager 是一款在 Kubernetes 集群里管理X.509证书的工具。它将证书和签发者建模为最高级的资源类型，并将证书作为服务安全地提供给工作在 Kubernetes 集群上的开发人员和应用程序。得益于对 Let's Encrypt ， HashiCorp Vault 和 Venafi 的内置支持， cert-manager 是一款非常有趣的，值得评估的证书管理工具。
Volta(Mar 2022, 试验)
当同时在多个 JavaScript 代码库上工作时，我们往往需要使用不同版本的 Node 和其他 JavaScript 工具。在开发机器上，这些工具通常安装在用户目录或本机中，这意味着需要一个解决方案，帮助开发者在多个版本之中进行切换。对于 Node 而言，nvm 能够做到这一点，但我们想重点强调一个替代方案 Volta ，我们的一些团队正在使用它。与使用 nvm 相比，Volta 有几个优点：它可以管理其他 JavaScript 工具，如 Yarn；它还具备一个基于项目绑定工具链某个版本的理念，这意味着开发人员可以简单使用给定代码目录中的工具，而不必担心需要手动切换工具版本 —— Volta 是通过使用路径中的 shims 来选择被绑定的版本。Volta 采用 Rust 编写，速度极快，以独立二进制文件进行分发，没有任何依赖。
包容性设计(Mar 2022, 评估)
我们建议各类组织评估包容性设计，以确保自己将无障碍性视为头等需求。因为大家常常直到软件发布之前，甚至是发布之后，才想起与无障碍性和包容性相关的要求。满足这些要求的成本最低也是最简单的方法，就是将它们完全纳入开发过程并同时向团队提供早期反馈。在过去，我们强调了针对安全性和跨功能需求实施“左移”的技术；关于这种技术的一种观点认为，它与实现无障碍性目标一致。
Micrometer(Mar 2022, 试验)
Micrometer 是一个跨平台的库，用于JVM的指标检测，支持 Graphite、New Relic、CloudWatch 和许多其他集成。 Micrometer 让库作者和团队都受益：库作者可以在他们的库中包含指标检测代码，而无需支持库用户正在使用的每个指标系统；团队可以在后端注册表上支持许多不同的指标，这使组织能够以一致的方式收集指标。
Capacitor(Mar 2022, 评估)
我们争辩跨平台移动开发工具的优点几乎与我们发布技术雷达的时间一样长。在2011年发布 cross-mobile platforms 时，我们首次注意到新一代工具的诞生。尽管我们最初对其持怀疑态度，然而这些工具在近些年逐渐被完善并被广泛采用。React Native 经久不衰的人气和用处是毫无争议的。Capacitor 是以 PhoneGap 为起源，之后被重命名为 Apache Cordova 的系列工具的最新一代。 Capacitor 将 Ionic 完全重写并让独立应用拥抱 渐进式网页应用 风格。迄今为止，我们的开发者喜欢这种用单一代码库统一管理网页、 iOS 和 Android 应用代码的方式，他们还可以按需访问原生 API 分别管理各个原生平台。 尽管 React Native 已经坐拥多年的跨平台经验， Capacitor 还是为跨平台提供了一种额外选择。
Sourcegraph(Mar 2022, 试验)
在往期的技术雷达中，我们介绍了两个基于抽象语法树（AST）表征的代码搜索和替换工具，Comby 和Sourcegraph。它们尽管有一些相似之处，但也有一些不同的地方。Sourcegraph 是一个商业工具（也有最多支持10个用户的免费版本），特别适合在大型代码库中进行搜索、导航或交叉引用等操作，重视与开发者的交互体验。相比之下，Comby 是一个用于自动化重复性任务的轻量级开源命令行工具。由于 Sourcegraph 是一个托管服务，它能持续监测代码库，并在成功匹配时发出警报。现在我们对 Sourcegraph 有了更多的经验，决定将其挪到试验状态，以反映我们从中获得的良好体验——但这并不意味着 Sourcegraph 比 Comby 更好。每个工具都有各自专注的方向。
Sourcegraph(Oct 2021, 评估)
另一个引起我们注意的基于抽象语法树的代码搜索工具是 Sourcegraph 。与开源的 Comby 相比，Sourcegraph 是一个商业工具（有 10 个用户的免费套餐）。 Sourcegraph 特别适合在大型代码库中搜索、导航或交叉引用。你可以通过 Sourcegraph 的网站访问云托管版本，进而搜索公开可用的开源存储库。 Comby 是用于自动执行重复性任务的轻量级命令行工具，而 Sourcegraph 的重点在于理解和导航大型代码库的交互式开发人员工具。与 Comby 类似 sed 的界面不同，Sourcegraph 的自动代码重写功能是由 UI 驱动的，允许用户在修改之前查看变更。由于 Sourcegraph 是一项托管服务，因此它还能够持续监控代码库并在匹配发生时发送警报。
Couchbase(Mar 2022, 试验)
当我们最初在 2013 年收录 Couchbase 时，它主要被视为是一个由 Membase 和 CouchDB 合并而来的持久化缓存。 从那时起，它经历了持续的的改进，一个由相关工具以及商业产品组成的生态系统也围绕着它成长了起来。它新增的产品套件包括 Couchbase Mobile 和 Couchbase Sync Gateway。这些功能协同工作，即使在设备由于网络不稳定而离线的时间段内也能够使数据保持最新。随着这些设备的激增，我们看到了市场对嵌入式数据持久化的需求不断增加，无论设备是否被连接，这种数据的持久化都能够保证设备继续工作。近期，我们的一个团队对 Couchbase 的离线同步能力进行了评估，发现这种现成的功能为他们节省了大量的精力，避免了投入成本自己去构建这种离线同步能力。
Couchbase(May 2013, 试验)
Couchbase is a persistent cache with auto-sharding features, master-less clusters and replicated data to avoid cachemisses. Because it supports the Memcached protocol, it allows drop-in replacement for Memcached based systems.
Temporal(Mar 2022, 评估)
Temporal 是一个用于开发长期运行工作流的平台，尤其适用于微服务架构。作为 Uber 开源项目（OOS）Cadence 的衍生项目，Temporal 对于长期运行的工作流采用了事件溯源 (event-sourcing) 模式，因此它们可以在进程或主机的崩溃后恢复。尽管我们不推荐在微服务架构中使用分布式事务，但如果你确实需要分布式事务或者长期运行的 Sagas，你或许会对 Temporal 有兴趣。
VerneMQ(Mar 2022, 试验)
VerneMQ 是一个开源、高性能的分布式 MQTT 消息服务器。在之前的技术雷达中我们评估过一些 MQTT 消息服务器，比如 Mosquitto 和 EMQ 。与它们类似，VerneMQ 也基于 Erlang/OTP 开发，具有高度可扩展性。它可以在硬件上水平和垂直扩展，以支持大量并发客户端的发布和订阅，同时保持低延迟和容错性。在我们的内部基准测试中，它已经能够帮助我们在单个集群中实现几百万个并发连接。它并不是新技术，我们在生产环境中使用了一段时间，目前运行良好。
非集群资源的 Operator 模式(Mar 2022, 评估)
除了管理部署在集群上的应用程序，我们看到 Kubernetes Operator 模式越来越多地用于其他地方。 非集群资源的 Operator 模式 可以利用自定义资源和在 Kubernetes 控制面板中实现的事件驱动调度机制，来管理与集群外部相关的活动。该技术建立在由 Kube 管理的云服务的思想之上，并将其扩展到其他活动中，例如持续部署或者及时响应外部存储库的变化。与专门构建的工具相比，这种技术的一个优势就是它开辟了一系列的工具，这些工具有的是 Kubernetes 自带的，有的则来自更广泛的生态社区。您可以使用 diff 、 dry-run 或 apply 等命令与 Operator 的自定义资源进行交互。Kube 的调度机制消除了以正确顺序编排活动的必要性，从而使开发更容易。如 Crossplane 、 Flux 和 Argo CD 等开源工具都利用了这项技术。随着时间的推移，我们希望看到更多这样的工具出现。我们还观察到的一个现象，虽然每个工具都有自己的适用场景，但它们不可避免的会被误用或过度使用。对此我们有个“老生常谈”：一项工具可以应用在某个场景，并不表示它就应当应用在这个场景。在确认简单的传统方法不适用之前，请不要创建自定义资源定义，因为这会导致额外的复杂性。
非集群资源的 Operator 模式(Oct 2021, 评估)
除了管理部署在集群上的应用程序，我们看到 Kubernetes Operator 模式越来越多地用于其他地方。非集群资源的 Operator 模式可以利用自定义资源和在 Kubernetes 控制面板中实现的事件驱动调度机制，来管理与集群外部相关的活动。该技术建立在由 Kube 管理的云服务的思想之上，并将其扩展到其他活动，例如持续部署或者及时响应外部存储库的变化。与专门构建的工具相比，这种技术的一个优势就是它开辟了一系列的工具，这些工具有的是 Kubernetes 自带的，有的则来自更广泛的生态社区。您可以使用 diff 、 dry-run 或 apply 等命令与 Operator 的自定义资源进行交互。Kube的调度机制消除了以正确顺序编排活动的必要性，从而使开发更容易。如 Crossplane 、 Flux和 ArgoCD  等开源工具都利用了这项技术。随着时间的推移，我们希望看到更多这样的工具出现。
WebAssembly(Mar 2022, 评估)
WebAssembly（WASM）是一项 W3C 标准，旨在为浏览器提供执行代码的能力。它是二进制的编码格式，其设计目标是可以发挥硬件的能力，让代码以接近原生的速度在浏览器中运行，目前 WASM 已被所有的主流浏览器支持并向下兼容。前端开发编程语言早期主要聚焦在 C、C++ 以及 Rust 上，WASM 的出现拓宽了可选范围。同时 WASM 还被 LLVM 支持，纳入为一个编译目标。当 WASM 在浏览器的沙盒环境中运行时，能够与 JavaScript 交互并共享相同的权限和安全模型。凭借其可移植性和安全性这两项关键能力，WASM 可以适配包括移动端、IoT 在内的更多平台。
WebAssembly(Nov 2018, 评估)
WebAssembly is a big step forward in the capabilities of the browser as a code execution environment. Supported by all major browsers and backward compatible, it's a binary compilation format designed to run in the browser at near native speeds. It opens up the range of languages you can use to write front-end functionality, with early focus on C, C++ and Rust, and it's also an LLVM compilation target. When run in the sandbox, it can interact with JavaScript and shares the same permissions and security model. When used with Firefox's new streaming compiler, it also results in faster page initialization. Although it's still early days, this W3C standard is definitely one to start exploring.
WebAssembly(May 2018, 评估)
WebAssembly is a big step forward in the capabilities of the browser as a code execution environment. Supported by all major browsers and backward compatible, it's a binary compilation format designed to run in the browser at near native speeds. It opens up the range of languages you can use to write front-end functionality, with early focus on C, C++ and Rust, and it's also an LLVM compilation target. When run in the sandbox, it can interact with JavaScript and shares the same permissions and security model. When used with Firefox’s new streaming compiler, it also results in faster page initialization. Although it's still early days, this W3C standard is definitely one to start exploring.
Collibra(Mar 2022, 评估)
在日益拥挤的企业数据目录市场中，我们的团队很喜欢使用Collibra。他们喜欢 SaaS 或自托管实例的部署灵活性，许多功能可以开箱即用，包括数据治理、数据血缘、数据质量和数据的可观测性。用户还可以选择使用仅需更小功能集合的更加去中心化的管理方法(如 Data mesh) 。真正令人引以为傲的的是他们经常被忽略的客户支持，对此我们认为是一种协作与支持。诚然，简单的数据目录和更全功能的企业平台之间存在矛盾，但到目前为止，使用它的团队对使用 Collibra 支持其需求的方式非常满意。
skopeo(Mar 2022, 评估)
skopeo 是一款可以对容器镜像和镜像仓库执行各种操作的命令行工具。它的大部分操作都不要求用户以 root 角色执行，也不需要运行守护进程。它是 CI 流水线中的实用部分，在推广镜像时，我们可以用skopeo把镜像从一个注册表拷贝到另一个注册表。这样的操作比直接拉取和推送镜像更好，因为我们不需要在本地存储这些镜像。skopeo 不是一个新工具，但它足够有用且未被充分认识到，所以我们认为它值得一提。
Podman(Mar 2022, 试验)
Podman 作为Docker 的替代方案，已经通过我们许多团队的验证。与 Docker 不同的是，Podman 使用一个无守护引擎来管理和运行容器，这是一种有趣的方案。此外，Podman 可以以普通用户身份运行而无需root权限，从而减少了攻击面。通过使用 Buildah 构建的开放容器倡议 (OCI) 镜像或者 Docker 镜像， Podman 可以适用于大多数容器使用场景。除了与 macOS 的一些兼容性问题外，我们团队在 Linux 各发行版上使用 Podman 的总体感觉非常好。
Podman(Apr 2021, 评估)
尽管Docker已经成为容器化的默认选项，这个领域的新玩家还是吸引了我们的注意Buildah和Podman就是这种情况，它们是在多个Linux发行版中使用rootless 方法构建映像(Buildah)和运行容器(Podman)的互补项目。Podman引入了一个无守护进程的引擎，来管理和运行容器，与Docker相比，这是一个有趣的方法。事实上，Podman可以使用Buildah或Docker创建的OCI (Open Container Initiative) 镜像，这样工具变得更有吸引力，也更容易使用。
Sealed Secrets(Mar 2022, 试验)
Kubernetes 原生支持称为“机密”（secret）的键值对象。然而默认情况下，这些 Kubernetes 的“机密”其实并不真的那么机密。尽管它们与其他键值数据分开处理，可以单独采取预防措施或访问控制，且支持在将“机密”存储在 etcd 之前，对其进行加密，但在配置文件中，“机密”是以纯文本字段的形式保存的。Sealed Secrets 提供组合运算符和命令行实用程序，使用非对称密钥来对“机密”进行加密，以便仅在集群中用控制器将其解密。此过程可确保“机密”在 Kubernetes 用于部署的配置文件中不会泄漏。一旦加密，这些文件就可以安全地共享或与其他部署制品一起存储。
Sealed Secrets(Oct 2021, 试验)
Kubernetes原生支持称为“机密”（secret）的键值对象。然而默认情况下，这些Kubernetes的“机密”其实并不真的那么机密。尽管它们与其他键值数据分开处理，可以单独采取预防措施或访问控制，且支持在将“机密”存储在 etcd 之前，对其进行加密，但在配置文件中，“机密”是以纯文本字段的形式保存的。Sealed Secrets提供组合运算符和命令行实用程序，使用非对称密钥来对“机密”进行加密，以便仅在集群中用控制器将其解密。此过程可确保“机密”在Kubernetes用于部署的配置文件中不会泄漏。一旦加密，这些文件就可以安全地共享或与其他部署制品一起存储。
Azure DevOps(Mar 2022, 试验)
随着 Azure DevOps 生态系统的不断发展，我们的团队正在更多的使用它，并取得了成功。这些服务包含一组托管服务，包括托管 Git 代码仓库、构建和部署流水线、自动化测试工具、待办工作管理工具和构件仓库。我们已经看到我们的团队在使用该平台时获得了良好的体验，这意味着 Azure DevOps正在走向成熟。我们特别喜欢它的灵活性； 它甚至允许用户使用来自不同供应商的服务。例如，你可以在使用 Azure DevOps的流水线服务的同时也使用一个外部 Git 数据仓库。我们的团队对 Azure DevOps Pipelines 尤其感到激动。随着生态系统的成熟，我们发现越来越多的团队已经加入了 Azure 技术栈，因为它可以轻松地与微软世界的其他部分集成。
Azure DevOps(Oct 2020, 试验)
Azure DevOps 服务包含 Git 仓库托管、CI/CD 流水线、自动化测试工具、待定项管理工具以及生成物（artifact）仓库等在内的一系列管理服务。在这个平台上，我们的团队积累了许多经验，并取得了不错的成绩——这也意味着 Azure DevOps 的逐步成熟。在灵活性上我们对它喜爱有加：它允许你使用来自不同供应商的服务。例如，你可以在 Azure DevOps 流水线服务上使用外部 Git 仓库。尽管我们的团队对 Azure DevOps Pipelines 尤为感兴趣，但不得不说，所有的 Azure DevOps 服务都提供了良好的开发者体验，有助于我们的团队交付价值。
Azure DevOps(Nov 2019, 评估)
Azure DevOps服务包括一组被托管的服务，如Git仓库、CI/CD流水线、自动化测试工具、待办列表管理工具和制品仓库。Azure DevOps Pipelines已经日趋成熟，其对流水线即代码的支持，以及在Azure DevOps市场中的生态系统的扩展能力，尤其赢得我们的青睐。但在撰写本文时，我们的团队还是发现它的一些功能不够成熟，比如缺少有效的UI，来进行流水线的可视化和导航，以及无法从制品或其他流水线，来触发某条流水线。
Azure DevOps(Nov 2018, 评估)
Azure DevOps services include a set of managed services such as hosted Git repos, CI and CD pipelines and artifact repository. Azure DevOps services have replaced Visual Studio Team Services. We've had a good experience in starting projects quickly with Azure DevOps services—managing, building and releasing applications to Azure. We've also run into a few challenges—such as lack of full support for CI and CD pipeline as code, slow build agent startup time, separation of build and release into different pipelines—and experienced a few downtimes. We're hoping that Azure DevOps services improve over time to provide a good developer experience when hosting applications on Azure, with a frictionless experience integrating with other Azure services.
npm工作区(Mar 2022, 评估)
在 node.js 的世界里，许多工具都支持多包开发，而 npm 7中加入了 npm工作区 来直接支持此特性。将相关联的包集中管理可以让开发更加便利，比如你可以在一个代码仓库中存储多个相关的库。应用 npm 工作区后，一旦你在顶级的 package.json 文件中添加配置，引入了一个或多个嵌套的 package.json 文件，像 npm install 这样的命令就可以跨多个包使用，依赖的源包会符号链接到根目录的 node_modules 路径下。其他的 npm 命令也可以作用于工作区，例如，你可以只用一条命令在多个包中执行 npm run 和 npm test 命令。这种开箱即用的灵活性减少了一些团队对于其他包管理器的需要。
kube-score(Mar 2022, 试验)
kube-score 是一款针对Kubernetes对象定义，进行代码静态检查的工具。它的输出是一份建议列表，里面包含了如何提升你的应用程序安全性及弹性的相关建议。它有一份包含了最佳实践的预定义检查，比如以非root权限运行容器，正确指定资源限制等。它已经存在了一段时间，我们在一些项目中将它作为Kubernetes manifests构建的CD流水线的一部分来使用。kube-score的一个显著缺陷是你无法添加自定义策略。在这种情况下，我们使用像Conftest 这样的工具，以弥补它的缺陷。
Flutter-Unity widget(Mar 2022, 试验)
Flutter 在构建跨平台移动应用方面越来越受欢迎， Unity 非常适合于构建增强现实（AR）和虚拟现实（VR）体验。而Flutter-Unity widget 则是整合 Unity 和 Flutter 的一个关键组件。它允许开发者在 Flutter widget 内嵌入 Unity 应用。该插件提供的重要能力之一是能够提供 Flutter 和 Unity 之间的双向通信。我们发现它的性能也相当不错，我们期待在更多的 Flutter 应用中使用 Unity。
策略性复刻(Mar 2022, 试验)
策略性复刻是一种有助于代码库重组或从单体代码库迁移到微服务的技术。具体来说，更常见的方式是首先对代码库完全模块化，但在很多情况下会花费很长时间或者很难实现。而策略性复刻则为之提供了一种可能的替代方案。通过这种技术，团队可以创建代码库的新分支，并使用它来处理和抽取某个特定的关注点或领域，同时删除不需要的代码。这种技术的应用可能只是整个单体的长期计划的一部分。
混杂平台团队(Mar 2022, 暂缓)
平台工程产品团队帮助交付团队自行完成部署和运营，缩短交付周期，降低整体复杂性，因此我们在之前的技术雷达中将它分类为采纳状态，认为它有益于内部平台团队的运营。 但不幸的是，我们也看到，那些没有清晰产出或者没有明确用户群的团队也被打上了“平台团队”的标签。于是这些团队不得不面对一堆混杂且毫不相干的系统，在高强度但是优先级不明确的工作中勉强完成交付，变成了所谓的 混杂平台团队 。它们实际上变相的成为了另一个通用支持团队，解决那些其他团队不适合或者不愿意做的事情。我们仍然坚信，平台工程产品团队只有关注那些清晰并且定义明确的（内部）产品，才能交付更好的产出。
Github Codespace(Mar 2022, 评估)
Github Codespace 允许开发者在云上创建开发环境，你可以通过 IDE 访问它，就像在本地环境一样。Github 不是第一家实现这个想法的公司，我们之前还提到过 Gitpod。我们喜欢 Codespace 允许通过使用 dotfiles 文件来标准化配置环境的功能，这能够帮助新团队成员更快上手；我们也十分中意 Codespace 能提供最高 32 核 64GB 内存虚拟机的特性，这些虚拟机可以在 10 秒钟内启动，有可能提供比开发笔记本电脑更强大的环境。
Vowpal Wabbit(Mar 2022, 试验)
Vowpal Wabbit 是一个多用途的机器学习库。 Vowpal Wabbit 最初是雅虎研究院于十多年前创建的，如今它依然在持续实现新的强化学习算法。我们想要特别提及的是 Vowpal Wabbit 9.0，它是六年后的一个主要版本，同时鼓励你规划 迁移 ，因为它拥有数个可用性改进，新降维算法和错误修复。
Vowpal Wabbit(Oct 2021, 试验)
Vowpal Wabbit 是一个多功能的机器学习库，尽管它最初由雅虎研究院于十多年前创立，但我们仍想强调许多最新的机器学习技术时至今日依旧最早被添加于此。如果对机器学习感兴趣，那么您最好对 Vowpal Wabbit 上的更新多加留意。值得注意的是，近年来微软也对 Vowpal Wabbit 展现出更为浓厚的兴趣，除聘请了一位主要贡献者外，还将该库集成到他们的 Azure 产品中，例如 machine-learning designer 和 Personalizer。
流式数据仓库(Mar 2022, 评估)
更快地响应客户洞察的需求助推了越来越多事件驱动架构和流式处理技术的采用。例如 Spark、Flink、Kafka Streams 等框架提供了一种范式，让简单事件的消费者和生产者可以在复杂的网络中合作，提供实时的数据洞见。但是这种编程风格需要投入时间和精力去掌握，并且当作为单点应用实现时，会缺乏互通性。这也使得流处理技术的大规模广泛应用需要大量的工程投资。如今，一大批新工具正崭露头角，为日渐庞大的使用 SQL 进行熟练分析的开发者群体提供流处理应用方面的帮助。同时，SQL作为通用流式处理语言的标准化也降低了实现流数据应用的门槛。另外，还有一些工具，如ksqlDB 和 Materialize 有助于将这些独立的应用整合为统一的平台。总而言之，企业中这些基于 SQL 的流处理应用集合可以称为 流式数据仓库
Blueboat(Mar 2022, 评估)
Blueboat 是一个无服务器 web 应用的多租户平台。它采用了被广泛使用的 V8 JavaScript 引擎，同时，出于安全和性能的考虑，它使用 Rust 原生地实现了常用的网络应用程序库。Blueboat 可以被看作是 CloudFlare Workers 或 Deno Deploy 的替代品，但与它们之间存在一个重要区别——你必须操作和管理底层基础设施。因此，我们建议你仔细评估 Blueboat 是否满足你的本地无服务器需求。
sqlc(Mar 2022, 评估)
sqlc 是一个特别的编译器，它可以根据 SQL 生成类型安全并且风格自然的 Go 代码。与其他基于对象关系映射 (ORM) 的方法不同，sqlc 允许你根据需要编写原生的 SQL。一旦 sqlc 被调用，它会检查 SQL 代码的正确性并生成高性能的 Go 代码，这些代码可以直接被应用程序的其它部分调用。凭借对 PostgreSQL 和 MySQL 的稳定支持，sqlc 值得我们一试，因此我们鼓励你对其进行评估。
Metaflow(Mar 2022, 试验)
Metaflow 是一个对用户友好的 Python 库和后端服务，可以帮助数据科学家和工程师构建和管理可用于生产的数据处理、机器学习训练及推理的工作流。Metaflow 提供一系列 Python API，将代码组织为由步骤组成的有向图。每一个步骤都可以灵活配置，例如其所需的计算和存储资源。每个步骤执行（也就是任务）的代码和数据副本都被保存起来，并可以在今后的运行或流程的下一步中被检索出来，帮助你从错误中恢复，重新执行任务，还可以追踪模型的版本以及多个运行之间的依赖关系。\nMetaflow 的价值主张是其惯用的 Python 库的简洁性：它与构建和运行时的基础设施完全集成，以支持在本地和规模化的生产环境中运行数据工程和科学任务。在撰写本条目时，Metaflow 和 AWS 服务高度集成，例如使用 S3 来做数据存储，step functions 来做编排。除 Python 以外，Metaflow 还支持 R 语言。其核心功能都是开源的。\n如果你正在 AWS 上构建和部署生产环境的机器学习和数据处理流水线，作为一个轻量级的全栈框架，Metaflow 可以替代例如 MLflow 这类更复杂的平台。
Grype(Mar 2022, 评估)
保证软件供应链的安全性已经得到交付团队的普遍关注，这种关注也反映在越来越多的新工具涌现在该领域中。Grype 就是一个新的针对 Docker 和 OCI 镜像进行漏洞扫描的轻量级工具。它可以以二进制文件安装，能在镜像被推至仓库前对其进行扫描，而且不需要在你的构建服务器上运行 Docker 守护进程。Grype 与 Syft 出自同一个团队，后者用于为容器镜像生成不同格式的软件物料清单 。Grype 可以使用 Syft 输出的软件物料清单扫描安全漏洞。
重新思考远程站会(Mar 2022, 试验)
站会一词源于在每日同步会议期间站起来的想法，目的是缩短会议时间。许多团队在他们的站会中试图遵守的共同原则是: 保持简洁扼要。但我们现在看到一些团队挑战这一原则并 重新思考远程站会 。在线下协作时，在一天的剩余时间里有很多自发进行相互同步的机会，以此作为短暂站会的补充。而在远程办公时，我们的一些团队正在尝试一种更长的会议形式，类似于Honeycomb 的成员所说的“漫谈式团队同步”。 这不是要完全摆脱日常同步。我们仍然认为它非常重要和有价值，尤其对于远程的组织方式而言。相反，我们想把日常同步会议的时间延长至一个小时，用以淘汰一部分团队会议，并使团队联系更紧密。会议中仍然可以包括常用的团队看板审阅，但是也可以加入更细节的澄清讨论，快速决策以及社交时间。只要它可以减少整体会议负担并提升团队凝聚力，就是成功的技巧。
ShedLock(Mar 2022, 评估)
有一种很常见的需求，是在分布式处理器集群上执行一次定时任务，且只执行一次。例如处理一批数据，发送一条通知，或者执行某个常规的清理操作，都属于这类情况。但是谁都知道这个问题很难，一组处理器如何通过有延迟而且不稳定的网络来实现稳定的协作？这就需要在集群中存在某种锁定机制，来协调这些操作。幸好有很多分布式存储可以实现这种锁定,ZooKeeper 和 Consul 等系统，以及 DynamoDB 或 Couchbase 等数据库都有必要的底层机制来管理集群内部的一致性。ShedLock 是一个小型类库，如果你正在尝试用 Java 来实现自己的定时任务，它可以使你的代码更方便地和上述工具集成。ShedLock 有获得和释放锁的 API，还有各种连接器，可以适配不同工具的锁。如果您正在编写自己的分布式任务，但是不想使用 Kubernetes 这种复杂的重量级平台，ShedLock 值得一试。
SpiceDB(Mar 2022, 评估)
SpiceDB 受谷歌 Zanzibar 启发，是一个用于管理应用程序权限的数据库系统。 你可以通过 SpiceDB 创建一个数据模式以对你的权限需求进行建模，并使用客户端库将创建的模式应用到任何一个受支持的数据库中； 你也可以向数据库中插入数据，并高效地检索问题的答案，例如查询 "这个用户有权访问某个资源吗?"，或者相反的问题： "这个用户有哪些资源可以访问?" 通常，我们提倡将授权策略与代码分离开，但 SpiceDB 更进一步，将数据与策略分离并将其以图的形式进行存储，以高效地应答授权信息的查询。 正因为这种分离，你必须确保应用程序的主要数据存储的变更会反映到 SpiceDB 中。 我们发现，在受 Zanzibar 启发的各种实现中， SpiceDB 是一个值得你基于当前授权需求进行评估的有趣框架。
过渡架构(Mar 2022, 试验)
过渡架构（transitional architecture）在替换遗留系统时是一种有用的做法。就像在建筑物建造或翻新过程中可能会建造、重新配置并最终拆除脚手架一样，在遗留系统迁移中也经常会需要临时架构步骤。尽管过渡架构最终会被移除或替换，但它们并不是一种浪费，这是因为过渡架构可以帮助降低风险，并可以将困难问题的解决分解为较小的步骤。这些较小的临时步骤很难构成一个完善的架构，因此避开了使用“大爆炸”方式替换遗留系统的陷阱。需要注意的是，替换结束后要记得移除架构的“脚手架”以避免它在以后成为技术债。
Remix(Mar 2022, 评估)
我们见证了浏览器从服务器端渲染到单页应用的变迁，而如今的 Web 开发似乎又回到了两者中间。Remix 就是这样一个例子。Remix 是一个全栈 JavaScript 框架，它并没有使用笨拙的静态构建，而是通过利用分布式系统和本地浏览器两者的特点一起来加快页面的加载速度。 它分别对嵌套路由和页面加载进行了部分优化，这使得页面渲染看起来特别快。Remix 与 Next.js 的定位十分相似，很多人也会将它们放在一起比较。 我们很高兴地看到，这些框架可以巧妙地将浏览器渲染与服务器端渲染结合起来，从而提供更好的用户体验。
面向编排的 Azure Data Factory(Mar 2022, 暂缓)
目前，Azure Data Factory 是以 Azure 为主要云供应商的组织用来编排数据处理流水线的默认产品。它支持数据提取、在使用不同存储类型的自有产品或者 Azure 服务之间复制数据，以及执行数据转换逻辑。尽管我们已有足够的经验使用 Azure Data Factory 对简单的自有服务数据进行云迁移，但我们不鼓励使用 Azure Data Factory 来编排 复杂的数据处理流水线和工作流。对于使用Azure Data Factory进行系统间的数据迁移，我们已经获得了一些成功案例，但对于更复杂的数据流水线，它仍然存在一些挑战——可调试性和错误报告都不尽人意；可观察性也有限（因为 Azure Data Factory 日志记录功能未与 Azure Data Lake Storage 或 Databricks 等其他产品集成，因此难以实现端到端的观察）；以及只有部分地区能够使用数据源触发机制等。因此，目前我们推荐使用其他开源编排工具（例如 Airflow）来处理复杂的数据流水线，而仅使用 Azure Data Factory 进行数据复制或数据快照。我们的团队会继续使用 Azure Data Factory 来移动和提取数据，但对于更庞杂的操作，我们推荐其他功能更全面的工作流工具。
面向编排的 Azure Data Factory(Nov 2019, 暂缓)
Azure数据工厂（ADF）是Azure目前默认的用于编排数据处理流水线的产品，可以用于数据提取，在使用不同存储类型的自有产品或者Azure服务之间复制数据，以及执行数据转换逻辑。尽管我们在使用ADF做简单的自有服务数据上云的迁移时感觉还可以，但我们不推荐使用Azure数据工厂来编排复杂的数据处理流水线。我们使用ADF的体验一直很不好，原因包括：可以通过代码实现的功能有限，因为ADF似乎优先考虑的是实现低代码开发平台的功能；可调试性和错误报告差；整个流水线的可观察性有限，因为ADF的日志记录功能无法与其他产品（如Azure Data Lake Storage或Databricks）集成，因此开发者难以实现流水线的端到端可观察性；以及只有部分地区能够使用数据源触发机制。因此，目前我们推荐使用其他开源编排工具（例如Airflow）来处理复杂的数据流水线，而仅使用ADF进行数据复制或数据快照。我们期望ADF未来会解决这些问题，以支持更复杂的数据处理工作流，并可以通过代码使用新功能。
CDKTF(Mar 2022, 评估)
迄今为止，许多组织已经创造了广阔的云服务图景。当然，这只有在使用基础设施即代码和成熟的工具时才可能实现。我们仍然喜欢 Terraform，尤其是它丰富且日渐增长的生态系统。然而，Terraform 的默认配置语言 HCL 缺乏抽象性，导致了它的玻璃天花板。虽然使用 Terragrunt 缓解了这一点，但我们的团队越来越渴望像现代编程语言所能提供的那种抽象性。由AWS CDK 团队和 Hashicorp 合作开发的 Terraform云开发工具包(CDKTF)，让团队有可能使用多种不同的编程语言，包括 TypeScript 和 Java，去定义并配置基础设施。通过这种方法，它在 Terraform 生态系统中紧跟Pulumi 的领先地位。我们已经对 CDKTF 有了很好的经验，但仍然决定将其暂留在评估状态，直到它脱离 beta 版本。
SQLFluff(Mar 2022, 评估)
尽管代码静态检查已经是软件工程中的古老实践了，但它在数据领域中的应用仍十分缓慢。SQLFluff是一个python实现的跨SQL方言的linter，它提供了简单的命令行界面（CLI），可以很容易地整合进CI/CD流水线。如果默认配置就适合你，那么SQLFluff在安装后无需任何额外设定就可工作，它会强制执行一套鲜明风格的标准来格式化代码，当然，你也可以通过添加一个dotfile设定自己的代码规范。这个命令行工具还能自动修复诸如空格或者关键词大小写等违反代码规范设定的格式错误。SQLFluff虽然还很年轻，但是SQL代码静态检查圈内获得更多关注是一件让人兴奋的事。
Bob(Mar 2022, 试验)
在使用 React Native 构建应用时，有时你会发现不得不创建自己的模块。例如，我们在为 React Native 应用程序构建一个 UI组件库时就遇到了这种需求。创建这样一个模块项目并不简单，但我们的团队成功地使用 Bob 来自动化实现了这一任务。Bob 提供了一个命令行界面来为不同的构建目标创建脚手架。这个脚手架并不限于核心功能，还可以选择性地包括示例代码、代码检查工具、构建流水线和其他功能。
Chrome Recorder panel(Mar 2022, 评估)
Chrome Recorder panel 是 Google Chrome 97 的预览功能，允许简单地录制和回放用户旅程。虽然这绝对不是一个新想法，但它集成在 Chrome 浏览器中的方式能允许快速地创建、编辑和运行脚本。Chrome Recorder panel 也很好地集成了性能面板，这让获取重复、持续的页面性能反馈变得更加容易。虽然总是需要谨慎使用录制/回放风格的测试，以避免脆弱的测试，但我们认为这个预览功能值得评估，特别是如果你已经在使用 Chrome 性能面板来测量页面。
统一远程团队墙(Mar 2022, 采纳)
统一远程团队墙 是一项简单的技术，可以用虚拟的方式重新引入团队墙实践。我们建议分布式工作的团队采用这种方式；我们从迁移到远程工作的团队那里听到的一件事是，他们怀念使用实体团队墙的时候。这是一个能统一显示各种故事卡、任务、状态和进度的地方，在团队中充当信息辐射器和信息枢纽的角色。但是这种墙仅仅是作为一个集成点存在，实际的数据存储在各种不同的系统中。 随着团队越来越远程化，他们不得不回归到各个信息源系统中去查看所需信息，很难再通过团队墙一目了然地了解项目。 尽管保持团队墙的最新状态可能会需要一些代价，但我们还是认为这些都是值得去做的。对于一些团队来说，更新实体墙是团队日常“仪式”的一部分，所以远程墙也可以像这样去做。
统一远程团队墙(Oct 2021, 试验)
随着远程分布式工作的团队越来越多，我们察觉到人们遗漏了一样东西——物理团队墙。它能统一显示各种故事卡、任务、状态和进度，在团队中充当信息辐射器和信息枢纽。通常来说，团队墙仅仅作为一个集成点，实际的数据存储在各种不同的系统中。而随着团队越来越远程化，我们不得不回归在各个信息源系统中查看所需信息的模式，很难再通过团队墙一目了然地了解项目。 统一远程团队墙 是一项重新引入虚拟团队墙的简单技术。与它为团队带来的益处相比，我们认为值得花费一定开销来保持团队墙的更新。对于一些团队来说，更新物理墙是日常“仪式”的一部分，远程墙也可以做到这一点。
Jetpack Glance(Mar 2022, 评估)
Android 12 对应用小部件做了重大更改，从而改善了用户和开发人员的体验。对于编写常规的 Android 应用程序，我们已经表达了对 Jetpack Compose 作为以一种现代方式来构建原生用户界面的偏好。现在，借助构建在 Compose 运行时之上的 Jetpack Glance，开发人员可以使用类似的声明式 Kotlin API 来编写小部件。最近，Glance 已被扩展以支持在Wear OS中构建Tiles。
Syft(Mar 2022, 试验)
使用软件物料清单(SBOM) 是改善“供应链安全”的关键要素之一，因此在发布软件构件的同时，发布相应的 SBOM 正变得越来越重要。Syft 是一个致力于为容器镜像和文件系统生成 SBOM 的 CLI 工具和 Go 语言库。它可以生成包括 JSON， CycloneDX 和 SPDX 在内的多种格式的 SBOM。Syft 输出的 SBOM 可以被 Grype 用于漏洞扫描。使用Cosign 将 SBOM 添加为证明文件，可以将生成的 SBOM 和镜像一起发布。这使得镜像的消费者可以对 SBOM 进行验证，并将其用于后续的分析。
Cloudflare Pages(Mar 2022, 评估)
当 Cloudflare Workers 发布的时候，我们着重介绍它是一个面向边缘计算的早期函数即服务（FaaS）方案，实现方案十分有趣。去年（2021年）四月发布的 Cloudflare Pages 并没有特别引人注目，因为 Pages 只是众多基于 Git 的网站托管解决方案中的一个。虽然 Cloudflare Pages 的确有一个大多数替代方案不具备的有用功能——持续预览。不过，现在 Cloudflare 已经将Workers 和 Pages 更紧密地集成了起来，创建了一个运行在 CDN 上的、完全集成的 JAMstack 解决方案。键值存储和高度一致的协调原语让新版 Cloudflare Pages 更具吸引力。
Google BigQuery ML(Mar 2022, 试验)
自从雷达上次收录了 Google BigQuery ML 之后，通过连接到 TensorFlow 和 Vertex AI 作为后台，BigQuery ML 添加了如深度神经网络以及 AutoML Tables等更复杂的模型。BigQuery 还引入了对时间序列预测的支持。之前我们关注一个问题是模型的可解释性。今年早些时候，BigQuery Explainable AI 被宣布为公众开放使用，在解决上述问题上迈出了一步。我们还可以将 BigQuery ML 模型作为 Tensorflow SavedModel 导出到 Cloud Storage，并将它们用于在线预测。但仍有一些需要权衡的事情，例如是否需要降低"机器学习持续交付"的难易程度以使其低门槛好上手，BigQuery ML 仍然是一个有吸引力的选择，特别是当数据已经存储在 BigQuery 中的时候。
Google BigQuery ML(May 2020, 评估)
通常需要先编写代码将数据带入机器学习模型，才能得出训练和预测结果。而 Google BigQuery ML能将模型带入数据，从而反转了这一模式。 Google BigQuery是一个数据仓库，能针对数据分析场景，使用 SQL 进行大规模查询。Google BigQuery ML 扩展了此功能及其 SQL 接口，通过利用 BigQuery 数据集，来创建、训练和评估机器学习模型，并最终运行模型预测，以创建新的 BigQuery 数据集。Google BigQuery ML 默认支持部分模型，例如用于预测的线性回归（linear regression），或用于分类的二元和多类回归（binary and multiclass regression）。另外，它还能导入已经训练好的TensorFlow模型（但功能有限）。尽管 BigQuery ML 及其基于 SQL 的方式，降低了使用机器学习做出预测和推荐的门槛（尤其针对一些需要快速探索的场景），但导致需要作出艰难的权衡——这种方式不利于模型训练的其他方面，例如道德偏差测试 (ethical-bias-testing)，可解释性和机器学习的持续交付。
Crossplane(Oct 2021, 评估)
Crossplane是基于Kubernetes Operator模式实现的另一种类型的工具，但它的副作用延伸到了Kubernetes集群之外。在上一期技术雷达中，我们提到了将Kube管理的云服务作为一种技术使用，而Crossplane正是这样做的。其思想是利用Kubernetes控制平面来提供你部署所依赖的云服务，即使它们还没有部署在集群上，例如管理数据库实例、负载平衡器和访问控制策略等。这款工具有两个值得关注的理由。首先，它展示了Kubernetes底层控制平面强大而灵活的执行环境。支持的自定义资源范围没有限制。其次，Crossplane为我们提供了除Terraform、CDK或Pulumi这些常用方案之外的另一种选择。Crossplane为主要的云服务提供了一组预定义的Provider，这些Provider涵盖最通用的配置服务。它并不是要试图成为一个通用的基础设施即代码 (IaC) 工具，而是要成为与Kubernetes部署工作相配套的工具。Crossplane通常与GitOps的实践联系在一起，它是独立的，并且允许你在需要管理外部云资源时，仍然留在Kubernetes的生态系统中。然而，Crossplane并不能帮助配置Kubernetes，你至少需要一个其他的IaC工具来引导集群。
用于Kubernetes的OPA Gatekeeper(Oct 2021, 试验)
用于Kubernetes的OPA Gatekeeper 是为 Kubernetes 实现的一个可定制的准入 webhook。它可以确保所有的规则都会被 Open Policy Agent (OPA) 执行。我们正在使用 Kubernetes 平台的这个扩展，来为集群添加一个安全层，以便通过提供一个自动化的治理机制，来确保所有的应用都符合定义好的规则。我们的团队喜欢它的可定制化能力。使用 CRD（CustomResourceDefinitions），就可以定义 ConstraintTemplates 和 Constraints。这会使得定义规则和对象(例如 deployments, jobs, cron jobs 等) 以及计算中的命名空间变得容易。
Nx(Oct 2021, 试验)
多年来，我们一直在争论是否应该把 monorepos 放入技术雷达中。 每次我们得出的结论都是：monorepos 引入的代价需要进行细致入微的讨论，该技术“太复杂了以至于无法进入技术雷达”。 现在我们看到 JavaScript 社区对 monorepos 越来越感兴趣，例如，在这期播客中讨论的构建由微前端组成的应用程序。 这是否是一个好主意，很大程度上取决于你的实际情况，我们当然不想给出一般性建议。 我们想要评论的是工具。 在团队中，我们看到了纷纷舍弃 Lerna ，而强烈倾向于使用 Nx 来管理基于JavaScript 的 monorepos。
pydantic(Oct 2021, 试验)
起初，Python 添加了类型注解用以支持静态分析。然而，考虑到类型注解和一般注解在其他编程语言中的广泛使用，开发者开始将 Python 的类型注解用于其他目的只是时间问题。pydantic 就是其中一种，用类型注解进行运行时数据验证和设置管理。当接收到JSON数据，并需要将其解析为复杂的 Python 结构时，pydantic 确保传入的数据与预期类型匹配，或在不匹配时报告错误。虽然 pydantic 可以被直接使用，许多开发者将它作为最流行的 Python web 框架之一—— FastAPI 的一部分来使用。事实上，在 FastAPI 中使用 pydantic 被认为非常有必要，以至于最近有一个 Python 更改提议——旨在降低加载带注解的代码到内存中的成本——被重新考虑， 因为它会在运行时破坏类型注解的使用。
CBOR/JSON 双重协议(Oct 2021, 试验)
尽管 CBOR 协议并不是什么新鲜事物，然而我们发现越来越多的数据交换场景都在使用它，尤其是在多种类型的应用程序需要互相通信的时候，比如服务与服务之间、浏览器与服务之间等等。Borer 是 CBOR 编码器/解码器的 Scala 实现，它允许互相通信的两端通过协商自由选择二进制或者传统 JSON 作为消息格式，这一点我们认为非常有用。同样的消息，既能够以普通文本在浏览器里显示，又能够表示为精简高效的二进制，这是非常实用的特性。在未来，随着物联网、边缘计算以及其他受限环境计算的逐渐兴起，我们认为 CBOR/JSON 混合协议会更加流行。
Chakra UI(Oct 2021, 试验)
Chakra UI 是专门为无障碍设计的一个React.js的UI组件库。我们很喜欢它关于无障碍设计的功能，比如深色模式以及与无障碍网页倡议（WAI-ARIA）的兼容。此外，它易于测试和定制，为开发提供了良好的体验，加速 UI 解决方案在生产环境中的开发过程。
React Three Fiber(Oct 2021, 评估)
随着3D和扩展现实（XR）应用在网页浏览器中的可行性提升及人们对其兴趣的增加，我们的团队已经尝试使用 React Three Fiber 在网页端开发3D体验。React Three Fiber 是一个将React.js 组件和状态模型转译为由 Three.js 渲染的3D对象的库。这一方法将3D网页编程开放给了更广泛的开发者群体，这部分开发者已经熟悉 React.js 和其丰富的工具以及库的生态系统。但是，在使用 React Three Fiber 开发应用时，我们的团队经常需要命令式地操作3D场景。这一点与 React 提供的响应式组件范式兼容得不太好，且开发者仍然必须理解基础的3D渲染机制。React Three Fiber 是否能够提供足够的抽象来吸引开发者学习其特性，或者直接使用 Three.js 开发其实更为容易？目前尚无定论。
Tauri(Oct 2021, 评估)
Tauri 是 Electron 的替代品，它使用 Rust 工具以及在操作系统 WebView 中渲染的 HTML 、 CSS 和 JavaScript 组合来构建桌面应用程序。与捆绑 Chromium 的 Electron 不同，用 Tauri 构建的应用程序利用了底层的 WebView ，即 macOS 上的 WebKit ， Windows 上的 WebView2 和 Linux 上的 WebKitGTK 。这种方法有一些有意思的利弊：一方面，你可以得到运行迅速而小巧的应用程序二进制文件；但另一方面，你需要验证不同系统中 WebView 的兼容性问题。
Babashka(Oct 2021, 评估)
即使现在已经有了各种开发和基础设施工具，但我们还是经常会需要使用脚本，将几项工作粘接起来，或者自动化重复的任务。当前编写这类脚本多使用 bash 或 Python 。然而，我们很高兴地看到， Clojure 成为了这类工作令人兴奋的新选择。这都要归功于 Babashka，一个使用 GraalVM 实现的完整的 Clojure 运行时。Babashka 附带的库已经可以涵盖大多数的脚本工具使用场景，并且它还支持加载更多的库。使用 GraalVM 保证了脚本的启动时间与原生工具相当。 Babashka 也是少见的支持多线程的脚本环境，可以用于少数特定的场景。
零信任架构(Oct 2021, 采纳)
我们总是听闻企业发现由于过度依赖“安全”的网络边界，他们的安全性受到严重损害。一旦这个外部边界被攻破，内部系统就会变得欠缺保护，攻击者能够快速而轻松地部署自动数据提取工具和勒索软件，而这些攻击往往在很长一段时间内都不会被察觉。这使我们认为推荐 零信任架构 （ZTA）作为默认方案是一个明智之选。\nZTA是安全架构和策略的一个范式转变。它基于这样的假设：网络边界不再代表安全边界，同时不应仅仅根据用户或服务的物理或网络位置来予以盲目的信任。可用于实现ZTA各方面的资源、工具和平台的数量不断增加：包括基于最小特权与尽可能细化的原则，还有以持续监控与自动减轻威胁的方式执行安全策略即代码；通过运用服务网格去执行应用到服务与服务到服务的安全控制；通过实现二进制证文去验证二进制执行文件的来源；除了传统的加密方式之外，该架构还添加了安全隔离区去加强数据安全的三大支柱：数据在传输、存储和内存中的安全。关于该主题的介绍，请参考NIST ZTA的出版物和谷歌关于BeyondProd的白皮书。
零信任架构(Oct 2020, 试验)
企业中计算和数据的结构不断变化：从单一应用程序到微服务；从集中式数据湖到数据网格；从本地托管到聚合云。与此同时，随着连接设备的激增，保护企业资产的方法在很大程度上仍保持不变。凭借对网络外围的高度依赖和信任——通过加强企业虚拟墙，使用专用链路和防火墙配置，以及替换不再适用于当今现实的静态和繁琐的安全过程的方法，企业继续进行大量投资，以保护其资产。这种持续的趋势迫使我们再次强调“零信任架构”。\n零信任架构是安全体系结构及策略的一种模式转变。它基于这样的假设：网络边界不再代表安全边界，不应仅基于物理或网络位置授予用户或服务隐式信任。用于实现零信任架构各个方面的资源，工具以及平台的数量持续增长，其中包括：以最小特权为基础，执行安全策略即代码，尽可能细化原则，并持续监控和自动缓解威胁；使用服务网格来实施应用到服务和服务到服务的安全控制；使用二进制鉴证以验证二进制文件的来源；除传统加密外，还包括安全区域，以强制实施数据安全性的三大支柱：传输，静态和内存。有关该主题的有用介绍，请参阅 NIST ZTA 刊物和有关 BeyondProd 的 Google 白皮书。
零信任架构(May 2020, 试验)
随着资产（数据、功能、基础架构和用户）跨越安全边界（本地主机，多云提供商以及各种SaaS供应商），组织的技术版图正在变得越来越复杂。这就要求企业安全计划和系统架构进行范式转变：从基于信任区和网络配置的静态、缓慢改变的安全策略，转变为基于临时访问权限的动态、细粒度的安全策略。\n零信任架构(Zero trust architecture, ZTA)是组织针对其所有资产（设备、基础设施、服务、数据及用户）实施零信任安全原则的策略和流程，以及对最佳实践的践行（包括不论网络位置确保所有访问和通信的安全、强制基于最小权限原则并尽可能细粒度控制的策略即代码、持续监控和自动缓解威胁等）。技术雷达介绍了很多赋能技术，例如安全策略即代码，端点安全边车 和 BeyondCorp。如果准备进一步了解ZTA，请参阅 NIST ZTA 和 Google 在BeyondProd 上发表的文章，以了解更多关于原则、赋能技术组件及迁移模式的信息。
NgRx(Oct 2021, 试验)
React 应用中的状态管理一直是技术雷达中反复出现的话题。最近我们阐明了对 Redux 这一流行框架的立场。NgRx 本质上是 Angular 的 Redux。它是一个使用 Angular 构建响应式应用的框架，可以进行状态管理并隔离副作用。 我们的团队认为使用 NgRx 很简单，不仅仅因为它由 RxJS 构建，他们还强调了我们从 Redux 中了解到的一个权衡：增加响应式状态管理就会增加复杂性，而只有大型应用才能利大于弊。NgRx提供的脚手架库Schematics以及一组支持可视化状态追踪和回溯调试的工具提高了开发体验。
Milvus 2.0(Oct 2021, 评估)
Milvus 2.0 是一个云原生的开源向量数据库，用于检索和管理由机器学习模型和神经网络所生成的嵌入向量。它支持多种向量索引，以供对音频、视频、图像或其他任意非结构性数据的嵌入向量进行近似最近邻（ANN）搜索。如果有相似性搜索方面的需求，我们推荐对Milvus 2.0这款相对较新的数据库进行评估。
lifelines(Oct 2021, 试验)
lifelines 是一个用 Python 编写的进行生存分析的库。它最初是为出生和死亡事件而开发的，现在已演变成一个用来预测任何持续时间的完整的生存分析库。除了医疗使用案例（例如用来回答：这个人能活多久？），我们也已经在零售和制造业中用它来回答类似 用户对一个服务订阅了多久？ 或 我们应该什么时候做下一个预防性的维护？这样的问题。
TensorFlow Lite(Oct 2021, 试验)
自2018年雷达中首次提到 TensorFlow Lite 以来，我们已经在一些产品中使用了它。很高兴它与宣传的效果一致。除了将预训练模型集成到移动应用程序中的标准用法， TensorFlow Lite 还支持设备上训练，从而进一步开辟应用领域。TensorFlow Lite 网站不仅展示了许多常见的应用示例（如图像分类和目标检测），还隐含了诸如姿态估计和手势识别等新交互方式的应用。
TensorFlow Lite(May 2018, 评估)
TensorFlow Lite is the designated successor of TensorFlow Mobile, which we mentioned in our previous Radar. Like Mobile it is a lightweight solution tuned and optimized for mobile devices (Android and iOS). We expect the standard use case to be the deployment of pretrained models into mobile apps but TensorFlow Lite also supports on-device learning which opens further areas of application.
Kats(Oct 2021, 评估)
Facebook Research 最近发布的 Kats 是一个轻量级的时间序列分析框架。时间序列分析是数据科学中的一个重要领域，包含预测、检测（周期性、异常值和变化点）、特征提取和多变量分析等问题域。在时间序列分析中，一般会使用不同的库进行不同的分析。而 Kats 则致力于提供一组算法和模型，为时间序列分析的所有问题域提供一站式服务。雷达已经介绍过同样来自 Facebook Research 的 Prophet —— Kats 提供的用于预测的模型。我们期待在涉及时间序列分析的问题中试用 Kats。
Code With Me(Oct 2021, 评估)
JetBrains 的协作编码工具 Code With Me 在远程优先的世界越来越受欢迎，因为许多团队都在使用各种 JetBrains 工具。与其他远程协作工具如 VSCode Visual Studio Live Share 相比，Code With Me 为开发团队提供了更好的远程结对编程和协作体验。 Code With Me 在邀请队友加入 IDE 项目并实时协作的能力值得探索。 但是，我们已经看到了它在无缝重构方面的一些限制，以及高延迟环境中的一些问题。 我们将持续在该领域关注这个工具。
Thought Machine Vault(Oct 2021, 评估)
我们很少在技术雷达中讨论商用软件，更不用说银行核心平台了。然而，讨论Thought Machine Vault（与Thoughtworks没有任何关系）却是一次破例。这个产品旨在支持良好的软件工程实践，比如测试驱动开发、持续交付和基础设施即代码。开发者通过在Vault里用Python编写智能合约，来定义银行产品。这与通过GUI或专属配置文件或两者兼有，来实现定制化的标准无代码方式截然不同。因为产品是用常规的Python代码定义的，因此开发者可以使用一系列工具，包括测试框架和版本控制工具，以此来确保工作是安全而准确的。我们希望更多的金融服务平台的设计，能像上面那样多考虑提升开发者的效率。
ViewInspector(Oct 2021, 试验)
当我们使用 SwiftUI 创建界面时，其背后理念是创建一个可以轻松映射到界面元素的视图模型。在这种场景下，大多数测试都可以在模型上完成，而我们只需使用标准的单元测试框架就能编写直观、高效的测试。为了测试模型和视图之间的数据绑定，开发者会使用 XCUITest，这个自动化框架会启动完整的应用并远程控制界面，它能达到目的，测试效果也还算稳定，但是耗时很长。\n想要更快地给 SwiftUI 编写单元测试，您可以试试 ViewInspector 开源库，它利用 Swift 开放的反射API 访问 SwiftUI 创建的底层视图。因此，基于 ViewInspector 的测试只需要实例化一个 SwiftUI 视图，定位到需要测试的界面元素，就可以对元素进行断言测试，而像点击这种基本的交互也可以被测试到。如同许多别的 UI 测试框架，ViewInspector 提供了定位界面元素的 API，您可以指定路径，通过视图层级结构找到元素，也可以使用一系列查找方法定位元素。基于 ViewInspector 的测试往往比用 XCUITest 的测试更简单，运行起来也要快得多。不过，需要注意的是，尽管用 ViewInspector 写测试很简单，您也可能因此过度测试——测试简单的一对一映射逻辑就像在复印代码，没有太大意义。此外，即便 ViewInspector 降低了测试 SwiftUI 代码的难度，也请记住要把大部分逻辑放在模型中实现。
Cosign(Oct 2021, 评估)
Sigstore 是云原生计算基金会（Cloud Native Computing Foundation，CNCF）旗下的项目，旨在简化软件签名和透明度。其中的 Cosign 用于容器签名及验证。Cosign 不仅支持 Docker 和开放容器计划（Open Container Initiative，OCI）镜像，还支持可以存储在容器注册表中的其他类型镜像。技术雷达介绍过功能类似的 Docker Notary。但 Notary v1 的问题在于需要维护单独的 Notary 服务器，而不能原生集成在容器注册表中。Cosign 将签名与镜像一起存储在注册表中，因此不存在这个问题。目前 Cosign 可以通过 Webhook 与 GitHub actions 及 Kubernetes 集成，并可以进一步集成在流水线中。我们已经在一些项目中使用了 Cosign，效果不错。
遗留系统的活文档(Oct 2021, 试验)
活文档来自行为驱动开发 (BDD) 社区，通常被视作有可执行规范且维护良好的代码库的“专利”。如今我们发现这种技术也可以应用于遗留系统。团队在进行系统现代化改造时，时常受限于缺乏业务知识。由于人员流动以及现有文档已经过时，代码成了唯一可靠的依据。因此当我们接管遗留系统时，如何重新建立文档与代码间的关联，以及如何在团队中传播业务知识变得尤为重要。在实践中，我们会首先尝试对代码进行简单的清理和安全的重构，以此加深我们对业务的理解。在此过程中，我们需要向代码添加注释，以便随后自动生成活文档。这与在全新项目中使用 BDD 非常不同，但对于遗留系统来说这是个良好的开端。根据生成的文档，我们可以进一步将一些规范转换为可执行的高阶自动化测试。反复执行此操作后，最终可以获得一份与代码密切相关并且部分可执行的 遗留系统的活文档 。
Three.js(Oct 2021, 试验)
我们第一次提到 Three.js 是2017年，在雷达的“评估”环上。在这之后，这个 web 3D 渲染库得到了快速的改进和发展。随着 WebGL API 标准的改进，以及对 WebXR 的支持，Three.js成为了一个可以用来营造沉浸式体验的工具。与此同时，浏览器对 3D 渲染和 WebXR 设备 API 的支持也得到提升，使得 web 成为一个越来越有吸引力的 3D 内容平台。尽管还有别的 3D 渲染库，我们团队还是更喜欢 Three.js，特别是和 React Three Fiber 一起用的时候，能抽象掉一些底层细节。不过，开发者仍然需要注意性能问题，有时还需要重构数据来优化渲染速度。
Three.js(Mar 2017, 评估)
Despite the fervor surrounding the spate of new headsets, we believe there are many VR and AR scenarios that make sense in the browser, particularly on mobile. Given this trend, we have seen an uptick in usage of Three.js, a powerful JavaScript visualization and 3D rendering framework. The growth in support for WebGL, which it is based on, has helped adoption, as has the vibrant community supporting this open source project.
Three.js(Nov 2016, 评估)
Despite the fervor surrounding the spate of new headsets, we believe there are many VR and AR scenarios that make sense in the browser, particularly on mobile. Given this trend, we have seen an uptick in usage of Three.js, a powerful JavaScript visualization and 3D rendering framework. The growth in support for WebGL, which it is based on, has helped adoption, as has the vibrant community supporting this open source project.
AR空间定位点(Oct 2021, 评估)
许多增强现实（AR）应用需要获得用户设备的位置和方向，为此，它们一般会使用基于 GPS 的方案，但 空间定位点 这一新技术也值得考虑。这一技术利用设备摄像头记录视觉图像，通过图像的特征点以及它们在 3D 空间中的相对位置来识别其在真实世界中的位置，然后在 AR 空间中创建相应的定位点。虽然空间定位点无法取代所有基于 GPS 和标记的定位点，但它们确实比大多数基于 GPS 的方案精度更高，也比基于标记的定位点更能适应不同的视角。目前，我们只使用过 Google 的 Android 云定位点 服务，它确实很有效。此外，Google 还一反常态地推出了 iOS 云定位点 服务，而微软的 Azure 空间定位点 服务甚至支持更多的平台。
Prefect(Oct 2021, 评估)
Prefect 是一款数据工作流管理工具，可以轻松地在数据管道中添加语义，如重试、动态映射、缓存和失败通知。你可以将 Python 函数标记为任务，并通过函数调用将它们串联起来构建数据流水线。将 Python API 与一些为通用数据操作预定义的任务相结合，这样在评估你的数据流水线工作流需求时，Prefect 会是一个值得考虑的选择。
gopass(Oct 2021, 评估)
gopass 是一个基于 GPG 和 Git 的团队密码管理器。它以 pass 为基础 ，并添加了多项功能，包括交互式搜索和单个树中的多密码存储。自提到 gopass 以来，我们已经在多个项目中使用它，有时甚至超出了它的极限。我们非常期待的一个功能是弃用保密信息的能力。可发现性是已知问题，但无法将保密信息标记为不再使用让这个问题变得更加复杂。不过，最大的问题是伸缩性。当你有 50 多人的团队多年使用同一个存储库时，我们发现存储库的大小可能会增长到数 GB。在新成员入职时重新加密可能需要半个多小时。潜在的问题似乎是，在我们的团队中，一切都在不断变化：人来人往，密钥转手，架构不断发展，添加新密钥，不再需要旧密钥。当变化较少时，即使对于大量用户，gopass 似乎能很好地工作。
gopass(May 2018, 试验)
gopass is a password management solution for teams, built on GPG and Git. It's a descendant of pass and adds features such as: support for recipient management and multiple password stores in a single tree; an interactive search functionality; time-based one-time password (TOTP) support; and storage of binary data. Migration of your pass store is fairly straightforward, because gopass is largely compatible with the format pass uses. This also means integration into provisioning workflows can be achieved with a single call to a stored secret.
gopass(Nov 2017, 试验)
gopass is a password management solution for teams, built on GPG and Git. It's a descendant of pass and adds features such as: support for recipient management and multiple password stores in a single tree; an interactive search functionality; time-based one-time password (TOTP) support; and storage of binary data. Migration of your pass store is fairly straightforward, because gopass is largely compatible with the format pass uses. This also means integration into provisioning workflows can be achieved with a single call to a stored secret.
Jetpack Hilt(Oct 2021, 试验)
Jetpack Hilt 最近发布了 1.0 版，我们的使用体验良好。 Jetpack Hilt 提供了用于将 Hilt 与各种其他 AndroidX 库（例如 WorkManager 和 Navigation）集成的扩展。它进一步扩展了 Hilt 的范围，为开发人员提供了一种将 Dagger 依赖注入集成到 Android 应用程序中的标准方法。 在之前 Radar 中我们提到过作为 Kotlin 原生依赖注入框架的 Koin。虽然在已有的大型代码库中，我们并不建议尝试替换 Koin。但当启动一个新项目时，Hilt 似乎是应该采取的方案。
Lens(Oct 2021, 试验)
我们的团队一直都在说使用 Lens 可视化和管理 Kubernetes 集群的良好体验。Lens被称为“Kubernetes的IDE”，它让与Kubernetes集群的交互成为可能，而不需要你记住命令或显示文件结构。Kubernetes可能很复杂，我们知道集群指标和部署负载的可视化工具可以节省时间，并减少维护Kubernetes集群的人力成本。Lens没有将维护Kubernetes的复杂工作隐藏在简单操作的UI界面之后，而是引入了管理员可以从命令行运行的工具。但是对于正在运行的集群，要谨慎使用UI交互方式修改，我们通常倾向于将基础架构变更 用代码实现 ，这样它们是可重复的、可测试的，并且不容易出现人为错误。不过，Lens确实是一款很好的一站式工具，可以交互式地浏览和理解集群状态。
Lens(May 2020, 评估)
Kubernetes 的一个优势是灵活性和可配置的范围，以及 API 驱动的、可编程的配置机制和使用 manifest 文件的命令行可见性与控制。然而，福祸相依，当部署非常复杂或者需要管理多个集群时，单纯通过命令行属性和 manifest 文件很难清楚地了解总体状态。Lens 试图通过一个集成环境来解决这个问题，这个集成环境可以用以查看集群的当前状态和工作负载，可视化集群指标，并通过内嵌的文本编辑器修改配置。与简单的点击界面不同，Lens 把管理员可能在命令行里运行的工具整合到了一个可导航的界面中。这个工具是试图驯服 Kubernetes 管理复杂性的几种方法之一。在这个领域，我们还没有见到一个明确的胜利者，不过 Lens 在用户图形界面和纯命令行工具之间找到了一个有趣的平衡。
Telepresence(Oct 2021, 评估)
Telepresence 是一款帮助缩短代码变更反馈周期的工具，在这之前，这些变更通常需要进行部署才能进行适当的测试。开发人员可以用它将本地机器上运行的进程插入到远程 Kubernetes 集群中，这样本地进程可以访问远程集群的服务和特性，本地服务也可以临时替代集群中的服务。\n在服务集成设置变得有些笨拙的情况下，Telepresence可以提高开发人员的生产力，并实现更有效的本地测试。然而，如果你习惯了使用这样一个聪明的工具，那可能会遭遇到更大的问题。例如，如果你是因为无法为本地开发设置所有必要的依赖而使用了 Telepresence，那更应该去调查设置和架构的复杂度。如果它是你进行服务集成测试的唯一方法，那请参考消费者驱动的契约 测试 或者其他自动化的集成测试方式。
Airflow(Oct 2021, 试验)
近年来，工作流管理工具越来越受到大家的关注，不管它是专注某个特定领域还是领域无关，这样的趋势归功于越来越多的数据处理流水线以及机器学习（ML）模型开发流程的自动化。Airflow 是早期开源的工作流编排引擎之一，它用代码将流水线定义为有向无环图（DAGs），这是对传统 XML/YAML 定义方式的一大改进。尽管 Airflow 仍然是被广泛使用的编排工具之一，但是我们还是鼓励你根据实际情况评估其他工具。例如， Prefect , 它的关键特性是支持动态的数据处理任务，任务本身通过 Python 范型函数实现。如果你需要和 Kubernetes 深度集成，那么可以考虑 Argo 。如果你需要编排机器学习（ML）工作流，那么 Kubeflow 和 MLflow 可能更合适。考虑到越来越多的新工具不断涌现，再加上 Airflow 本身的功能短板（比如缺少对动态工作流的支持，中心化的流水线调度机制），我们不再推荐 Airflow 作为首选的编排工具。\n我们相信，随着流式处理越来越多地用于数据分析和数据流水线，以及通过去中心化的 Data Mesh来管理数据，人们使用编排工具来定义和管理复杂数据流水线的需求会越来越少。
Airflow(Oct 2020, 采纳)
Airflow仍然是我们广泛采用的最喜欢的开源工作流管理工具，用于构建作为有线无环图（DAGs）的数据处理流水线。这是一个蓬勃发展的领域，开源工具有 Luigi 和 Argo，厂商工具则有 Azure Data Factory 或者 AWS Data Pipeline。然而 Airflow 特别之处在于它对工作流的程序化定义，而非低代码配置文件，以及对自动化测试的支持，开源并支持多平台，对数据生态丰富的集成点还有广泛的社区支持。不过在像数据网格这样的去中心化数据架构中，Airflow 的劣势在于它是一个中心化的工作流编排。
Airflow(Mar 2017, 试验)
Airflow is a tool to programmatically create, schedule and monitor data pipelines. By treating Directed Acyclic Graphs (DAGs) as code, it encourages maintainable, versionable and testable data pipelines. We've leveraged this configuration in our projects to create dynamic pipelines that resulted in lean and explicit data workflows. Airflow makes it easy to define your operators and executors and to extend the library so that it fits the level of abstraction that suits your environment.
Comby(Oct 2021, 评估)
本期技术雷达引入了两款使用抽象语法树表示进行搜索和替换代码的工具。它们与jscodeshift有相似的定位，但包含适用于多种编程语言的解析器。尽管它们有一些相似之处，但它们在某些方面还是有所不同。其中 Comby 工具的独特之处，在于其简单的命令行界面，该命令行界面是根据awk和sed等Unix工具的精神设计的。虽然 Unix 命令基于操作匹配文本的正则表达式，但 Comby 使用特定于编程语言结构的模式语法，并在搜索之前解析代码。这有助于开发人员在大型代码库中搜索结构模式。和sed一样，Comby 可以用新的结构替换它匹配的模式。这对于大型代码库进行自动批量更改，或在一组微服务存储库中进行重复更改非常有用。由于这些工具相当新，我们希望看到一系列尚未发现的创造性用途。
Dive(Oct 2021, 试验)
Dive 是一个针对 Docker 镜像的分析工具，用于检查镜像文件中的每一层级、识别每一层上发生的变化。Dive 可以估测出镜像文件的镜像效率和已浪费空间，还能集成到持续集成（CI）流水线，根据效率得分或者已浪费空间让构建失败。我们已经在一些项目上使用了该工具，实践证明它的确非常有用，尤其在你构建镜像时，对额外的工具或空间消耗容忍度极低的情况下。
ksqlDB(Oct 2021, 评估)
如果你正在使用 Apache Kafka 并构建流处理应用程序，ksqlDB 是一个不错的框架，用来以类似SQL的语句编写简单的应用程序。ksqlDB 并不是一个传统的SQL数据库。然而，它允许你在现有的Kafka topics上使用轻量级类似SQL的语句来构建新的 Kafka streams 或 tables 。和从传统数据库读取数据类似，Queries 能够拉取数据，或者当有增量变化发生时把结果推送到应用程序。你可以选择将其作为现有 Apache Kafka 原生部分安装并以 standalone server 的方式运行，或者作为 Confluent Cloud 上一个完全托管的服务。我们正在简单的数据处理场景中使用 ksqlDB 。在更复杂的场景中，比如当应用程序需要在代数 SQL 查询之外进行编码的情况下，我们会继续在 Kafka 之上使用诸如 Apache Spark 或 Apache Flink 这些数据处理框架。我们建议在应用程序的简单性允许的情况下尝试使用 ksqlDB。
Contrast Security(Oct 2021, 试验)
Contrast Security 提供一个包括了静态应用安全测试（static application security testing，SAST）、交互式应用安全测试（interactive application security testing，IAST）、开源扫描、运行时应用自保护（runtime application self-protection 、RASP）等多种组件的安全平台。至今它已经有几年历史了，我们也在多个项目上使用过它。关于 Contrast 平台，我们尤其喜欢的一点是它的运行时库分析。它帮助我们定位没被使用的库，这反过来帮助了我们对漏洞安排优先级，并移除掉潜在未使用的库。这和与日俱增的保障软件供应链安全的重要性密切相关。我们也相当喜欢它的IAST组件。我们发现它在持续交付（continuous delivery，CD）流水线中很有效率，误报更少，并且能发现相当范围的漏洞。
Operator Framework(Oct 2021, 评估)
我们持续看到Kubernates在新场景中的应用。比如，Kubernetes 被扩展为在集群之外或跨多个基础设施提供商管理运行的资源，或者被用来管理超出 Kubernetes 初始范围的有状态应用程序。这些扩展功能可能正在使用Kubernetes Operator模式：构建具有被管理自定义资源所特定领域知识的控制器。比如，管理有状态应用程序的operator可以使用 Kubernetes 原始类型，自动执行应用程序部署之外的特定任务，例如恢复、备份和升级数据库。\nOperator Framework是一组开源工具，可简化构建和管理Kubernetes operators的生命周期。尽管有多种框架可以帮助你构建 Kubernetes operator，但 Operator Framework 仍然是一个不错的选择。它通过 Operator Lifecycle Manager 模块支持丰富的 operator 生命周期管理；通过 Operator SDK ，它可以支持多种语言，自行构建 operator 代码，并提供用于发布和共享 operator 的 目录。如果你计划构建 Kubernetes operator，我们建议你尝试使用 Operator Framework，从而可靠地加速你的开发。
Operator Framework(Apr 2021, 评估)
Operator框架是一套开源工具，可简化Kubernetes operators的构建和生命周期管理。Kubernetes operator模式最初由CoreOS引入，是一种使用Kubernetes原生能力来封装操作应用程序知识的方法；它包括要管理的资源和确保资源与其目标状态匹配的控制器代码。这种方法已被用于扩展Kubernetes，以原生化管理众多应用程序，特别是有状态的应用程序。Operator框架有三个组件：Operator SDK，简化了Kubernetes operators的构建、测试和打包；Operators生命周期管理器负责operators的安装、管理和升级；以及发布和共享第三方operators的目录。我们的团队发现Operator SDK在快速开发kubernetes原生应用程序时特别强大。
Berglas(Oct 2021, 试验)
Berglas 是一款用来管理 Google 云平台（GCP）上私密信息的工具。我们此前已经推荐过“密码即服务”作为在现代分布式架构中存储和分享私密信息的技术，GCP 为此提供了 Secret Manager，而 Berglas 与 Secret Manager 配合使用效果良好。这对那些尚未直接集成 Secret Manager 的 GCP 服务来说尤其有用，在这种情况下，另一选择则是自行编写代码或脚本。Berglas 作为命令行工具和库，同时也能在密码即服务以外的场景中派上用场。Berglas 的作者——恰好也正是 HashiCorp Vault 的原作者，他目前正在 Google 工作，但 Berglas 并不是 Google 的官方工具。
InsightFace(Oct 2021, 评估)
基于 PyTorch 及 MXNet 的 InsightFace 是开源的 2D 及 3D 深度人脸分析工具集。InsightFace 使用前沿且精确的方法进行人脸检测、人脸识别和人脸对齐。InsightFace 最吸引我们的是它为 ArcFace——用于检测两个图像相似性的前沿机器学习模型—— 提供了一个的最佳实现。带有 ArcFace 的 InsightFace 在 LFW 数据集上获得了 99.83% 的准确率。我们正在使用它进行面部重复数据剔除，效果很好。
XTDB(Oct 2021, 评估)
具备双时态图查询的开源文档数据库 XTDB  ，每条记录都原生支持两个时间轴：valid time时间轴（涉及事实发生时间），以及 transaction time时间轴（涉及事实被数据库处理和记录的时间）。在很多场景中，支持双时态都是有益的，比如当进行用于执行时间感知查询的分析型用例的设计时，当审计事实的历史变化时，当支持分布式数据架构以保证时间点查询的全局一致性时（例如数据网格，当保持数据不变性时，等等。XTDB 以文档形式获取信息，而信息用可扩展数据表示法 (EDN，是 Clojure 语言的一个子集) 格式表示。 XTDB 支持图和 SQL 查询，并可通过 REST API 层和 Kafka 连接等模块进行扩展。我们很高兴地看到， XTDB 的采用率有所增长，另外它也增加了对事务和 SQL 的支持。
XTDB(Nov 2019, 评估)
Crux是一个带有双时态图查询的开源文档数据库。许多数据库系统都是有时态的，这意味着它们可以帮助我们对事实及其所发生的时间进行建模。双时态数据库系统不仅可以对事实所发生的有效时间进行建模，还可以对收到事实并产生交易的时间进行建模。如果需要使用具有图查询功能的文档库来查询内容，可以试试Crux。虽然该数据库当前还处在alpha测试阶段，且缺乏SQL支持，但是可以使用Datalog查询界面来读取和遍历关系。
MirrorMaker 2.0(Oct 2021, 试验)
基于 Kafka Connect 框架构建的MirrorMaker 2.0 (也称为 MM2 )，弥补了以前 Kafka 复制工具中的许多短板。它可以成功地跨集群 geo-replicate 主题数据和元数据，包括偏移量、消费者组和授权命令行( authorization command lines, ACLs )。MM2 能够保留分区，并能检测新的主题和分区。我们很欣赏其所具备的下述逐步进行集群迁移的能力（当从本地集群迁移到云集群时，这种方法尤其有用）：同步主题和消费者组之后，先把客户端迁移到新集群里；然后把生产者迁移到新集群里；最后关闭 MM2，并将旧集群下线。此外，MM2 还可用于灾难恢复和高可用性场景。
Kotlin Multiplatform Mobile(Oct 2021, 试验)
随着跨平台移动开发的端到端体验日益高效愉悦，构建跨平台移动应用成为了许多组织的一项强有力选择。Kotlin Multiplatform Mobile（KMM）是JetBrains 提供的 SDK，在利用 Kotlin 跨平台能力的同时，它还提供了工具和特性以优化开发体验。使用 KMM 时，您只需用 Kotlin 对业务逻辑和核心应用程序编写一份代码，然后即可被 Android 和 iOS 应用共享。仅在必要时（如利用原生UI元素），您才需要针对特定的平台编写代码，且这些特定代码保存在各个平台的不同视图中。基于 KMM 的迅速发展我们将其移至“试验”环。我们也看到一些组织已经将其作为了默认选项。
Kotlin Multiplatform Mobile(Apr 2021, 评估)
在跨平台移动开发的趋势下，Kotlin Multiplatform Mobile(KMM) 成为了该领域的新成员。KMM 是JetBrains 提供的 SDK，它利用了 Kotlin 的 跨平台能力，包含丰富的工具和特性，使整个构建跨平台移动应用的体验变得更加愉悦和高效。使用 KMM 时，您只需用 Kotlin 对业务逻辑和核心应用程序编写一份代码，然后即可被 Android 和 iOS 应用共享。仅在必要时（如利用原生UI元素），您才需要针对特定的平台编写代码，且这些特定代码保存在各个平台的不同视图中。尽管仍处在 Alpha 测试阶段，Kotlin Multiplatform Mobile 正在高速演进中。我们一定会密切关注它，希望您也如此。
Hotwire(Oct 2021, 评估)
继成功发布服务器端 Email 应用 HEY 之后， Basecamp 对外公布，他们于今年夏天将旗舰产品 Basecamp 3 迁移到了 Hotwire 。当很多组织越来越多地把单页应用（SPAs）作为新 Web 开发的首选，我们非常兴奋地看到 Hotwire 一直在逆流而上。和单页应用（SPAs）不同， Hotwire 应用程序的绝大部分业务逻辑和界面导航都在服务器端运行，只有很少量的 JavaScript 在浏览器上运行。 Hotwire 把 HTML 页面模块化为组件（称为 Turbo Frames ），这些组件支持延迟加载，有相互独立的上下文，能够基于用户行为修改上下文从而更新 HTML 页面。单页应用（SPAs）提供无可否认的用户响应能力，但是把传统服务器端 Web 编程的简单性与现代浏览器工具相结合，为平衡开发人员效率和用户响应能力提供了一种令人耳目一新的方式。
Hotwire(Apr 2021, 评估)
Hotwire (跨端传送HTML)是一项构建网页应用的技术。页面由组件组成，然而与现代单页应用不同，这些组件的HTML在服务端生成并“跨端”传送至浏览器。这样的应用只在浏览器端运行少量的JavaScript代码用以将HTML片段组合在一起。包括我们在内的许多团队在异步web请求获得跨浏览器支持的2005年前后都尝试了这项技术，然而由于各种原因，这项技术并未引起很多注意。 如今，Hotwire使用现代网页浏览器和HTTP的能力来实现单页应用（SPA）的快速、自适应和动态特性。它通过将逻辑放在服务端并保持客户端代码的简洁，实现了更简单的网页应用设计。Basecamp团队发布了一些Hotwire框架来支持他们自己的应用程序，其中包括Turbo和Stimulus。Turbo包含了提升应用程序响应速度的一系列技术和框架，例如防止整个页面重新加载、从缓存预览页面以及根据请求将页面切片等。Stimulus旨在通过将JavaScript对象与HTML页面元素关联起来，以增强浏览器当中的静态HTML。
Vercel(Oct 2021, 试验)
自从首次评估JAMstack以来，我们已经看到越来越多这种风格的Web应用。然而，当构建传统的动态网站和后端服务的基础设施对JAMstack来说太重的时候，我们的团队就会选择Vercel。Vercel是一个托管静态网站的云平台。更重要的是，它实现了开发、预览和发布JAMstack网站工作流程的无缝衔接。相关的部署配置非常简单。通过和GitHub集成，每个代码提交或Pull Request，都可以触发一个新的带有预览链接的网站部署。这个操作极大地加快了开发过程中的反馈。Vercel还使用CDN来扩展和加速生产环境的站点。值得一提的是，Vercel背后的团队也在支持另一个广受欢迎的框架——Next.js。
Azure认知搜索(Oct 2021, 评估)
Azure认知搜索为需要对异构内容进行文本检索的应用程序，提供搜索即服务的功能。它提供基于推送或基于拉取的API，来上传图像。它能将图像、非结构化文本或结构化文档内容编入索引，也能有限地支持基于拉取的数据源类型 。它能以REST和 .NET SDK为基础，提供用来执行搜索查询的API。搜索时既可以使用简单的查询语言，又可以使用更强大的Apache Lucene查询。后者具有字段范围查询、模糊搜索、中缀和后缀通配符查询、正则表达式搜索等功能。我们已经成功地将Azure认知搜索与其他的Azure服务一起使用，包括在Cosmos DB中搜索上传的内容。
Mambu(Oct 2021, 试验)
Mambu 是一个 SaaS 云银行平台。它使客户能够轻松灵活地构建和更改他们的银行和借贷产品。与其他开箱即用但只能通过硬编码来集成的银行核心平台不同， Mambu 是专为不断变化的金融产品而设计的。它具备别具一格的工作流，同时使用 API 驱动的方法，来定制业务逻辑、流程和集成方式。我们目前有几个项目在使用 Mambu 。凭借其基于云的可扩展性和高度可定制的特性，它正在成为构建金融产品时明智的默认业务领域系统。
Mock Service Worker(Oct 2021, 试验)
Web 应用，特别是企业内部应用，通常分为两个部分。用户界面和小部分业务逻辑运行在浏览器中，而大部分业务逻辑、认证和持久化工作运行在服务器中。这两部分一般会通过在 HTTP 上传输 JSON 进行通讯。但请不要误认为这些端点（endpoint）是真正的 API，它们只是当应用要穿越两个运行环境时的实现细节而已。与此同时，它们也提供了一个合适的“接缝”，以便独立测试这些“零件”。当测试 JavaScript 部分时，可以通过像 Mountebank 这样的工具在网络层对其服务端进行打桩（stub）和模拟（mock）。Mock Service Worker 则提供了另一种选择——在浏览器中拦截各种请求，从而进一步简化了手工测试。和Mountebank一样，为了测试网络交互，Mock Service Worker 运行在浏览器外部的 Node.js 进程中。由于 GraphQL 的复杂性，此前我们一直难以对它在网络层进行手工模拟。而在 REST 交互之外， Mock Service Worker 对 GraphQL API 的模拟能力也为它锦上添花。
Mock Service Worker(Oct 2020, 评估)
Web 应用，特别是企业内部应用，通常分为两个部分。用户界面和小部分业务逻辑运行在浏览器中，而大部分业务逻辑、认证和持久化工作运行在服务器中。这两部分一般会通过在 HTTP 上传输 JSON 进行通讯。但请不要误认为这些端点（endpoint）是真正的 API，不，它们只是当应用要穿越两个运行环境时的实现细节而已。与此同时，它们也提供了一个合适的“接缝”，以便独立测试这些“零件”。当测试 JavaScript 部分时，可以通过像 Mountebank 这样的工具在网络层对其服务端进行打桩（stub）和模拟（mock）。还有一种方式是在浏览器中拦截各种请求。我们很喜欢这种由 Mock Service Worker 带来的方式，因为 Service Worker 是前端开发人员比较熟悉的抽象层。这种方法可以简化设置，并且执行得也更快。不过，由于这些测试没有测到真正的网络层，所以你还要实现一些端到端测试，才能得到一个健康的测试金字塔。
远程集体编程(Oct 2021, 试验)
我们持续看到许多团队在工作中远程协作。对于这些团队来说， 远程集体编程 是一种值得尝试的技术。远程集体编程允许团队成员快速“蜂拥”在一个问题或者一小段代码周围，不用受多个人挤在一张办公桌前这种物理限制。团队可以对一个问题或者一段代码，使用其选择的视频会议工具进行快速地协作，而无需连接到一个大型显示器，预定会议室或者找一个白板。
远程集体编程(Apr 2021, 评估)
Mob编程是我们团队发现的一项能使远程工作变得更加方便且容易的技术。 远程 mob 编程 允许团队成员快速“蜂拥”在一个问题或者一小段代码周围，不用受物理限制而需要找到一个可以容纳多人的房间。团队可以在一个问题或者一段代码进行快速地协作，而无需连接到一个大型显示器，预定会议室或者找一个白板。
远程自发技术讨论(Oct 2021, 评估)
我们观察到远程协作工具的持续创新。Slack新增的 Huddles 特性提供了类似Discord的持久化语音通话，供用户随时加入或退出。 Gather 提供了一种有创意的方式，通过头像和视频模拟虚拟办公室。很多集成开发环境 (IDE) 为结对编程和调试提供了直接的协作功能：我们之前列举了 Visual Studio Live Share ，并在本期当中包含了 JetBrains Code With Me 。由于包括视频会议在内的工具持续地演化协作方式，我们看到参与 远程自发技术讨论 的团队数量与日俱增，重新创造了非正式对话的自发性，而非预定 Zoom 或 Microsoft Teams 会议的意向性。我们并不期待通过数字化工具完全重建面对面交流的丰富性，但我们确实看到，通过为团队提供多种协作渠道而非依赖一套工具链的方式，提升了远程团队的效率。
现代 Unix 命令(Oct 2021, 评估)
爱上 Unix 有很多理由，其中一个对行业产生深远影响的是 Unix 的哲学：应用程序应当“只做一件事，而且做好它”。在 Unix 中，一组简单的命令可以被管道串在一起形成更复杂的解决方案，这正体现了 Unix 的哲学。近年来，开发者贡献出了越来越多的 现代 Unix 命令 ，他们通常用 Rust 编写，试图把命令变得更小更快。这些命令引入了附加的功能，比如语法高亮，并且充分支持了现代化终端的特性。它们的目的在于，在原生层面帮助开发者更好的和 git 集成，并能识别出源码文件，例如，bat 是 cat 的替代品，它支持分页和语法高亮；exa 替代 ls，它支持显示文件的额外信息；还有 ripgrep，它默认忽略 gitignore、二进制和隐藏文件，是比 grep 更快的替代品。Modern Unix 仓库列举了其中的一些命令。我们很喜欢使用这些 Unix 命令，你也应该试试用它们改善命令行使用体验。不过，注意不要在脚本中用它们代替默认 OS 发行版中的标准命令，这会降低脚本在其他机器上的可移植性。
Micoo(Oct 2021, 评估)
Micoo 是拥挤的视觉回归测试工具赛道中又一新入竞争者，它是开源的解决方案，独立完备，通过提供 Docker 镜像实现简单快捷的环境设置。Micoo 还为 Node.js 、 Java 和 Python 提供了不同的客户端，以及 Cypress 插件，方便集成市面上大多数常见的前端UI自动化测试框架或解决方案。尽管 Micoo 没有提供某些基于SaaS或其他商业解决方案的所有功能，但我们的团队已经广泛使用 Micoo ，并获得了积极的体验。他们特别强调了 Micoo 不仅适用于移动端、桌面应用程序，也适用于网页。
Arium(Oct 2021, 试验)
Arium 是一个Unity 3D应用测试框架。功能测试是健康的测试金字塔中的一个重要组成部分。以包装 Unity Test framework 而成的Arium，让您能够在多个平台上为3D应用编写功能测试。我们已经在一些项目上成功地使用了它。
PyTorch Geometric(Oct 2021, 评估)
PyTorch Geometric 是 PyTorch 的几何深度学习扩展库。几何深度学习旨在构建能从非欧几里得数据（比如，图网络）中学习的神经网络。基于图网络的机器学习方法在社交网络建模和生物医药领域，特别是在药物发现领域，越来越受到人们关注。PyTorch Geometric 提供了一个易于使用的库，用于设计复杂的图网络问题，比如蛋白质结构的表示。这个扩展库同时支持 GPU 和 CPU，还在最新研究成果的基础上，内置了大量基于图的机器学习算法。
Wav2Vec 2.0(Oct 2021, 试验)
Wav2Vec 2.0 是用于语音识别的自我监督学习框架。 在这个框架里，模型被分为两个阶段进行训练。 首先，它从使用未标记数据的自我监督模式开始，并尝试实现最佳的语音表达。 然后它进行有监督的微调整，在此期间，已被标记的数据指导模型去预测特定的单词或音素。使用 Wav2Vec 后，我们发现它的方法非常强大，即使有标记数据的可用性有限，它也可以为区域语言构建自动语音识别模型。
Zap(Oct 2021, 试验)
Zap 是一个用于 GoLang 的超高性能的结构化日志库，它比标准的日志实现和其他日志库更快。Zap 既有一个“漂亮”的记录器，提供了结构化和 printf 风格的接口，也有一个更快的记录器，仅提供了结构化的接口。我们的团队已经大规模地使用了它，并且很高兴将其推荐为他们的首选解决方案。
React Hooks(Oct 2021, 采纳)
React Hooks 引入了一种管理状态逻辑的新方法；鉴于React组件相比较类来说更接近于函数，Hooks接受了这一点并将状态传给函数，而不是将函数作为方法传给带有状态的类。React应用中状态管理的另一个主要内容是 Redux ，我们注意到它已经受到审查，可以看到，在某些时候Redux的复杂性并不值得，对于这些情况，使用Hooks的简单方法是更可取的。完全靠自己去引入这种实现很快会变得棘手；因此我们推荐考虑结合 React Context 以及useContext和useReducer Hooks，并根据这篇 博客文章 中解释的路线来实现。
React Hooks(May 2020, 采纳)
React Hooks 引入了一种管理状态逻辑的新方法； 鉴于 React 组件相比较类来说更接近于函数， Hooks 接受了这一点并将状态传给函数，而不是将函数作为方法传给带有状态的类。 基于我们的经验，Hooks 提高了组件之间功能的重用性和代码的可读性。 考虑到 Hooks 使用 React Test Renderer 和 React Testing Library改进了可测试性，以及不断增长的社区支持，我们将其作为我们的首选方法。
React Hooks(Nov 2019, 试验)
今年年初，React Hooks成为了流行的JavaScript框架。它无需编写类就可以使用状态和其他React功能，从而提供了一种比使用高阶组件或render-props更简洁的方法。诸如Material UI和Apollo之类的库已经切换到使用Hooks了。测试Hooks时会遇到一些问题，特别是使用Enzyme时，这能帮助我们重新评估是否选择Enzyme作为工具。
Quarkus(Oct 2021, 试验)
我们在两年前开始评估 Quarkus，现在我们团队在这方面对它有了更多的经验。 Quarkus 是为 OpenJDK HotSpot 和 GraalVM 量身定制的 Kubernetes 原生 Java 技术栈。在过去的两年里，Quarkus 已经连接了 Java 世界中最好的库，并简化了代码配置，给我们的团队提供了一个很好的开发体验。 Quarkus 的启动时间非常快（几十毫秒）并且具有较低的 RSS 内存占用；这归功于它的 container-first 构建方法：它使用提前编译技术在编译时进行依赖注入，这样就避免了反射的运行时间成本。使用Quarkus的同时我们的团队也不得不做出一些妥协：在流水线上构建Quarkus需要将近10分钟；一些依赖注解和反射的功能（如 ORM 和序列化器）也受到了限制。这些妥协一部分是使用 GraalVM 造成的。因此，如果您的应用程序不是为了 FaaS 运行的，那么使用 Quarkus 和 HotSpot 也是一个不错的选择。
Quarkus(Nov 2019, 评估)
Quarkus是Red Hat的一个云原生、容器化优先的用于编写Java应用程序的框架。它具有非常快的启动时间（几十毫秒）和较低的内存占用率，这使其非常适用于Faas或者频繁的在容器编排中进行扩展和收缩。像Micronaut框架一样，Quarkus通过使用提前编译技术在编译时进行依赖注入，避免了反射造成的运行时成本。它还可以很好地和GraalVM的原生映像配合使用来进一步减少启动时间。Quarkus支持命令式和响应式模型。Quarkus与Micronaut和Helidon一起领导着新一代Java框架，这些框架试图在不牺牲开发人员效率的前提下，解决应用的启动性能和内存问题。它已经引起了社区的广泛兴趣，值得关注。
乾坤(Oct 2021, 评估)
微前端 自推出以来，一直很受欢迎。然而，如果团队未能保持应用程序从样式技术到状态管理的一致性，则很容易陷入微前端的无序。 乾坤，在中文中代表天地，是一个旨在为此提供开箱即用解决方案的JavaScript库。乾坤基于single-spa，允许不同的框架共存于单一应用程序中。它还提供了样式隔离和 JavaScript 沙箱，以确保微应用的样式或状态不会相互干扰。乾坤在社区中获得了一定的关注；我们的团队也在评估它，希望它可以支持更为友好的调试。
Konga(Oct 2021, 评估)
用来管理 Kong API网关 的Konga，是一个开源UI平台。它曾在往期技术雷达中位于试验环。我们的团队喜欢它快捷的配置和丰富的功能，因为这可以使团队能轻松地试验和试用配置。另外它是开源的，这使团队不必担心软件使用许可成本。
React Native Reanimated 2.0(Oct 2021, 试验)
如果我们想在 React Native 应用中制作动画，可是使用 React Native Reanimated 2.0。 我们之前有 Reanimated 1.x，但它存在与 Reanimated 声明式语言的复杂性相关的问题，并且还有一些与 React Native JavaScript 线程和 UI 线程之间的初始化和通信相关的额外性能成本。 Reanimated 2.0 尝试重新构想如何在 UI 线程中绘制动画；它允许我们使用 JavaScript 编写动画代码并在使用名为 animation worklets 的新 API 的 UI 线程上运行它们。它通过在 UI 线程上生成一个辅助 JavaScript 上下文来使之可以运行 JavaScript 函数。 我们在需要动画的 React Native 项目中使用它，并且非常喜欢它。
Batect(Oct 2021, 试验)
Batect 持续赢得我们开发者的欢迎，并被很多人作为配置本地开发和测试环境的默认方式。这个开源工具（碰巧由一名 Thoughtworker 开发）基于 Docker ，让设置和分享构建环境变得特别简单。这样，Batect 就可以成为你构建系统的入口，取代那个 “check out and go” 方法里无处不在的go脚本。Batect 会根据开发者的反馈持续演进，最近它新增了对 Docker BuildKit 和 Shell tab 补全的支持。
Batect(Apr 2019, 试验)
So much energy and effort continue to be wasted on configuring local development environments and troubleshooting the "works on my machine" problem. For many years our teams have adopted the "check out and go" approach where we use a scripted approach to ensure the local development environment is configured consistently. batect is an open source tool developed by a ThoughtWorker that makes it easy to set up and share a build environment based on Docker. batect becomes the entry point script for your build system, launching containers to perform build tasks that don't rely at all on local setup. Changes to build configuration and dependencies are simply shared through source control without requiring any changes or installations on local machines or CI agents. While we like Cage, among other tools, in this space, we see batect quickly growing in favor with our teams.
Headless UI(Oct 2021, 评估)
Headless UI 是为React.js 和 Vue.js提供的无样式组件库 ，它和 Tailwind CSS 诞生于同一个团队。和其他自带默认样式的组件库不同，开发人员不需要订制或者调整默认样式就能开始使用，这一点非常讨人喜欢。组件丰富的功能和完全的可访问性，再加上可以随意添加样式，开发人员能够更高效地专注于业务问题和用户体验。 毫无疑问，Headless UI 也可以很好的与 Tailwind CSS 类结合使用。
Transloco(Oct 2021, 评估)
Transloco 是一个用来构建多语言应用程序的 Angular 库， 它可以在模板中使用，并提供了处理更复杂情况的功能。 由于翻译是在运行时按需加载的，Transloco 可以轻松地在 Web 浏览器中实现语言切换。 Transloco 还可以通过模板管道对数字、日期等进行本地化处理。
Proxyman(Oct 2021, 评估)
它可能并不是你每天都需要的工具，但是当你在诊断令人讨厌的网络问题手忙脚乱时，它能帮你获得功能丰富的 HTTP 调试代理。 Proxyman 就是这样一个工具。 我们的一些团队已经使用它有段时间了，作为在 macOS 上 Charles 的直接替代品，我们非常喜欢它最新型的界面和证书管理。
fastlane(Oct 2021, 采纳)
代码签名是发布 iOS 应用中的一步。虽然这一步已经有 Apple 的工具链支持，但过程仍易出错，充满了意外和不便之处。我们非常高兴地告诉你， fastlane 已经成为了我们自动发布移动应用时的选择。 fastlane 为代码签名提供了一个更好的解决方案 —— match 。它已被集成在 fastlane 顺滑的流程中，并且为管理团队的代码签名实现了一个新的方法。这种方法并不将签名密钥缺省存入开发者 macOS 的钥匙串中，而是将密钥与证书存入一个 Git 仓库中。这不仅让新上项目的成员更加方便地设置开发机器，而且在我们的体验中，这也是把代码签名融入持续交付流水线的最简单的方式了。
fastlane(Nov 2017, 采纳)
Web application developers have it easy when it comes to simplifying and automating diverse application workflows; they can choose from a variety of solutions to help automate release processes. When developing for mobile, however, we're dealing with two operating systems with two different ways of building, testing, distribution, generating screenshots, signing and distributing applications. To help ease the pain, our teams have adopted fastlane as the go-to tool to automate the release process for iOS and Android applications. Using simple configurations and multiple pipelines, they can achieve continuous delivery for mobile development.
fastlane(Mar 2017, 采纳)
Web application developers have it easy when it comes to simplifying and automating diverse application workflows; they can choose from a variety of solutions to help automate release processes. When developing for mobile, however, we're dealing with two operating systems with two different ways of building, testing, distribution, generating screenshots, signing and distributing applications. To help ease the pain, our teams have adopted fastlane as the go-to tool to automate the release process for iOS and Android applications. Using simple configurations and multiple pipelines, they can achieve continuous delivery for mobile development.
fastlane(Nov 2016, 试验)
fastlane is our go-to tool for automating most of the boring activities involved in getting iOS and Android mobile apps built, tested, documented and provisioned. Simple configuration, a range of tooling and multiple pipelines make this a key ingredient in doing continuous delivery for mobile.
DoWhy(Oct 2021, 试验)
DoWhy 是一个 Python 库，用于执行端到端的因果推理和分析。尽管利用当时存在的变量的相关性，机器学习模型可以根据事实数据进行预测。但在我们需要问如果和为什么问题的场景中，它们是不够的。如果一个变量改变了呢？对结果会有什么影响？因果推理是回答此类问题的一种方法。它估计了因果效应，也就是说，如果我们改变一个原因变量，结果会发生多大的变化。由于实验的成本或限制，当我们无法通过观察和收集 A/B 测试的数据来得出答案时，就可以采用这种方法。基于使用过去收集的事实和数据以及人们可以在了解领域时做出的假设，DoWhy 库对因果效应进行估计。它使用了一个四步流程，即根据假设对因果关系图进行建模，确定结果的原因，估计因果效应，最后通过反驳结果来挑战这些假设。我们已经在生产中成功地使用了这个库，它是因果估计用例中常用的库之一。
平台工程产品团队(Oct 2021, 采纳)
我们继续将 平台工程产品团队 视为默认团队配置，关键在于是他们只是一个专注于内部平台客户的产品团队。因此，在使用与任何其他（以外部为重点的）产品团队相同的工程学科和工作方式的同时，明确定义客户和产品至关重要；平台团队在这方面并不特殊。我们强烈警告不要只将现有的内部团队重命名为“平台团队”，而同时保持工作方式和组织结构不变。在考虑如何最好地组织平台团队时，我们仍然非常喜欢使用团队拓扑中的概念。我们认为平台工程产品团队是一种标准方法，也是高性能 IT 的重要推动者。
平台工程产品团队(Apr 2021, 采纳)
正如本期雷达主题之一所指出的那样，业界在创建和支持内部平台的“平台工程产品团队”中积累了越来越多的经验。组织中的团队使用这些平台，可以加速应用程序开发，降低运营复杂性并缩短产品上市时间。随着采用率的提高，我们对于这种方法的好和坏的模式也越来越清楚。创建平台时，至关重要的是要明确定义可以从中受益的客户和产品，而不是凭空建立。我们不仅要谨防分层平台团队，它保留了现有技术孤岛，只是贴上了“平台团队”的标签而已，还要小心工单驱动的平台运营模型。当考虑如何最好地组织平台团队时，我们仍然是团队拓扑概念的忠实拥护者。我们认为平台工程产品团队是一种标准方法，并且是高性能IT的重要推动者。
平台工程产品团队(May 2020, 试验)
采用云计算和DevOps，虽然提高了团队生产力，减少了对集中式运维团队和基础设施的依赖，但也制约了那些缺乏自管理完整应用和运维技巧的团队。一些组织通过创建 平台工程产品团队 来应对这些挑战。这些团队维护着一个内部的应用平台，该平台使交付团队能够自助部署和运维系统，从而减少交付时间和降低技术栈的复杂度。这里的重点是 API 驱动的自服务和支持工具，而交付团队仍然需要对部署在该平台上的应用负责。当组织考虑组建这样一个团队的时候应当非常小心，避免无意中创建一个独立的 DevOps 团队，也不要把现有托管及运维设施重新打上平台的标签。关于如何最佳地组建平台团队，我们一直在使用团队拓扑中的概念，将项目中的平台团队划分为赋能团队、核心“平台中的平台”团队和齐头并进的团队。
平台工程产品团队(Nov 2017, 评估)
The adoption of cloud and DevOps, while increasing the productivity of teams who can now move more quickly with reduced dependency on centralized operations teams and infrastructure, also has constrained teams who lack the skills to self-manage a full application and operations stack. Some organizations have tackled this challenge by creating platform engineering product teams. These teams operate an internal platform which enables delivery teams to self-service deploy and operate systems with reduced lead time and stack complexity. The emphasis here is on API-driven self-service and supporting tools, with delivery teams still responsible for supporting what they deploy onto the platform. Organizations that consider establishing such a platform team should be very cautious not to accidentally create a separate DevOps team, nor should they simply relabel their existing hosting and operations structure as a platform.
平台工程产品团队(Mar 2017, 评估)
The adoption of cloud and DevOps, while increasing the productivity of teams who can now move more quickly with reduced dependency on centralized operations teams and infrastructure, also has constrained teams who lack the skills to self-manage a full application and operations stack. Some organizations have tackled this challenge by creating platform engineering product teams. These teams operate an internal platform which enables delivery teams to self-service deploy and operate systems with reduced lead time and stack complexity. The emphasis here is on API-driven self-service and supporting tools, with delivery teams still responsible for supporting what they deploy onto the platform. Organizations that consider establishing such a platform team should be very cautious not to accidentally create a separate DevOps team, nor should they simply relabel their existing hosting and operations structure as a platform.
Tailwind CSS(Oct 2021, 试验)
我们的开发人员一直在使用 Tailwind CSS 提高工作效率，并且对其在大型团队和代码库的可扩展性印象深刻。 Tailwind CSS通过较低层次的 CSS 样式类降低复杂性，为 CSS 工具和框架提供了一种替代方法。Tailwind CSS 易于定制，可以适应任何客户的视觉设计。 我们还发现它与 Headless UI 搭配得很好。 Tailwind CSS 使开发者不需要编写任何新的样式类或 CSS 样式。从长远来看，这将产出更易于维护的代码。Tailwind CSS 在可重用性和自定义创建可视化组件之间，提供了适当的平衡。
Tailwind CSS(May 2020, 评估)
CSS工具和框架提供了预先设计的组件，帮助开发者快速实现想要的页面效果。但是随着开发的进行，它们变得难以定制。Tailwind CSS 提供了一种有趣的方法。为了便于定制，它仅提供了较低层次的CSS样式类来构建模块，且没有自带任何多余的复杂样式。较低层次CSS样式类广泛的覆盖，使开发者不需要编写任何新的样式类或CSS样式。从长远来看，这将产出更易于维护的代码。这样来看 Tailwind CSS 在可重用性和自定义创建可视化组件之间，提供了适当的平衡。
Jetpack Compose(Oct 2021, 采纳)
仿照苹果推出的 SwiftUI ，Google 也为现代 Android 应用提供了完全不同的全新用户界面构建方式 Jetpack Compose。Compose 提供了更强大的工具和一组直观的 Kotlin API，这在多数情况下可以减少代码量，并且比起先定义静态 UI 再填充数据的传统方式，在应用运行时直接创建用户界面会更容易。随着 Compose Multiplatform 和 Kotlin Multiplatform 的出现，开发者现在可以使用统一的工具套件来构建桌面、网页以及原生 Android 应用。此外，Compose 支持 Wear OS 3.0+，而随着 Kotlin Multiplatform Mobile 提供对 iOS 的支持，将来 Compose 也可能会支持 iOS。
Pull Request 等同于代码同行评审(Oct 2021, 暂缓)
一些组织似乎觉得Pull request 等同于代码同行评审。他们认为唯一能够实现代码同行评审的方法就是 Pull request 。我们发现这种方法会造成严重的团队瓶颈，并且显著地降低反馈的质量，因为超负荷的评审人员会开始简单地拒绝 Pull requests 。虽然有观点认为，这是一种展示代码评审强制性的方式，但是我们的一个客户被告知，这种观点没有任何的依据，因为没有证据能够表明代码在接受之前被任何人实际阅读过。Pull requests 只是管理代码评审工作流的一种方式，我们敦促人们考虑其它的方法，特别是在需要仔细提供指导和反馈的情况下。
Pull Request 等同于代码同行评审(Apr 2021, 暂缓)
一些组织似乎觉得 代码同行评审等同于pull request 。他们认为唯一能够实现代码评审的方法就是pull request。我们发现这种方法会造成严重的团队瓶颈，并且显著地降低反馈的质量，因为超负荷的评审人员会开始简单地拒绝pull requests。虽然有观点认为，这是一种展示代码评审强制性的方式，但是我们的一个客户被告知，这种观点没有任何的依据，因为没有证据能够表明代码在被接受之前真的有被阅读过。Pull requests只是管理代码评审工作流的一种方式，我们敦促人们考虑其它的方法，特别是在需要对代码提供指导和反馈的情况下。
Regula(Oct 2021, 评估)
基础设施即代码（infrastructure as code，IaC）的其中一个信条是自动化测试。假设我们的测试金字塔强壮，在底层的代码层面的测试有良好的覆盖，那我们能产出更好而且更安全的基础设施。不幸的是，支持这个领域的工具相当稀缺。Conftest 经常被用于测试 Terraform 的 JSON 和 HCL 代码，然而它是一个普通用途的工具。Regula 是一个有吸引力的替代品。和 Conftest 类似，Regula 以 Open Policy Agent 的 Rego 语言编写的规则，来检查基础设施代码的合法性，但它同时提供了一系列的基础类型来对基础设施配置进行特别的验证。因为两个工具都是基于 Rego 语言的，Regula 规则也可以由 Conftest 运行。然而，Regula 有自己的命令行工具，它可以在流水线上不依赖 Conftest 或者 OPA 来运行测试。我们的开发者认为 Regula 可以节约时间并产出更可读、可维护和简练的测试代码。即便如此，两个工具都只验证基础设施代码。一个完整的测试集应该也去测试基础设施本身，以确保代码被正确地翻译了。
Confluent Kafka REST Proxy(Oct 2021, 试验)
Kafka 是事件驱动架构的常规默认平台，但若调整其以适应遗留系统的环境，则会引入不匹配的问题。然而在一些案例中，我们成功地使用 Confluent Kafka REST Proxy，来将遗留系统环境的复杂度降至最低。该代理允许开发人员通过 HTTP 接口访问 Kafka ，这在难以使用原生 Kafka 协议的环境中尤为有用。例如，只须让 SAP 团队通过预配置好的 SAP 远程函数调用，发出一条 HTTP POST 命令，就能消费到由 SAP 发出的这个事件。这避免了启用 SAP 相关的 Java 抽象（以及用来管理它的团队）。尽管此代理的功能非常全面，但与任何此类适配器工具一样，我们都建议应谨慎且清醒地了解其中所涉及到的利弊权衡。我们相信，该代理允许遗留系统的生产者发送事件这一点是很有价值的，但经由它来创建事件的消费者时要多加小心，因为抽象会变得更为复杂。该代理不会改变 Kafka 消费者是有状态的这一事实，这意味着由 REST API 创建出的消费者实例，会与特定的代理相绑定。此外，需要进行 HTTP 调用来消费主题中的消息，会改变 Kafka 事件的标准语义。
ExternalDNS(Oct 2021, 评估)
ExternalDNS 将Kubernetes的Ingress和Service所对应的DNS记录，同步给外部的DNS提供商。而这项工作原本由kops dns-controller、Zalando's Mate或者route53-kubernetes来完成。由于人们更加青睐ExternalDNS，后两者目前已被弃用。该工具使得用户可以通过公共DNS服务器，来发现Kubernetes的内部资源，从而减少了因 Ingress 主机或者 service IP地址发生改变，而需要更新DNS时的一些人工步骤。它支持大量可以直接使用的DNS服务提供商，并且正在通过社区支持增加更多DNS服务提供商。就像那句老玩笑话所说，万事皆关乎DNS。
FastAPI(Apr 2021, 试验)
越来越多的团队正在使用Python作为他们解决方案的首选语言，这不仅针对数据科学，也同样对于后端服务。在这些场景中，FastAPI给了我们优秀的体验。这是一个使用Python 3.6或更新版本来构建API的现代、快速（高性能）的Web框架。不仅如此，该框架及其生态还包括了诸如用OpenAPI来创建API文档这样的功能，使团队可以聚焦在业务功能并快速创建REST API。这些特性使FastAPI在这个领域成为了现有解决方案的良好替代品。
分层的平台团队(Apr 2021, 暂缓)
软件平台的流行为组织创造了很多价值，但是在构建基于平台的交付模型的道路上到处都是潜在的死胡同。在这些新流行技术的刺激下，我们往往会发现它们实际上都是“新瓶装旧酒”，是“老技术”在新时代背景下的另一种“复兴”，这很容易使我们忽略一开始选择放弃这些技术的原因。我们在上一期的技术雷达中发表的 披着API网关外衣的企业服务总线 就是一个很好的例子。我们看到的另一个例子是“按技术层级划分团队”，只不过换了个说法将其称为平台。在构建应用程序的上下文中，前端团队，业务逻辑团队和数据团队分开是很常见的，而在组织根据平台能力划分业务或数据层团队时我们看到了与之相似的模型结构。由于康威定律，我们知道围绕 业务能力 组织平台功能团队是一种更有效的方式，它为团队提供能力的端到端的所有权，包括数据所有权。这有助于避免 分层的平台团队 的依赖管理问题，否则做任何事情的时候前端团队都必须依赖业务逻辑团队，而业务逻辑团队又必须依赖数据团队。
Angular Testing Library(Apr 2021, 试验)
随着继续使用JavaScript开发Web应用，我们也从Testing Library的应用测试方法中获益良多；并且继续针对它的一系列软件包进行探索和经验积累，不仅仅限于React Testing Library。Angular Testing Library在以用户为中心测试UI组件的方面上拥有这个大家庭的全部优势，鼓励测试用户行为，而非UI细节的实现方式，使得测试更具有可维护性。虽然缺乏完善的文档，但Angular Testing Library提供了良好的测试示例来帮助我们针对于不同场景更好地上手。我们已经成功地在Angular项目上应用了这个测试库，并且建议你们也能尝试一下这个可靠的测试方法。
NATS(Apr 2021, 评估)
NATS是一种快速和安全的消息队列系统，具有异常广泛的功能和潜在的市场。有人会问，为什么还需要另一个消息队列系统？自从企业开始使用计算机以来，各种形式的消息队列系统已经存在了很长时间了，并且针对各种任务，经历了多年的改进和优化。但是，NATS 的确具有几个有趣的特征，并且其独特的伸缩性，既能用于嵌入式控制器，又能用于全球范围云托管的超级集群。 NATS 旨在支持来自移动设备或 IoT 并通过互连系统的网络所传递的连续数据流，对此我们特别感兴趣。但是，该系统也需要解决一些棘手的问题，其中最重要的，是确保消费者仅看到他们被允许访问的消息和主题，尤其是当网络跨越组织边界时。 NATS 2.0 引入了一个安全和访问控制框架。该框架支持多租户群集。在该群集中，帐户限制了用户对消息队列和主题的访问。 NATS 是 Go 语言编写的，最初主要被Go语言社区所接受。尽管该系统针对几乎所有广泛使用的编程语言都提供客户端，但是 Go 语言所实现的客户端是迄今为止最受欢迎的。我们的一些开发人员发现，所有编程语言的客户端库，都倾向于要提供 Go 语言客户端所具备的特性。小型无线设备的带宽和处理能力的提高，意味着企业必须实时处理的数据量只会增大。可以评估 NATS 作为在企业内部和企业之间，以流的形式传输数据的可行性。
Blazor(Apr 2021, 试验)
虽然 JavaScript 及其生态系统已经在 Web UI 领域占据了统治地位，但随着 WebAssembly 的出现，一些新的机遇之窗也正在打开。Blazor 依然值得我们的关注；我们的团队使用 C# 在 WebAssembly 之上构建交互丰富的用户界面，取得了良好的效果。同时，能够在前端使用 C#，也意味着可以共享代码和复用现有的库。除此以外，配合使用 bUnit 这类现存的调试和测试工具，这个开源框架值得一试。
Blazor(Oct 2020, 评估)
虽然 JavaScript 及其生态系统已经在 Web UI 领域占据了统治地位，但随着 WebAssembly 的出现，一些新的机遇之窗也正在打开。我们看到一个有趣的新选择 —— Blazor，它可以使用 C# 来构建交互式 Web UI。我们青睐这个开源框架，是因为它能让我们在浏览器中基于 WebAssembly 运行 C# 代码，从而利用 .NET 标准运行时环境和生态系统以及它的各种自定义库。此外，只要需要，它还可以在浏览器中与 JavaScript 代码进行双向互操作。
AWS CodePipeline(Apr 2021, 暂缓)
根据ThoughtWorks多个团队的使用经验，我们建议你谨慎使用AWS CodePipeline。 具体来说，我们发现一旦团队的需求超出简单的流水线范畴，此工具就会变得难以使用。尽管初次使用AWS时，像是赢得了“快速的胜利”，但我们建议你后退一步，评估AWS CodePipeline是否可以满足你的长期需求，例如流水线的fan-out和fan-in，或者是更复杂的部署，以及具有特殊依赖关系及触发条件的测试场景。
同态加密(Apr 2021, 评估)
完全的同态加密 (HE)是指一类允许在加密数据上直接进行计算操作（如搜索和算数运算）的加密方法。同时计算的结果仍然以加密的形式存在，并且稍后可以对其进行解密和显示。虽然同态加密问题早在1978年就被提出来了，但直到2009年才出现解决方案。随着计算机算力的提升，和诸如SEAL, Lattigo, HElib 和 Python中的部分同态加密之类易于使用的开源库的出现，同态加密在现实世界的应用程序中的应用才真正地变得可行。那些令人振奋的应用场景包括在将计算外包给一个不受信的第三方时的隐私保护，例如在云端对加密数据进行计算，或使第三方能够聚合同态加密后的联邦机器学习的中间结果。此外，大多数的同态加密方案被认为是对量子计算机安全的，并且标准化 同态加密的努力也正在进行之中。尽管同态加密目前在性能和可支持的计算类型上还存在诸多局限，但是它仍然是一个值得引起我们注意的技术。
假设驱动的遗留系统改造(Apr 2021, 试验)
我们经常被要求更新、升级或者修正那些原本不是由我们构建的遗留系统。有时，我们需要注意一些技术问题，比如提升性能和可靠性。解决这些问题的常用方法是使用与用户故事卡相同的格式创建“技术故事卡”，但以技术成果而非业务成果作为目标。但是这些技术任务通常很难估计需要的时间，花费的时间比预期的要长，最终也时常会得不到预想的成果。另一种更成功的方法是应用 假设驱动的遗留系统改造 。不同于面向标准的 backlog 工作，在这一方法下，团队提出可度量的预期技术成果，并共同建立一组对问题的假设。然后，团队根据优先级在有限时长内进行迭代试验，来验证或推翻每个假设。由此将产生优化后的工作流程，这一流程不是为了按照计划朝着可预测的结果前进，而是为了减少不确定性。
Snowflake(Apr 2021, 试验)
自从上次在雷达上提到 Snowflake 以来，对于它的使用，以及作为数据仓库和数据湖的替代方案的data mesh，我们都获得了更多经验。 Snowflake 在时间旅行、零拷贝克隆、数据共享及其应用市场等功能方面，继续给人留下深刻印象。Snowflake 至今还没出现任何令我们不喜欢的地方，所以相较于其他选择来说，我们的顾问会更偏爱使用它。亚马逊的数据仓库产品 Redshift 正在朝着将存储和计算进行分离的方向发展，而这一直都是 Snowflake 的强项。如果使用 Redshift 产品中的 Spectrum 特性进行数据分析，就会感觉它并非那么方便和灵活，部分原因是它受到了 Postgres 的约束（虽然我们也喜欢用Postgres。而进行联合查询（federated queries）可能是使用 Redshift 的原因。在操作方面，Snowflake 的操作会更简单。 虽然BigQuery是另一种选择，且非常易于操作，但在多云的场景下，Snowflake是更好的选择。我们已经在GCP、AWS和Azure上成功地使用了 Snowflake。
Snowflake(May 2020, 试验)
对我们的很多客户来说，Snowflake 已被证明是一个健壮的 SaaS 大数据存储、数仓或数据湖解决方案。它拥有先进的架构，来扩展存储、算力和服务，以加载、卸载和使用数据。它也非常灵活，支持结构化、半结构化和非结构化数据。它为不同的访问模式（如用于数据科学的Spark和用于分析的 SQL），提供相应的 connector（数量正不断增加）。它也能运行在多种云平台上。对许多客户而言，我们建议公共系统（如大数据存储）要使用托管服务。然而，如果出于风险和法规的考虑，无法使用托管服务的话，那么 Snowflake 对于具有大数据量和大处理量的公司，是个不错的选择。我们已经成功地在中型项目中使用了 Snowflake ，但尚未在数据需要跨组织部门存储的大型生态系统中尝试过。
Snowflake(Nov 2019, 评估)
我们经常将数据仓库和中心化的基础设施联系起来，而随着围绕数据的需求不断增长，中心化的基础设施是难以扩展和管理的。然而，Snowflake是一种全新的SQL数据仓库即服务解决方案，专为云平台而构建。Snowflake拥有大量精心设计的功能，例如数据库级的原子性，结构化和半结构化数据支持，数据库内分析功能，尤其是将存储、计算和服务层明确分离，从而解决了大多数数据仓库所面临的挑战。
Streamlit(Apr 2021, 试验)
Streamlit 是开源的 Python 应用程序框架，供数据科学家使用，以构建交互式数据应用程序。调整机器学习模型需要花费大量时间，但是我们可以在 Streamlit 中快速构建独立的原型，并在实验循环中收集反馈，而不用在主程序（使用模型的应用程序）中反复调整。Streamlit相较于 Dash 等竞争对手表现更佳出众， 因为它专注于快速原型开发，并支持大量的可视化库（例如 Plotly 以及 Bokeh）。 我们已经在几个项目中使用了 Streamlit，并且很喜欢用它轻松地构建交互式可视化应用。
Streamlit(Oct 2020, 评估)
Streamlit 是 Python 编写的开源应用框架，数据科学家用其来构建好看的数据可视化应用。Streamlit 专注于快速原型设计，并且支持各种不同的可视化库(包括 Plotly和Bokeh)，因此在Dash等竞品中脱颖而出。对于需要在实验周期中快速展示的数据科学家来说，Streamlit 是一个可靠的选择。我们在一些项目中使用它，并且只需要花费很少的工作量就能把多个交互式可视化放在一起。
Distroless Docker images(Apr 2021, 试验)
在为应用构建 Docker 镜像时，我们常常会考虑两件事：镜像的安全性和大小。通常情况下我们会使用容器安全扫描工具来检测和修复常见的漏洞和风险，并使用 Alpine Linux 之类的小型发行版来解决镜像过大和分发性能的问题。然而随着安全威胁的增长，消除所有潜在的攻击面变得空前重要，这就是 distroless Docker images 正成为部署容器默认选项的原因。Distroless Docker images 通过放弃完整的操作系统发行版来减少内存占用和依赖关系，它还可以减少安全扫描噪声和应用程序攻击面。此外，这一技术还意味着需要修补的漏洞更少了，镜像更小性能也更好了。Google 针对不同的语言发布了一套 distroless container images ，你可以使用 Google 构建工具 Bazel 或者简单地使用多阶段 Dockerfiles 创建 distroless 的应用程序镜像。请注意，默认情况下，distroless 容器没有用于调试的 shell，不过，你可以在网上轻松地找到包含 BusyBox shell的 distroless 容器调试版。Distroless Docker image 是 Google 开创的技术，根据我们的经验，这种技术的应用仍然主要局限于 Google 生成的镜像，如果有更多的供应商可供选择，我们会更放心。另外，在使用 Trivy 或类似的漏洞扫描器时要小心，因为只有较新版本才支持 distroless 容器。
Distroless Docker images(Oct 2020, 试验)
当为我们的应用构建 Docker 镜像的时候，我们常常会考虑两件事情：镜像的安全性和大小。通常情况下我们使用容器安全扫描工具来检测和修复常见的漏洞和风险，以及使用 Alpine Linux 来解决镜像大小和分发性能问题。我们现在已经获得了有关 distroless Docker images 的更多经验，并准备推荐这种方法作为容器化应用程序的另一重要安全预防措施。Distroless Docker images 通过移除完整的操作系统发行版来减少占用空间和依赖。此技术可减少安全扫描噪声和应用程序攻击面，需要修补的漏洞较少，此外，这些较小的镜像更有效。 Google 针对不同的语言发布了一套 distroless container images。你可以使用 Google 构建工具 Bazel 或者仅仅使用多阶段 Dockerfiles 创建简单的应用程序镜像。请注意，默认情况下，Distroless 容器没有用于调试的 shell。不过，你可以在网上轻松地找到 Distroless 容器的调试版本，包括 BusyBox shell。 Distroless Docker image 是 Google 率先提出的技术，根据我们的经验，仍然主要限于 Google 生成的镜像。我们希望这项技术能够超越这一生态系统。
Distroless Docker images(Nov 2018, 评估)
When building Docker images for our applications, we're often concerned with two things: the security and the size of the image. Traditionally, we've used container security scanning tools to detect and patch common vulnerabilities and exposures and small distributions such as Alpine Linux to address the image size and distribution performance. In this Radar, we're excited about addressing the security and size of containers with a new technique called distroless docker images , pioneered by Google. With this technique, the footprint of the image is reduced to the application, its resources and language runtime dependencies, without operating system distribution. The advantages of this technique include reduced noise of security scanners, smaller security attack surface, reduced overhead of patching vulnerabilities and even smaller image size for higher performance. Google has published a set of distroless container images for different languages. You can create distroless application images using the Google build tool Bazel, which has rules for creating distroless containers or simply use multistage Dockerfiles. Note that distroless containers by default don't have a shell for debugging. However, you can easily find debug versions of distroless containers online, including a busybox shell.
Jotai和Zustand(Apr 2021, 评估)
我们在之前的技术雷达中评价过尚处试验开始阶段的React应用程序状态管理。我们将Redux移回到试验环, 标明它不再是我们的默认选项，并且提到了Facebook的Recoil。在这一期的技术雷达中，我们要强调的是 Jotai 和 Zustand。它们都是React的状态管理包，且目标都是小巧易用。也许不完全是巧合，两者的名字分别是日语和德语中对于单词 状态的翻译。 除了这些相同点，两者的设计也是有所不同的。Jotai的设计与Recoil相似，都是状态由存储在React组件树中的原子组成，而Zustand将状态存储在React外部的单个状态对象中，就像Redux采取的方式一样。Jotai的作者提供了一个非常有用的对照表，可供你决策使用哪一个工具。
Why Did You Render(Apr 2021, 试验)
使用React开发时，我们经常会遇到的情况是：因为某些组件进行了不必要的重复渲染而导致页面性能很差。Why Did You Render是一个能够帮助侦测组件重新渲染的库。它是通过对React的猴子补丁实现了这一点。我们在一些项目中使用它来调试性能问题，并取得了很好的效果。
LitElement(Apr 2021, 试验)
自从我们于2014年第一次提到Web Components以来，它已经取得了稳步的发展。作为Polymer项目的一部分，LitElement是一个简单的库，你可以使用它创建轻量级Web组件。它实际上只是一个基类，它去掉了很多常见的模板，从而使编写Web组件变得更加容易。我们已经在项目上成功地使用了它，并且随着技术的成熟和LitElement库的广受欢迎，它在Web Components项目中的应用将会越来越普遍。
LitElement(Oct 2020, 评估)
自我们于2014年第一次提到 Web Components 以来，它已经取得了稳步的发展。作为 Polymer 项目的一部分，LitElement 是一个简单的库，你可以使用它创建轻量级 web 组件。它实际上只是一个基类，它减少了对许多常见引用文件的需要，并且使编写 Web 组件变得更加容易。我们已经在项目中使用它取得了早期的成功，并且很高兴看到这项技术的成熟。
用Kafka API而非Kafka(Apr 2021, 评估)
随着越来越多的企业开始运用事件在微服务之间共享数据、收集分析数据或传输数据到数据湖，Apache Kafka已经成为支撑事件驱动架构的最受欢迎的平台。尽管 Kafka 的可伸缩的消息持久化概念是革命性的，但要使其正常工作，还是需要依赖众多的活动部件，包括 Zookeeper、代理、分区和镜像。虽然实现和维护这些组件会很棘手，但是它们确实在需要的时候，尤其是在企业规模的应用中，提供了极大的灵活性和强大功能。因为采用 Kafka 完整生态系统的门槛较高，所以我们乐于见到一些平台在最近的爆发式增长。这些平台提供 用Kafka API而非Kafka 的功能。最近涌现出的Kafka on Pulsar和Redpanda，就是属于这类平台。而Azure Event Hubs for Kafka则提供了对 Kafka 生产者和消费者 API 的兼容。但由于 Kafka 的某些功能（例如数据流客户端库）与这些替代代理不兼容，因此仍然有理由选择 Kafka 而不是这些替代代理。然而究竟开发者是否会采用“用Kafka API而非Kafka”的策略，抑或这只是 Kafka 的竞争对手试图将用户引诱到 Kafka平台之外，还有待观察。最终，也许Kafka最持久的影响力，就是其提供给客户的易用协议和API。
LVGL(Apr 2021, 评估)
随着智能家居和可穿戴设备的日益普及，对直观的图形用户界面(GUI)的需求越来越大。但是，如果从事嵌入式设备的开发，而不是Android/iOS，GUI的开发可能需要花费很多精力。作为一个开源的嵌入式图形库，LVGL越来越受欢迎。LVGL已经适配了主流的嵌入式平台，如NXP、STM32、PIC、Arduino和ESP32。它的内存占用空间非常小：64 kB闪存和8 kB RAM就足以让它工作，而且它可以在各种Cortex-M0低功耗MCU上平稳地运行。LVGL支持触摸屏、鼠标和按钮等输入类型，并包含30多个控件，包括适合智能手表的TileView。它选择的MIT授权并不限制企业和商业用途。我们的团队对这个工具的反馈是积极的，且一个使用LVGL的项目已经投入生产，更确切地说是小批量生产。
使用工具管理 Xcodeproj(Apr 2021, 试验)
许多使用 Xcode 编写 iOS 代码的开发者经常会因为 Xcodeproj 文件总是随着项目配置变化而变化而头痛不已。由于Xcodeproj 文件格式难以阅读，因此合并文件冲突非常复杂，有可能导致生产力下降甚至打乱整个项目，因为这个文件一旦出现错误，Xcode 将无法正常运行，开发工作也很可能被迫中断。因此，我们建议不要手动合并修复 Xcodeproj文件，或是对其进行版本管理，而是 使用工具管理 Xcodeproj : 用 YAML（XcodeGen，Struct），Ruby（Xcake）或是 Swift（Tuist）定义你的Xcode项目配置。这些工具会根据配置文件和项目结构生成 Xcodeproj 文件，因此， Xcodeproj 文件合并冲突将成为历史，相比之下配置文件冲突要容易处理得多。
Bit.dev(Apr 2021, 评估)
Bit.dev 是一个云托管平台，用于通过 Bit 抽取、模块化并重用UI组件。虽然 Web components 已经存在一段时间了，但通过组装从其它项目抽取出来的独立小组件，来构建现代前端应用，仍然很困难。而 Bit 要解决的，就是这个问题。它是一个简洁的命令行工具，可以从已有的库或项目当中抽取组件。要进行组件协作，既可以在 Bit 的基础上自行构建相关服务，也可以直接使用 Bit.dev。
Remote - WSL(Apr 2021, 评估)
在过去的几年里，我们曾经讨论过几次 Windows Subsystem for Linux (WSL)。尽管我们欣喜于看见WSL的进步，比如WSL2的改进，却一直没有将它收录在技术雷达中。这一期里，我们想要着重介绍一个Visual Studio Code插件，它能够显著提升WSL的使用体验。Windows中的代码编辑器虽然可以访问WSL文件系统，但是并不能感知隔离的Linux环境。然而有了 Remote - WSL 插件，Visual Studio Code 不仅可以感知WSL，还允许开发者启动Linux shell，并且支持在Windows下调试WSL里运行的二进制代码。在 WSL支持 中可以看到，Jetbrains的IntelliJ也在这方面做出了稳步的改进。
SWR(Apr 2021, 试验)
我们团队发现在合适的情况下，使用React Hooks 的库SWR可以达到代码整洁和性能大幅提升的效果。SWR实现了更新的同时使用过期数据（stale-while-revalidate, 缩写即SWR）的HTTP缓存策略，即第一次从缓存中返回（过期）数据，然后发送拉取数据的请求（更新），最后用最新的返回数据刷新缓存。我们告诫团队仅在应用程序应返回过期数据时才使用SWR缓存策略。需要注意的是，HTTP 要求以最新的数据缓存来响应请求，而只能在经过深思熟虑的情况下才允许返回过期的响应。
SWR(Oct 2020, 评估)
SWR 是用于获取远程数据的 React Hooks 库，它实现了 stale-while-revalidate HTTP缓存策略。SWR 首先从缓存（过时的）中返回数据，然后发送获取请求（再验证）并最终用更新的响应数据刷新数值。组件因此持续而且自动地获得一个数据流，先是过时的，然后是刷新过的。我们的开发者在使用 SWR 时获得了很好的开发体验，并且因为数据总是显示在屏幕上，从而显著提升用户体验。然而，我们提醒团队，只有当应用程序返回过时数据是合适的时候，才能使用 SWR 缓存策略。要注意，HTTP 通常要求缓存要用最新的响应返回给请求，只有在需要非常慎重的场景下，才会允许返回过时的响应数据。
axe-core(Apr 2021, 试验)
让网络具有包容性，就需要重视在软件交付的所有阶段都考虑并验证它的可访问性。许多流行的可访问性测试工具，都是为对完成后的Web应用程序进行测试而设计的。结果问题往往发现得较晚，并且更难解决，最终累积成为债务。最近在ThoughtWorks网站上工作时，我们将开源可访问性（a11y）测试引擎 axe-core 纳入了构建流程。它为团队成员提供了关于遵守无障碍规则的早期反馈，即使在早期增长阶段也是如此。但是，并非每个问题都可以通过自动检查发现。商业版的axe DevTools扩展了axe-core的功能，其中包括可以指导团队成员针对大多数可访问性问题进行探索性测试。
Azure Machine Learning(Apr 2021, 暂缓)
我们之前已经观察到，云供应商会将越来越多的服务推向市场。同时雷达还记录了我们担忧的一些问题，即有些服务还没有完全准备就绪，就被推向市场供人使用。不幸的是，以我们的经验来说，Azure Machine Learning 就属于这类服务。作为 限界低代码平台 领域的 新产品 ，Azure ML 承诺为数据科学家提供更多的便利。但是，最终它没有实现诺言。实际上，我们的数据科学家仍然认为，使用 Python 会更为容易。尽管我们付出了巨大的努力，但仍难以使其规模化。此外缺少足够的文档也是它的另一个问题。所以我们将其移动至暂缓环。
最简单的机器学习(Apr 2021, 试验)
所有主流的云厂商都提供了令人眼花缭乱的机器学习解决方案。这些强大的工具虽然可以为用户提供很多价值，但同时也意味着一定的开销：云厂商收取的除了基本的服务运行成本外， 还包含一些营业税。 这些复杂的工具需要被使用者理解和操作，随着架构中新工具的添加，税也会随之水涨船高。 根据我们的经验，很多团队之所以会选择复杂的工具，常常是因为他们低估了诸如线性回归之类的简单工具的力量。 其实，许多机器学习问题并不需要GPU或神经网络。 因此，我们提倡在现有的计算平台上使用简单的工具和模型，以及少量的Python代码来实现一个 最简单的机器学习 。 只有在能够证明它的必要性时，才使用这些复杂的工具。
按需分发模块(Apr 2021, 试验)
适用于Android 系统的按需分发模块是一个框架，允许为适当结构的App下载和安装仅包含所需功能的量身定制的 APK。对于下载速度可能堪忧的大型应用，或用户可能仅在初次安装时使用某些功能的应用来说，此框架值得一试。它还可以简化对多个设备的处理，而无需使用不同的 APK。iOS平台下也有类似的框架 。
Yelp detect-secrets(Apr 2021, 评估)
Yelp detect-secrets是一个用于检测代码库中存储的密码的Python模块；它会扫描一个路径下所有的文件寻找密码。它可以被用作Git预提交钩子或在CI/CD流水线的适当位置来进行扫描。它的默认配置上手十分容易，如果有需要也可以进行自定义配置。你还可以安装自定义插件去扩充它默认的启发式搜索。与其他相似的工具比较，我们发现这款工具光以开箱即用的配置，就可以检测到更多种类的密码。
云沙箱(Apr 2021, 试验)
由于云服务变得越来越常见，并且创建 云沙箱 变得更加容易且可大规模应用，我们的团队因此更倾向于使用完全基于云（相对本地而言）的开发环境，并以此来减少维护复杂度。我们发现用于本地模拟云原生服务的工具限制了开发者对构建和测试周期的信心，所以我们将重点放在标准化云沙箱上，而不是在开发机器上运行云原生组件。这样的方式可以使基础设施即代码实践得到更好的强制应用，并为开发人员提供沙箱环境良好的适应过程。当然这种转变也存在风险，因为它假定开发人员将完全依赖于云环境的可用性，并且可能会减慢开发者获得反馈的速度。我们强烈建议您采用一些精益治理的实践来管理这些沙箱环境的标准化，尤其是在安全、访问控制和区域部署方面。
Redpanda(Apr 2021, 评估)
Redpanda 是一个数据流处理平台。它与 Apache Kafka 的 API 兼容，能够使运行在 Kafka 生态系统中的架构得到比 Kafka 更好的简单性、性能和硬件效率。Redpanda 是由 C++ 编写的，因此不需要 JVM，也无须诸如 ZooKeeper 这样的外部依赖。它利用 Raft 协议进行数据复制，并通过了Jepsen 的测试来验证其正确性。在完成了一系列优化之后，Redpanda 还大大减少了尾部延迟，并提高了吞吐量。Redpanda 还为企业用户提供了一些高级功能，包括分层存储和对 WebAssembly (WASM) 的内联转换。
JuiceFS(Apr 2021, 评估)
JuiceFS 是基于Redis 和对象存储而构建的开源分布式 POSIX 文件系统。如果要构建新的应用程序，那么我们建议始终与对象存储进行直接交互，而无需经过另一个抽象层。另外，如果要将依赖于传统 POSIX 文件系统的遗留系统迁移到云上，也可以考虑使用JuiceFS。
AWS云开发工具包(Apr 2021, 试验)
我们许多使用AWS的团队中发现，AWS云开发工具包(AWS CDK)是一个合理的 AWS 默认工具，以实现基础设施的整备工作。其特别之处在于，他们喜欢使用主流编程语言而不是配置文件来进行开发，从而可以使用现有的工具、测试方法和技能。但与类似的工具一样，此时也仍需要谨慎地确保部署易于理解和维护。这个开发工具包目前支持TypeScript、JavaScript、Python、Java、C# 和 .NET。新语言的支持正在被添加到 CDK 中。此外，我们使用了 AWS 云开发工具包和 HashiCorp 的Terraform 云开发工具包来生成 Terraform 配置，并成功实现了与Terraform平台的整备。
AWS云开发工具包(Oct 2020, 评估)
对于我们许多团队来说，Terraform 已成为定义云基础设施的默认选择。但是，我们的一些团队一直在尝试使用 AWS云开发工具包(AWS CDK)，并对其爱不释手。他们尤其喜欢该工具能使用一流的编程语言，而不是配置文件，从而可以利用现有的工具、测试方法和技能。像类似的工具一样，确保部署易于理解和维护也需要花费心思。该工具包目前支持 TypeScript、JavaScript、Python、Java、C＃和.NET。AWS 和 HashiCorp 团队最近发布了 Terraform云开发工具包预览版，以生成 Terraform 配置，并用于 Terraform 平台的整备。我们将继续观察 AWS CDK。
AWS云开发工具包(Nov 2019, 评估)
尽管我们很多团队，已经将Terraform作为定义云基础设施的默认选择，但另一些团队却已经开始尝试使用AWS Cloud Development Kit （AWS CDK），并对其青睐有加。他们尤其喜欢该工具使用编程语言而不是配置文件来定义云基础设施，这样就能使用已有的工具、测试方法和技能来进行工作。即使对于定义云基础设施这样的工具，也需要用心确保部署代码易于理解和维护。考虑到该工具很快就会支持C#和Java语言，并且暂时忽略某些功能上的差距，如果希望不使用配置文件来定义云基础设施，我们认为AWS CDK值得关注。
UI/BFF共享类型(Apr 2021, 试验)
随着TypeScript成为前端开发的常用语言以及Node.js成为BFF的首选技术，我们看到 “UI/BFF共享类型”正在被越来越多地使用 。在这种技术中，一个类型定义不仅会被使用在前端请求返回的数据中，也会被使用在服务端用来满足这些查询。由于这种做法会跨越流程边界产生不必要的紧密耦合，因此我们通常会对这种做法保持谨慎。但是，许多团队发现这种方法的好处胜过耦合带来的风险。当一个团队同时拥有UI和BFF代码时，通常会将组件存在同一个代码库中，这个时候BFF模式是最有效的，因此UI / BFF对可以被看作是一个单一的内聚系统。当BFF提供强类型的查询时，可以针对前端的特定需求量身定制查询结果，而不必重用一个通用的实体，因为这些通用实体需要为很多消费者服务因此会包含很多不必要的字段。这样可以减少意外地将不必要的数据暴露给用户的风险，防止对返回的数据对象进行错误的解释，并使查询更加表意。当使用io-ts来增强运行时类型安全性时， 这种实践特别有用。
Sentry(Apr 2021, 采纳)
在前端错误报告方面，Sentry已经成了许多团队的默认选项。Sentry提供了一些便利的功能，比如错误分组，以及使用适当的参数定义错误过滤规则，可以极大地帮助处理来自终端用户设备的大量错误。通过将Sentry集成到持续交付流水线中，你可以上传源码映射文件，从而更高效地调试错误，并能很容易追踪到是在哪个版本的软件中产生了这些错误。我们很欣赏尽管Sentry是一个SaaS产品，但它的源代码是公开的，这样就可以免费用于一些较小的用例和自托管中。
Sentry(Oct 2020, 试验)
Sentry 是一款跨平台应用监控工具，并聚焦在错误报告。像 Sentry 这样的工具，区分像 ELK Stack 那样传统的日志解决方案之处在于，它们重点关注发现、研究以及修复错误上。Sentry 已经面世有一阵子了，它支持多个语言和框架。我们在许多项目中使用过 Sentry，它在跟踪错误、发现某个提交是否真实修复了问题、以及警告我们有没有出现回归问题等方面帮助很大。
Sentry(May 2018, 评估)
Sentry is an error-tracking tool that helps monitor and fix errors in real time. Error tracking and management tools such as Sentry distinguish themselves from traditional logging solutions such as the ELK Stack in their focus on discovering, investigating and fixing errors. Sentry has been around for some time and is quite popular — error-tracking tools are increasingly useful with the current focus on "mean time to recovery". Sentry — with its integration options with Github, Hipchat, Heroku, Slack, among other platforms — enables us to keep a close eye on our apps. It can provide error notifications following a release, enable us to track whether new commits actually fix the issue and alert us if an issue comes back due to a regression.
Graal原生镜像(Apr 2021, 评估)
Graal原生镜像是一种以静态链接可执行文件或共享库的形式，将Java代码编译为操作系统本机二进制代码的技术。原生镜像经过优化，减少了应用程序的内存占用和启动时间。我们的团队已经成功地在serverless架构中，将Graal原生镜像作为小型Docker容器执行，减少了启动时间。尽管Graal原生镜像是为与Go或Rust等编程语言一起使用而设计的，这些编程语言需要本机编译，需要更小的二进制文件尺寸和更短的启动时间，但对于有其他需求并希望使用基于jvm的语言的团队来说，Graal原生镜像也同样有用。\nGraal原生镜像构建器，native-image，支持基于jvm的语言——如Java、Scala、Clojure和Kotlin——并能在多个操作系统上构建可执行文件，如Mac OS、Windows和众多Linux发行版。由于它需要一个封闭的假设，即所有代码在编译时都是已知的，因此需要对诸如反射或动态类加载这样的特性进行额外的配置，因为不能在构建时仅从代码推断出类型。
Redash(Apr 2021, 试验)
采用“谁构建，谁运行”的DevOps理念，意味着团队已经增加了对技术和业务指标的关注，这些指标可以从他们部署的系统中提取出来。我们经常发现，分析工具对于大多数开发人员来说都很难使用，所以捕获和呈现指标的工作就留给了其他团队——而这已经是在交付功能给最终用户很久之后的事了。我们的团队发现，Redash 可以让普通开发人员以自助的方式创建仪表板，这对于查询产品指标非常有用，它缩短了反馈周期，并让整个团队专注于业务产出。
Prowler(Apr 2021, 试验)
我们很高兴看到基础设施配置扫描工具的可用性和成熟度都越来越好：Prowler帮助团队扫描AWS基础设施配置，并根据扫描结果提高安全性。 尽管Prowler已经存在了一段时间，但在过去的几年中，它有了长足的进步，我们也发现了通过一个较短的反馈闭环来提升项目安全性的价值。 Prowler将AWS CIS benchmarking分为几类（身份和权限管理，日志，监控，网络，CIS Level 1，CIS Level 2，EKS-CIS），其中包括许多检查，可以帮助你深入了解PCI DSS和GDPR合规性。
关注隐私的网络分析(Apr 2021, 评估)
关注隐私的网络分析 是一种收集网络分析的技术，它通过对终端用户匿名化的处理而防止泄漏其隐私信息。遵守通用数据保护条例(GDPR)的一个令人惊讶的结果是，许多组织不惜降低用户体验地使用复杂的cookie同意过程，尤其是在用户没有立即同意“所有cookies”的默认设置的情况下。关注隐私的网络分析具有双重优势，无论是形式还是实际它都遵守了GDPR条例，与此同时也避免了引入具有侵入性的Cookie同意书。这项技术的一个实现便是Plausible。
Recommender(Apr 2021, 评估)
大型云服务供应商的服务数量持续增长，对应工具的便利性和成熟度也在不断提高。Recommender 是谷歌云的一项服务，可以分析现有资源，并根据实际使用量给出如何优化的建议。该服务包含了针对安全、计算使用以及节省成本等方面的一系列 Recommender。例如，IAM 角色 通过指出未曾使用过的可能过于宽泛的权限，来帮助更好地实现最小权限原则。
工单驱动的平台运营模式(Apr 2021, 暂缓)
平台化的终极目标之一便是将基于工单的流程降到最低，因为这些流程会在价值流中形成队列。遗憾的是，我们仍然看到一些组织在这一目标的推进上做得不够有力，并因此导致了 工单驱动的平台运营模式 。尤其是当这些平台化服务是构建于一些自服务的和API驱动的公有云服务之上时，这一情况便格外令人沮丧。虽然从一开始就实现自服务且不依赖于工单是很困难且没有必要的，但必须明确的是，这应该是我们努力的目标。 对官僚主义的过度依赖和信任的缺失是组织在面对这种基于工单的流程却不愿做出改变的原因之一。在平台中加入更多的自动化校验和告警是帮助我们从工单审批流程中抽身的一种方法。例如给团队提供运行成本的可见性，并设置自动化的成本护栏以避免意外的成本激增。通过实现安全策略即代码，使用配置扫描器 或类似Recommender的分析工具，来帮助团队做正确的事。
单页应用 (SPA) 注入(Apr 2021, 试验)
绞杀榕模式常被用作遗留系统现代化改造的默认策略，这种策略下，新代码包围在旧代码周围，并慢慢地实现旧代码的能力来满足所需功能。这种“由外而内”的方式对于很多遗留系统非常有用，但现在我们有了更多单页应用（SPA）的经验，可以用它们来替换遗留系统，我们正使用相反的“从内到外“的方式来替换遗留系统。与包围遗留系统不同，我们向旧应用HTML文档嵌入新的单页应用，并基于此逐渐扩展功能。只要用户能够容忍由于页面大小增加而带来的性能问题，新单页应用的框架就不需要与原有框架保持一致（例如，向原有的AngularJS应用嵌入新的React应用）。 单页应用注入 允许你逐渐迭代掉旧的单页应用，直到它被新应用完全替代掉。与绞杀榕模式通过在已有稳定代码的基础上构建新代码并最终替换旧代码相比，这种方式更接近于向已有应用注入一个外部的代理并依赖原有单页应用的功能，直到新应用能够完全接管。
bUnit(Apr 2021, 评估)
bUnit 是一款专门为Blazor 量身打造的测试库，它可以在已有的单元测试框架（如NUnit、xUnit或MSUnit）中轻松地创建Blazor组件测试。它为组件提供了一个外观（facade），可以在熟悉的单元测试范式中运行和测试，从而允许快速反馈并对组件测试进行隔离。如果你正在开发Blazor，我们建议你把bUnit添加到工具列表并进行尝试。
Materialize(Apr 2021, 试验)
Materialize 是一种流数据库。在无需复杂的数据管道的情况下，只须用标准SQL视图描述计算，然后将 Materialize 连接到数据流，就能实现增量计算。底层的差分数据流引擎能够运行增量计算，从而以最小的延迟，提供一致且准确的结果。与传统数据库不同，定义 Materialize 视图不存在任何限制，并且计算可以实时执行。我们将 Materialize 与 Spring Cloud Stream 以及 Kafka 配合使用，从而在分布式事件驱动的系统中，查询事件流并分析结果。其效果令人满意。
Materialize(Oct 2020, 评估)
Materialize 是一种具备以下优势的流式数据库——无须配置复杂的数据管道，就可进行增量计算。其配置过程十分简单，只须通过标准 SQL 视图来描述计算，然后将 Materialize 连接到数据流即可。底层的差异数据流引擎能够执行增量计算，以最小的延迟提供一致且正确的输出。与传统数据库不同，定义 Materialize 的视图没有任何限制，并且计算是实时执行的。
Opstrace(Apr 2021, 评估)
Opstrace是一个用于实现系统可观测性的开源平台，旨在部署于用户自己的网络中。如果不使用像 Datadog 这样的商业解决方案(例如，由于成本或数据驻留地点的考虑)，那么唯一的解决方案就是构建由开源工具组成的自己的平台。这需要投入很大的工作量，而 Opstrace 就是来解决这个问题的。它使用开源 api 和接口，如Prometheus和Grafana，并在上面添加了额外的特性，如TLS和身份验证。Opstrace 的核心运行了一个Cortex集群，提供可伸缩的 Prometheus API 和 Loki日志集群。与 Datadog 或 SignalFX 等解决方案相比，它是崭新的平台，所以仍然缺少一些特性。尽管如此，它所解决的上述问题，使其在该领域仍然很有前景，值得关注。
MLflow(Apr 2021, 试验)
MLflow 是一款用于机器学习实验跟踪)和生命周期管理的开源工具。开发和持续进化一个机器学习模型的工作流包括，一系列实验（一些运行的集合），跟踪这些实验的效果（一些指标的集合），以及跟踪和调整模型（项目）。MLflow 可以通过支持已有的开源标准，以及与这个生态中许多其他工具的良好集成，来友好地辅助这个工作流。在 AWS 和 Azure 中，MLflow 作为云上 Databricks 的受管服务，正在加速成熟，我们已经在我们的项目中成功使用过它。我们还发现 MLflow 是一个模型管理，以及跟踪和支持基于 UI 和 API 交互模型的很棒的工具。唯一的担忧在于，MLflow 作为单一平台，一直在尝试交付太多的混淆关注点，比如模型服务和打分。
MLflow(Oct 2020, 试验)
MLflow 是一款用于机器学习实验跟踪)和生命周期管理的开源工具。开发和持续进化一个机器学习模型的工作流包括，一系列实验（一些运行的集合），跟踪这些实验的效果（一些指标的集合），以及跟踪和调整模型（项目）。MLflow 可以通过支持已有的开源标准，以及与这个生态中许多其他工具的良好集成，来友好地辅助这个工作流。在 AWS 和 Azure 中，MLflow 作为云上 Databricks 的受管服务，正在加速成熟，我们已经在我们的项目中成功使用过它。我们还发现 MLflow 是一个模型管理，以及跟踪和支持基于 UI 和 API 交互模型的很棒的工具。唯一的担忧在于，MLflow 作为单一平台，一直在尝试交付太多的混淆关注点，比如模型服务和打分。
可变字体(Apr 2021, 试验)
可变字体 能避免查找和引用多个具有不同字重和样式的字体文件。这种方法使得所有变体样式都保存在一个字体文件中，并且可以使用属性来选择所需的样式和字重。尽管这不是新技术，但我们仍然看到网站和项目因使用这种简单方法而受益。如果页面中包含相同字体的不同变体，建议尝试使用可变字体。
Dagster(Apr 2021, 评估)
Dagster 是一个用于机器学习、机器分析，以及纯 ETL 数据管道的开源数据编排框架。与其他任务驱动框架不同，Dagster 知晓流经流水线的数据并可以提供类型安全性。借助对流水线和产生资产的统一视图，Dagster 可以计划和编排 Pandas，Spark，SQL，或任何 Python 可调用的接口。该框架相对较新，我们建议您对其在数据流水线中的能力进行评估。
天真的密码复杂度要求(Apr 2021, 暂缓)
密码策略是当前很多组织会默认启用的标准。然而，我们仍然见到很多组织内部要求密码必须包含符号、数字、大小写字母和特殊字符。诸如这样的要求就是 天真的密码复杂度要求 。这些要求会导致错误的安全意识，因为用户会由于满足这些要求的密码太难以记忆和输入，而选择使用更不安全的密码。正如NIST（美国国家标准技术研究所）推荐所提到的，影响密码强度的主要因素是密码的长度，因此用户应该选择更长的密码，最长为64个字符（包括空格）。这些密码会更安全，并且更易于记忆。
Contextual bandits(Apr 2021, 试验)
Contextual bandits 是一类非常适用于解决探索/利用权衡问题的强化学习算法。该算法以赌场中的“老虎机”命名，通过探索不同的选择，学习有关预期结果的更多信息，并通过利用表现良好的选项来平衡该结果。我们已经在一些场景中成功地使用了该技术，在这些场景中只使用了少量的数据来训练和部署一些机器学习模型。事实上，我们可以在此探索/利用的权衡过程中添加上下文，使它适合于各种用例，包括 A/B 测试、推荐和布局优化。
部署漂移提示器(Apr 2021, 评估)
部署漂移提示器 使得部署在多个环境中的软件版本漂移能够被可视化。使用了自动部署方式的组织在将软件部署到接近生产环境的环境中时，可能需要人工批准，这就意味着这些环境里的代码版本可能比当前的开发版本落后好几个版本。这项技术使得这些延后能够被展示在一个简单的面板内，包括在每个环境当中，每个被部署的组件有多大程度的延后。这能够帮助突出由于已经完成的软件没有部署到生产环境而导致的机会成本，并使得团队注意相关的风险，例如尚未部署的安全修复。
代码与流水线的所有权分离(Apr 2021, 暂缓)
理想情况下，尤其是当团队实践DevOps时，流水线和被部署的代码应该由同一个团队所有。遗憾的是，我们仍然可以看到 代码与流水线的所有权分离 的团队：他们的流水线由基础设施团队所有，这会导致变更延迟、改进受阻以及开发团队缺乏对部署的所有权和参与度。造成这种情况的一个原因显然是团队分离，另一个原因可能是想要保留审核的流程和“守门员”的角色。尽管使用这种方式（例如：监管控制）可能有比较合理的解释，但总的来说，我们发现它令人不悦并且收效甚微。
Next.js(Apr 2021, 试验)
在上一次我们介绍了有关如何使用Next.js构建React 代码库之后，我们又有了更多的使用经验。Next.js是一个一站式零配置的框架，该框架提供了包括简化的路由、采用Webpack 和Babel进行自动打包和编译、快速热重载等其它可为开发人员提供便利工作流的工具。它默认提供服务器端渲染、搜索引擎优化和改善初始加载时间等功能，并支持增量静态生成模块代码。使用过Next.js的团队为我们提供了积极的体验报告，同时鉴于其庞大的社区，我们对该框架的发展保持乐观的态度。
Next.js(Apr 2019, 评估)
React.js has revolutionized the way most people write single-page JavaScript applications. Generally, we recommend you use Create React App throughout the application lifecycle so you don't have to configure your setup, builds and packages manually. But some developers will prefer a tool whose initial defaults reflect a sound set of opinions. Next.js is just such an opinionated framework and it is garnering quite a bit of interest among our front-end enthusiasts. Next.js simplifies routing, renders on the server side by default and streamlines dependencies and builds. We're keen to see if it lives up to expectations on our own projects.
去中心化身份(Apr 2021, 评估)
SSL/TLS 的核心贡献者 Christopher Allen 在2016年给我们介绍了一种用于支撑新型数字化身份的10个原则，以及实现这一目标的途径：通往自主身份之路。自主身份也被称为 去中心化身份 ，按照基于IP协议栈的信任标准，是一种“不依赖任何中心化权威并且永远不能被剥夺的任何人、组织或事物的终身可转移身份”。采纳和实现去中心化身份正在逐渐升温并变得可能。我们看到了它在隐私方面的应用：客户健康应用、 政府医疗基础设施 和 公司法律身份。如果想快速地应用去中心化身份，你可以评估 Sovrin Network，Hyperledger Aries 和 Indy 等开源软件，以及去中心化身份 和 可验证凭证 标准。我们正在密切关注这个领域，并帮助我们的客户在数字信任的新时代进行战略定位。
去中心化身份(Oct 2020, 评估)
SSL/TLS 的核心贡献者 Christopher Allen 在2016年给我们介绍了一种用于支撑新型数字化身份的10个原则，以及实现这一目标的途径：通往自主身份之路。自主身份也被称为 去中心化身份 ，按照基于IP协议栈的信任标准，是一种“不依赖任何中心化权威并且永远不能被剥夺的任何人、组织或事物的终身可转移身份”。采纳和实现去中心化身份正在逐渐升温并变得可能。我们看到了它在隐私方面的应用：客户健康应用、 政府医疗基础设施 和 公司法律身份。如果想快速地应用去中心化身份，你可以评估 Sovrin Network，Hyperledger Aries 和 Indy 等开源软件，以及去中心化身份 和 可验证凭证 标准。我们正在密切关注这个领域，并帮助我们的客户在数字信任的新时代进行战略定位。
去中心化身份(May 2020, 评估)
自互联网诞生以来，技术领域已朝着去中心化的方向加速发展。虽然如HTTP之类的协议和如微服务或数据网格这样的的架构模式，使得去中心化的实现成为可能，但身份管理仍然保持着中心化的实现。然而，分布式账本技术（DLT）的出现使 去中心化身份识别 的概念成为可能。在一个去中心化身份识别系统里，实体是离散的可识别单元，例如人、组织和事件都可以自由使用任何共享的信任根。相反，常规的身份管理系统基于集中的权限和注册表，例如公司目录服务、证书颁发机构或域名注册表。\n去中心化身份标识符 的开发是主要的启用标准，它是全球独特的、持久的的且可加密验证的自我主权标识符。尽管规模化的去中心化身份标识符的实现仍然很少见，但我们对这一运动的前提感到兴奋，并已开始在架构中使用这一概念。有关最新的实验和行业合作，请查看Decentralized Identity Foundation。
.NET 5(Apr 2021, 评估)
我们不会在雷达中介绍每一个新的.NET版本，但 .NET 5 意味着在将.NET Core 和.NET Framework 合并为单一平台方面迈出了重要一步。各组织应该开始制定策略，当.NET 5或6 版本可用时，将他们的开发环境（根据部署目标的不同而混合不同的框架）迁移到单一版本的.NET 5 或6 。这种方法的优势将是一个通用的开发平台，不必考虑预期环境：Windows、Linux、跨平台移动设备（通过Xamarin）或浏览器（使用Blazor)。虽然对于有工程文化支持的公司来说，多语言开发仍将是首选方法，但其他公司会发现在单一平台上进行标准化的.NET 开发更有效率。目前，我们希望将其保留在“评估”环中，看看.NET 6中的最终统一框架表现如何。
API扩张-收缩(Apr 2021, 采纳)
API扩张-收缩模式，有时也被称为并行修改，很多人对这个模式都很熟悉，尤其是在与数据库或代码一起使用的时候，而在API方面我们只看到较低的采用率。它具体指的是，人们通常会采用复杂的版本控制和破坏性的修改来实现API升级，而其实简单的扩张再收缩就可以满足需求。例如，在想要弃用API中的某个元素时，先添加一个不包含这个元素的API，然后在消费者都切换到新的API之后，再删除该元素以及包含该元素的旧API。这种方式确实需要API消费者的一些协调和可见性，可能需要通过消费者驱动的契约测试之类的技术来实现。
开放应用程序模型(Apr 2021, 评估)
开放应用程序模型 (OAM) 旨在为“基础设施即软件”制定标准化方案。利用组件、应用程序配置、范围和特征等抽象，开发人员能以与平台无关的方式描述其应用程序。而平台实现者则完全可以用工作负载、特征和范围等另一套抽象来定义其平台。自从上次提到 OAM 以来，我们一直对其首个实现 KubeVela 保持着关注。 如今 KubeVela 即将发布1.0版，我们期待着它能证明 OAM 构想中的前景。
开放应用程序模型(Oct 2020, 评估)
我们以前多次谈到创建平台工程产品团队来支持公司其他产品团队有许多好处，但实施起来确实很难。在基础设施即代码的世界中，业界似乎仍在寻找正确的抽象。尽管诸如 Terraform 和 Helm 之类的工具，已经朝着正确的方向迈进，但其重点仍然是管理基础设施，而不是应用程序开发。当然，业界还是存在一些向“基础设施即软件”方向的转变，比如涌现出 Pulumi 和 CDK 等新工具。而开放应用程序模型(OAM)则试图对该领域进行标准化。通过使用组件、应用程序配置、范围和特征等抽象，开发人员能以与平台无关的方式描述其应用程序。而平台实现者则完全可以用工作负载、特征和范围等另一套抽象来定义其平台。 OAM 是否能被广泛采用还有待观察，但是我们建议关注这个有趣且有用的想法。
HashiCorp Boundary(Apr 2021, 评估)
在代理访问你的主机和服务的场景下，安全网络和身份管理的能力是不可或缺的，HashiCorp Boundary将这些能力合并在一处，如果需要，还可以连接多种云服务和本地自行部署的资源。密钥管理可以通过集成你选择的密钥服务来实现，无论是云厂商提供的密钥服务，还是诸如HashiCorp Vault这样的工具。HashiCorp Boundary支持越来越多的身份认证提供方，并且可以集成到你的服务整体架构当中，来帮助定义主机甚至是服务级别的权限。比如说，它可以用来实现对Kubernetes集群的细粒度访问控制。HashiCorp Boundary也正在继续开发以支持更多功能，诸如从不同的来源动态拉取服务目录。所有这些实现都被封装在HashiCorp Boundary当中，对作为终端用户的、习惯于shell使用体验的工程师来说是不可见的，这一切都是通过Boundary的网络管理层安全地进行连接。
Zally(Apr 2021, 评估)
随着API规范生态系统的成熟，我们看到了更多可以自动化检查样式的工具。Zally是一个简便的基于OpenAPI的代码扫描工具，它有助于确保API遵循团队制定的API样式指南。以开箱即用的方式，Zally会针对为Zalando的API样式指南开发的规则集进行验证，同时它还支持基于Kotlin扩展机制开发自定义的样式规则。Zally提供了直观的UI界面，展示样式违规的地方，同时也提供了命令行工具，这样可以轻松地集成到持续交付流水线中。
安全多方计算(Apr 2021, 评估)
安全多方计算 (MPC) 解决了多方隐私保护的协作计算中，各方互相不信任的问题。其目的是在无可信第三方的情况下，安全地计算出一个商定的问题。计算时，每个参与者都必须参与结果计算，并且不能被其他参与者获得计算结果。安全多方计算的一个简单例子是百万富翁问题：两个百万富翁想了解谁是最富有的人，但又不想透露给彼此他们的实际净资产，同时他们也都不信任第三方。安全多方计算的实施方法各不相同，可能包括秘密共享，遗忘传输，混淆电路或同态加密。最近出现的一些商业安全多方计算解决方案（例如Antchain Morse）声称有助于解决诸如多方联合信用调查和病历数据交换等情形下，秘密共享和安全机器学习的问题。尽管从市场营销的角度来看，这些平台很有吸引力，但它们是否真的有用仍拭目以待。
OR-Tools(Apr 2021, 试验)
OR-Tools 是用于解决组合优化问题的开源软件套件。 这些优化问题有很多可能的解决方案，而OR-Tools之类的工具对于寻求最佳解决方案非常有帮助。 你可以使用任何一种支持语言（Python，Java，C#或C++）对问题建模，然后从几种支持的开源或商业选项中选择解决方案。 我们已经在整数和混合整数编程的多个优化项目中成功使用了OR-Tools。
Kotlin Flow(Apr 2021, 试验)
Kotlin 协程 的引入为Kotlin的创新打开了一扇大门——直接集成到协程库中的Kotlin Flow 就是其中之一。Kotlin Flow是一种基于协程的响应式流的实现。与RxJava不同的是，流是Kotlin原生的API，与熟悉的序列API类似，包括 map 和filter方法。跟序列一样，流是“冷”的，这就意味着只有当需要使用的时候才构造序列的值。所有这些特性使多线程代码的编写比其他方法更加简单和易于理解。可以预见，通过toList方法将流转换成列表将会成为测试中的一种常见模式。
Longhorn(Apr 2021, 评估)
Longhorn 是Kubernetes的分布式块存储系统。 Kubernetes有很多持久性存储选项，但是，Longhorn与大多数存储选项不同，它是从头开始构建的，提供了增量快照和备份，从而减轻了在非云托管的Kubernetes上运行复制存储的痛苦。随着Longhorn最近对ReadWriteMany（RWX）的实验性支持，你甚至可以挂载相同的存储卷，来进行跨多个节点的读写访问。为Kubernetes选择合适的存储系统是一项艰巨的任务，我们建议你根据需求评估使用Longhorn。
自研基础设施即代码 (IaC) 产品(Apr 2021, 暂缓)
那些由公司或社区所支持的（至少在业界引起关注的）产品，正在不断发展。但有时组织会倾向于在现有的外部产品之上，构建框架或抽象，来满足组织内非常特定的需求，并认为这种适配会比其现有的外部产品具备更多好处。我们发现一些组织试图基于现有外部产品，创建自研基础设施即代码 (IaC) 产品。他们低估了根据其需求不断演进这些自研解决方案而所需投入的工作量。很快他们就会意识到，所基于的外部产品的原始版本要比他们自己的产品好得多。在有些情况下，构建在外部产品之上的抽象，甚至削弱了外部产品的原始功能。虽然目睹过组织自研产品的一些成功案例，但是我们仍然建议要审慎地考虑这种方式。因为这会带来不可忽视的工作量，并且需要确立长期的产品愿景，才能达到预期的结果。
Combine(Apr 2021, 采纳)
我们几年前把 ReactiveX（反应式编程开源框架中的一个系列）移到了技术雷达的“采纳”环中。2017年，我们提到了 RxSwift，它可以将反应式编程应用到基于 Swift 的 iOS 开发中。此后，Apple 以 Combine 的形式推出了自己的反应式编程框架。对于仅支持 iOS 13 及更高版本的App而言，Combine 已经成为默认的选择。它比 RxSwift 更容易学习，并且与 SwiftUI 集成得很好。如果您想要将现有项目框架从 RxSwift 转换为 Combine，或者在一个项目中同时使用两者，可以了解一下 RxCombine。
Flipper(Apr 2021, 试验)
Flipper是可扩展的移动应用程序调试工具。它开箱即用，支持profiling，交互式布局检查，日志查看器以及适用于iOS，Android和React Native应用程序的网络检查器。与其他用于移动应用程序的调试工具相比，我们发现Flipper轻量级，功能丰富且易于设置。
esbuild(Apr 2021, 试验)
我们一直渴望找到可以缩短软件开发反馈周期的工具。  esbuild就是这样一个工具。 随着前端代码库逐渐变大，我们经常会遇到打包时间过长的问题。esbuild 是一个对打包速度进行了优化的 JavaScript 打包器，它可以将打包时间减少 10 到 100 倍。它是用 Golang 编写的，并且使用了更高效的方式进行解析、打印和生成 sourcemap，构建速度远远超过了 Webpack 和 Parcel 这样的工具。esbuild 可能在 JavaScript 语法转换方面没有它们全面，但这并不妨碍我们很多团队将 esbuild 作为默认的打包工具。
Ethical Explorer(Apr 2021, 试验)
Ethical OS背后的组织——Omidyar网络，是eBay创始人Pierre Omidyar发起的一个自述为致力于社会变革的冒险。Omidyar网络最近新发布了一个名为Ethical Explorer的版本。新的Ethical Explorer在Ethical OS实践得来的经验教训的基础上，增加了更深入的问题供产品团队考虑。Ethical Explorer可以在这里免费下载，并可折叠为卡片来引发讨论，这些卡片上有针对技术上的若干种“危险区”的一些开放性问题，包括监视（使用我们产品或服务的人是否可能追踪或识别其他用户信息？）、虚假信息、排异排外、算法歧视、沉迷上瘾、数据控制、安全攻击以及权限过大。其中的实战指南包括一些工作坊、开启对话的思路和获得组织支持的技巧。为了让我们的行业更好地发挥数字社会当中的伦理外部性(ethical externalities)作用，我们仍然有很多工作要做，但我们已经使用Ethical Explorer开展了一些卓有成效的产品讨论，并且对产品决策在解决社会问题中的重要性的认识不断扩大也同样鼓舞了我们。
Apache Pinot(Apr 2021, 评估)
Apache Pinot是分布式 OLAP 数据存储系统，旨在提供低延迟的实时分析。它可以从批处理数据源（例如 Hadoop HDFS、Amazon S3、Azure ADLS或Google Cloud Storage）以及流式数据源（例如 Apache Kafka ）中提取数据。如果需要进行面向用户的低延迟数据分析，则 Hadoop SQL 方案不能保证所需的低延迟。诸如 Apache Pinot（或Apache Druid和Clickhouse等）现代 OLAP 引擎，可以实现低得多的延迟，特别适合针对不可变数据（如聚合）进行快速分析的场景（或许需要进行实时数据提取）。 Apache Pinot 最初由 LinkedIn 构建，并于2018年底进入Apache孵化阶段。此后，该系统又增加了插件架构和SQL支持等关键特性。 Apache Pinot 的操作相当复杂，并且具有许多需要控制的部件，但是如果需要分析的数据量足够大，并且对查询要求低延迟，则建议评估一下 Apache Pinot。
AWS Data Wrangler(Apr 2021, 试验)
AWS Data Wrangler 是一个开源库，可以将数据框连接到 AWS 数据相关的服务，从而将 Pandas 的功能扩展到 AWS。另外，该库还利用 Apache Arrow 和 Boto3 暴露了一些 API，用于从数据湖和数据仓库中加载、转换和保存数据。AWS Data Wrangler 最大的限制是不支持大型的分布式数据流水线操作。但是，你可以使用原生的数据服务（如 Athena、Redshift 和 Timestream 等）进行大批量的数据上传和提取工作，来表示适用于数据框的复杂转换。我们在生产环境中使用过 AWS Data Wrangler。它可以使你专注于编写转换，而不必在连接AWS数据服务上花费太多时间。
TrustKit(Apr 2021, 试验)
我们在使用 SSL 公钥绑定时需要格外小心。因为一旦选择了错误的安全策略或者忘记进行绑定备份，应用程序可能会因为异常而停止运行。这正是 TrustKit 的有用之处。它是 iOS 平台上用于简化 SSL 公钥绑定的一个开源框架，同样也支持了 Android 平台。关于如何选择合适的绑定策略，以及更多细节问题的指导，您可以查阅这份上手指南。我们已经在多个项目的生产环境中运用了 TrustKit ，效果很好。
imgcook(Apr 2021, 评估)
还记得在研究项目pix2code中，如何通过图形用户界面的截图自动生成代码吗？现在这个技术已经出现了产品化的版本— imgcook，它是阿里巴巴旗下的软件即服务产品。它可以通过智能化技术把不同种类的视觉稿(Sketch/PSD/静态图片)一键生成前端代码。在双十一购物狂欢节期间，阿里巴巴需要定制大量的活动广告页面。经常会有一次性页面需要被快速开发完成。通过深度学习方法，用户体验设计师的设计，首先被处理为前端代码，然后由开发人员进行调整。我们的团队正在评估这项技术：尽管图像处理是在服务器端进行的，主页界面却在网页上，imgcook提供可以集成软件设计及开发生命周期的 工具 。imgcook可以生成静态代码，如果你定义了领域专用语言，它也可以生成数据绑定模块代码，该技术还没达到完美的程度，设计人员需要参考某些规范，以提高代码生成的准确性（此后仍需开发人员的调整）。我们对于魔术代码生成一直十分谨慎，因为从长远看，生成的代码通常很难维护，imgcook也不例外。但是如果你限定它用于特定的上下文，例如一次性活动广告页，这项技术值得一试。
LeakCanary(Apr 2021, 采纳)
如今，我们的移动开发团队认为 LeakCanary 是 Android 开发中的默认选项。它的集成极其简单，同时提供能够清晰回溯内存泄漏原因的通知，从而帮助我们侦测到 Android 上恼人的泄漏问题。我们推荐你把 LeakCanary 加入工具包，它可以帮你节省在多个设备上排查内存泄漏的时间。
LeakCanary(Nov 2017, 评估)
Our mobile teams have been excited about LeakCanary, a tool for detecting annoying memory leaks in Android and Java. It's simple to hook up and provides notifications with a clear trace-back to the cause of the leak. Adding this to your toolkit can save tedious hours troubleshooting out-of-memory errors on multiple devices.
微前端中的模块映射(Apr 2021, 评估)
当使用多个 微前端来组建应用程序时，系统的某些部分需要确定加载哪些微前端以及从哪里加载它们。一直以来，我们要么通过构建定制化解决方案，要么采用single-spa之类的热门框架来解决这个问题。最近出现了一个新标准模块映射，它对这两种方案都有所助益。我们的初步经验表明，使用 微前端中的模块映射 可以清晰地分离关注点。它使用JavaScript代码说明要导入的内容，同时在初始化HTML的响应中使用一个轻量脚本指定从哪里加载微前端。 显然，HTML是在服务器端生成的，这样在渲染过程中就可以使用一些动态配置。在许多方面，这种技术让我们想起了动态Unix库的linker/loader目录。目前，只有Chrome浏览器支持模块映射，但是通过SystemJS polyfill就可以使它得到更加广泛的应用。
机器学习的持续交付 （CD4ML）(Apr 2021, 采纳)
我们将机器学习的持续交付（CD4ML）作为所有部署在生产环境中的机器学习解决方案的默认起点。许多组织越来越依赖于机器学习解决方案来提供客户产品和内部运营，因此将持续交付（CD）所获得的经验教训和良好实践应用于机器学习解决方案具有良好的商业意义。
机器学习的持续交付 （CD4ML）(Oct 2020, 试验)
大约十年前，我们引入了持续交付(CD)，将其作为我们交付软件解决方案的常规方式。如今解决方案在不断增多，其中也包括机器学习模型，并且我们发现在这种解决方案上，持续交付实践仍然适用。我们将之称为机器学习的持续交付(CD4ML)。尽管 CD 的原则仍保持不变，但用于实现训练、测试、部署和监测模型的端到端过程，其实践和工具需要进行一些修改。例如:版本控制不仅要考虑代码的版本控制，还要考虑数据、模型及其参数的版本控制；测试金字塔扩展为包含模型偏差、公平性、数据和特征验证；部署过程必须考虑如何针对当前的冠军模型来提升和评估新模型的性能。当业界正在为 MLOps 这个新的流行词庆祝时，我们反而认为 CD4ML 才是我们实现端到端（可靠地发布以及持续改进机器学习模型，由想法到生产）过程的整体方法。
机器学习的持续交付 （CD4ML）(May 2020, 试验)
利用机器学习使业务应用和服务智能化，并不仅仅是训练模型并为其提供服务。 它需要实现一整套端到端、持续可重复的模型训练、测试、部署、监控和运维周期。机器学习下的持续交付 （CD4ML） 是一种可靠的端到端开发、部署和监控机器学习模型的技术。支撑CD4ML的基础技术栈包括数据访问和探索工具、工件（例如数据、模型和代码）的版本控制、持续交付流水线、用于各种部署和实验的自动化环境设置、模型性能评估和跟踪，以及模型运作的可观测性。公司可以根据现有的技术栈选择自己的工具集。CD4ML强调自动化和避免手工交接。CD4ML是我们开发机器学习模型的默认方法。
机器学习的持续交付 （CD4ML）(Nov 2019, 试验)
随着基于ML的应用程序的日益普及以及构建它们所涉及的技术复杂性，我们的团队严重依赖于机器学习的持续交付（CD4ML），以安全快速且可持续的方式交付此类应用程序。CD4ML是将CD原理和实践引入ML应用程序的学科。它消除了从训练模型到部署生产环境的长周期。在构建和部署模型的端到端过程中，CD4ML消除了不同团队、数据工程师、数据科学家和ML工程师之间的手动传递。使用CD4ML，我们的团队成功地实现了基于ML的应用程序所有组件的自动化版本管理，测试和部署，包括数据，模型和代码。
机器学习的持续交付 （CD4ML）(Apr 2019, 试验)
Continuous delivery for machine learning (CD4ML) apply continuous delivery practices to developing machine learning models so that they are always ready for production. This technique addresses two main problems of traditional machine learning model development: long cycle time between training models and deploying them to production, which often includes manually converting the model to production-ready code; and using production models that had been trained with stale data.\nA continuous delivery pipeline of a machine learning model has two triggers: (1) changes to the structure of the model and (2) changes to the training and test data sets. For this to work we need to both version the data sets and the model's source code. The pipeline often includes steps such as testing the model against the test data set, applying automatic conversion of the model (if necessary) with tools such as H2O, and deploying the model to production to deliver value.
LGTM(Oct 2020, 评估)
编写安全的代码十分重要，但是开发人员还有很多其他事情需要考虑，不能把时间全花在这里。LGTM 不仅为开发人员提供了一道安全防护网，也是一个安全代码实践的知识库。这是一个专注于安全的静态代码分析工具，以 CodeQL 查询语言实现了（部分开放源代码的）安全编码规则。LGTM 适用于Java、Go、JavaScript、Python、C＃及C/C++，并可以将白盒安全检查集成到持续集成流水线中。LGTM 与 CodeQL 都来自于 Github 安全实验室。
Amundsen(Oct 2020, 评估)
数据科学家将大量时间花在数据发现上，这意味着在这一领域能够提供帮助的工具势必会令人兴奋。尽管 Apache Atlas 项目已经成为了元数据管理的实际工具，但数据发现仍然不是那么容易完成的。Amundsen可以与 Apache Atlas 协同部署，为数据发现提供更好的搜索界面。
图表即代码(Oct 2020, 试验)
我们看到越来越多的用于创建软件架构和 图表即代码 的工具。相较于使用其他更重量级的工具，这些工具可以更方便的做版本控制，还可以从多个源创建领域特定语言。我们很喜欢这类工具，例如 Diagrams， Structurizr DSL， AsciiDoctor Diagram，还有诸如 WebSequenceDiagrams，PlantUML 等系列产品，当然还有久负盛名的 Graphviz。现在创建一个 SVG 也变得相当简单了，如果能自己动手很快地写一个小工具来做这个，倒也不失为一个不错的选择。例如，本期雷达的某位作者就自己动手写了一个小的 Ruby 脚本用来快速地创建 SVG。
single-spa(Oct 2020, 试验)
single-spa是个 JavaScript 框架，它把多个微前端集成为一个前端应用。虽然我们告诫提防微前端混乱，借口使用微前端来混合和匹配多个框架，但 single-spa 恰恰干的就是这个。我们明白存在一些正当的场景，比如在有必要集成多个框架时，你需要升级多个微前端中某个框架到新版本。single-spa 一直是我们团队在集成微前端时的默认框架选择，他们发现它可以跟 SystemJS 工作得很好，并且能管理单个依赖的不同版本。
single-spa(Nov 2017, 评估)
single-spa is a JavaScript metaframework that allows us to build micro frontends using different frameworks that can coexist in a single application. In general, we don't recommend using more than one framework for an application, but there are times when we can't avoid doing so. For instance, single-spa can be quite useful when you're working with a legacy application and you want to experiment by developing a new feature, with either a new version of the existing framework or a completely different one. Given the short life span of many JavaScript frameworks, we see a need for a solution that would allow for future framework changes and localized experimentation, without affecting the entire application. single-spa seems to be a good start in that direction.
Debezium(Oct 2020, 试验)
Debezium 是一个变更数据捕获（Change Data Capture, CDC） 平台，可以将数据库变更流式传输到Kafka 的 topics。 CDC是一种流行的技术，具有多种应用场景，例如：将数据复制到其他数据库、输送数据给分析系统、从单体中提取数据至微服务以及废除缓存。 Debezium 对数据库日志文件中的变更做出反应，并具有多个CDC连接器，适用于多种数据库，其中包括Postgres、MySQL、Oracle 和 MongoDB。 我们在许多项目中都使用了Debezium，它对我们来说非常有效。
Debezium(Nov 2018, 评估)
Debezium is a change data capture (CDC) platform that can stream database changes onto Kafka topics. CDC is a popular technique with multiple use cases, including replicating data to other databases, feeding analytics systems, extracting microservices from monoliths and invalidating caches. We're always on the lookout for tools or platforms in this space (we talked about Bottled Water in a previous Radar) and Debezium is an excellent choice. It uses a log-based CDC approach which means it works by reacting to changes in the database's log files. Debezium uses Kafka Connect which makes it highly scalable and resilient to failures and has CDC connectors for multiple databases including Postgres, Mysql and MongoDB. We're using it in a few projects and it has worked very well for us.
Redux(Oct 2020, 试验)
Redux 已被移回试验环，因为我们不再将其视为 React 应用程序默认的状态管理方式。经验表明，在许多情况下 Redux 框架仍然具有一定的价值。但是与其他方法相比，Redux 会导致代码冗长难读。而引入 Redux Sagas 通常更会加剧这个问题。相对的，React 最新版本中的功能已经可以有效地管理状态，而无需引入其他框架。但需要着重强调的是，当简单的状态管理解决方案开始变得复杂时，仍然可以考虑使用 Redux，或者是 Facebook 最近发布的 Recoil。
Redux(Mar 2017, 采纳)
With the increasing complexity of single-page JavaScript applications, we have seen a more pressing need to make client-side state management predictable. Redux, with its three principles of restrictions for updating state, has proven to be invaluable in a number of projects we have implemented. Getting Started with Redux and idiomatic Redux tutorials are a good starting point for new and experienced users. Its minimal library design has spawned a rich set of tools, and we encourage you to check out the redux-ecosystem-links project for examples, middleware and utility libraries. We also particularly like the testability story: Dispatching actions, state transitions and rendering can be unit-tested separately from one another and with minimal amounts of mocking.
Redux(Nov 2016, 采纳)
With the increasing complexity of single-page JavaScript applications, we have seen a more pressing need to make client-side state management predictable. Redux, with its three principles of restrictions for updating state, has proven to be invaluable in a number of projects we have implemented. Getting Started with Redux and idiomatic Redux tutorials are a good starting point for new and experienced users. Its minimal library design has spawned a rich set of tools, and we encourage you to check out the redux-ecosystem-links project for examples, middleware and utility libraries. We also particularly like the testability story: Dispatching actions, state transitions and rendering can be unit-tested separately from one another and with minimal amounts of mocking.
Redux(Apr 2016, 试验)
Redux is a great, mature tool that has helped many of our teams reframe how they think about managing state in client-side apps. Using a Flux-style approach, it enables a loosely coupled state-machine architecture that's easy to reason about. We've found it a good companion to some of our favored JavaScript frameworks, such as Ember and React.
jest-when(Oct 2020, 采纳)
jest-when 是一个轻量级的 JavaScript 库，为 Jest 提供匹配模拟函数入参的能力。Jest 是全栈测试的好工具，而 jest-when 则可以帮助检查模拟函数接收的参数是否符合期望，这样就能够为依赖较多的模块写出更健壮的单元测试。jest-when 易于使用，并支持多种匹配器。因此在需要匹配模拟函数入参时，我们会默认选择 jest-when。
jest-when(Nov 2019, 试验)
jest-when是一个轻量级的JavaScript库，通过匹配模拟函数调用的参数完善了Jest的功能。Jest是测试整个技术栈的好工具，而jest-when可以帮助检查模拟函数接收的参数。这样就能够为具有很多依赖的模块写出更强壮的单元测试。
Strikt(Oct 2020, 试验)
Kotlin 的生态在持续生长，更多的类库开始充分利用 Kotlin 语言的特性，去换掉他们的 Java 替代品。Strikt 是一个可以让你以非常流畅的风格编写测试断言的断言库。它使用 Kotlin 的 blocks 和 lambdas，帮助你的测试不那么冗长，以保持可读性。Strikt 还支持创建自定义断言，这会让你的测试更特定于领域。
Kiali(Oct 2020, 评估)
考虑到服务网格越来越多被用来部署大量的容器化微服务，我们期待看到能自动化并简化此类架构风格相关的管理工具的出现。Kiali 就是这样的工具。Kiali 提供了一个图形化用户界面，用于观察和控制使用 Istio 部署的服务网络。我们发现 Kiali 对可视化网络中的服务拓扑结构，并理解它们彼此之间的路由流量，尤其有帮助。比如，当和 Flagger 结合使用时，Kiali 可以显示出那些路由到某个金丝雀服务发布的请求。我们特别喜欢 Kiali 的一个能力，它能让我们向某个服务网格人工注入网络错误，以测试面临网络中断时的弹力。因为配置以及在复杂的微服务网格中运行错误测试带来的复杂度，这个实践经常会被忽略掉。
Concourse(Oct 2020, 试验)
要实现可持续跨多环境构建和部署生产软件的持续交付流水线，需要一种将构建流水线和工件视为一等公民的工具。当我们初次接触 Concourse 时，就喜欢上了它简单灵活的模型，基于容器的构建原理以及它迫使你定义 流水线即代码的事实。自那以后，Concourse 的可用性得到了改善，其简单的模型也经受住了时间的考验。我们的许多团队以及客户已经成功地将 Concourse 长时间用于大型流水线设置中。我们还经常借助 Concourse 的灵活性在例如硬件集成测试需要本地设置这种情况下随地工作。
Concourse(Apr 2016, 评估)
Many development teams are making the move from simple continuous integration servers to Continuous Delivery pipelines, often spanning multiple environments, reaching into production. To implement such a pipeline successfully and operate it in a sustainable way requires a CI/CD tool that treats build pipelines and artifacts as first-class citizens; and unfortunately there aren’t many. Concourse CI is a promising new entrant in this field, and our teams that have tried it are excited about its setup, which enables builds that run in containers, has a clean, usable UI and discourages snowflake build servers.
Dependabot(Oct 2020, 采纳)
在所有帮助保持依赖更新的可选工具中，Dependabot 一直是我们认为可靠的默认选择。Dependabot 跟GitHub 的集成平滑，并能自动发送你的pull request，更新依赖到最新的版本。它能在整个组织级别启动，这样所有团队接收到这些 pull request 要容易得多。即便你没有在使用 GitHub，也仍然可以在构建流水线中使用 Dependabot库。如果选择替代品，你可以考虑 Renovate，它支持更多的服务，包括 GitLab，Bitbucket 以及 Azure DevOps。
Dependabot(Nov 2019, 试验)
使代码库的依赖保持最新是一件很麻烦的事，但是出于安全考虑，及时响应依赖的更新还是很重要的。你可以使用工具让这个过程尽可能轻松和自动化。我们的团队在实际使用Dependabot时觉得不错。它可以与GitHub仓库集成，自动检查依赖的版本更新，并在必要时提交一个升级依赖的PR。
Dependabot(May 2018, 评估)
Keeping dependencies up to date is a chore, but it's important to manage upgrades frequently and incrementally. We want the process to be as painless and automated as possible. Our teams have often hand-rolled scripts to automate parts of the process; now, however, we integrate commercial offerings to do that work. Dependabot is a service that integrates with your GitHub repositories and automatically checks your project dependencies for new versions. When required, Dependabot will open a pull request with upgraded dependencies. Using features of your CI server, you can automatically test upgrades for compatibility and automatically merge compatible upgrades to master. There are alternatives to Dependabot, including Renovate for JavaScript projects and Depfu for JavaScript and Ruby projects. Our teams, however, recommend Dependabot because of its multilanguage support and ease of use.
Arrow(Oct 2020, 采纳)
Arrow 的推广语是“Kotlin标准库的函数式伴侣”。事实证明，其所提供的现成可用的更高级别抽象的程序包非常有用，以至于我们的团队在使用 Kotlin 时，都将 Arrow 视为明智的默认选择。最近，为准备1.0版的发布，Arrow 团队进行了几处更改，包括添加了新模块，删除了一些旧模块，并将一些功能标记为过时。
Arrow(Nov 2019, 试验)
Arrow是适用于Kotlin的函数式编程库，是由两个现有流行库（kategory和funKTionale）合并而成。虽然Kotlin为函数式编程提供了构建模块，但Arrow为应用程序开发人员准备了随时可用的高级抽象包。它提供数据类型、类型类、作用（Effects）、Optics和其他函数式编程模式，并且可以与流行库相集成。我们对于Arrow最初的好印象如今已经在生产环境的应用构建中得到了印证。
Arrow(Apr 2019, 评估)
Arrow is a functional programming library for Kotlin, created by merging two existing popular libraries (kategory and funKTionale). While Kotlin provides building blocks for functional programming, Arrow delivers a package of ready-to-use higher-level abstractions for application developers. It provides data types, type classes, effects, optics and other functional programming patterns as well as integrations with popular libraries. With Arrow, existing libraries are unified, which should go a long way to avoid fractured communities in this space.
Testing Library(Oct 2020, 评估)
Testing Library 是用于在众多框架（如React，Vue，React Native 以及 Angular）中测试应用程序的软件包集合。这组库通过鼓励测试用户行为，而非实现细节的方式（如在特定时间点中 UI 存在的元素），来帮助你以用户为中心的方式测试 UI 组件。这种思维方式的好处之一在于测试更加可靠，这也是我们所认为的主要区别。我们建议在任意框架中测试 Web 程序时，都使用该系列工具。尽管仅有 React Testing Library 和 Angular Testing Library 的直接使用经验，我们仍对 Testing Library 印象深刻。
Eleventy(Oct 2020, 评估)
只要场景允许，我们一直信赖使用静态网站生成器来避免复杂性，并提升性能。虽然 Eleventy 出现已经有年头了，但它日渐成熟，最近重获我们的关注。而我们之前的喜好比如 Gatsby.js 出现了一些伸缩性的问题。Eleventy 学习起来很快，可以很容易构建出网站。我们还喜欢它的模板功能，可以方便地创建出语义标签（自然可访问性也更高），以及它对翻页简单又智能的支持。
CML(Oct 2020, 评估)
在之前的雷达中，我们提到将机器学习的持续交付作为一种技术，而在这一期中，我们想重点推出一个极具前景的新工具——持续机器学习（或者叫 CML），它的创造者也创造了 DVC。CML 致力于把持续集成和持续交付的最佳工程实践引入到 AI 和 ML 的团队，同时帮助你在传统的软件工程技术栈之上，组织你的 MLOps，而不是创建单独的 AI 平台。我们对他们能优先支持 DVC 感到欣慰，认为这是新工具正在急速发展的好兆头。
使用原生的远程工作方法(Oct 2020, 试验)
随着新冠疫情的蔓延，至少在目前，高度分散的团队似乎将成为“新常态”。在过去的六个月中，我们掌握了许多关于有效远程工作的知识。从积极的方面来说，良好的视觉工作管理和协作工具使得和同事们远程协作比以往更容易。例如，开发人员可以借助 Visual Studio Live Share 和 GitHub Codespaces 来促进团队协作并提高生产力。远程工作的最大弊端可能是筋疲力尽：许多人一整天被安排了大量的“背对背”视频通话，这种缺点带来的风险也开始显现。尽管在线可视化工具使得协作变得更容易，但也有可能会构建出复杂的巨型图，而这些图最终会难以使用；并且工具扩散的安全性方面也需要小心管理。我们的建议是记住后退一步，和你的团队沟通，评估可行与不可行的方法，并根据需要改变流程和工具。
使用原生的远程工作方法(May 2020, 试验)
分布式团队有多种形态和设置；对于我们来说，100％位于同一地点的交付团队反而已经成为例外。我们大多数团队都是多点团队，或者至少有一些团队成员在异地工作。因此，默认情况下 使用原生的远程工作方法可以极大地帮助团队提高整体流程和效率。首先要确保每个人都可以访问必要的远程系统。此外，请使用例如Visual Studio Live Share、MURAL或Jamboard等工具，将在线工作坊和远程结对变成惯例，而不是偶尔为之。但是，“使用原生的远程工作方法”不只是将本地的协同实践平移到数字世界：拥抱更多的异步沟通、围绕决策文档的更多纪律以及"始终远程"会议是我们团队默认采用的其他方法，用于应对随时可能发生的位置变换。
浏览器定制的腻子脚本（polyfills）(Oct 2020, 评估)
腻子脚本在 Web 演进的过程中非常有用，它为那些尚未实现某些现代特性的浏览器提供了替代功能。但是，Web 应用通常会把这些腻子脚本发布到并不需要它们的浏览器中，这就导致了不必要的下载和解析开销。情况已经越来越明朗，因为现在只剩下少数几个渲染引擎，而大多数腻子脚本只针对其中之一：IE11 使用的 Trident 渲染引擎。此外，它的市场份额正在不断减少，其技术支持也将在一年内结束。所以，我们建议你使用 浏览器定制的腻子脚本 ，仅向特定浏览器发布必要的腻子脚本。该技术甚至已经由 Polyfill.io 实现成了服务。
声明式数据管道定义(Oct 2020, 试验)
许多数据管道都是在一个巨大的、或多或少是由 Python 或 Scala 编写的命令式脚本中定义的。该脚本包含各个步骤的逻辑以及将这些步骤链接在一起的代码。在 Selenium 测试中遇到类似的情况时，开发人员发现了 Page Object 模式，此后许多行为驱动开发(BDD)框架都实现了将步骤定义与整合代码进行分离。一些团队正在尝试将同样的思想引入数据工程。单独的声明式数据管道定义(也许是用 YAML 编写的)只包含声明和步骤顺序。它声明输入和输出数据集，在需要更复杂逻辑时引用脚本。A La模式 是一个相对较新的工具，它采用 DSL 方法来定义管道，不过 airflow-declarative 工具似乎是这个领域中最有前景的工具，它是一个将 YAML中定义的有向无环图转换为 Airflow 任务调度的工具。
声明式数据管道定义(May 2020, 评估)
许多数据管道都或多或少地使用了 Python 或 Scala 编写的命令式脚本来定义。这样的脚本中包含了各个步骤的逻辑以及将这些步骤串联起来的代码。在使用 Selenium 测试时， 出现过类似的情况，而后开发人员发现了 Page Object 模式，后来许多行为驱动开发（BDD）框架都实现了步骤定义与步骤组合之间的分离。 现在，一些团队正在尝试为数据工程引入相同的思路。一个独立的 声明式数据管道定义 （可能是用 YAML 编写的）仅包含一些步骤的声明和顺序。 它定义了输入和输出的数据集，并且在需要更复杂的逻辑时决定是否需要以及何时引入脚本。 我们发现了该领域的第一个开源工具——A La Mode。
JupyterLab(Oct 2020, 试验)
在上一期雷达中，JupyterLab 还处于评估象限，作为项目 Jupyter 基于 web 的用户界面，现在它已经成为许多数据从业者的首选。JupyterLab 的使用正在迅速超越 Jupyter Notebooks，且终将取而代之。如果你仍在使用 Jupyter Notebooks，去尝试一下 JupyterLab 吧。JupyterLab 的交互环境是对 Jupyter Notebook 的改进：通过单元格拖拽、tab 自动补全等新特性对原有的功能进行了扩展。
JupyterLab(May 2020, 评估)
JupyterLab 是 Jupyter 项目的下一代基于 web 的用户操作界面。对于 Jupyter Notebook 的长期用户来说，JupyterLab 也值得一试，因为它提供一个用于 Jupyter Notebook、代码和数据的交互式环境。我们将 JupyterLab 视作 Jupyter Notebook 的一次进化。 JupyterLab 通过扩展其原有功能（允许将代码、可视化和文档存于一处），来提供更好的体验。
披着API网关外衣的企业服务总线(Oct 2020, 暂缓)
长期以来，我们都反对使用 中心化的企业服务总线，并且将 "智能端点和哑管道 " 定义为微服务架构的一个核心特性。遗憾的是，我们观察到传统的企业服务总线正在沉渣泛起， 披着API网关外衣的企业服务总线 正卷土重来，这自然会对过度庞大的API网关起到推波助澜的作用。不要被市场所惑，无论它顶着什么名号，只要是将业务逻辑（包括编排和转换）放到一个中心化的工具中，都必然会增加架构的耦合度，降低系统的透明度，增加对供应商的绑定，而且还没有任何明显的好处。API 网关仍然可以作为对通用关注点的一个非常有用的抽象，但是我们始终相信，业务逻辑应该由 API 提供，而不是 API 网关或是企业服务总线。
Babylon.js(Oct 2020, 评估)
在几年前我们写到超越游戏的VR时，我们没有预见到 VR 解决方案会以多快以及多深的程度进入到除了视频游戏之外的领域。事后看来，我们当然看到了一些兴趣和采纳的增长，但人们对它的理解却比我们预期的要慢得多。原因之一可能是工具。Unity 和 Unreal 是两个用于开发 VR 应用的成熟又强大的引擎。我们还特别提到 Godot。然而，这些引擎跟大多数 web 和企业团队熟悉的那些工具很不同。随着我们继续探索，我们意识到基于 web 的 VR 方案已经取得巨大进展，其中对 Babylon.js 我们有相当积极的经验。Babylon.js 是用 TypeScript 编写并在浏览器中渲染出它的应用，这为许多开发团队提供了熟悉的开发体验。此外，Babylon.js 也是开源软件，成熟而且资金充足，这让它足具吸引力。
微前端的无序(Oct 2020, 暂缓)
自从我们2016年首次引入微前端以来，这个理念已经变得越来越受欢迎，并获得了主流的认可。但是正如其他名称比较易记的新技术一样，微前端偶尔也会被误用或滥用。尤其值得注意的是，在人们倾向于将一系列相互竞争的技术、工具或框架混合使用在一个页面中时，往往会拿微前端来做挡箭牌，从而导致 微前端的无序 。而这其中则以多个前端框架的混用尤甚。例如，在单页面应用中混合使用React.js 和 Angular。虽然这种做法在技术上是有可能的，但如果不是作为某个经过深思熟虑的过渡策略的一部分，那这种做法就是非常不可取的。团队之间还需要保持样式技术(例如： CSS-in-JS 或 CSS modules) 和组件集成方式(例如：iFrames 或 web components)的一致性。此外，在状态管理、数据获取、构建工具、分析等其他方面，组织还需要决定到底应该保持一致的标准化方式，还是将这些问题都交由团队自己做决定。
XState(Oct 2020, 试验)
在之前的雷达中，我们曾经提及多个状态管理的类库，但 XState 在其中显得与众不同。它是个简单的 JavaScript 和 TypeScript 框架，可以创建有限状态机并可视化为状态图。它可以跟最流行的响应式 JavaScript 框架（Vue.js，Ember.js，React.js 以及 RxJS）集成，并基于 W3C 标准来创建有限状态机。另外一个值得留意的特性是它可以序列化状态机的定义。在其他的上下文中（尤其在编写游戏逻辑时）创建有限状态机时，我们发现一件很有帮助的事情，是 XState 对状态以及可能的转换的可视化能力，通过它的 visualizer 实现起来是如此容易。
XState(May 2020, 评估)
我们在之前的技术雷达中收录了几个状态管理库，但是 XState 采用的方法略有不同。这是一个简单的 JavaScript 和 TypeScript 框架，用于创建有限状态机并将其可视化为状态图。它与一些流行的响应式 JavaScript 框架 (Vue.js , Ember.js , React.js 和 RxJS) 集成，并且是基于W3C标准的有限状态机。另一个值得注意的功能是状态机定义的序列化。我们发现有一点很有用，那就是在其他上下文中创建有限状态机（特别是在编写游戏逻辑）时，可视化状态及其可能的转换的能力。 我们确实很喜欢Xstate的visualizer可以很容易做到这一点。
并行核对(Oct 2020, 试验)
大规模替换遗留代码始终是一项艰巨的工作，而且经常受益于执行 并行核对（Parallel run with reconciliation） 。实际上，该技术依赖于通过旧代码和新代码执行相同的生产流程，从旧代码返回响应，比较结果从而对新代码产生信心。尽管这是一种古老的技术，但近年来，我们在持续交付实践（如金丝雀发布和特性切换）的基础上看到了更健壮的实现，并通过添加额外的实验和数据分析层来比较实时结果来扩展它们。我们甚至已经使用这种方法来比较跨功能的结果，例如响应时间。尽管我们已结合定制工具多次使用该技术，但我们还是要感谢 GitHub 的Scientist工具，该工具对应用程序的关键部分进行了现代化改造，现已移植到多种语言。
Pitest(Oct 2020, 试验)
传统的测试方法通常聚焦于评估我们的生产代码是不是在做该做的事情。然而，我们也可能在测试代码中犯错，比如引入了不完整或者无用的断言，导致盲目的自信。这就是变异测试的由来；它会评估测试自身的质量，发现很难意识到的临界情况。我们的团队使用 Pitest 已经有一阵子了，现在推荐在 Java 项目中使用它，用于衡量测试套件的健康程度。简而言之，变异测试会给生产代码引入一点变化，然后再次执行相同的测试；如果测试仍然是绿色的，意味着测试不够好仍然需要改进。如果你在使用 Java 以外的语言，那 Stryker 是个好的选择。
Pitest(Nov 2016, 评估)
Pitest is a test coverage analysis tool for Java that uses a mutation-testing technique. Traditional test coverage analysis tends to measure the number of lines that are executed by your tests. It is therefore only able to identify code that is definitely not tested. Mutation testing, on the other hand, tries to test the quality of those lines that are executed by your test code and yet might contain general errors. Several problems can be spotted this way, helping the team to measure and grow a healthy test suite. Most of such tools tend to be slow and difficult to use, but Pitest has proven to have better performance, is easy to set up, and is actively supported.
Sensei(Oct 2020, 评估)
来自 Secure Code Warrior 的 Sensei 是一款可以很容易地创建和分发安全代码质量规则的 Java IDE 插件。在 ThoughtWorks，我们通常提倡“工具胜过规则”，也就是说，要更容易地做正确的事情，而不是遵守像检查列表那样的治理规则和过程，而 Sensei 就符合这个哲学。开发者可以创建出很容易跟其他团队成员共享的代码片段。它们被实现成针对 Java AST 的查询，可以很简单，也可以很复杂，这样的例子包括对于 SQL 注入和加密漏洞的警告，以及其他。另外一个我们喜欢的特性是，Sensei 在 IDE 中一旦发现代码变化就开始执行，因此它比其他传统的静态分析工具提供了更快的反馈。
Rust(Oct 2020, 试验)
Rust 编程语言持续流行，并连续五年被开发人员们评为 Stack Overflow 的“最受喜爱”语言。我们当然也喜欢它。它是一种快速，安全且富有表现力的语言，随着它的生态系统发展，其实用性也不断提高。例如，Rust 开始用于数据科学和机器学习，并能显著提高性能。同时，用 Rust 编写的面向流的低延迟数据库 Materialize 也应运而生。
Rust(May 2020, 试验)
Rust 日益受到欢迎。曾经，Rust、C++ 和 Go 哪门语言更好的讨论火了一段时间，谁是赢家却尚未明确。近期，令人感到高兴的是，Rust 改善显著，添加并稳固了更多内置 API，包括上一期技术雷达中提到的高级异步支持。此外，Rust 还启发了新语言的设计。例如， Libra 区块链上的 Move 语言 借鉴了 Rust 的内存管理方式来管理资源，从而确保了数字资产永远不会被复制或隐式丢弃。
Rust(Apr 2019, 试验)
Since we last featured it on the Radar in January 2015, we've seen steadily increasing interest in Rust. Some of our clients are now using Rust, mostly in the context of infrastructure tooling but also in high-powered embedded devices. Interest was fuelled by a growing ecosystem as well as improvements to the language itself. The latter included straightforward performance improvements but also changes that make Rust more intuitive, for example the change to non-lexical scoping. Most of the significant changes are included in the Rust 2018 standard released last December.
Rust(Jan 2015, 评估)
Rust is a system programming language with modern affordances. It features a rich typing system, safe memory model and task-based concurrency. Compared to the Go language, Rust is more friendly to people who would like to write code in a functional style.
OSS Index(Oct 2020, 评估)
能够识别出应用系统的依赖是否含有已知漏洞，对于开发团队来说是很重要的事情。OSS Index 可以帮助到这一点。OSS Index是一套免费的开源组件目录，以及设计用来帮助开发者识别漏洞、了解风险并确保软件安全的扫描工具。我们的团队已经通过不同的语言，把这份索引集成到流水线中，比如 AuditJS 和 Gradle plugin。它的运行速度很快，定位漏洞精准，并且几乎没有误报。
Flagger(Oct 2020, 评估)
服务网格和 API 网关为流量路由到不同的微服务提供一个方便的方法，只要这些微服务都实现了相同的 API 接口。Flagger 利用这个特性，可以做到动态调整路由到某个新版本服务的部分流量。这对于金丝雀发布或者蓝绿部署是一项通用的技术。Flagger 和各种流行的代理（包括 Envoy 和 Kong）结合使用，可以逐步增加对于某个服务的请求，并报告负载的指标，从而为新的发布提供快速反馈。我们很高兴 Flagger 简化了这个极具价值的实践，从而可以被广泛采纳。虽然 Flagger 由 Weaveworks 赞助，但你可以独立使用 Flagger，无需捆绑使用 Weaveworks 的其他工具。
pnpm(Oct 2020, 评估)
pnpm 是一款很有前途的 Node.js 包管理器，它相对于其他包管理器的快速和更高的效率吸引了我们的密切关注。所有依赖被保存在磁盘上的唯一位置，并链接到各自的node_modeles目录。pnpm 还支持文件级别的增量优化，并提供了可靠的 API 来扩展和定制化，它还支持存储服务器模式，这可以更进一步加速依赖的下载。如果你的组织有大量的项目拥有相同的依赖，也许你需要关注一下 pnpm。
基于IP协议栈的信任(Oct 2020, 评估)
个人和组织如何在网络上建立数字化的信任，这一持续的挑战催生了关于如何证明身份、如何分享和验证建立信任所需的属性以及如何安全交易的新方法。我们的技术雷达介绍了一些开启数字信任新时代的基础技术，例如去中心化身份和可验证凭证。\n但是，如果没有将技术栈进行标准化的治理，以实现互操作性，那么就不可能实现这种全球规模的变化。作为Linux基金会的下属组织，新的基于IP协议栈信任基金会已经着手实现这一点。TCP/IP 的标准化成就了互联网的成功，从而实现了数十亿设备之间的互操作。该组织从中获得启发，正在定义具有4层的 基于 IP 协议栈的信任的技术和治理标准。 基于IP 协议栈的信任标准，包括公共工具，例如去中心化的标识符、去中心化的身份验证、代理（如数字钱包）的标准化协议、通信与数据交换协议（如用于发布和验证可验证凭证的数据流）以及应用生态系统（例如教育、金融、医疗保健等）。如果要重新考虑设计身份系统，以及如何建立与现有生态系统的信任，建议研究基于 IP 协议栈的信任标准，及其支持工具 Hyperledger Aries。
Trivy(Oct 2020, 采纳)
用来创建和部署容器的流水线，应该包含容器安全扫描这个步骤。我们的团队尤其喜欢 Trivy ——一个针对容器的漏洞扫描器。在这个领域的工具中，我们尝试过 Clair 和 Anchore Engine。跟 Clair 不一样，Trivy 不止会检查容器，而且会检查代码库中的依赖。同时，由于它是一个独立的二进制包，所以更容易在本地设置和运行。Trivy 的其他好处还有，它是开源软件，并支持 distroless containers 容器。
Trivy(Nov 2019, 试验)
我们应该在生成和部署容器的构建流水线中引入容器安全扫描。我们团队特别喜欢Trivy——一款用于容器的漏洞扫描器。它提供独立的二进制文件，相比于其他工具更容易安装和配置。而且Trivy是开源软件，并支持Distroless容器。
定制化服务模板(Oct 2020, 采纳)
自从 定制化服务模板 在雷达中出现以来，这个模式已经被广泛采用以帮助组织向微服务过渡。伴随着可观察性工具、容器编排和服务网格边车的不断进步，服务模板可以通过精心挑选的默认值，减少服务与基础设施配合所需的大量设置，从而帮助快速建立新服务。对定制化服务模板应用产品管理原则也取得了成功。以内部开发者作为客户，定制化服务模板可以帮助开发者将代码发布到生产环境，并提供合适的可观察性以进行操作。定制化服务模板带来的另一个好处，是可以作为轻量级的治理机制，对技术选型的默认项进行集中管理。
定制化服务模板(Jan 2015, 试验)
We see multiple organizations creating a Tailored Service Template which can be used to quickly seed new services, pre-configured to operate within that organization's production environment. The template contains a default set of decisions such as web frameworks, logging, monitoring, build, packaging, and deployment approaches. This is a very useful technique for encouraging collaborative evolution while retaining lightweight governance.
定制化服务模板(Jul 2014, 试验)
We see multiple organizations creating a Tailored Service Template which can be used to quickly seed new services, pre-configured to operate within that organization's production environment. The template contains a default set of decisions such as web frameworks, logging, monitoring, build, packaging, and deployment approaches. This is a very useful technique for encouraging collaborative evolution while retaining lightweight governance.
安全策略即代码(Oct 2020, 采纳)
随着技术格局逐渐复杂化，诸如安全性的问题需要引入更多的自动化和工程实践。在系统构建过程中，我们需要将安全策略——即保护系统免受威胁和破坏的规则和程序，纳入考虑中。例如，访问控制策略定义，并强制谁在什么情况下可以访问哪些服务和资源；相反，网络安全策略应动态限制特定服务的流量速率。 我们的一些团队在 安全策略即代码 上有着丰富的经验。当我们说…即代码时，不仅意味着将这些安全策略写入文件中，还需要将其应用到诸如在代码中采用版本控制、在流水线中引入自动验证、在环境中自动部署并观察监控其性能等实践中。基于我们的经验以及现有工具（包括开放策略代理）和平台（如提供了灵活策略定义和实施机制，以支持安全策略即代码实践的 Istio）的成熟度，我们强烈建议在你的环境中使用此技术。
安全策略即代码(May 2020, 试验)
安全策略是保护我们的系统免受威胁和破坏的规则和程序。例如，访问控制策略定义并强制谁可以在什么情况下访问哪些服务和资源；或者网络安全策略可以动态地限制特定服务的流量速率。当今技术环境的复杂性要求将安全策略视为代码；我们需要定义安全策略脚本、将其加入版本控制中、自动验证、自动部署并监测其性能。Open Policy Agent这样的工具或者Istio之类的平台提供了灵活的策略定义和实施机制，它们都可以支持 安全策略即代码 的实践。
安全策略即代码(Nov 2019, 试验)
安全策略是保护我们的系统免受威胁和破坏的规则和程序。例如，访问控制策略定义并强制谁可以在什么情况下访问哪些服务和资源；或者网络安全策略可以动态地限制特定服务的流量速率。当今技术环境的复杂性要求将安全策略视为代码；我们需要定义安全策略脚本、将其加入版本控制中、自动验证、自动部署并监测其性能。Open Policy Agent这样的工具或者Istio之类的平台提供了灵活的策略定义和实施机制，它们都可以支持安全策略即代码的实践。
Snorkel(Oct 2020, 评估)
现代机器学习模型非常复杂，并且需要大量标记训练数据集进行学习。Snorkel 始于斯坦福 AI 实验室，开发者们意识到手动标记数据非常昂贵，而且通常不可用。Snorkel 使我们可以通过创建标记函数的方式自动对训练数据进行标记。Snorkel 采用监督式学习技术来评估这些标记函数的准确性和相关性，然后重新赋权并组合输出标签，从而生成高质量的训练标签。由此，Snorkel 的创建者们推出了一个名为 Snorkel Flow 的商业平台。尽管 Snorkel 本身已不再被积极研发，但它在使用弱监督方法标记数据方面的思想仍具有重要意义。
Zola(Oct 2020, 评估)
Zola 是用 Rust 编写的静态网站生成器。它是一个没有依赖的可执行文件，执行速度非常快，并且支持你期望的所有常用功能，例如，支持 Sass、markdown 和热加载。我们已经成功地使用 Zola 构建了静态网站，并欣赏它的易用性。
Fastify(Oct 2020, 试验)
在需要用 Node.js 实现时，我们看到团队非常高兴能使用 Fastify。这个 web 框架提供了方便的请求-响应验证处理，支持 TypeScript，以及为团队提供更轻松的开发体验的插件生态系统。虽然它在Node.js生态中是个很好的选择，我们仍然坚持之前的建议：不要陷入Node 过载的场景中。
Opacus(Oct 2020, 评估)
差分隐私的概念最初出现在2016年的雷达中。虽然通过系统模型推断查询来破坏隐私的问题在当时可以被识别出来，但因为几乎没有补救措施，它在很大程度上还是个理论性问题。整个行业都缺少能预防它发生的工具。Opacus 是一个 Python 的新库，可以结合PyTorch 使用，来帮助阻挡某种类型的差分隐私攻击。虽然这是很有前景的进展，但发现正确的模型以及能应用其上的数据集，一直颇具挑战。这个库仍然很新，所以我们拭目以待未来人们对它的接受度会变成什么样。
Helm(Oct 2020, 采纳)
Helm 是用于 Kubernetes 的包管理器。它附带一个专为 Kubernetes 应用甄选过的仓库，维护于Charts 的官方库中。之前我们提到过 Helm，现在 Helm 3已经发布，其中最显著的变化是 Helm 2的服务器端组件 Tiller 的移除。去掉 Tiller 的设计好处在于，你只能从客户端对 Kubernetes 集群作出修改，也就是说，你只能依据作为 Helm 命令行用户的权限来修改集群。我们已经在许多客户项目中使用了 Helm，它的依赖管理、模板以及钩子机制都极大简化了 Kubernetes 的应用生命周期管理。
Helm(Apr 2019, 试验)
Helm is a package manager for Kubernetes. It comes with a repository of curated Kubernetes applications that are maintained in the official Charts repository. Helm has two components: a command line utility called Helm and a cluster component called Tiller. Securing a Kubernetes cluster is a wide and nuanced topic, but we highly recommend setting up Tiller in a role-based access control (RBAC) environment. We've used Helm in a number of client projects and its dependency management, templating and hook mechanism has greatly simplified the application lifecycle management in Kubernetes. However, we recommend proceeding with caution — Helm's YAML templating can be difficult to understand, and Tiller still has some rough edges. Helm 3 is expected to address these issues.
Helm(May 2018, 试验)
Helm is a package manager for Kubernetes. The set of Kubernetes resources that together define an application is packaged as charts. These charts can describe a single resource, such as a Redis pod, or a full stack of a web application: HTTP servers, databases and caches. Helm, by default, comes with a repository of curated Kubernetes applications that are maintained in the official charts repository. It’s also easy to set up a private chart repository for internal usage. Helm has two components: a command line utility called Helm and a cluster component called Tiller. Securing a Kubernetes cluster is a wide and nuanced topic, but we highly recommend setting up Tiller in a role-based access control (RBAC) environment. We’ve used Helm in a number of client projects and it’s dependency management, templating and hook mechanism has greatly simplified the application lifecycle management in Kubernetes.
Recoil(Oct 2020, 评估)
越来越多正在使用 React 的团队，都开始重新评估他们对于状态管理的选项，这也是我们在重新考虑 Redux 时提到的。现在，React 的缔造者 Facebook，发布了 Recoil，一个用于管理状态的全新框架。它源自一个要应付大量数据的内部应用。即便现在对 Recoil 没有充分的实践经验，我们仍然能预见它的潜力和前景。API 简单易学，感觉像是惯用的 React。不像其他方法，Recoil 为应用间共享状态提供了一个有效而灵活的办法：它支持从派生数据和查询动态地创建状态，并在不损害代码分割的情况下，实现整个应用范围内的状态监控。
Flutter Driver(Oct 2020, 评估)
Flutter Driver是Flutter应用的集成测试库。通过 Flutter Driver，你可以在真实设备或模拟器上测试和驱动测试套件。我们的团队一直在编写单元测试和 widget 测试，以确保 Flutter 应用的大部分业务功能已被实现。不过，对于测试实际用户交互方面，我们仍在评估。
用于业务分析的日志聚合(Oct 2020, 暂缓)
几年前，出现了新一代的日志聚合平台，该平台能够存储和搜索大量的日志数据，用来发掘运营数据中的趋势和洞见。 这种工具有很多，Splunk是其中最著名的。由于这些平台可在整个应用程序范围内提供广泛的运营和安全可见性，因此管理员和开发人员越来越依赖于它们。当干系人发现可以使用 日志聚合进行业务分析 时，他们便开始乐于此道。但是，业务需求可能会很快超越这些工具的灵活性和可用性。旨在提供技术可观察性的日志通常很难对用户有深刻的理解。我们更喜欢使用专门为用户分析而设计的工具和指标，或者采用更具事件驱动性的可观察性方法，其中收集、存储业务和运营事件的方式可以用更多专用工具来重现和处理。
用于业务分析的日志聚合(May 2020, 暂缓)
几年前，出现了新一代的日志聚合平台，该平台能够存储和搜索大量的日志数据，用来发掘运营数据中的趋势和洞见。 这种工具有很多，Splunk是其中最著名的。由于这些平台可在整个应用程序范围内提供广泛的运营和安全可见性，因此管理员和开发人员越来越依赖于它们。当干系人发现可以使用“日志聚合进行业务分析”时，他们便开始乐于此道。但是，业务需求可能会很快超越这些工具的灵活性和可用性。旨在提供技术可观察性的日志通常很难对用户有深刻的理解。我们更喜欢使用专门为用户分析而设计的工具和指标，或者采用更具事件驱动性的可观察性方法，其中收集、存储业务和运营事件的方式可以用更多专用工具来重现和处理。
Dremio(Oct 2020, 评估)
Dremio 是一个云数据湖引擎，支持针对云数据湖存储的交互式查询。通过使用 Dremio，你无需再为了满足预测性能而将数据提取和转存到一个专门的数据仓库，因此也无需再专门管理那些数据管道了。Dremio 为数据湖中的数据创建虚拟的数据集，并为消费者提供统一的视图。Presto 使存储与计算层分离的技术得到了普及，而 Dremio 则通过提升性能和优化运营成本使这一技术得到了更进一步的推广。
Yarn(Oct 2020, 试验)
Yarn 仍然是许多团队在包管理器上的默认选择。我们对 Yarn 2的面世感到兴奋，它是一次全新的发布，包括大量的更新和改进。除了可用性优化和工作区的改进外，Yarn 2还引入了 zero-installs 的概念，它可以让开发者在克隆项目后直接运行项目。但是，Yarn 2也带来一些破坏性的变化，这让升级过程并不简单直白。而且它默认是即插即用（PnP）环境，同时不支持 React Native PnP 环境。当然，团队可以选择退出 PnP 环境，或者停留在 Yarn 1。但他们应该意识到，Yarn 1目前已经处于维护模式。
Yarn(May 2018, 试验)
Yarn is a fast, reliable and secured package manager for JavaScript. Using a lock file and a deterministic algorithm, Yarn is able to guarantee that an installation that worked on one system will work exactly the same way on any other system. By efficiently queuing up requests, Yarn maximizes network utilization and as a result we’ve seen faster package downloads. Yarn continues to be our tool of choice for JavaScript package management in spite of the latest improvements in npm (version 5).
Yarn(Nov 2017, 评估)
Yarn is a new package manager that replaces the existing workflow for the npm client while remaining compatible with the npm registry. With the npm client, we may end up with a different tree structure under node_modules based on the order that dependencies are installed. This nondeterministic nature can cause "works on my machine" problems. By breaking the installation steps into resolution, fetching and linking, Yarn avoids these issues using deterministic algorithms and lockfiles and thus guarantees repeatable installations. We've also seen significantly faster builds in our continuous integration (CI) environment because of Yarn caching all the packages it downloads.
Yarn(Mar 2017, 评估)
Yarn is a new package manager that replaces the existing workflow for the npm client while remaining compatible with the npm registry. With the npm client, we may end up with a different tree structure under node_modules based on the order that dependencies are installed. This nondeterministic nature can cause "works on my machine" problems. By breaking the installation steps into resolution, fetching and linking, Yarn avoids these issues using deterministic algorithms and lockfiles and thus guarantees repeatable installations. We've also seen significantly faster builds in our continuous integration (CI) environment because of Yarn caching all the packages it downloads.
Bitrise(Oct 2020, 采纳)
Bitrise，一款用于移动应用的领域特定 CD 工具，仍然是移动开发工作流中很有用的一部分。每个团队都应该去使用它。Bitrise 能够构建，测试和部署移动应用，从开发者的笔记本电脑一直到应用商店的发布。它易于配置，并提供了一整套预构建的步骤，来满足大多数移动开发的需要。
Bitrise(Nov 2019, 试验)
移动应用的构建、测试和部署，尤其是将流水线从代码仓库打通到应用商店的时候，会涉及许多复杂的步骤。虽然这些步骤可以由脚本或普通CI/CD工具提供的流水线自动完成，但我们团队发现，Bitrise这个专注移动应用的持续交付工具对于不需要集成后端流水线的团队来说会更有用。它配置简单，还预置了丰富的部署步骤，可以满足绝大多数移动应用开发所需。
Bitrise(Nov 2018, 评估)
Building, testing and deploying mobile applications entails a number of complex steps, especially when we consider a pipeline from source code repositories to app stores. All these steps can be automated with scripts and build pipelines in generic CI/CD tools. However, for teams that focus on mobile development, and have little or no requirement to integrate with build pipelines for back-end systems, a domain-specific tool can reduce the complexity and maintenance overhead. Bitrise is easy to set up and provides a comprehensive set of prebuilt steps for most mobile development needs.
Dash(Oct 2020, 试验)
这一期雷达引入了一些新的工具，它们可以创建出帮助终端用户可视化并与数据交互的 web 应用。虽然还有更多简单的可视化库比如 D3，但它们在构建独立的可以操作既有数据集的分析应用上，还是减少了可观的工作量。来自 Plotly 的 Dash 在数据科学家中获得越来越多的关注，它可以用 Python 创建出功能丰富的分析应用。Dash 增强了 Python 数据类库，就像 Shiny 之于 R。这些应用有时会被认为是仪表盘，但它们可能涉及的功能，要远远超过这个名词所暗含的部分。Dash 尤其适合构建可伸缩的，随时可上线的应用，这跟同门类中另一个工具 Streamlit 不同。当你需要为商业用户呈现更复杂的分析功能时，请考虑使用 Dash，如果只是少量甚至零代码的方案，你可以选择 Tableau。
Katran(Oct 2020, 评估)
Katran 是一款高性能的 layer 4 负载均衡器。它并不适合所有人，但如果你需要 layer 7负载均衡器（比如 HAProxy 或者 NGINX）的替代品，或者你想要伸缩负载均衡器到两台及更多的服务器上，那我们推荐你评估一下 Katran。相对于 L7 负载均衡器上的循环 DNS 技术，或者网络工程师通常用于解决类似挑战的 IPVS 内核模型，我们把 Katran 看作一个更灵活和有效的选择。
Immer(Oct 2020, 试验)
随着单页面 JavaScript 应用越来越复杂，以可预测的方式进行状态管理就显得愈发重要。不可变性（Immutability）可以帮我们确保应用具有一致的表现，不幸的是，JavaScript 没有提供内置的具有深层不变性的数据结构（参见 ES 记录与元组提案）。Immer（在德语中是永远的意思）是一个极小的包，它可以让你用更加便利的方式处理不可变状态。它基于写时复制（copy-on-write）机制进行工作，具有最小化的 API，而且只操作普通的 JavaScript 对象和数组。这意味着其数据访问是无缝的，不需要做大规模重构就能把不可变性引入到现有代码库中。目前，我们的很多团队都在自己的 JavaScript 代码库中使用它，相对于 Immutable.js，我们更喜欢它一些，这就是把它移入“试验”中的原因。
Immer(Apr 2019, 评估)
With the increasing complexity of single-page JavaScript applications, managing state predictably is becoming more and more important. Immutability can help to ensure our applications behave consistently, but unfortunately JavaScript doesn't natively support the ability to create immutable objects. Libraries such as Immutable.js filled that gap but introduced new problems because now two kinds of objects and arrays existed in the application, the library's version and the native JavaScript ones. Immer — German for always — is a tiny package that lets you work with immutable state in a more convenient way. It's based on the copy-on-write mechanism, has a minimal API and operates on normal JavaScript objects and arrays. This means that data access is seamless and no large refactoring efforts are needed when introducing immutability to an existing codebase.
gossm(Oct 2020, 评估)
当你想要连接到 AWS 上的某个服务器实例时，我们通常推荐要经由一个堡垒机，而不是直接连接。然而，仅仅因此而预置一台堡垒机的过程会让人崩溃掉，这也是为什么AWS 的系统会话管理器提供了管道来更容易地连接到你的服务器。Gossm 是一个开源的 CLI 工具，它可以更方便地使用会话管理器。Gossm 让你通过 ssh 或者 scp 这样的工具，在终端直接利用会话管理器的安全机制和 IAM 策略。它还有一些 AWS CLI 不具备的能力，包括服务器发现和 SSH 集成。
Bokeh(Oct 2020, 试验)
Bokeh 是 Python 中最重要的库之一，通过 JavaScript 在浏览器中的渲染，它可以用于科学绘制和数据可视化。与创建出静态图像的桌面工具相比，这样的工具更易于在 web 应用探索中重用代码。Bokeh 尤其擅长这一点。这个库已经足够成熟，功能齐全。我们喜爱 Bokeh 之处在于：它保持对于作为展示层工具的专注，不会越界到比如数据聚合（参照 ggplot）或者 web 应用开发（参照 Shiny或者 Dash）。所以当分离关注点对你来说很重要时，使用 Bokeh 就是件很愉悦的事情了。Boken 提供了web UI 小部件，并能运行于服务器模式，但你可以伺机使用或者放弃这些特性。Bokeh 很灵活，使用方式很直白，它也没有那么多依赖（比如 pandas或者 notebooks）。
Bokeh(May 2015, 评估)
In the world of data science and analytics, much of the work is done using Python and R, languages which sadly offer few options for web-accessible plotting of visualizations. One approach is to convert the result of analysis into something that can be easily visualized and interacted with in the browser. We’re aware of two tools that are an attempt to do this. Bokeh is a Python and JavaScript library that allows you to create interactive visualizations “in the style of D3.js” but with high performance over large or streaming data sets. Vega is a declarative visualization grammar for D3 that consumes server-generated JSON datasets and translates visualization descriptions into D3.js code.
jscodeshift(Oct 2020, 试验)
维护大规模的 JavaScript 代码库从来不是一件容易的事情，而迁移重大的变更更是极具挑战。在简单的场景中，带有重构能力的 IDE 也许能帮得上忙。但是，如果代码库依赖广泛，每次想要做出重大的变更时，你都不得不遍历客户端代码库，才能做出合适的更新。这需要人工的监管并手工完成。jscodeshift，一个可以重构 JavaScript 和 TypeScript 的工具，能帮助减轻这种痛苦。它能把你的代码分析成抽象语法树（AST），并提供 API 通过不同的变换（也就是在既有的组件上添加、重命名以及删除属性）操作这棵树，然后把这棵树导出成最终源代码。jscodeshift 还附带一个简单的单元测试程序，它能用测试驱动开发的方法编写迁移 codemods。我们还发现 jscodeshift 对于维护设计系统尤其有效。
HashiCorp Sentinel(Oct 2020, 评估)
尽管我们是定义安全策略即代码的积极倡议者，但这个领域的工具一直很有限。如果你在使用 HashiCorp 产品（比如 Terraform 或者 Vault ），并且不介意为企业版本付费，那你就可以使用 HashiCorp Sentinel。事实上，Sentinel 是一门完整的编程语言，用来定义和实现基于上下文的策略决策。比如，在 Terraform 中，它可以用来在应用基础设施变更前，测试是否存在策略违规。在 Vault 中，Sentinel 可以用来定义对 API 的细粒度访问控制。这样的方法提供了类似高级编程语言提供的封装、可维护性、可读性和扩展性，自然相比较传统的声明式安全策略而言更具吸引力。Sentinel 和 Open Policy Agent 属于同一类型的工具，但它是专利所有，闭源，并且只能工作于 HashiCorp 产品中。
Kustomize(Oct 2020, 试验)
Kustomize 是一个管理和定制 Kubernetes 清单文件的工具。它能让你在把 Kubernetes 基础资源应用到不同环境之前，选择和修补它们。它现在已经获得了 kubectl 的原生支持。我们很喜欢它，因为它可以帮助你的代码遵守 DRY 原则。与 Helm（想干的事情太多——包管理、版本管理等等）相比，我们发现 Kustomize 遵循Unix哲学：把一件事情做好，以及每个程序的输出都可以成为另一个程序的输入。
Tekton(Oct 2020, 评估)
Tekton 是一个诞生不久的 Kubernetes 原生平台，用于管理持续集成和交付(CI/CD)管道。它不仅在 Kubernetes 上安装和运行，并且还将其 CI/CD 管道定义为 Kubernetes自定义资源。这意味着这些管道现在可以由原生的 Kubernetes 客户端(CLI 或 api)控制，并且可以利用底层资源管理特性(如回滚)。管道的声明格式很灵活，并且允许定义有条件的工作流、并行执行路径以及操作最终任务进行清理等特性。因此，Tekton 可以支持具有回滚、金丝雀发布等功能的复杂混合部署工作流。Tekton 是开源的，同时也作为GCP 管理服务被提供出来。虽然文档还有待改进，社区也在扩大，不过我们已经成功地将 Tekton 用于 AWS 上的生产工作负载。
Terragrunt(Oct 2020, 试验)
我们已经广泛地使用 Terraform 来创建和管理云基础设施。根据我们的经验，在建立较大规模的基础设施时，代码往往会被拆分为若干个模块，并通过不同的方式被引入到基础设施的创建中，但是这种做法缺乏灵活性，进而会导致无法避免的代码重复，并最终会使团队停滞不前。我们通过使用 Terragrunt 来解决这个问题， 它是基于 Terraform 的一个很薄的包装层，它实现了 Yevgeniy Brikman 的 Terraform: Up and Running 倡导的实践。我们发现 Terragrunt 非常有用，它鼓励多环境的版本化模块和可复用性。生命周期钩子作为另一个非常有用的特性提供了更多的灵活性。在打包方面，Terragrunt 与 Terraform 具有相同的局限性：即没有一个合适的方式来定义包以及包与包之间的依赖关系。但是我们可以使用模块并指定一个与 Git 标签相关联的版本号来解决这个问题。
Terragrunt(Nov 2018, 评估)
We widely use Terraform as code to configure a cloud infrastructure. Terragrunt is a thin wrapper for Terraform that implements the practices advocated by the Terraform: Up and Running book. We've found Terragrunt helpful as it encourages versioned modules and reusability for different environments with some handy features, including recursive code execution in subdirectories. We'd like to see the tool evolve to support CD practices natively, where all code can be packaged, versioned and reused across different environments on CD pipelines. Our team achieves this today with workarounds.
安全区域(Oct 2020, 评估)
安全区域 ，也称为可信执行环境（TEE)，是指一种隔离具有较高安全级别的环境（处理器，内存和存储），并且仅提供与其周围的不受信任执行上下文进行有限信息交换的技术。例如，硬件和系统级别的安全区域可以创建并存储私钥，并使用它们执行如加密数据或验证签名等操作，而无需私钥离开安全区域或将其加载到不受信任的应用程序内存中。安全区域提供了一系列有限的指令来执行受信任的操作，并隔离不受信任的应用上下文。\n长久以来，这项技术一直得到许多硬件和系统供应商（包括 Apple）的支持，并且已有开发人员在物联网和边缘应用中使用该技术。然而，直到最近它才在企业和基于云的应用中获得关注。云提供商已经开始引入机密计算功能，如基于硬件的安全区域：Azure 机密计算基础架构允许启用 TEE 的虚拟机，并通过 Open Enclave SDK 开源库进行访问以执行受信操作。同样地，仍处于测试阶段的 GCP 机密虚拟机和 Compute Engine 允许使用在内存中进行数据加密的虚拟机，AWS Nitro Enclaves 紧随其后，即将发布其预览版。随着基于云的安全区域和机密计算的引入，我们现在可以在数据保护的两个支柱：存储的数据保护，传输的数据保护上添加第三个支柱：内存的数据保护。\n尽管仍处于企业安全区域的初级阶段，我们还是建议你考虑此技术，同时了解已知可能危及底层硬件提供商的安全区域漏洞。
Honeycomb(Oct 2020, 试验)
Honeycomb 是一种可观测性服务，它可以从生产系统中提取丰富的数据，并可以通过动态采样对其进行管理。开发人员可以记录大量丰富的事件，然后决定如何对它们进行切片和关联。理性预测生产系统出了哪些问题的时代已经过去，在当今的大型分布式系统中，这种交互式方法非常有用。Honeycomb 团队正在积极开发多种语言和框架的插件，已经支持的有Go、Node、Java 和 Rails，其他新功能正在迅速添加。另外，其简化过的定价模型也让它更具吸引力。我们团队喜欢它。
Honeycomb(Apr 2019, 评估)
Honeycomb is an observability tool that ingests rich data from production systems and makes it manageable through dynamic sampling. Developers can log large amounts of rich events and decide later how to slice and correlate them. This interactive approach is useful when working with today's large distributed systems because we've passed the point where we can reasonably anticipate which questions we might want to ask of production systems.
Litmus(Oct 2020, 评估)
Litmus 是一个低门槛的混沌工程工具。它可以用很低的代价往你的 Kubernetes 集群中注入各种各样的错误。除了随机干掉某些 Pod 之外，它提供的众多功能尤其让我们感到兴奋，比如仿真各种网络问题、CPU 问题、内存问题和 I/O 问题等。Litmus 还支持一些量身定制的试验，来仿真 Kafka 和 Cassandra 等常见服务中的错误。
ShellCheck(Oct 2020, 试验)
尽管基础设施领域的工具已经得到了极大的改进，在某些情况下编写一些 shell 脚本仍然是有价值的。但是由于 shell 脚本的语法非常晦涩难懂，再加上我们现在对编写shell 脚本疏于练习，我们已经开始乐于使用 ShellCheck 来简化 shell 脚本的编写。ShellCheck 可以用于命令行，或者作为构建的一部分，甚至作为很多流行的集成开发环境的扩展来使用。它的 Wiki 页面包含了数百个 ShellCheck 可以识别的问题的详细描述，而且绝大多数的工具和集成开发环境在发现问题的时候，都提供了非常方便地方式来访问该问题对应的 Wiki 页面。
Apollo Federation(Oct 2020, 暂缓)
我们首次在技术雷达中介绍 GraphQL 时，曾提醒误用它会导致反模式，从长远来看弊大于利。尽管如此，我们发现团队对 GraphQL 越来越感兴趣，因为它能够 聚合来自不同资源的信息。这次我们想提醒你谨慎使用 Apollo Federation 和它对公司统一数据图的强大支持。即便乍看之下，有跨组织的普适概念这种想法是具有吸引力的，但是我们必须考虑之前业界做过的类似尝试——如 MDM 和规范数据模型等，这些尝试暴露了这种方法的缺陷。挑战会是巨大的，特别是当我们发现所在的领域要创建一个独特统一的模型非常复杂的时候。
依赖漂移适应度函数(Oct 2020, 采纳)
演进式架构借用自进化计算而引入的适应度函数，可以客观地展示应用程序及架构是否正在偏离期望的指标，实际上是可以集成到发布流水线中的测试。 依赖漂移适应度函数 追踪应用程序一个主要指标，即应用依赖的库、API或环境组件的新鲜度，并可以将过时需要更新的依赖标记出来。随着 Dependabot、Snyk 这类用于检测依赖漂移的工具日趋成熟，我们可以轻松地在软件发布流程中加入依赖漂移适应度函数，以保证应用程序依赖的更新。
依赖漂移适应度函数(Nov 2019, 试验)
许多团队和组织缺少正式或一致的方式来跟踪软件中的技术依赖关系。当软件需要更改，而其中使用的过时版本的库、API或者组件引发问题或者延期时，这个问题就暴露出来了。依赖漂移适应度函数是一项引入了特定的演进式架构适应度函数的技术，它能随着时间推移追踪这些依赖，从而能够指出可能需要的工作，以及某个潜在问题是在好转还是恶化。
回旋实验(Oct 2020, 评估)
使用 A/B 测试进行对照实验是揭示有关产品开发决策的好方法。 但是，当我们无法让参与 A/B 测试的两个小组之间彼此独立时，这个方法就失效了，也就是说，将某人添加到"A”小组中会影响“B”小组，反之亦然。 解决此问题空间的一种技术是回旋实验 。 这里的核心概念是我们在特定区域中以交替的时间段在实验的“A”和“ B”模式之间来回切换，而不是在同一时间段内同时运行。 然后，我们比较两个时段之间的客户体验和其他关键指标。 我们已经在某些项目中尝试了此方法，并且取得了不错的效果——它是我们的实验工具栏中一款很好的工具。
事件拦截(Oct 2020, 试验)
随着越来越多的公司从遗留系统中迁移出来，我们觉得有必要强调一种从这些系统中获取数据的新机制，它可以作为变动数据捕获（CDC）的替代方案。Martin Fowler 早在2004 年就描述了事件拦截。在现代术语中，它涉及到在进入系统时将请求分流，以便逐步构建一个替代系统。这通常是通过复制事件或消息来实现的，但是 HTTP 请求分流也同样有效。例如在将事件写入大型机之前在销售点系统处将事件分流，又如在将支付事务写入核心银行系统之前对其进行分流。这两种情况都会导致部分遗留系统的逐步替换。我们认为，这种从源头获取状态更改，而不是使用 CDC 进行后期处理来重新创建状态更改的技术，一直以来都被忽视了，这也是我们在本期技术雷达中强调它的原因。
生产化的笔记本(Oct 2020, 暂缓)
在过去的几十年里，最初由 Wolfram Mathematica 引入的计算笔记已经发展到可以支持科学研究、探索和教育工作流程了。自然，它们还支持数据科学工作流，并且诸如 Jupyter notebooks 和 Databricks notebooks 已经成为了一个很好的工具，它们提供了简单且直观的交互计算环境，能够结合代码来分析富文本数据，并将其可视化来讲述数据故事。这些笔记本是作为提供现代科学交流和创新的最终媒介而设计的。不过，在近几年，我们发现一种趋势：笔记本成为运行生产质量类型的代码媒介，其中这些代码通常用于驱动企业运营。我们看到笔记本平台供应商宣传他们的探索笔记本在生产中的使用。这是一个好的期望——对数据科学家来说，简易化编程却没有得到很好的实现，并且牺牲了可扩展性、可维护性、弹性以及一个长线产品代码所需支持的所有其他品质。因此我们不推荐生产化的笔记本，而是鼓励对数据科学家赋能，使其能够使用正确的编程框架构建预生产代码，从而简化持续交付工具以及端到端机器学习平台的抽象复杂性。
生产化的笔记本(Apr 2019, 暂缓)
Jupyter Notebooks have gained in popularity among data scientists who use them for exploratory analyses, early-stage development and knowledge sharing. This rise in popularity has led to the trend of productionizing Jupyter Notebooks, by providing the tools and support to execute them at scale. Although we wouldn't want to discourage anyone from using their tools of choice, we don't recommend using Jupyter Notebooks for building scalable, maintainable and long-lived production code — they lack effective version control, error handling, modularity and extensibility among other basic capabilities required for building scalable, production-ready code. Instead, we encourage developers and data scientists to work together to find solutions that empower data scientists to build production-ready machine learning models using continuous delivery practices with the right programming frameworks. We caution against productionization of Jupyter Notebooks to overcome inefficiencies in continuous delivery pipelines for machine learning, or inadequate automated testing.
Hermes(Oct 2020, 评估)
Hermes 是一个经过优化的 JavaScript 引擎，可在 Android 端快速启动 React Native 应用程序。JavaScript 引擎（例如 V8）具有即时（JIT）编译器，可在运行时对代码进行分析以生成优化的指令。而 Hermes 采用了另一种方法，将 JavaScript 代码提前编译（AOT）为优化的字节码。这样做的结果是，你可以获得更小的 APK 图片大小，更少的内存消耗和更快的启动时间。我们正在一些 React Native 应用中认真评估 Hermes，建议你也这样做。
Firebase(May 2020, 试验)
谷歌的Firebase自2016年被我们纳入无服务器架构以来，发生了重大的演变。 Firebase 是一个综合性平台，可用于构建移动和Web应用，并运行在谷歌可伸缩基础设施上。我们尤其喜欢 Firebase App Distribution 和 Firebase Remote Config。前者可通过持续部署流水线，轻松发布应用程序的测试版本。而后者可以将配置更改，动态地推送给应用程序，而无须重新发布应用程序。
MediaPipe(May 2020, 评估)
MediaPipe 是一个用于构建多模态（例如视频，音频，时间序列数据等），跨平台（例如Android，iOS，Web 和边界设备）的应用类机器学习流水线。它提供包括面部识别，手部识别，手势识别以及物体识别在内的多种能力。尽管 MediaPipe 主要部署在移动设备上，但多亏了 WebAssembly 和 XNNPack 机器学习推理类库的帮助，使得它也能在浏览器上运行。就像目前所看到的一样，我们正在探索一些将 MediaPipe 用于增强现实的用例。
Dojo(May 2020, 试验)
几年前，Docker（通常是跟容器一起）彻底改变了我们对于打包、部署和运行应用程序的看法。尽管在生产环境中情况有所改善，但是开发人员依然需要花费大量时间去设置开发环境，并且经常遇到“但它在我的机器上是好的”这类问题。Dojo 旨在通过 Docker 镜像的版本化和发布来创建标准的开发环境，并以此来解决这个问题。我们的几个团队已经借助 Dojo 来简化从本地开发到生产流水线中的开发、测试和构建过程。
Exposed(May 2020, 试验)
在长期使用 Kotlin 的过程中，我们的开发团队没有将 Java 框架与 Kotlin 混用，从而获得了更多针对 Kotlin 设计的框架的经验。作为轻量级的对象关系映射器（ORM），Exposed 过了好一阵子才引起我们的注意。Exposed 有两种数据库访问方式：类型安全的内部 DSL 包装 SQL，以及数据访问对象（DAO）模式的实现。它具有一个成熟的 ORM 所能被期待的功能，例如对多对多引用的处理，急切加载（eager loading）以及对跨实体联接的支持。Exposed 受到我们团队青睐的地方还在于，方法实现无需代理，并且不依赖于反射，这无疑对性能有所帮助。
用于机器学习的实验跟踪工具(May 2020, 试验)
机器学习的日常工作通常可以归结为一系列的实验，包括选择建模方法和网络拓扑，训练数据以及优化调整模型。 数据科学家必须利用经验和直觉来做出一些假设，然后去评估这些假设对模型的整体性能的影响。 随着这种实践的成熟，我们的团队发现对“用于机器学习的实验跟踪工具”的需求日益增长。 这些工具可以用于帮助研究人员跟踪实验， 从而使这些实验变得更加的有条不紊。 尽管这个领域还没有出现明确的赢家，但是已经出现了MLflow这类的工具以及诸如Comet和Neptune这样的平台，它们使得整个机器学习的工作流程变得更加的严谨和可重复。
用于机器学习的实验跟踪工具(Nov 2019, 试验)
机器学习的日常工作通常可以归结为一系列的实验，包括选择建模方法，网络拓扑，训练数据集以及对模型的各种优化或调整。由于其中许多模型仍然难以解析或解释，因此数据科学家必须使用经验和直觉来假设一些改变，然后测量这些变化对模型整体性能的影响。随着这些模型在业务系统中使用得越来越普遍，出现了几种不同的“用于机器学习的实验跟踪工具”，以帮助研究人员有条理地进行实验，并跟踪这些实验结果。尽管该领域还没有明确的赢家出现，但是诸如MLflow和Weights＆Biases之类的工具，Comet和Neptune之类的平台，已经在整个机器学习工作流程中引入了严谨性和可重复性。除此之外，它们还促进了相互协作，将数据科学从一项单独的工作转变为一项团队协作的运动。
Gitflow 的长期分支(May 2020, 暂缓)
五年前，我们强调了 Gitflow 长期分支 的问题。从本质上讲，长期分支与将所有更改持续集成到源代码中的方法背道而驰。并且，根据我们的经验，持续集成对大多数软件开发来说是更好的方法。后来，因为看到不少团队几乎只用长期分支，我们将警惕的态度扩大到 Gitflow 本身。时至今日，我们依然能看到以 Web 系统持续交付为既定目标的团队沉迷于长期分支。因此当看到 Gitflow 的作者现在已经在他的原有文章中添加了一条注释，解释说 Gitflow 当初不是为此类场景而设计时，我们非常高兴。
Gitflow 的长期分支(May 2015, 暂缓)
Gitflow is a strict branching pattern for releases using Git. Although not an inherently bad pattern, we often see it misused. If the feature and develop branches are short lived and merged often, you are really using the power of Git, which makes these activities easy. However, a problem we often see is that these become long lived branches , which results in the dreaded merge conflicts many people began using Git to escape. A merge is a merge. Regardless of the source control tool or pattern you use. If you wait more than a day or two to merge, you could hit a big merge conflict. This becomes a real issue if you have a larger team. If you have more than a few people waiting to merge, you can have a serious a bottleneck. Introducing patterns like Gitflow require the discipline to merge often to be successful. So by all means use the pattern, but only if you have the discipline to prevent long lived branches
Figma(May 2020, 采纳)
不论是对设计师，还是多角色团队而言，Figma 都已被证明是协作设计的首选工具。它允许开发人员和其他角色通过浏览器查看和评论设计，而无需使用桌面版本。和它的竞争对手（如Invision 或 Sketch）相比，Figma 将版本控制、协作设计和设计分享这些功能都集中到一个工具上，这使得我们的团队更容易一起想出新点子。我们的团队发现 Figma 十分有用，特别是在开启和促进远程分布式设计工作方面。 除了实时设计和协作功能外，Figma 还提供了一个 API 以帮助改善 DesignOps 流程 。
Figma(Nov 2019, 试验)
交互和视觉设计的一大痛点是缺乏用于协作的工具，Figma就是为此而生的。它不仅具有与Sketch和Invision等设计程序相同的功能，而且还支持与其他人实时协作，帮助多人一起探索新的想法。我们的团队发现Figma非常有用，特别是它支持与简化了远程和分布式的设计工作。除了协作功能之外，Figma还提供了有助于改善DesignOps流程的API。
Matomo(May 2020, 评估)
Matomo （前身为Piwik）是一款开源的网站分析平台，可以完全控制对分析数据的访问。可以自托管 Matomo ，并保护网站分析数据的安全，防止第三方非授权访问。Matomo 还可以轻松地将网站分析数据与内部数据平台集成，为用户需求量身定制使用模型。
最简特性开关(May 2020, 采纳)
我们遗憾地发现，人们很少使用特性开关，且经常混淆其类型和使用场景。为了从持续集成中受益，一些团队会使用 LaunchDarkly 等重量级平台来实现特性切换（包括发布切换），即使他们所需要的仅仅是简单地 if/else 条件控制。 因此，除非你需要 A/B 测试、金丝雀发布或将特性发布的职责交给业务人员，我们建议使用 最简特性开关 来代替不必要的复杂的特性切换框架。
Argo CD(May 2020, 试验)
在不评判 GitOps 技术的情况下，我们想针对在 Kubernetes 环境中对应用的部署和监控，来讨论 Argo CD。鉴于其能在 Kubernetes 指定的目标环境中，自动将应用部署至所期望的状态，以及在下述方面带给我们的良好体验——排查失效部署的故障原因、验证日志以及监控部署状态，我们建议尝试使用 Argo CD。此外，用户甚至可以通过图表化方式，实时查看集群运行状态、变更如何传播以及 pod 如何被创建和销毁。
半监督学习循环(May 2020, 试验)
半监督学习循环 是一类迭代式的机器学习工作流，它们利用未标记数据中尚待发现的关系，来提升学习性能。这些技术通过不同方式组合已标记和未标记的数据集，从而改进模型。此外，它们还对在不同数据子集上训练出来的模型进行对比。与机器从未标记数据中推断分类的无监督学习，以及训练集完全标记的有监督技术不同，半监督技术利用的是一小部分已标记数据和大量的未标记数据。半监督学习还与主动学习技术密切相关，在主动学习技术中，人们被引导至选择性标记的模糊数据点。因为能够精确标记数据的专家是稀缺资源，并且标记通常是机器学习工作流中最耗时的活动，所以半监督技术不仅降低了训练成本，还使机器学习对于新型用户而言是可行的。我们还看到了弱监督技术的应用，它使用了机器标记的数据，但其可信度低于人工标记的数据。
半监督学习循环(Nov 2019, 评估)
半监督学习循环是一类迭代式的机器学习工作流，它们利用未标记数据中尚待发现的关系，来提升学习性能。这些技术通过不同方式组合标记和未标记的数据集，从而改进模型。此外，它们还对在不同数据子集上训练出来的的模型进行对比。与机器从未标记数据中推断分类的无监督学习，以及训练集完全标记的有监督技术不同，半监督技术利用的是一小部分被标记数据和大部分未标记数据。半监督学习还与主动学习技术密切相关，在主动学习技术中，人们被引导至选择性标记的模糊数据点。因为能够精确标记数据的专家是稀缺资源，并且标记通常是机器学习中最耗时的活动，所以半监督技术不仅降低了训练成本，还使机器学习对于新型用户而言是可行的。
Gitpod(May 2020, 评估)
大多数软件可以通过简单的两步进行构建：签出代码库，然后运行一个构建脚本。不过，建立一个完整编码环境的过程仍然很繁琐。Gitpod 通过为 Github 或 GitLab 仓库提供基于云的、现成的代码环境来解决这个问题。它提供了一个基于 Visual Studio 代码的 IDE，可以在 web 浏览器中运行。默认情况下，这些环境是在谷歌云平台上启动的，当然也可以部署内部解决方案。它的价值是显而易见的，特别是对于开源软件，这种方法可以降低临时贡献者的门槛。然而，这种方法在企业环境中的可行性还有待观察。
微前端(May 2020, 采纳)
引入微服务令我们受益匪浅，使用微服务，团队可以扩展那些独立部署及维护的服务的交付。遗憾的是，我们也看到许多团队创建了单体前端——一个建立在后端服务之上的大而混乱的浏览器应用程序——这在很大程度上抵消了微服务带来的好处。自从问世以来， 微前端 持续变得流行。我们已经看到，许多团队采用这种架构的某种形式，来管理多开发人员和多团队的复杂性，以提供相同的用户体验。在去年的六月份，这个技术的发起人之一，发表了一篇介绍性的文章，可以起到微前端参考文献的作用。它展示了这种设计是如何通过各种Web编程机制实现的，以及使用React.js构建了一个示例应用程序。我们有理由相信，随着大型组织尝试在跨多团队中分解UI开发，这种风格将越来越流行。
微前端(Nov 2019, 采纳)
引入微服务令我们受益匪浅，使用微服务，团队可以扩展那些独立部署及维护的服务的交付。遗憾的是，我们也看到许多团队创建了单体前端——一个建立在后端服务之上的大而混乱的浏览器应用程序——这在很大程度上抵消了微服务带来的好处。自从问世以来，微前端持续变得流行。我们已经看到，许多团队采用这种架构的某种形式，来管理多开发人员和多团队的复杂性，以提供相同的用户体验。在今年的六月份，这个技术的发起人之一，发表了一篇介绍性的文章，可以起到微前端参考文献的作用。它展示了这种设计是如何通过各种Web编程机制实现的，以及使用React.js构建了一个示例应用程序。我们有理由相信，随着大型组织尝试在跨多团队中分解UI开发，这种风格将越来越流行。
微前端(Apr 2019, 采纳)
We've seen significant benefits from introducing microservices, which have allowed teams to scale the delivery of independently deployed and maintained services. Unfortunately, we've also seen many teams create a frontend monolith — a large, entangled browser application that sits on top of the backend services — largely neutralizing the benefits of microservices. Since we first described micro frontends as a technique to address this issue, we've had almost universally positive experiences with the approach and have found a number of patterns to use micro frontends even as more and more code shifts from the server to the web browser. So far, web components have been elusive in this field, though.
微前端(May 2018, 试验)
We've seen significant benefits from introducing microservices architectures, which have allowed teams to scale the delivery of independently deployed and maintained services. Unfortunately, we've also seen many teams create front-end monoliths — a single, large and sprawling browser application — on top of their back-end services. Our preferred (and proven) approach is to split the browser-based code into micro frontends. In this approach, the web application is broken down into its features, and each feature is owned, frontend to backend, by a different team. This ensures that every feature is developed, tested and deployed independently from other features. Multiple techniques exist to recombine the features — sometimes as pages, sometimes as components — into a cohesive user experience.
微前端(Nov 2017, 试验)
We've seen significant benefits from introducing microservices architectures, which have allowed teams to scale the delivery of independently deployed and maintained services. Unfortunately, we've also seen many teams create front-end monoliths — a single, large and sprawling browser application — on top of their back-end services. Our preferred (and proven) approach is to split the browser-based code into micro frontends. In this approach, the web application is broken down into its features, and each feature is owned, frontend to backend, by a different team. This ensures that every feature is developed, tested and deployed independently from other features. Multiple techniques exist to recombine the features — sometimes as pages, sometimes as components — into a cohesive user experience.
微前端(Mar 2017, 评估)
We've seen significant benefit from introducing microservice architectures, which have allowed teams to scale delivery of independently deployed and maintained services. However, teams have often struggled to avoid the creation of front-end monoliths—large and sprawling browser applications that are as difficult to maintain and evolve as the monolithic server-side applications we've abandoned. We're seeing an approach emerge that our teams call micro frontends. In this approach, a web application is broken up by its pages and features, with each feature being owned end-to-end by a single team. Multiple techniques exist to bring the application features—some old and some new—together as a cohesive user experience, but the goal remains to allow each feature to be developed, tested and deployed independently from others. The BFF - backend for frontends approach works well here, with each team developing a BFF to support its set of application features.
微前端(Nov 2016, 评估)
We've seen significant benefit from introducing microservice architectures, which have allowed teams to scale delivery of independently deployed and maintained services. However, teams have often struggled to avoid the creation of front-end monoliths—large and sprawling browser applications that are as difficult to maintain and evolve as the monolithic server-side applications we've abandoned. We're seeing an approach emerge that our teams call micro frontends. In this approach, a web application is broken up by its pages and features, with each feature being owned end-to-end by a single team. Multiple techniques exist to bring the application features—some old and some new—together as a cohesive user experience, but the goal remains to allow each feature to be developed, tested and deployed independently from others. The BFF - backend for frontends approach works well here, with each team developing a BFF to support its set of application features.
Cosmos(May 2020, 评估)
自从我们在技术雷达中，对区块链这一领域作出初始评估 以来，该领域技术的性能有了极大的提升。然而，目前仍然没有哪个区块链平台能够达到“互联网级别”的吞吐量。各种区块链平台相继发展，产生了不少新的数据和价值孤岛。这使得区块链社区的关键主题一直是跨链技术。区块链的未来，可能是由若干独立且并行的区块链而组成的网络。这也是Cosmos的愿景。Cosmos 发布了 Tendermint 和 CosmosSDK，以使开发人员可以定制独立的区块链。这些并行的区块链，可以通过 IBC（Inter-Blockchain Communication，区块链间通信协议） 和 Peg Zone 来交换价值。对于 CosmosSDK ，我们的团队拥有丰富的经验。而 IBC 协议正在日趋完善。这种架构可以解决区块链的互操作性和可伸缩性的问题。
.NET Core(May 2020, 采纳)
虽然 .NET Core 之前已进入雷达的采纳环，表明它已成为我们 .NET 项目的默认平台，但我们觉得有必要再次关注一下 .NET Core。随着去年 .NET Core 3.x 的发布，. NET Framework的大部分特性，现在都已移植到 .NET Core 中。微软在.NET Framework最新一次发布中，强调.NET Core 是 .NET 的未来。微软已经做了大量工作，来使 .NET Core 达到容器友好。我们大多数基于 .NET Core 的项目，都是针对Linux的，并通常以容器形式进行部署。即将发布的 .NET 5 ，看起来很有前途。我们对此充满期待。
.NET Core(May 2018, 采纳)
Our teams have confirmed that .NET Core has reached a level of maturity that makes it the default for .NET server applications. The open source .NET Core framework enables the development and deployment of .NET applications on Windows, macOS and Linux with first-class cross-platform tooling. Microsoft provides blessed Docker images which make it easy to deploy .NET Core applications in a containerized environment. Positive directions in the community and feedback from our projects indicate that .NET Core is the future for .NET development.
.NET Core(Nov 2017, 试验)
We're seeing increased adoption of .NET Core, the open source cross-platform software framework. .NET Core enables the development and deployment of .NET applications on Windows, macOS and Linux. With the release of .NET Standard 2.0 increasing the number of standard APIs across .NET platforms, the migration path to .NET Core has become clearer. Issues related to library support on .NET Core are becoming less problematic, and first-class cross-platform tooling is now available, allowing for productive development on non-Windows platforms. Blessed Docker images are provided to make it easy to integrate .NET Core services into a containerized environment. Positive directions in the community and feedback from our projects indicate that .NET Core is ready for widespread use.
.NET Core(Mar 2017, 评估)
.NET Core is an open source modular product for creating applications that can be easily deployed in Windows, macOS and Linux. .NET Core makes it possible to build cross-platform web applications using ASP.NET Core with a set of tools, libraries and frameworks—another choice for microservices architecture. The community around .NET Core and other related projects has been growing. New tools have appeared and evolved quickly, such as Visual Studio Code. There are Docker images based on both Linux and Windows (Nano Server) with .NET Core that simplify applying a microservice architecture. CoreCLR and CoreFX appeared in the Radar in the past. However, a few months ago Microsoft announced the release of .NET Core 1.0, the first stable version. We see good new opportunities, changes and a vibrant community as reasons to keep assessing this product.
.NET Core(Nov 2016, 评估)
.NET Core is an open source modular product for creating applications that can be easily deployed in Windows, macOS and Linux. .NET Core makes it possible to build cross-platform web applications using ASP.NET Core with a set of tools, libraries and frameworks—another choice for microservices architecture. The community around .NET Core and other related projects has been growing. New tools have appeared and evolved quickly, such as Visual Studio Code. There are Docker images based on both Linux and Windows (Nano Server) with .NET Core that simplify applying a microservice architecture. CoreCLR and CoreFX appeared in the Radar in the past. However, a few months ago Microsoft announced the release of .NET Core 1.0, the first stable version. We see good new opportunities, changes and a vibrant community as reasons to keep assessing this product.
.NET Core(Nov 2015, 评估)
CoreCLR and** CoreFX** is the core platform and framework for .NET. Although not new, they have recently been open sourced by Microsoft. A key change is that these dependencies are bin-deployable, they do not need to be installed on a machine in advance.  This eases side-by-side deployments, allowing applications to use different framework versions without conflicts. Something written in .NET is then an implementation detail, you can install a .NET dependency into any environment. A .NET tool is no different than something written in C from an external dependency perspective, making it a much more attractive option for general purpose applications and utilities. CoreFX is also being factored into individual NuGet dependencies, so that applications can pull what they need, keeping the footprint for .NET applications and libraries small and making it easier to replace part of the framework.
Sarama(May 2020, 试验)
Sarama是Apache Kafka的 Go 客户端库。如果你在 Go 中开发 API，你会发现 Sarama 非常容易设置和管理，因为它不依赖于任何原生库。Sarama 有两种类型的 API——一种高层 API 用于轻松地生产和消费消息，另一种底层 API 用于控制网络上的字节。
React Testing Library(May 2020, 采纳)
JavaScript的世界日新月异，随着我们使用框架的经验越来越多，我们的倾向也在改变。我们深入使用某些框架，其他备选框架自然黯然失色。在React前端测试方面，React Testing Library就是这样一个例子。我们团队很喜欢的是，用这个框架写的测试比其他框架(如 Enzyme)更健壮，因为它鼓励独立测试组件间的关系，而不是测试全部实现细节。 这种思维源自于测试库，React Testing Library 是它的一部分，它还为像Angular 和 Vue.js这样的框架提供了一整套库。
React Testing Library(Nov 2019, 试验)
JavaScript世界日新月异，随着我们在框架使用方面的经验越来越多，我们的推荐也随之改变。有些框架随着我们的深入使用，会使其他类似框架都黯然失色。在React前端测试方面，React Testing Library就是这样一个例子。用它写的测试比其他框架（如Enzyme）脆弱，因为它鼓励独立测试组件间的关系，而不是测试全部实现细节。
React Testing Library(Apr 2019, 评估)
As the pace of change in JavaScript frameworks has slowed, our teams have more time to work with specific frameworks and are gaining deeper insights as a result. With React and the dominant testing framework, Enzyme, we've observed a worrying trend of unit tests becoming tightly coupled to implementation details without providing — because the focus is on shallow details — much confidence that features work as expected. These unit tests make evolving the design difficult and they shift too much responsibility up the test pyramid to functional testing. This has made us revisit the idea of subcutaneous testing. Additionally, because of its design, Enzyme has issues trying to keep up with React's development. All this has pushed us toward assessing react-testing-library as a new framework for testing React applications.
MURAL(May 2020, 试验)
MURAL 自诩为“视觉协作的数字工作空间”，并允许团队在基于白板和便利贴构建的共享工作空间内进行交互。它的功能包括投票、评论、注释和“跟随演讲者”。我们特别喜欢它的模板特性，它允许主持人设计并与团队重用引导会话。所有主流的办公协作软件在这个领域都有工具可以使用(例如，谷歌 Jamboard 和微软白板),这些都是值得研究的，但我们发现 MURAL 使用起来非常顺畅、方便和灵活。
mkcert(May 2020, 试验)
mkcert 是一个用于创建本地信任的开发证书的便捷工具。在本地开发环境中使用真实的CA（Certificate Authority，证书颁发机构）签发的证书，是非常困难的，特别是对于像 example.net、localhost 或者 127.0.0.1 这样的主机来说，使用真实的CA签发的证书是不可能的。在这样的情况下，自签发的证书可能是唯一的选择。mkcert 可以生成自签发的证书，并把本地 CA 安装到系统根证书库中。对于本地开发和测试以外的所有情况，我们强烈建议使用真实的 CA 签发的证书以避免信任问题。
Stratos(May 2020, 评估)
Ultraleap （前身为 Leap Motion）在XR（Extended Reality，扩展现实）领域一直处于领先地位。它创造了出色的手部跟踪硬件，使用户的手可以融入虚拟现实世界中。Stratos 是 Ultraleap 的底层触觉、传感器和软件平台。它可以使用定向超声波，在空中产生触觉反馈。比如响应驾驶员的手势，以调节车内空调，并在交互界面上实现触觉反馈。看到这项技术，以及富有创造力的技术人员将该技术应用于各种场景，我们十分欣喜。
Hot Chocolate(May 2020, 试验)
GraphQL 生态系统和社区正不断发展。其中，Hot Chocolate 是用于 .NET（包括 .NET Core 和 .NET Classic）的 GraphQL 服务器。该平台可用于构建和托管 schema，并能使用与 GraphQL 相同的基本组件（数据加载器，解析器，schema，操作和类型）对这些 schema 进行查询。Hot Chocolate 的开发团队最近增添了 schema 拼接功能，允许从单个入口点跨多个 schema（从不同位置聚合而成）进行查询。尽管该功能有被滥用的可能，我们的团队仍对 Hot Chocolate 感到满意，因为它提供了详尽的文档，并且能让我们迅速为客户提供价值。
Hot Chocolate(Apr 2019, 评估)
The GraphQL ecosystem and community keep growing. Hot Chocolate is a GraphQL server for .NET (core and classic). It lets you build and host schemas and then serve queries against them. The team behind Hot Chocolate has recently added schema stitching which allows for a single entry point to query across multiple schemas aggregated from different locations. Although there are plenty of ways to misuse this approach, it's worth assessing whether to add it to your toolkit.
Enzyme(May 2020, 暂缓)
我们通常不会将已经移除的工具保留在技术雷达上，但是我们的团队强烈感受到Enzyme应该替换为React Testing Library来用于测试React界面组件。使用Enzyme的团队发现它对于被测试组件内部的聚焦会导致脆弱的、无法维护的测试。
Enzyme(Nov 2019, 暂缓)
我们通常不会将已经移除的工具保留在技术雷达上，但是我们的团队强烈感受到Enzyme应该替换为React Testing Library来用于测试React界面组件。使用Enzyme的团队发现它对于被测试组件内部的聚焦会导致脆弱的、无法维护的测试。
Enzyme(May 2018, 采纳)
Enzyme has become the defacto standard for unit testing React UI components. Unlike many other snapshot-based testing utilities, Enzyme enables you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications. In many of our projects it’s used within a unit testing framework such as Jest.
Enzyme(Mar 2017, 试验)
We've been enjoying the rapid component-level UI testing that Enzyme provides for React.js applications. Unlike many other snapshot-based testing frameworks, Enzyme allows you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications.
Enzyme(Nov 2016, 试验)
We’ve been enjoying the rapid component-level UI testing that Enzyme provides for React.js applications. Unlike many other snapshot-based testing frameworks, Enzyme allows you to test without doing on-device rendering, which results in faster and more granular testing. This is a contributing factor in our ability to massively reduce the amount of functional testing we find we have to do in React applications.
遗留系统迁移的功能一致性(May 2020, 暂缓)
我们发现，越来越多的组织需要替换陈旧的遗留系统，以适应其客户（内部和外部）的需求。我们持续看到的一种反模式是 遗留系统迁移的功能一致性 ，即保留旧版本同样功能的愿望。我们认为这错失了一个巨大的机会。随着时间流逝，旧系统往往会变得臃肿，包含了许多不被用户使用的功能（根据2014年Standish Group的报告，这一比例为50％）和随着时间而发展的业务流程。替换这些功能是一种浪费。我们的建议：说服你的客户退一步思考，了解他们的用户当前需要什么，并根据业务结果和指标，对这些需求进行优先排序——这通常说起来容易做起来难。这意味着需要进行用户调研，并采用现代产品开发实践，而不是简单地替换现有的系统。
遗留系统迁移的功能一致性(Nov 2019, 暂缓)
我们发现，越来越多的组织需要替换陈旧的遗留系统，以适应其客户（内部和外部）的需求。我们持续看到的一种反模式是遗留系统迁移的功能一致性，即保留旧版本同样功能的愿望。我们认为这错失了一个巨大的机会。随着时间流逝，旧系统往往会变得臃肿，包含了许多不被用户使用的功能（根据2014年Standish Group的报告，这一比例为50％）和随着时间而发展的业务流程。替换这些功能是一种浪费。我们的建议：说服你的客户退一步思考，了解他们的用户当前需要什么，并根据业务结果和指标，对这些需求进行优先排序——这通常说起来容易做起来难。这意味着需要进行用户调研，并采用现代产品开发实践，而不是简单地替换现有的系统。
务实的远程结对(May 2020, 采纳)
我们坚信结对编程可以提高代码质量，在团队中传播知识，并可以在总体上更快地交付软件。然而在后 COVID 的世界中，许多软件团队将是分布式的或完全远程工作的。因此在这种情况下，我们建议采用 务实的远程结对 ，即根据手头的工具调整结对策略。考虑使用 Visual Studio Live Share 这样的的工具来实行高效、低延迟的协作。仅当结对双方居住的地理位置相对靠近且网络带宽足够高时，才使用高清的屏幕共享。让所处时区相近的开发人员结对工作，而不要无视地理位置。如果出于客观原因导致结对难以进行，也有一些应对措施可以执行，例如独立编码辅以代码审查、基于 pull-request 的协作（但要提防 Gitflow 长期分支），或仅在代码关键部分进行短期结对。以我们多年的经验看来，采用实用主义的远程结对编程是有效的。
Anka(May 2020, 试验)
Anka 是一组辅助 iOS 和 macOS 应用开发的工具，用于创建、管理、分发、构建和测试可复制的 macOS 虚拟环境。它为 macOS 环境带来了类似于 Docker 的体验，包括即时启动，用于管理虚拟机的命令行工具，以及用于对虚拟机进行版本化和打标记以便进行分发的注册表。我们已经使用 Anka 为客户构建了 macOS 私有云。在需要虚拟化 iOS 和 macOS 的环境时，这是一个值得考虑的工具。
Anka(Apr 2019, 评估)
Anka is a set of tools to create, manage and distribute build and test macOS reproducible virtual environments for iOS and macOS development. It brings Docker-like experience to macOS environments: instant start, CLI to manage virtual machines and registry to version and tag virtual machines for distribution. We discovered Anka when we proposed a macOS private cloud solution to a client. This tool is worth considering when applying DevOps workflow to iOS and macOS environments.
流水线即代码(May 2020, 采纳)
流水线即代码 技术强调，用于构建、测试和部署我们应用程序或基础设施的交付流水线配置，都应以代码形式展现。这些代码应置于版本控制系统中，并切分成包含自动化测试和部署的可复用组件。随着组织逐渐演变为构建微服务或微前端的去中心化自治团队，人们越来越需要以代码形式管理流水线这种工程实践，来保证组织内部构建和部署软件的一致性。这种需求使得业界出现了很多交付流水线模板和工具，它们可以以标准的方式构建、部署服务和应用。这些工具用大多采用声明式交付流水线的形式，采用一个流水线蓝图，来执行一个交付生命周期中不同阶段的任务，如构建、测试和部署，而不用关心实现细节。以代码形式来完成构建、测试和部署流水线的能力，应该成为选择CI/CD工具的评估标准之一。
流水线即代码(Mar 2017, 采纳)
Teams are pushing for automation across their environments(testing), including their development infrastructure. Pipelines as code is defining the deployment pipeline through code instead of configuring a running CI/CD tool. LambdaCD, Drone, GoCD and Concourse are examples that allow usage of this technique. Also, configuration automation tools for CI/CD systems like GoMatic can be used to treat the deployment pipeline as code—versioned and tested.
流水线即代码(Nov 2016, 采纳)
Teams are pushing for automation across their environments, including their development infrastructure. Pipelines as code is defining the deployment pipeline through code instead of configuring a running CI/CD tool. LambdaCD, Drone, GoCD and Concourse are examples that allow usage of this technique. Also, configuration automation tools for CI/CD systems like GoMatic can be used to treat the deployment pipeline as code—versioned and tested.
Hydra(May 2020, 试验)
并非每个人都需要自托管的 OAuth2 解决方案，但若需要，可关注 Hydra。这是一款完全符合规范的开源 OAuth2 服务器及 OpenID connect 提供方。Hydra 具有用于开发环境的内存存储支持，以及用于生产环境的关系数据库（PostgreSQL）。无状态的 Hydra 平台，拥有类似九头蛇海德拉的魔力（在希腊神话中， Hydra 意指九头蛇海德拉。即使斩断它的一颗头，也会生出新的头。与之类似，Hydra 平台中无状态的服务器实例出一旦失效，平台会创建新的实例。——译者注），且易于在 Kubernetes 等平台上进行横向伸缩。根据性能要求，在对 Hydra 实例进行横向伸缩时，需要调整数据库实例的数量。由于 Hydra 并未提供任何开箱即用的身份管理解决方案，所以可以通过一个整洁的 API ，将现有的任何身份管理系统，与 Hydra 集成在一起。这种清晰地将身份管理与 OAuth2 框架其余部分相分离的设计，使 Hydra 与现有身份验证生态系统的集成更加容易。
Hydra(Nov 2019, 评估)
并非每个人都需要一个自托管的OAuth2解决方案，但是如果你需要，我们发现Hydra是一个非常有用的方案，它是一个完全兼容开源OAuth2认证服务器和OpenID Connect的服务提供方。我们非常喜欢它，因为它不提供开箱即用的认证管理解决方案，无论采用哪种身份管理方式，都可以通过干净的API与其集成。身份认证管理与OAuth2框架其余部分之间的清晰区分，使Hydra与现有身份认证生态系统的集成更加容易。
基础设施即代码(May 2020, 采纳)
尽管 基础设施即代码 是一种相对旧的技术（我们早在2011年的技术雷达中就已经介绍过它），但在现代云时代，构建基础设施的行为已经成为了将配置指令传递到云平台的重要组成部分，因此它变得非常重要。当我们说“即代码”时，是指我们在软件领域学到的所有良好实践都应应用于基础设施。使用源代码控制，遵守 DRY原则、模块化、可维护性以及使用自动化测试和部署都是关键的实践。我们当中具有深厚软件和基础设施背景的人，需要体谅和支持那些没有做过这些的同事。仅仅说“像对待代码一样处理基础设施”还不够，我们需要确保从软件世界学到的来之不易的经验教训，也能够同样应用到整个基础设施领域。
基础设施即代码(Oct 2012, 采纳)
We continue to highlight infrastructure as code. This technique treats infrastructure configuration in the same way as code; checking configuration into source control, then carefully pushing changes out to the data center.
基础设施即代码(Jul 2011, 采纳)
The DevOps movement continues to grow, with developers and operations staff working closely together to solve the “software last mile” problem. Infrastructure as code is a technique for treating infrastructure configuration in the same way as code; checking it into source control, then using it to push changes out to the data center. In addition to web server, application server and application configuration, we are seeing network configuration treated in the same way. Network switch, firewall and load balancer configuration can be infrastructure as code, and even changed at runtime.
基础设施即代码(Jan 2011, 采纳)
The large number of hosts and devices in a modern datacenter or cloud deployment have made manually installing and configuring infrastructure unwise. Infrastructure as code is an approach whereby infrastructure configuration is scripted or described by files that are stored in version control, and changes are pushed out to the datacenter in a controlled manner. This parallels the discipline of source control and build promotion used in software development, hence ‘as code’. The two front-running open source tools for infrastructure automation are Chef and Puppet. They both use a textual DSL to script automation. Using this approach provides consistent and repeatable environment changes, reducing the manual effort involved, especially in troubleshooting environmental differences.
Anthos(May 2020, 评估)
我们看到了企业云策略的以下转变，即从无意而为的混合云，或从整个云的迁移，转向有意而为且精密复杂的混合云、多云或可移植云。在这种转变中，企业会从多个维度，来建立和执行下述云策略——基于风险、控制能力和性能情况，来决定将在何处托管其各种数据和功能；如何在降低运维成本的同时，充分利用企业内部的基础设施；如何既充分利用多个云提供商及其独特的差异化服务，又不会给构建和运行应用程序的用户带来复杂性和摩擦。\nAnthos 是谷歌针对上述转变而创建的平台。它通过一系列开源技术（例如 GKE、Service Mesh 和基于 Git 的配置管理系统），为实现混合云和多云策略，提供高级管理和控制平面（plane）。它支持在不同的托管环境（包括 Google Cloud 和本地硬件）上，运行可移植的数据流量和相关功能。尽管其他云提供商拥有类似平台，但 Anthos 打算在支持混合云的基础上更进一步，使用开源组件来让可移植云成为可能（但这还有待观察）。我们看到人们对 Anthos 的兴趣正在上升。尽管谷歌的托管混合云方案看似很有前景，但这并不是灵丹妙药，因为需要对现有云和本地系统进行更改。针对考虑使用 Anthos 的客户，我们的建议是，在 Google Cloud 生态系统的服务和其他选项之间，进行权衡取舍，以保持所选的服务，能得到合理的中立和控制程度。
仅快照测试(May 2020, 暂缓)
在遗留系统中工作时，为了保证系统继续运行且不破坏遗留代码功能，快照测试的价值是不可否认的。然而，我们看到了使用 仅快照测试 作为主要测试机制这种常见但有害的做法。快照测试可以验证组件在 DOM 中生成的确切结果，但不能验证组件的行为。 因此，它可能是脆弱且不可靠的，还会催生“仅删除快照后重新生成快照”这样不好的实践。与此相反，您应该通过模拟用户的操作，对组件的逻辑和行为进行测试。 Testing Library 系列中的工具也鼓励这种思维方式。
Apache Pulsar(May 2020, 评估)
Apache Pulsar是一个开源的 pub-sub （发布-订阅）消息与流媒体平台，与Apache Kafka在同一领域展开竞争。它提供了我们所期望的功能，如低延迟的异步及同步消息传递，可进行容量伸缩的消息持久化存储，以及多种客户端程序库。Pulsar 吸引我们的地方，是能轻易实现容量伸缩，尤其适合在多用户类型的大型组织中使用。Pulsar 原生支持多租户、异地备份、基于角色的访问控制和计费隔离。此外，我们还期望 Pulsar 能解决高容量数据系统中，消息日志无限增长的问题。在这些系统中，事件一旦持久化，就需要无限期地保存，并且订阅者可以从历史节点开始订阅消息。这是通过一个分层存储的模型来实现的。尽管 Pulsar 对于大型组织是一个有前景的平台，但依然有提升的空间。目前，安装 pulsar 需要管理ZooKeeper和BookKeeper以及其他工具。我们期待随着 Pulsar 的日益普及，用户很快能够得到更广泛的社区支持。
Karate(May 2020, 试验)
基于认为测试是唯一真正重要的 API 规范的经验，我们一直在寻找对测试有帮助的新工具。Karate 是一种 API 测试框架，其独特之处在于它不依赖通用编程语言，而直接使用基于 Gherkin 的语法编写测试。 Karate 使用一种领域特定语言，来描述基于HTTP的API测试。我们的团队喜欢 Karate 为 API 规范带来的易读性，并建议将其应用于测试金字塔的较高层次，而非过量应用在细节的断言中。
Karate(Apr 2019, 评估)
Given our experience that tests are the only API specifications that really matter, we're always on the lookout for new tools that might help. Karate is an API testing framework whose unique feature is that tests are written directly in Gherkin without relying on a general-purpose programming language to implement test behavior. Karate is really a domain-specific language for describing HTTP-based API tests. Although this approach is interesting and makes for some very readable specifications for simple tests, the special-purpose language for matching and validating payloads can become quite syntax-heavy and difficult to understand. It remains to be seen if more complex tests written in this style will be readable and maintainable over the long haul.
GraphQL Inspector(May 2020, 试验)
GraphQL Inspector 可以比较两个 GraphQL 模式（schema）之间的变更。我们曾经警告要谨慎使用 GraphQL。自那以后，我们很高兴看到 GraphQL 相关的工具有了一些改进。ThoughtWorks的大多数团队会继续将GraphQL 用于服务器端资源聚合。通过将 GraphQL Inspector 集成到团队的 CI 流水线中，我们已经能够捕获 GraphQL 模式中潜在的重大变化。
Tamer(May 2020, 评估)
如果需要将关系数据库中的数据收集到 Kafka 的 Topic 中，可以考虑使用Tamer，它将自己标榜为“驯化的 Kafka JDBC数据源连接器 ”。尽管Tamer是一个相对较新的框架，但它比Kafka JDBC连接器更高效，尤其是在处理大量数据时。
Manifold(May 2020, 评估)
Manifold 是机器学习的一个与模型无关的可视化调试工具。模型开发人员通常会花费大量的时间用于迭代和改进现有模型，而不是创建一个新的模型。通过将焦点从模型转移到数据，Manifold 对影响模型性能的数据集特征进行可视化，并以此补充现有的性能指标。我们认为 Manifold 将会是机器学习生态系统中一个值得考虑的实用工具。
Goss(May 2020, 试验)
Goss 是一个供应测试工具，往期的技术雷达在介绍TDD开发容器脚本 时曾提到过它。与 Serverspec 相比，Goss 的功能还不够完备，因此还不足以作为 Serverspec 的替代方案。可是如果它的功能恰好能满足需求，考虑一下它也未尝不可，更何况它非常小巧，开箱即用，不像 Serverspec 一样还需要专门的 Ruby 运行环境。使用 Goss 这种工具的一个常见的反模式就是分开维护代码和测试，这样在实际的基础设施即代码文件发生变化的时候，也必须相应地修改测试断言。这种测试的维护工作量非常大，而且因为代码和测试之间的严格一致性，当工程师更新了一个而忘记更新另外一个的时候往往会导致测试失败。而且这些测试很少能发现真正的问题。
Sizzy(May 2020, 评估)
构建一个在多种设备和屏幕尺寸上看起来都符合预期的网页应用并不是一件简单的事情。Sizzy 是一个 SaaS 解决方案，用于在一个浏览器窗口内展示多个视窗。应用会被同时渲染到所有的视窗中，并且对应用的交互也会同步到所有视窗中。根据我们的经验，以这种方式与应用交互，可以更容易地在视觉回归测试工具于构建流水线中标记问题之前发现潜在的问题。尽管如此，我们也应该指出，我们的一些开发人员在尝试使用了一段时间 Sizzy 之后，总的来说，还是更倾向于使用 Chrome 提供的工具。
AsyncAPI(May 2020, 评估)
开放标准是构建分布式系统的基础支柱之一。例如，OpenAPI（以前被称为 Swagger） 规范作为定义 RESTful API 的行业标准，对微服务等分布式架构的成功至关重要。基于它涌现出了大量用于构建、测试和监控 RESTful API 的工具。然而在使用事件驱动 API 的分布式系统中，这种标准化在很大程度上是缺失的。\nAsyncAPI 是一项开源计划，旨在构建急需的事件驱动和异步 API 标准以及开发工具。AsyncAPI 规范受 OpenAPI 规范的启发，以一种机器可读的格式描述和记录了事件驱动 API。它与协议无关，因此可以适用于包括 MQTT，WebSocket 和 Kafka 在内的许多协议的 API 上。我们期待看到 AsyncAPI 的持续改进以及其工具生态系统的进一步成熟。
Phrase(May 2020, 试验)
正如在 Crowdin 的描述中所提到的，现在可以使用多种平台来管理产品的多语言翻译，而无需再通过电子邮件来发送大型的电子表格。在这些平台中，我们的团队报告了使用 Phrase 的良好体验，并强调它对所有关键用户群体都非常易用：翻译人员使用的是一个非常方便的浏览器 UI；管理者也可以在这个 UI 上添加新的字段，并与其他团队的翻译进行同步；开发人员可以在本地或通过构建流水线来访问 Phrase。另一个值得一提的特性是，Phrase 还通过使用标签实现了翻译的版本管理，这使得在实际产品中对比不同版本的翻译成为可能。
GraphQL 用于服务端资源聚合(May 2020, 试验)
我们看到越来越多的工具（例如 Apollo Federation）支持将多个 GraphQL 端点聚合到一个图中。但必须提醒的是，不要滥用 GraphQL，尤其是作为服务间的协议时。我们的实践是仅将 GraphQL 用于服务端资源聚合。使用这种模式时，微服务会持续发布明确定义的 RESTful API，而聚合服务或 BFF(Backend for Frontends) 模式则使用 GraphQL 解析器集成其他服务资源。图的形状需由领域建模实践驱动，以确保在必要时（在每个限界上下文都是一个微服务的情况下）将统一语言局限在子图内。该技术简化了聚合服务或 BFF 的内部实现，同时鼓励对服务进行良好的建模以避免贫血 REST。
GraphQL 用于服务端资源聚合(May 2018, 评估)
One pattern that comes up again and again when building microservice-style architectures is how to handle the aggregation of many resources server-side. In recent years, we've seen the emergence of a number of patterns such as Backend for Frontend (BFF) and tools such as Falcor to address this. Our teams have started using GraphQL for server-side resource aggregation instead. This differs from the usual mode of using GraphQL where clients directly query a GraphQL server. When using this technique, the services continue to expose RESTful APIs but under-the-hood aggregate services use GraphQL resolvers as the implementation for stitching resources from other services. This technique simplifies the internal implementation of aggregate services or BFFs by using GraphQL.
Wire(May 2020, 评估)
Golang 社区中有相当一部分人是依赖注入怀疑论者，部分原因是他们将模式与特定框架相混淆，并且具有系统编程背景的开发人员本能地不喜欢反射引起的运行时开销。Wire 应运而生，这是一种编译时依赖注入工具，可以同时生成代码并将组件连接在一起。Wire 没有额外的运行时开销，并且更易于推断静态依赖关系图。 无论你手写代码还是使用框架，我们都建议使用依赖注入来鼓励模块化和可测试的设计。
ERNIE(May 2020, 评估)
在上一期技术雷达中，我们加入了BERT—— NLP（Natural Language Processing，自然语言处理） 领域中的一个关键里程碑。去年，百度发布了 ERNIE 2.0（Enhanced Representation through kNowledge IntEgration），它在 7 个 GLUE(General Language Understanding Evaluation) 语言理解任务和全部 9 个中文 NLP 任务上的表现均优于 BERT。和 BERT 一样，ERNIE 也提供了无监督预训练语言模型。它可以通过添加输出层的方法来进行微调，以创建多种 NLP 任务的当前最优模型。ERNIE 与传统预训练方法不同之处在于，它是一个连续的预训练框架。它可以不断地引入各种各样的预训练任务，以帮助模型有效地学习语言表达，而不是仅使用少量的预训练目标进行训练。我们对 NLP 的进步感到非常兴奋，并期待在我们的项目中尝试。
Crowdin(May 2020, 试验)
大多数需要支持多语言的项目，都始于先以一种语言构建功能，然后再通过电子邮件和电子表格进行离线翻译，来管理其余语言的翻译工作。尽管这种简单的方法可行，但事情很快就会失控。因为接下来，会不得不持续为不同的语言翻译者回答相同的问题，导致翻译者、校对人员和开发团队之间的协作失去活力。在为数不多的几个有助于简化项目本地化工作流程的平台中，Crowdin 是其中之一。使用 Crowdin ，在开发团队持续构建功能的同时，平台可以将需要翻译的文本转变为在线工作流。我们喜欢 Crowdin 能促使团队持续和增量地完成翻译工作，而不是在最后阶段大批量地管理这些工作。
Crowdin(Nov 2019, 评估)
开发团队在开发大多数具有多语言支持的项目时，往往一开始只构建一种语言的功能，然后以电子邮件和电子表格形式，离线翻译其余语言。这种简单的安排虽然可行，但很快就会失控。因为可能需要为不同的语言翻译者，重复回答相同的问题，从而使译者、校对人员和开发团队，耗费大量精力进行协作。Crowdin是少数几个同类平台中的一员，能简化项目本地化工作流程的。开发团队在持续构建功能的同时，Crowdin平台可以持续将待翻译文本，整合至在线工作流中。我们喜欢Crowdin能推动团队持续和渐进地整合翻译工作，从而避免在最后阶段才进行大批量的处理。
MeiliSearch(May 2020, 评估)
MeiliSearch是一个快捷、易用且易部署的文本搜索引擎。多年来，Elasticsearch 在具备容量伸缩特点的文本搜索领域，已成为流行选择。但是，如果数据量不大，无须进行分布式的文本搜索，但仍然想实现一个快捷的容错搜索引擎，那么就建议评估一下MeiliSearch。
Clinic.js Bubbleprof(May 2020, 评估)
在提升代码性能的过程中，定位代码的瓶颈和延迟点通常比较困难，特别是在异步操作中。性能剖析工具此时就十分重要。Clinic.js Bubbleprof会可视化Node.js进程中的异步操作，绘制程序调用流中的延迟图。我们很喜爱这类工具，因为它帮助开发人员轻松的定位和确定代码改进的优先级。
CSS-in-JS(May 2020, 试验)
自2017年，我们把 CSS-in-JS 作为新兴技术提出后，它变得越来越流行了，在我们的工作中也可以看到明显的趋势。基于一些扎实的生产经验，我们现在推荐 CSS-in-JS 为试用技术。在上次的技术雷达中我们提到过，要了解这个技术， 样式化组件 框架是一个很好的出发点。在使用 CSS-in-JS 技术的时候，除了它的种种优点，通常也会遭遇到一个缺点：运行时计算样式会导致 用户可感知延迟。通过 Linaria， 我们看到了一类新的在创建时就考虑到这个问题的框架。Linaria 引入了许多技术把大部分性能开销转移到构建时间。不过这也带来了一些妥协，最常见的就是不支持 IE11 的动态样式。
CSS-in-JS(Nov 2017, 评估)
CSS in JS is a technique of writing CSS styling in the JavaScript programming language. This encourages a common pattern of writing the styling with the JavaScript component it applies to, co-locating presentational and logical concerns. The new players — including JSS, emotion and styled-components — rely on the tooling to translate the CSS-in-JS code to separate CSS stylesheets, to make them suitable for browser consumption. This is the second-generation approach to writing CSS in JavaScript and unlike the previous approaches doesn’t rely on in-line styles. That means it provides the benefit of supporting all CSS features, sharing of CSS using the npm ecosystem and utilization of components across multiple platforms. Our teams have found styled-components working well with component-based frameworks, such as React, and unit testing of CSS with jest-styled-components. This space is new and rapidly changing; the approach requires some effort for manual debugging of the generated class names in the browser, and it may not apply to some projects where the front-end architecture does not support reusing components and requires global styling.
预检构建(May 2020, 评估)
尽管相比 Gitflow 来说，我们强烈推荐 CI，但我们知道直接向主干提交然后在 master 分支上跑 CI，在团队过大的时候是低效的。构建会变慢或不稳定，也可能团队会缺乏在本地运行完整测试集的纪律。在这种情况下，一次红色的构建可以阻塞多名或多对开发者的工作。许多团队通常依赖功能分支来绕过这些问题，而不是解决潜在的根本原因——构建缓慢、不能本地运行测试或迫使许多人在同一位置工作的单体架构。我们不鼓励功能分支，因为它可能需要巨大的努力来解决合并冲突，并且还可能在解决冲突的过程中拉长了反馈周期和引入缺陷。取而代之的是，我们提议使用 预检构建 作为替代方案：它是基于 Pull Request 的构建，针对只在流水线运行期间存在的为每个commit建立的微型分支。为了自动化这一工作流，我们已经见到了类似 Bors 这样的机器人程序，它将合并 master 分支和删除迷你分支（当构建成功时）的工作自动化。我们正在评估这个流程，你也应该试试看，但请不要用它去解决错误的问题，因为这样的话可能会带来分支滥用，导致弊大于利。
云平移(May 2020, 暂缓)
奇怪的是，有了十多年的云迁移行业经验之后，我们仍然认为有必要呼吁大家警惕 云平移 。因为它只将云视为托管的解决方案，并且在云上直接简单复制现有的架构、安全实践和IT运营模式。这种方式并未意识到云在敏捷性和数字创新方面的优势。云迁移需要有意地跨多个轴向云原生状态转变，并且根据独特的迁移环境，每个组织最终的结果可能会处于从云平移到云原生迁移这样一个波谱中的某个位置。例如，系统架构作为交付敏捷性的支柱之一，我们通常需要对其进行修改。简单地将现有系统平移为容器具有很强的诱惑性。尽管此策略可以加快云迁移的速度，但在创建敏捷性以及交付功能和价值方面却存在不足。云上的企业安全与传统的通过防火墙和分区的基于边界的安全从根本上是不同的，它需要企业迈向零信任架构。同时，它还需要IT运营模式的改革，以便于通过自助式的自动化平台安全地提供云服务，使团队能够承担更多的运营责任并获得自治权。最后，组织必须建立起能支撑持续变化的基础，例如同样迁移为应用和基础设施进行持续测试而创建的的流水线。这些将有助于迁移过程，并最终构建一个更健壮和完善的系统，同时也为组织提供了持续演进和改进自身系统的方式。
云平移(Nov 2016, 暂缓)
As more organizations are choosing to deploy applications in the cloud, we're regularly finding IT groups that are wastefully trying to replicate their existing data center management and security approaches in the cloud. This often comes in the form of firewalls, load balancers, network proxies, access control, security appliances and services that are extended into the cloud with minimal rethinking. We've seen organizations build their own orchestration APIs in front of the cloud providers to constrain the services that can be utilized by teams. In most cases these layers serve only to cripple the capability, taking away most of the intended benefits of moving to the cloud. In this edition of the Radar, we've chosen to rehighlight cloud lift and shift as a technique to avoid. Organizations should instead look more deeply at the intent of their existing security and operational controls, and look for alternative controls that work in the cloud without creating unnecessary constraints. Many of those controls will already exist for mature cloud providers, and teams that adopt the cloud can use native APIs for self-serve provisioning and operations.
云平移(Jan 2015, 暂缓)
As cloud adoption grows we are unfortunately seeing a trend to treat the cloud as just another hosting provider. Cloud lift and shift is unfortunately being encouraged by large vendors re-branding existing hosting offerings as "cloud." Few of these offer any real flexibility or pay-as-you-use pricing. If you think you can move to the cloud without re-architecting, you are probably not doing it right.
云平移(Jul 2014, 暂缓)
As cloud adoption grows we are unfortunately seeing a trend to treat the cloud as just another hosting provider. Cloud lift and shift is unfortunately being encouraged by large vendors re-branding existing hosting offerings as "cloud." Few of these offer any real flexibility or pay-as-you-use pricing. If you think you can move to the cloud without re-architecting, you are probably not doing it right.
Marquez(May 2020, 评估)
Marquez 是相对年轻的开源项目，用于数据生态系统中元数据的采集和托管。它使用简单的数据模型，来表现诸如世袭（lineage)、上下游数据处理作业及其状态之类的元数据，并用灵活的标签标记数据集的属性。Marquez 提供了简单的 RESTful API 来管理元数据，从而简化了与数据生态系统中其他工具集的集成。\n我们已将Marquez作为起点，轻松对其进行扩展，以适应需求，例如执行安全策略，并改用其领域语言等。如果需要一个小巧简单的工具，来完成数据处理作业和数据集的存储和可视化，那么 Marquez 是一个很好的开始。
Gloo(May 2020, 评估)
随着 Kubernetes 和 service mesh 的日益普及，API 网关在云原生分布式系统中一直面临着生存危机。毕竟，许多 API 网关的功能，如流量控制，安全性，路由和可观察性等，现在都是由集群的入口控制器和网格网关提供。Gloo 是一个支持这种变化的轻量级API网关，它使用 Envoy 作为其网关技术，同时为外部用户和应用程序提供附加价值，如 API 的内聚视图等。Gloo 还提供了一套管理界面用于控制 Envoy 网关，并运行和集成了多个服务网格的实现，如 Linkerd，Istio 和 AWS App Mesh。尽管它的开源版本已经提供了 API 网关的基本功能，但它的企业版有一组更成熟的安全控件，如 API 密钥管理， OPA集成等。Gloo 是一个很有前途的轻量级 API 网关。它很好地适应了云原生技术和架构的生态系统，同时避免了在 API 网关中引入业务逻辑以迎合最终用户的陷阱。
道德偏见测试(May 2020, 试验)
在过去的一年中，人们对机器学习，尤其是深度神经网络的兴趣发生了转变。到目前为止，人们对各个模型无限潜能的兴奋，驱动了多种工具及技术的发展。然而近期以来，人们越来越担心这些模型可能无意间造成的伤害。例如，模型可以无意中被训练做出有利可图的信用决策，粗暴地排除处于不利地位的申请人。幸运的是， 道德偏见测试 越来越受关注，这将有助于发现潜在的有害决定。lime、AI Fairness 360 或 What-If Tool 等工具可以帮助发现训练数据中由少数群体导致的偏差，Google Facets 或 Facets Dive 等可视化工具可用于发现训练数据集内的子组。除了道德偏见测试，我们还将 lime（local interpretable model-agnostic explanations，局部可知、模型不可知的解释）用于理解机器学习分类器的预测以及分类器（或模型）的功能。
道德偏见测试(Nov 2019, 评估)
在过去的一年，我们已经看到人们对机器学习尤其是深度神经网络的兴趣正在发生变化。到目前为止，这些模型的卓越功能推动了工具和技术上令人兴奋的发展。虽然目前，人们越来越担心这些模型可能会造成意外伤害。例如，一个模型可以经过训练，通过简单地排除弱势申请人，而做出有利可图的信用决策。幸运的是，我们看到人们对道德偏见测试的兴趣与日俱增，这将有助于发现潜在的有害决策。一些工具，例如lime，AI Fairness 360或者What-If，可以帮助我们发现一些训练数据和可视化工具中未被充分代表的群体而导致的不准确性。可视化工具中，Google Facets和Facets Dive可以用来发现大量训练数据中的子组。但是，这是一个正在发展的领域，我们期待随着时间的推移，出现针对道德偏见测试的标准和实践。
DeepWalk(May 2020, 评估)
DeepWalk是一个有助于将机器学习应用于图的算法。 在处理以图表示的数据集时，关键问题之一就是从图中提取特征。 这就是 DeepWalk 可以发挥作用的地方。 DeepWalk 使用 SkipGram 来构造嵌入式节点，它将图视为一种语言，图中的每一个节点都是该语言中的唯一单词，DeepWalk 通过随机遍历图中有限的节点来将单词构造成句子。 这些图嵌入随后便可应用于各种机器学习模型中。 我们有些项目需要在图上应用机器学习，DeepWalk是我们尝试的技术之一。
NLP的迁移学习(May 2020, 试验)
该技术之前处于技术雷达的评估维度。NLP（Natural Language Processing，自然语言处理领域的创新在持续快速发展，并且由于无处不在的 迁移学习 ，使得我们可以将这些创新应用到项目中。GLUE基准测试(一套语言理解任务)的得分在过去几年里有了显著的进步，平均分数从刚发布时的70.0上升到2020年4月处于领导地位的90.0。我们在NLP领域的很多项目，从ELMo、BERT和 ERNIE等预训练模型开始，然后根据项目需求进行微调，可以取得重大进展。
NLP的迁移学习(Apr 2019, 评估)
Transfer learning has been quite effective within the field of computer vision, speeding the time to train a model by reusing existing models. Those of us who work in machine learning are excited that the same techniques can be applied to natural language processing (NLP) with the publication of ULMFiT and open source pretrained models and code examples. We think transfer learning for NLP will significantly reduce the effort to create systems dealing with text classification.
kind(May 2020, 试验)
kind 是一个用于在 Docker 容器节点中运行本地 Kubernetes 集群的工具。通过与 kubetest 集成，kind 使 Kubernetes 中的端到端测试变得很简单。我们已经借助 kind 创建临时性的 Kubernetes 集群,在持续集成 （Continuous Integration，CI） 管道里测试 Kubernetes 中的资源，例如控制器和自定义资源（Custom Resource Definitions，CRDs）。
Deequ(May 2020, 评估)
在数据工程中使用良好的软件工程实践，也仍然存在一些工具空白。我们的一个团队尝试在数据管道中的不同步骤之间自动执行数据质量检查时，惊讶地发现，在该领域中只有很少的工具。他们选择了 Deequ ，这是一个用来为数据集编写类似单元测试的库。 Deequ 建立在 Apache Spark 之上，虽然它是由AWS 实验室发布的，但也可以被用在 AWS 以外的环境。
Trillian(May 2020, 评估)
Trillian 是一种可加密验证的集中式数据存储。在去信任化和去中心化的环境中，可以使用基于区块链的分布式账本。然而，在企业应用环境中，当不需要使用会耗费大量CPU资源的共识协议时，建议尝试一下 Trillian。
Jaeger(May 2020, 试验)
Jaeger 是一个开源的分布式追踪系统。类似于 Zipkin，它的灵感来自于谷歌的 Dapper 论文，并且遵循 OpenTelemetry 规范。我们在 Kubernetes 上成功的将 Istio 和 Envoy 与 Jaeger 集成，并且很喜欢 Jaeger 的 UI。Jaeger 暴露了 Prometheus 格式的追踪指标，以便其他工具使用它。然而，新一代的工具，如Honeycomb，将追踪和度量集成到单个可观测性流中以支持更简单的聚合分析。Jaeger 在2017年加入了CNCF，并且最近被提升到 CNCF 的最高成熟度级别，这表明它已被广泛部署到生产系统中。
Jaeger(Nov 2018, 评估)
Jaeger is an open source distributed tracing system. Similar to Zipkin, it's been inspired by the Google Dapper paper and complies with OpenTracing. Jaeger is a younger open source project than Zipkin, but it's gained popularity quickly due to a larger number of supported languages for the client libraries and easy installation on Kubernetes. We've used Jaeger successfully with Istio, integrating application traces with Envoy on Kubernetes, and like its UI. With Jaeger joining CNCF, we anticipate a larger community engagement effort and deeper integration with other CNCF projects.
Istio(May 2020, 采纳)
如果正在构建和运行规模化的微服务架构，且已采用 Kubernetes，那么使用服务网格来管理所有架构切面，应当是一个默认选择。在众多服务网格实现中，Istio 是最主流的。它的功能十分丰富，包含服务发现、流量管理、服务到服务以及源到服务的安全性、可观察性（包括遥测和分布式追踪）、滚动发布及韧性机制等。其最新版本易于安装，并提供了控制面板架构，用户体验得到了改善。尽管我们承认维护自己的 Istio 和 Kubernetes 实例，不仅需要足够的知识，还需要一定的内部资源，可能并不适合能力不足的团队，但在我们的诸多项目中，Istio 在保证运维质量的同时，的确降低了大规模微服务的实现门槛。
Istio(Apr 2019, 试验)
Istio is becoming the de facto infrastructure to operationalize a microservices ecosystem. Its out-of-the-box implementation of cross-cutting concerns — such as service discovery, service-to-service and origin-to-service security, observability (including telemetry and distributed tracing), rolling releases and resiliency — has been bootstrapping our microservices implementations very quickly. It's the main implementation of the service mesh technique we've been using. We've been enjoying its monthly releases and its continuous improvements with seamless upgrades. We use Istio to bootstrap our projects, starting with observability (tracing and telemetry) and service-to-service security. We're closely watching its improvements to service-to-service authentication everywhere in and outside of the mesh. We'd also like to see Istio establish best practices for configuration files to strike a balance between giving autonomy to service developers and control to the service mesh operators.
Istio(Nov 2018, 评估)
When building and operating a microservices ecosystem, one of the early questions to answer is how to implement cross-cutting concerns such as service discovery, service-to-service and origin-to-service security, observability (including telemetry and distributed tracing), rolling releases and resiliency. Over the last couple of years, our default answer to this question has been using a service mesh technique. A service mesh offers the implementation of these cross-cutting capabilities as an infrastructure layer that is configured as code. The policy configurations can be consistently applied to the whole ecosystem of microservices; enforced on both in and out of mesh traffic (via the mesh proxy as a gateway) as well as on the traffic at each service (via the same mesh proxy as a sidecar container). While we're keeping a close eye on the progress of different open source service mesh projects such as Linkerd, we've successfully used Istio in production with a surprisingly easy-to-configure operating model.
Vue.js(May 2020, 采纳)
Vue.js 在我们的社区中已经成为一个值得信赖且备受喜爱的成功的前端框架。虽然还有其他被广泛采用的同类型产品，比如 React.js，但简明的API设计、职责清晰的指令及模块（一个模块对应一个文件的设定）和更简单的状态管理，都让Vue.js成为有力的竞争者。
Vue.js(Mar 2017, 试验)
In the ever-changing world of front-end JavaScript frameworks, one of the emerging favorites appears to be Vue.js. Vue.js is a lightweight alternative to AngularJS. It is designed to be a very flexible—and a less opinionated—library that offers a set of tools for building interactive web interfaces around concepts such as modularity, components and reactive data flow. It has a low learning curve, which makes it interesting for less experienced developers and beginners. Note, though, that Vue.js is not a full-blown framework; it is focused on the view layer only and therefore is easy to integrate with other libraries or existing projects.
Vue.js(Nov 2016, 评估)
In the ever-changing world of front-end JavaScript frameworks, Vue.js has gained a lot of ground as a lightweight alternative to AngularJS. It is designed to be a very flexible—and a less opinionated—library that offers a set of tools for building interactive web interfaces around concepts like modularity, components and reactive data flow. It has a low learning barrier, which makes it interesting for junior developers and beginners. Vue.js itself is not a full-blown framework; it is focused on the view layer only and therefore is easy to integrate with other libraries or existing projects.
Koin(May 2020, 试验)
随着 Kotlin 被越来越多地用于移动和服务端开发，其相关生态系统也在不断发展。Koin 是一个Kotlin框架，用于处理软件开发中的常规问题之一：依赖注入。 尽管有多种 Kotlin 依赖注入框架可供选择，我们的团队更喜欢 Koin 的简单性。Koin 避免使用注解，而是通过构造函数或模仿 Kotlin 的延迟初始化，从而仅在需要时才注入对象。 这与 Android 基于静态编译的 Dagger 注入框架形成鲜明对比。 我们的开发人员喜欢此框架的轻量级本质及其内置的可测试性。
通过容器编排管理有状态系统(May 2020, 评估)
我们建议在 利用容器编排平台（例如Kubernetes）管理有状态系统时要谨慎 。有些数据库不能为容器的编排提供原生支持——它们不期望被调度器终结并重新部署到另一台主机。在这样的数据库上构建高可用服务并非易事。因此我们仍然建议在裸机或虚拟机（VM）上运行它们，而不是将其强行适配到容器平台上。
ScoutSuite(May 2020, 试验)
ScoutSuite 是基于 Scout2（在2018年技术雷达上出现过）的一个增强版工具，提供跨AWS、Azure、GCP和其他云提供商的安全状态评估。它的工作原理是自动聚合环境的配置数据，并应用规则对环境进行审计。我们已经在多个项目中发现它对即时安全评估非常有用。
ScoutSuite(May 2018, 评估)
Scout2 is a security auditing tool for AWS environments. Instead of manually navigating through web pages, you can rely on Scout2 to fetch all the configuration data of an AWS environment for you; it even generates an attack surface report. Scout2 ships with preconfigured rules and can be easily extended to support more services and test cases. Since Scout2 only performs AWS API calls to fetch configuration data and identify security gaps, it is not necessary to complete and submit the AWS Vulnerability / Penetration Testing Request Form.
Visual Studio Live Share(May 2020, 试验)
Visual Studio Live Share 是用于 Visual Studio Code 及 Visual Studio 的扩展套件。如果你的团队正在寻找一种良好的远程协作方式，可以考虑这款出色的工具。Live Share 提供了良好的、低延迟的远程结对体验，并且所需的带宽比粗暴地共享整个桌面要少得多。更重要的是，开发人员可以在结对过程中使用他们各自的配置、扩展和快捷键。Live Share 不仅支持编辑、调试代码的实时协作，还支持语音呼叫，以及共享终端和服务器。
Visual Studio Live Share(Nov 2018, 试验)
Visual Studio Live Share is a suite of extensions for Visual Studio Code and Visual Studio. The real-time collaboration for editing and debugging of code, voice calls, sharing a terminal and exposing local ports have reduced some of the obstacles we'd otherwise encounter when pairing remotely. In particular, we like that Live Share allows developers to collaborate with each other, while continuing to use their preconfigured editor, which includes themes, key maps and extensions.
Snowpack(May 2020, 评估)
Snowpack 是 JavaScript 构建工具领域中的一个有趣的新成员。与其他解决方案相比，Snowpack 的关键的改进是可以使用 React.js，Vue.js 和 Angular 等现代框架来构建应用程序，而无需打包器。由于省去了打包的环节，对代码的任何修改都几乎可以立即显示在浏览器上，因此开发过程中的反馈周期得到了极大的改善。为了达到这个神奇的效果，Snowpack 将 node_modules 中的依赖转换为单个的 JavaScript 文件，并将其放置于一个新的 web_modules 目录中，从这个目录中可以将它们作为 ECMAScript 模块（ESM）导入。对于 IE11 和其他不支持 ESM 的浏览器，它也支持一种变通方法。遗憾的是，目前还没有任何浏览器可以从 JavaScript 中导入 CSS，因此使用 CSS 模块 并不简单。
Cypress(May 2020, 采纳)
Cypress 在我们的团队中备受青睐，作为健康的测试金字塔的一部分，我们的端到端测试一直是由开发人员自行管理。我们之所以决定在本期技术雷达中再次提起它，是因为 Cypress 最近的版本增加了对 Firefox 的支持 ，我们强烈建议在多种浏览器上进行测试。Chrome 和基于 Chromium 的浏览器所处的主导地位，已经产生了一个令人担忧的趋势，即团队似乎只使用 Chrome 进行测试，而这可能会导致一些糟糕的意外。
Cypress(Apr 2019, 采纳)
We keep receiving positive feedback on "post-Selenium" web UI testing tools such as Cypress, TestCafe and Puppeteer. Running end-to-end tests can present challenges, such as the long duration of the running process, the flakiness of some tests and the challenges of fixing failures in CI when running tests in headless mode. Our teams have had very good experiences with Cypress by solving common issues such as lack of performance and long wait time for responses and resources to load. Cypress has become the tool of choice for end-to-end testing within our teams.
Cypress(Nov 2018, 试验)
Running end-to-end tests can present challenges, such as the long duration of the running process, the flakiness of some tests and the challenges of fixing failures in CI when running tests in headless mode. Our teams have had very good experiences with Cypress by solving common issues such as lack of performance and long wait time for responses and resources to load. Cypress is a useful tool that helps developers build end-to-end tests and records all test steps as a video in an MP4 file to make it easier to identify errors.
Cypress(May 2018, 评估)
Fixing end-to-end test failures in CI can be a painful experience, especially in headless mode. Cypress is a useful tool that helps developers build end-to-end tests easily and records all test steps as a video in an MP4 file. Instead of reproducing the issue in headless mode, developers can watch the testing video in order to fix it. Cypress is a powerful platform, not only a testing framework. Currently, we've integrated its CLI with headless CI in our projects.
Cypress(Nov 2017, 评估)
Fixing end-to-end test failures in CI can be a painful experience, especially in headless mode. Cypress is a useful tool that helps developers build end-to-end tests easily and records all test steps as a video in an MP4 file. Instead of reproducing the issue in headless mode, developers can watch the testing video in order to fix it. Cypress is a powerful platform, not only a testing framework. Currently, we've integrated its CLI with headless CI in our projects.
Falco(Nov 2019, 评估)
随着人们普遍使用Kubernetes作为容器编排器，与容器和Kubernetes相关的安全工具也在快速发展。Falco就是一个专注运行时安全的容器原生工具。它利用Sysdig的Linux内核监控和系统调用性能数据，可以深度洞察系统的行为，进而帮助我们发现应用程序、容器、主机或者Kubernetes编排器自身的异常行为。我们喜欢Flaco，因为它不需要植入第三方的代码或者附加其他容器就能工作。
ESLint(Nov 2019, 采纳)
我们在许多项目中都使用ESLint作为标准。作为JavaScript的代码检查工具，它提供了很多规则集、推荐规则和插件，可以扩展为不同的框架或JavaScript风格。我们发现，通过在开发时对代码进行实时分析，Eslint可以极大地帮助团队在开发过程中建立和遵循代码规范。Eslint不仅可以通过实施最佳实践和代码规范，对编码实践进行标准化，还能识别代码中的漏洞。这是因为ESLint与大多数IDE都能很好地集成，并可以在编码过程中提供实时反馈。特别是它的样式规则可以自动修复代码错误，持续有效并且不会产生额外的开发成本。ESlint社区的文档很好地解释了它的编码模式，可以帮助开发人员快速掌握规则。随着ESLint变得越来越通用和强大，它已经被行业所认可。例如TypeScript团队就选择支持ESLint并与其合作，而非TSLint。
GraalVM(Nov 2019, 评估)
GraalVM是一种由Oracle开发的通用虚拟机，用于运行基于JVM的语言，JavaScript，Python，Ruby和R以及C/C++等其他基于LLVM的语言编写的应用程序。简单地说，GraalVM可以用作VM和其他所支持的非JVM的语言的高性能虚拟机。但它也允许我们编写多种语言的应用程序，而且对性能影响很小;它的原生镜像程序（当前仅可作为早期采用者的技术使用）让我们可以提前将Java代码编译成独立的可执行文件，从而加快启动速度并减少内存的使用。GraalVM在Java社区引起了巨大的反响，并且许多Java框架（包括Micronaut，Quarkus和Helidon）已经在利用它的技术了。
Data discoverability(Nov 2019, 试验)
数据科学家和分析师在工作流程中遇到的主要问题之一是找到所需的数据，弄清楚数据含义，并评估其是否值得使用。由于缺少可用数据源的元数据，并且缺少搜索和定位数据所需的适当功能，因此这仍然是一个挑战。我们鼓励提供分析数据集或构建数据平台的团队以数据的可发现性为其生态圈的首要功能；提供轻松定位可用数据，检测其质量，了解其结构和源头，并获得访问权的能力。传统上，此功能是由庞大的数据分类解决方案提供的。近年来，我们已经看到相关开源项目的增长，这些项目正在改善数据提供者和数据消费者的开发体验，从而使他们真正做好一件事：使数据易于发现。这些工具包括Lyft的Amundsen和LinkedIn的WhereHows。我们希望看到的改变是，提供者有意识地分享利于可发现性的元数据，从而帮助发现性工具从应用程序数据库中推断出部分元数据信息。
Pipelines for infrastructure as code(Nov 2019, 采纳)
使用持续交付流水线来编排软件的发布过程已经成为主流观念。CI/CD工具能够被用来测试服务器的配置（如Chef cookbooks，Puppet modules和Ansible playbooks），服务器的镜像构建（如Packer），环境的生成（如Terraform，CloudFormation）和环境间的集成。将流水线用于基础设施即代码，可以让你在变更应用于运行环境（包括开发和测试环境）之前就发现错误。它们还提供了CD/CD代理（Agent）而非独立工作站的方式，来确保基础设施工具运行的一致性。我们团队在项目中采用这种技术取得了良好的效果。
Pipelines for infrastructure as code(May 2018, 试验)
The use of continuous delivery pipelines to orchestrate the release process for software has become a mainstream concept. However, automatically testing changes to infrastructure code isn’t as widely understood. Continuous integration (CI) and continuous delivery (CD) tools can be used to test server configuration (e.g., Chef cookbooks, Puppet modules, Ansible playbooks), server image building (e.g., Packer), environment provisioning (e.g., Terraform, CloudFormation) and integration of environments. The use of pipelines for infrastructure as code enables errors to be found before changes are applied to operational environments — including environments used for development and testing. They also offer a way to ensure that infrastructure tooling is run consistently, from CI/CD agents, as opposed to being run from individual workstations. Some challenges remain, however, such as the longer feedback loops associated with standing up containers and virtual machines. Still, we've found this to be a valuable technique.
Pipelines for infrastructure as code(Nov 2017, 试验)
The use of continuous delivery pipelines to orchestrate the release process for software has become a mainstream concept. However, automatically testing changes to infrastructure code isn’t as widely understood. Continuous integration (CI) and continuous delivery (CD) tools can be used to test server configuration (e.g., Chef cookbooks, Puppet modules, Ansible playbooks), server image building (e.g., Packer), environment provisioning (e.g., Terraform, CloudFormation) and integration of environments. The use of pipelines for infrastructure as code enables errors to be found before changes are applied to operational environments — including environments used for development and testing. They also offer a way to ensure that infrastructure tooling is run consistently, from CI/CD agents, as opposed to being run from individual workstations. Some challenges remain, however, such as the longer feedback loops associated with standing up containers and virtual machines. Still, we've found this to be a valuable technique.
Detekt(Nov 2019, 试验)
Detekt是用于Kotlin的静态代码分析工具。Dekekt可以基于高度可配置的规则集提供代码坏味道以及复杂度的检查报告。可以通过命令行运行，也可以通过Gradle、SonarQube或IntelliJ以插件方式运行。我们的团队发现了使用Detekt来维护高质量代码的巨大价值。将分析及生成报告集成到构建流水线上后，显而易见，重要的是定期检查报告，并给团队留出时间解决所发现的问题。
Detekt(Apr 2019, 评估)
Detekt is a static code analysis tool for Kotlin. It finds code smells and code complexity. You can run it from the command line or use its plugins for integration with popular developer tools such as Gradle (to perform code analysis via builds) or SonarQube (to perform code coverage in addition to static code analysis), and IntelliJ. Detekt is a great addition to build pipelines of Kotlin applications.
10x engineers(Nov 2019, 暂缓)
在过去的几个月中，10倍工程师一词受到了密切的关注。一个广泛传播的推文讨论在实质上建议公司应原谅反社会和破坏性的行为，以留住被认为个人产出巨大的工程师。幸运的是，许多人在社交媒体上都嘲笑了这个概念，但是“明星开发者”的刻板印象仍然普遍存在。根据我们的经验，伟大的工程师不是因为个人产出而是因为能在优秀的团队中合作而诞生。打造一支混合不同经验和背景，但成员才华横溢的团队，并为团队合作、学习和持续改进提供良好的助力，这会是更行之有效的方式。这些10倍团队行动起来更快，弹性也更强——而无需屈从错误的行为。
Azure Pipelines(Nov 2019, 评估)
Azure Pipelines是Azure DevOps套件中的一款产品，提供了基于云的解决方案，能为Azure DevOps Git或其他Git解决方案（如Github或Bitbucket）中的项目，实现流水线即代码的功能。该解决方案的亮点在于，能将脚本运行在Linux、MacOS和Windows代理（agent）上，而无须自行管理虚拟机。这对于团队（尤其是在Windowks环境下使用.NET框架的团队）来说，意味着前进了一大步。我们也正在评估此服务在iOS方面的持续交付能力。
GCP Pub/Sub(Nov 2019, 试验)
GCP Pub/Sub是谷歌云的事件流平台。对于谷歌云平台上我们所使用的许多架构而言，由于具备大规模事件提取、无服务器工作负载通信以及具备能进行流数据处理的工作流等特性，这一基础设施广受欢迎。该平台另一个独特功能，是支持拉和推两种事件订阅方式，即在订阅期间能接收所有可用的已发布消息，并能将消息推送到特定端点。我们很喜欢该平台的可靠性和伸缩性，其工作表现名实相符。
ROS(Nov 2019, 试验)
ROS（Robot Operating System，机器人操作系统）这套程序库和工具集，能帮助软件开发人员创建机器人应用程序。它也是一个开发框架，提供硬件抽象、设备驱动、程序库、可视化程序、消息传递、包管理等功能。开放自动驾驶平台Apollo Auto正是基于ROS的。在另一个ADAS（高级驾驶辅助系统）模拟项目中，我们还使用了ROS的消息传递系统（使用bag文件格式）。随着ADAS的发展，ROS这项不算新的技术，又重新引发开发人员的关注。
Facets(Nov 2019, 评估)
不论是直接使用还是作为机器学习模型的训练输入，越来越多的重要决策源自于大数据集。因此了解数据中的差距、缺陷和潜在偏见十分重要。Google的Facets项目在此领域提供了两个有力工具：Facets Overview和Facets Dive。Facets Overview对数据集中的特征分布进行可视化，可以展现训练和验证集的偏斜，并且可以用于比较多个数据集；Facets Dive用于在大数据集中挖掘和可视化单个数据点，并使用不同的可视维度来探究属性之间的关系。它们都是进行道德偏差测试的有力工具。
Yocto Project(Nov 2019, 试验)
我们可以看到，越来越多强大的IOT设备选择运行Linux而不是运行一个定制的嵌入式系统。然而为了节省资源并减少攻击面，仍然有必要创建一个自定义的Linux版本，其中只包含运行设备程序的相关工具和依赖。在这种情况下可以考虑使用Yocto。它可以针对具体的需求裁剪并创建自定义的Linux发行版。Yocto的学习曲线陡峭，并且由于它的灵活性很高，很容易出错。但是经过多年发展，Yocto已经建立起了一个活跃的社区，可以起到一些帮助。与同类工具相比，它更容易被集成至持续交付的工作流。而且与Android Things和Ubuntu core不同，Yocto并没有绑定在一个指定的生态系统上。
Container security scanning(Nov 2019, 采纳)
持续采用容器的方式进行部署，尤其是Docker，让容器安全扫描变成了必不可少的技术，我们已将该技术移至“采纳”中以体现这一点。具体来说，容器为安全问题带来了一条新的途径，在部署过程中使用工具扫描和检查容器尤为重要。我们更愿意将自动化扫描工具的运行作为部署流水线的一部分。
Container security scanning(Apr 2019, 试验)
The container revolution around Docker has massively reduced the friction in moving applications between environments, fueling increased adoption of continuous delivery and continuous deployments. The latter, especially, has blown a rather large hole in the traditional controls over what can go to production. The technique of container security scanning is a necessary response to this threat vector. Tools in the build pipeline automatically check containers flowing through the pipeline against known vulnerabilities. Since our first mention of this technique, the tool landscape has matured and the technique has proven useful on development efforts with our clients.
Container security scanning(Mar 2017, 评估)
The container revolution instigated by Docker has massively reduced the friction in moving applications between environments but at the same time has blown a rather large hole in the traditional controls over what can go to production. The technique of container security scanning is a necessary response to this threat vector. Docker now provides its own security scanning tools, as does CoreOS, and we've also had success with the CIS Security Benchmarks. Whichever approach you take, we believe the topic of automated container security validation is of high value and a necessary part of PaaS thinking.
Container security scanning(Nov 2016, 评估)
The container revolution instigated by Docker has massively reduced the friction in moving applications between environments but at the same time has blown a rather large hole in the traditional controls over what can go to production. The technique of container security scanning is a necessary response to this threat vector. Docker now provides its own security scanning tools, as does CoreOS, and we’ve also had success with the CIS Security Benchmarks. Whichever approach you take, we believe the topic of automated container security validation is of high value and a necessary part of PaaS thinking.
GraphQL(Nov 2019, 评估)
我们已经在项目中看到了许多成功的GraphQL实现，也看到了一些有趣的模式和应用，比如将GraphQL用于服务器端资源聚合。尽管如此，对该框架的滥用、以及使用过程可能遇到的一些问题，我们并非毫无担忧。例如N+1查询可能带来的性能问题，以及添加新模型时需要大量样板代码而导致的复杂性等。这些问题有一些解决方法，例如使用查询缓存等。虽然这项技术不是银弹，我们仍然认为它值得作为系统架构的一部分进行评估。
GraphQL(Nov 2016, 评估)
When we look at REST implementations in the wild, we frequently see REST misused to naively retrieve object graphs through chatty interactions between client and server. Facebook's GraphQL is an interesting alternative to REST that might be a better approach for this very common use case. As a protocol for remotely retrieving object graphs, GraphQL has received enormous attention recently. One of GraphQL's most interesting features is its consumer-oriented nature: The structure of a response is driven entirely by the client, not the server. This decouples the consumer and forces the server to obey Postel's law. Client implementations are now available in many programming languages, but we have seen a flurry of interest of Facebook's Relay, a JavaScript framework that was designed to support the React.js stateless component model.
AWSume(Nov 2019, 评估)
AWSume是一个方便的脚本，用于在命令行中管理AWS会话令牌及担任角色凭证。当需要同时使用多个AWS账号时，AWSume就很有用武之地。这个脚本可以从CLI缓存中读取配置，省去了在每条命令中分别指定配置的麻烦。AWSume还可以将配置输出至环境变量，这样命令与AWS SDK都能够获取到正确的凭证。
Automated machine learning (AutoML)(Nov 2019, 试验)
机器学习的强大能力和远大前途使得对专业人才的需求远远超出了专门从事该领域的数据科学家的数目。针对这种技能上的差距，我们看到了自动化机器学习（AutoML）工具的出现，这类工具旨在帮助非专业人士更容易地自动化完成从模型选择到模型训练的端到端过程。比如Google的AutoML，DataRobot和H2O AutoML Interface。尽管我们已经从这些工具中看到了可喜的成果，但还是要提醒企业不要将其视为机器学习旅程的全部。如H2O网站所述，“在数据科学领域，仍需要相当深厚的知识和经验才能产出高性能的机器学习模型”。对自动化技术的盲目信任，还会增加引入道德偏见或做出不利于少数群体的决策风险。虽然企业可以使用这些工具作为起点，生成基本有用的经过训练的模型，但我们还是鼓励他们寻找经验丰富的数据科学家来验证和完善最终的模型。
What-If Tool(Nov 2019, 评估)
机器学习世界的研究重点稍微从探索“模型能够理解什么”，转向了研究“模型是如何理解的”。由于人们担心引入偏差，或者过度泛化模型的适用性，因此开发出了What-If Tool（WIT）这样的工具。这个工具可帮助数据科学家深入研究模型的行为，并将各种功能和数据集对输出的影响进行可视化。WIT由Google引入，简化了比较模型、切片数据集、可视化构面和编辑单个数据点等任务，并可以在Tensorboard或Jupyter notebooks中使用。尽管WIT可以帮助执行分析，但研究者仍然需要对模型背后的数学和理论有深刻的理解。WIT只是数据科学家用来深入了解模型行为的工具，对于使用不当或缺乏训练不佳的算法，初级用户不应奢望有任何工具可以消除或减轻其风险或造成的损害。
asdf-vm(Nov 2019, 评估)
asdf-vm是一个按项目管理多语言运行时版本的命令行工具。它与Ruby的rvm和Node的nvm等其他命令行版本管理工具类似，但更可以通过可扩展的插件体系架构支持多语言。当前插件列表包括多种语言，以及Bazel或tflint等可能需要针对每个项目管理其运行时版本的工具。
Binary attestation(Nov 2019, 试验)
随着容器的广泛使用，由自治团队部署大型服务并以越来越快的速度持续交付，在许多组织已变成一种通用实践，这也导致对自动部署时软件安全控制的需求增多。二进制鉴证就是一项实现部署时安全控制的技术，用密码学技术验证部署用的二进制镜像。使用这项技术，一个签证人，一个自动构建流程，或者一个安全小组可以签发已经通过安全检查、测试，并得到授权的待部署镜像。支持在部署前创建证明和验证镜像签名的，除了Grafeas的GCP Binary Authorization服务，还有in-toto和Docker Notary这样的工具。
Testing using real device(Nov 2019, 采纳)
当成功采用持续交付后，团队尽可能让各种测试环境更接近于生产环境。这样他们就可以避免那些只会在产品环境中暴露的缺陷。这对于嵌入式和物联网软件也有效。如果我们不在真实的环境中测试，可预见的是，我们将在产品环境中首次发现某些缺陷。使用真实设备进行测试，在持续交付流水线中确保提供正确的设备，可以帮助避免这个问题。
Skaffold(Nov 2019, 评估)
Google为我们带来了Skaffold——用于自动化本地开发工作流程的开源工具，同时也支持部署至Kubernetes。Skaffold会检测源代码的变更，触发工作流以构建，标记和部署到K8s集群中，并捕获应用程序日志返回命令行。工作流程支持将不同的构建和部署工具以插件化形式引入，并且还提供默认配置，使入门变得更容易。
Zhong Tai(Nov 2019, 试验)
近年来，中台一直是中国IT界的流行语，但它尚未在西方国家流行起来。中台的核心是提供封装业务模型的方法。它旨在帮助新型的小型企业提供一流的服务，而无需传统企业基础架构的成本，并使现有组织能够以惊人的速度将创新服务推向市场。中台战略最初是由阿里巴巴提出的，并很快被许多中国的互联网公司所采用，因为它们的商业模式是数字原生的，可以复制到新的市场和领域。如今，越来越多的中国公司将中台作为数字化转型的杠杆。
Aplas(Nov 2019, 评估)
我们的软件大厦变得越来越复杂，也越来越难以理解。Aplas是一个新的软件映射工具，可以用地图的形式可视化软件布局。Aplas首先会获取当前系统的元数据，然后在地图上投影各种视图。可以手动或通过API自动获取元数据。我们很高兴看到该产品不断发展，也看到自动收集元数据所带来的种种可能性。例如，通过公开运行成本等架构适应度函数，应该可以可视化呈现云基础设施的成本。我们经常面临的另一个问题是想要了解哪些系统用何种技术与其他系统进行通讯，这一点也可以使用Aplas帮助我们进行可视化。
Kuma(Nov 2019, 评估)
Kuma是可用于Kubernetes、VMs和裸机环境的，与平台无关的服务网格。它基于Envoy实现了一个控制平面来监测任何4层/7层的网络流量，以此保护、观察、路由和增强服务之间的连接性。大多数服务网格的实现都是针对Kubernetes生态系统的，这本身没问题，但是会阻碍现有的非Kubernetes应用程序使用服务网格。现在，你可以通过Kuma来使网络基础设施现代化，而不是花费精力完成大量的平台迁移工作。
Twistlock(Nov 2019, 试验)
Twistlock是提供构建时和运行时安全漏洞检测和预防功能的商业产品，可以保护VM、容器调度程序和容器，以及应用程序依赖的各类注册中心和存储库。Twistlock帮助我们的团队加快了受监管应用程序的开发，这些应用程序的基础设施和架构需要遵循一定的规范，例如支付卡行业（PCI）标准和《健康保险可移植性和责任法案》（HIPAA）。我们的团队很享受Twistlock带来的开发人员体验：能够以代码形式管理资源，可以轻松地与其他常见可观察性平台进行集成，以及根据行业共识最佳实践来衡量基础架构的，直接可用的基准测试。我们在例行的运行时扫描过程中，尤其是在有合规性要求的情况下，使用Twistlock对云原生应用程序进行扫描。
Sidecars for endpoint security(Nov 2019, 试验)
我们今天构建的许多技术解决方案，都运行在日益复杂的多云或混合云环境中，其中包含多个分布式组件和服务。在这种情形下，我们在实施初期应用了两个安全原则: 零信任网络，永远不要信任网络并始终进行验证；以及最小权限原则，即授予执行特定作业所需的最小权限。端点安全性的边车(Sidecars for endpoint security)是实现这些原则的一种常用技术，用于在每个组件的端点上实施安全控制，例如服务、数据存储和Kubernetes控制接口的API。我们使用进程外的边车来实现——一个共享相同执行上下文、主机和标识的运行中的进程或容器。开放策略代理(Open Policy Agent)和Envoy是实现此技术的工具。用于端点安全的Sidecars将可信的足迹最小化到本地端点，而不是整个网络。最后，我们希望由负责端点的团队负责sidecar安全策略的配置，而不是单独的中心化团队。
Sidecars for endpoint security(May 2018, 评估)
Microservices architecture, with a large number of services exposing their assets and capabilities through APIs and an increased attack surface, demand a zero trust security architecture — ‘never trust, always verify’. However, enforcing security controls for communication between services is often neglected, due to increased service code complexity and lack of libraries and language support in a polyglot environment. To get around this complexity, some teams delegate security to an out-of-process sidecar — a process or a container that is deployed and scheduled with each service sharing the same execution context, host and identity. Sidecars implement security capabilities, such as transparent encryption of the communication and TLS (Transport Layer Security) termination, as well as authentication and authorization of the calling service or the end user. We recommend you look into using Istio, linkerd or Envoy before implementing your own sidecars for endpoint security.
Sidecars for endpoint security(Nov 2017, 评估)
Microservices architecture, with a large number of services exposing their assets and capabilities through APIs and an increased attack surface, demand a zero trust security architecture — ‘never trust, always verify’. However, enforcing security controls for communication between services is often neglected, due to increased service code complexity and lack of libraries and language support in a polyglot environment. To get around this complexity, some teams delegate security to an out-of-process sidecar — a process or a container that is deployed and scheduled with each service sharing the same execution context, host and identity. Sidecars implement security capabilities, such as transparent encryption of the communication and TLS (Transport Layer Security) termination, as well as authentication and authorization of the calling service or the end user. We recommend you look into using Istio, linkerd or Envoy before implementing your own sidecars for endpoint security.
Fairseq(Nov 2019, 评估)
Fairseq是Facebook AI Research的序列到序列建模工具套件，允许研究人员和开发人员训练定制模型以进行翻译、摘要、语言建模和其他NLP任务。对于PyTorch的用户来说，这是一个不错的选择。它提供了各种序列到序列模型的参考实现，支持跨多个GPU和机器的分布式训练，可扩展性强，并具有许多预训练的模型，其中包括RoBERTa，它是对BERT的优化。
Flair(Nov 2019, 评估)
Flair是一个简单的基于Python的NLP框架。它让用户可以执行标准的NLP任务，例如命名实体识别（NER），词性标记（PoS），词义消歧和分类，并且在一系列NLP任务中都表现良好。Flair为各种文字和文档嵌入提供了一个简单且统一的界面，包括BERT、Elmo及其自己的Flair嵌入。同时，它还提供多语言支持。这个框架本身是建立在PyTorch之上的。我们在某些项目中正在使用它，并且喜欢它的易用性和强大的抽象。
Flutter(Nov 2019, 试验)
我们的一些团队使用了Flutter并且很喜爱它。作为跨平台框架，它可以帮助我们用Dart语言编写原生移动应用。借助Dart，Flutter可以编译成平台原生代码并直接和目标平台通讯，从而避免了桥接和上下文切换。Flutter的热重载（hot-reload）特性亦让人惊叹，它能在编写代码时提供超快的视觉反馈，我们推荐你在项目中尝试使用Flutter。
Flutter(Nov 2018, 评估)
Flutter is a cross-platform framework that enables you to write native mobile apps in Dart. It benefits from Dart and can be compiled into native code and communicates with the target platform without bridge and context switching—something that can cause performance bottlenecks in frameworks such as React Native or Weex. Flutter's hot-reload feature is impressive and provides superfast visual feedback when editing code. Currently, Flutter is still in beta, but we'll continue keeping an eye on it to see how its ecosystem matures.
Flutter(May 2018, 评估)
Flutter is a cross-platform framework that enables you to write native mobile apps in Dart. It benefits from Dart and can be compiled into native code and communicates with the target platform without bridge and context switching — something that can cause performance bottlenecks in frameworks such as React Native or Weex. Flutter’s hot-reload feature is impressive and provides superfast visual feedback when editing code. Currently Flutter is still in beta, but we’ll continue keeping an eye on it to see how its ecosystem matures.
MemGuard(Nov 2019, 评估)
如果应用程序将敏感信息（例如加密密钥）以纯文本的形式存储在内存中，很可能会被人利用成为攻击媒介而导致信息泄露。大多数基于云的解决方案通常使用HSM（hardware security modules，硬件安全模块）以避免受到此类攻击。但如果是自托管服务且无法使用HSM时，仍然希望避免这类攻击，MemGuard就非常有用了。MemGuard可以作为软件安全区，在内存中存储敏感信息。尽管MemGuard不能替代HSM，但它也实现了许多安全策略，如防止冷启动攻击，避免垃圾收集的干扰，并使用防护分页技术加固以减少泄露敏感数据的可能性。
Commitizen(Nov 2019, 采纳)
Commitizen是一款提升GIT提交过程效率的小工具。它会提示你提供任何必要字段，还会恰当地格式化提交信息。Commitizen内置了对多种提交规范的支持，同时还允许你定制自己的提交规则。这个简单的工具能够节约时间，而不必等待提交钩子运行检查再驳回提交。
Oculus Quest(Nov 2019, 评估)
我们在雷达中对AR/VR（增强现实/虚拟现实）技术关注了很长时间，但其仅仅在特定的平台及外接方案上展现了吸引力。Oculus Quest打破了这个局面，成为首批面向大众消费市场的无需智能手机绑定或支持的VR一体机之一。该设备为潜在的VR应用的大量增长打开了大门，其需求将反过来推动市场朝着更积极创新的方向发展。我们很欣赏该设备为VR普及带来的推动力，迫不及待地想看到即将到来的变化。
Apache Flink(Nov 2019, 试验)
自从Apache Flink在2016年首次进入技术雷达“评估”环以来，越来越多的人开始采用它了。Flink被视为领先的流处理引擎，在批处理与机器学习领域也逐渐成熟。与其他流处理引擎相比，Flink的独特之处在于，它使用了一致的应用状态检查点。当发生错误时，应用可以重启，并从最近的检查点载入状态继续处理，就好像错误从未发生一样，这让我们不必为了容错而不得不构建和操作复杂的外部系统。我们看到越来越多的公司，在使用Flink构建他们的数据处理平台。
Apache Flink(Nov 2016, 评估)
Interest continues to build for Apache Flink, a new-generation platform for scalable distributed batch and stream processing. At the core of Apache Flink is a streaming data-flow engine, with support for tabular (SQL-like), graph-processing and machine learning operations. Apache Flink stands out with feature rich capabilities for stream processing: event time, rich streaming window operations, fault tolerance and exactly-once semantics. The project shows significant ongoing activity, with the latest release (1.1) introducing new datasource/sink integrations as well as improved streaming features.
Apache Flink(Apr 2016, 评估)
Apache Flink is a new-generation platform for scalable distributed batch and stream processing. At its core is a streaming data-flow engine. It also supports tabular (SQL-like), graph-processing and machine-learning operations. Apache Flink stands out with feature-rich capabilities for stream processing: event time, rich streaming window operations, fault tolerance and exactly-once semantics. While it hasn't reached version 1.0, it has raised significant community interest due to innovations in stream processing, memory handling, state management and simplicity of configuration.
in-toto(Nov 2019, 评估)
我们注意到，越来越多的地方，尤其是在受监管的行业，为了确保软件的供应链安全会使用二进制验证。当前主流的做法，或是构建一个定制的二进制验证系统，亦或是依赖于某个云厂商提供的服务。我们高兴地看到出现了开源的in-toto项目。In-toto是一个框架，能够以密码学的方式验证软件制品生产路径上的每个组件和步骤。该项目可以与众多广泛使用的构建工具、容器审计工具和部署工具进行集成。由于软件供应链工具是一个组织的安全设施中至关重要的部分，因此我们非常喜欢in-toto。作为一个开源项目，它的行为是透明的，并且其自身的完整性和供应链也可以由社区进行验证。至于它是否会赢得足够多的用户和贡献者以在这个领域竞争，我们拭目以待。
Jib(Nov 2019, 试验)
构建容器化应用程序可能需要在开发环境和构建代理上进行复杂的配置。如果你要构建Java应用程序并使用Docker，则可以考虑使用Google的Jib。Jib是同时支持Maven和Gradle的开源插件。Jib插件使用构建配置中的信息，将应用程序直接构建为Docker镜像，而不需要Dockerfile或Docker守护程序。Jib也针对镜像分层进行了优化，可以提升后续构建的速度。
ONNX(Nov 2019, 评估)
目前，围绕神经网络的相关工具和框架的生态系统正在迅速地发展。但是，这些框架和工具之间的互通性也成为一个挑战。在机器学习领域，通常需要在一种工具中快速进行原型设计和训练，然后将其部署到其他工具中进行推理。因为这些工具的内部格式并不兼容，为了使他们兼容，我们需要实现并维护很多麻烦的转换器。开放神经网络交换格式ONNX的出现，就是为解决这一问题。在ONNX中，表示神经网络的图形由标准规格的操作符和一系列表示训练权重和神经网络模型的格式所组成，这些图形可以在不同的工具间传递。这种一致的格式带来了很多的可能性，其中之一就是Model Zoo，它是一系列基于ONNX格式的预训练模型的集合。
Paged.js(Nov 2019, 评估)
在使用HTML和相关技术来生产书籍和其他印刷品时，必须考虑分页问题。这包括页面计数器、页眉和页脚中的重复元素和分页符。Paged.js是一个开源代码库，它为Paged Media和Generated Content for Paged Media CSS模块实现了一系列补充代码。它仍处于试验阶段，但填补了HTML的“编写一次，到处发布”的重要空白。
Styled components(Nov 2019, 试验)
使用带标签的模板文字styled components，可以将为React组件设置样式所需的CSS直接放入创建该组件的JavaScript代码中。这大大减轻了管理CSS的痛苦，并且不需要为避免CSS中的命名冲突而想尽办法，比如命名约定等。开发人员在查看组件定义时可以直接看到样式，而不必记住几MB的CSS样式。当然，将CSS放入JavaScript代码中，可能会使跨不同组件样式的一致性变得更加困难，因此我们建议使用这种方法时一定要理解其优缺点。
Pumba(Nov 2019, 评估)
Pumba是Docker的混沌测试和网络仿真工具。Pumba可以终止、停止、删除或暂停docker容器，还可以仿真网络并模拟不同的网络故障，例如延迟、数据包丢失和带宽速率限制。Pumba使用tc工具进行网络仿真，因此在容器中需要安装tc，或者需要在带有tc的边车容器中运行Pumba。在对运行在多个容器中的分布式系统做混沌测试时，无论是从本地还是在构建流水线中都可以使用Pumba。
Front-end integration via artifact(Nov 2019, 暂缓)
当团队接受微前端这个概念时，他们有很多种方式将各个微前端集成到一个应用程序中，同样也会有一些反模式。其中最常见的一种方式就是通过制品进行前端集成。每一个微前端会被构建成一个制品，这个制品通常是一个被推送到注册表中的NPM软件包。接下来，在不同的构建流水线中，将各个包组合成一个最终的软件包，这个软件包包含了所有的微前端。从纯粹的技术角度来看，这种集成方式可以使应用程序正常运行。但是，通过制品的方式进行集成，意味着每一次修改都需要重建整个包。这不仅耗时，还有很大可能会带来负面的开发体验。更糟糕的是，这种集成方式会引入构建过程中微前端的直接依赖关系，从而导致相当大的协调开销。
JAMstack(Nov 2019, 评估)
许多年前从手机原生开发兴起的后端即服务开发模式，现在在Web开发上变得流行起来。我们将这种集合了静态站点生成和利用第三方API进行客户端渲染的框架被称为JAMstack（JAM代表JavaScript，API和Markup），例如Gatsby.js。这种方式之所以能给用户提供丰富的体验，主要依靠的是API和SaaS。因为HTML不管是在网页浏览器中还是在构建时渲染，它的部署模型和全静态生成的网站是一样的，共同的好处是服务端的攻击面很小，而使用很少的资源可以获得极好的性能。事实上，像这种在部署上对内容发布网络（CDN）非常友好的技术，我们开玩笑想把它称为CDN优先应用程序。
MicroK8s(Nov 2019, 评估)
过去我们讨论过Kubernetes，它仍是在生产集群中部署和管理容器的默认选择。但为开发人员提供类似的本地体验变得越来越困难。在一些其他选项中，我们发现MicroK8s非常有用。安装MicroK8s snap，需要选择一个发布渠道（稳定版、候选版、Beta版或Edge版），使用一些命令来让Kubernetes运行起来即可。你也可以持续关注主流版本的发布，并选择是否自动化升级。
Mongoose OS(Nov 2019, 试验)
Mongoose OS依然是我们首选的开源微控制器操作系统和嵌入式固件开发框架。值得关注的是，Mongoose OS为嵌入式开发人员解决了一个明显的问题，即消除了用于原型设计的Arduino固件与裸机微控制器原生SDK之间所存在的冲突。我们的团队已成功将Cesanta的新型端到端设备管理平台mDash，用于一些新的小型硬件项目中。如今，主要的物联网（IoT）云平台供应商，都支持Mongoose OS开发框架，以进行设备管理、连接控制和空中（OTA）固件升级。自从我们上次将Mongoose OS纳入技术雷达以来，意法半导体、德州仪器和乐鑫科技等公司所生产的板卡和微控制器，都开始对其提供了支持。其对OTA固件更新的无缝支持，以及单设备级别的内置安全性，都将继续受到我们的青睐。
Mongoose OS(May 2018, 评估)
With an accelerated growth of connected embedded devices and wider accessibility of hardware, Mongoose OS fills a noticeable gap for embedded software developers: the gap between Arduino firmware suitable for prototyping and bare-metal microcontrollers' native SDKs. Mongoose OS is a microcontroller operating system that comes with a set of libraries and a development framework to support typical Internet of Things (IoT) applications with connectivity to generic MQTT servers and popular IoT cloud platforms such as Google Cloud IoT Core and AWS IoT by default. In fact, Google recommends a Mongoose starter kit for its Cloud IoT Core. We’ve had a seamless experience using Mongoose OS in our embedded projects building connected workspaces. We especially liked its built-in security at the individual device level and OTA firmware updates, among other features. At the time of writing, only a limited number of microcontrollers and boards are supported with more popular ARM-based microcontrollers still under development.
Loki(Nov 2019, 试验)
Loki是一个配合Storybook使用的可视化回归工具，我们在UI开发环境中提到过Storybook。只需几行配置，就可以使用Loki测试所有UI组件。推荐在Docker容器中使用Chrome，以避免在不同的环境中运行测试时出现的1像素差异问题。我们的经验是测试非常稳定，但是Storybook的更新往往会由于细微的差异而导致测试失败。Loki似乎也无法测试使用position：fixed的组件，但可以使用fixed包装组件来规避这个问题。
Explainability as a first-class model selection criterion(Nov 2019, 试验)
深度神经网络在很多问题上都表现出了惊人的记忆力和准确性。只要有足够的训练数据和适当拓扑选择，这些模型就能满足并超越某些特定问题域中的人类能力。然而，它们天生是不透明的。虽然模型的某些部分可以通过迁移学习进行重用，但是我们很少能够赋予这些元素人类可理解的意义。相比之下，可解释的模型是一个允许我们说明决策是如何做出的模型。例如，一个决策树产生描述分类过程的推理链。可解释性在某些受监管的行业，或当我们关注决策的道德影响时变得至关重要。由于这些模型被更广泛地合并到关键的业务系统中，因此将可解释性作为模型选择的头等标准非常重要。尽管功能强大，神经网络在可解释性要求严格的情况下，也可能不是一个合适的选项。
Data integrity at the origin(Nov 2019, 采纳)
今天，许多组织对如何解锁用于分析的数据的解决方案是建立迷宫般的数据管道。管道从一个或多个数据源检索，清理，然后转换数据并将其移动到另一个位置以供使用。这种数据管理方法通常会让使用数据的管道承担一项困难的任务，即验证入站数据的完整性，并构建复杂的逻辑来清理数据，以满足所需的质量级别。根本的问题是，数据源没有为其消费者提供高质量数据的动机和责任。出于这个原因，我们强烈主张从源头保证数据完整性，我们的意思是，任何提供可消费数据的源头，必须明确地描述其数据质量的标准，并确保这些标准。这背后的主要原因是，原始系统和团队最熟悉他们的数据，并且最适合在源头修复它。数据网格架构更进一步，将可消费数据与产品相比较，其中的数据质量及其目标是每个共享数据集的整体属性。
Fission(Nov 2019, 评估)
Kubernetes的无服务器生态系统正在增长。我们在之前的雷达中讨论过Knative，现在我们看到Fission获得了关注。Fission让开发人员可以专注于编写短期的函数并将它们映射到HTTP请求，而Kubernetes资源的自动化和其他工作则交给框架幕后处理。Fission还允许组合功能，通过web hooks与第三方提供商集成，并自动管理Kubernetes基础设施。
Tensorflow(Nov 2019, 试验)
TensorFlow的2.0版本保持了其作为业界领先的机器学习框架的突出地位。TensorFlow最初是一个数字处理程序包，后来逐渐扩展为包括支持各种机器学习方法和执行环境（从移动CPU到大型GPU群集）的库。在此过程中，出现了许多框架，以简化网络创建和训练的任务。同时，其他框架（尤其是PyTorch）提供了一种命令式编程模型，该模型使调试和执行变得越来越容易。TensorFlow 2.0现在默认为命令流（立即执行），并采用Keras作为单个高阶API。尽管这些更改提高了TensorFlow的可用性并使其较PyTorch更具竞争力，但这是一次重大的重写，常常破坏向后兼容性——TensorFlow生态系统中的许多工具和服务框架都无法立即适配新版本。目前，请考虑是否要在TensorFlow 2.0中进行设计和试验，或恢复到版本1以在生产环境中服务和运行模型。
Tensorflow(Nov 2016, 评估)
Google's TensorFlow is an open source machine-learning platform that can be used for everything from research through to production and will run on hardware from a mobile CPU all the way to a large GPU compute cluster. It's an important platform because it makes implementing deep-learning algorithms much more accessible and convenient. Despite the hype, though, TensorFlow isn't really anything new algorithmically: All of these techniques have been available in the public domain via academia for some time. It's also important to realize that most businesses are not yet doing even basic predictive analytics and that jumping to deep learning likely won't help make sense of most data sets. For those who do have the right problem and data set, however, TensorFlow is a useful toolkit.
Docker Notary(Nov 2019, 评估)
Docker Notary是对镜像、文件及容器等资产进行签名的开源工具，用于验证资产的来源。对于受控的环境来说这是超级有用的功能，而对于其他环境来说也是很好的实践。容器在创建时，会使用代表发布者身份的私钥及哈希进行签名，并存储至元数据。对于已经发布的容器（或其他资产），就可以用镜像的哈希以及发布者的公钥对其来源进行验证。虽然已经有Docker Trusted Registry这样可公开访问、可信任的注册中心，但也可以运行自己的注册中心。我们的团队在本地运行Notary服务时发现还有些问题，并建议使用其他支持Notary的注册中心。
Rootless containers(Nov 2019, 评估)
理想情况下，容器应该由各自的容器运行时管理和运行，而不应具有root权限。这不是小事，当它实现时，能够减少攻击面并避免所有类型的安全问题，特别是容器外的权限升级。无根容器在社区被讨论了很长时间，它是开放容器运行时规范及其标准实现runc的一部分，而runc是Kubernetes的基础。现在，Docker 19.03将无根容器作为一个实验性特性引入。尽管功能齐全，该特性还不能与其他部分特性兼容，比如cgroups资源控制和AppArmor安全配置文件。
Privacy-preserving record linkage (PPRL) using Bloom filter(Nov 2019, 评估)
在使用共享密钥的场景下，不同数据提供者之间的记录连接是很容易实现的。但是你可能并没有一个共享密钥；即使有，基于隐私的考虑也不建议公开它。使用布隆过滤器（Bloom filter，一种节省空间的概率数据结构）建立保护隐私的记录连接（PPRL）是一种成熟的技术，它允许来自不同数据提供者进行概率记录链接，而不会公开私密的个人身份资料。例如，当连接来自两个数据提供者的数据时，每个提供者使用布隆过滤器，加密其个人身份数据以获得加密链接密钥，然后通过安全通道将它们发送给你。一旦接收到数据，就可以通过计算来自每个提供者的加密链接密钥之间的相似度得分，来链接这些记录。与其他技术相比，我们发现使用布隆过滤器的PPRL对于大型数据集是可伸缩的。
Micronaut(Nov 2019, 试验)
Micronaut是一个JVM框架，可以用来构建Java，Kotlin或者Groovy服务。它没有通过运行时反射来完成依赖注入（DI）和生成代理（传统框架的常见缺点），而是使用了DI/AOP容器在编译时执行依赖注入，因此具有内存占用小、启动时间短的特点。这使得它不仅在标准的服务器端微服务方面，在物联网、Android应用程序和无服务器功能等环境中也很有吸引力。Micronaut使用Netty，并且对响应式编程提供一流的支持。它还包含了服务发现和熔断等特性，这些特性使得它对云计算非常友好。对于JVM领域的全栈框架来说，Micronaut是一个非常有前途的新成员。我们在越来越多的生产项目中看到了它的身影，这促使我们将其移至试用阶段。
Micronaut(Apr 2019, 评估)
Micronaut is a new JVM framework for building microservices using Java, Kotlin or Groovy. It distinguishes itself through a small memory footprint and short startup time. It achieves these improvements by avoiding runtime reflection for DI and proxy generation, a common shortcoming of traditional frameworks, and instead uses a DI/AOP container which performs dependency injection at compile time. This makes it attractive not just for standard server-side microservices but also in the context of, for example, the Internet of Things, Android applications and serverless functions. Micronaut uses Netty and has first-class support for reactive programming. It also includes many features that make it cloud-native friendly such as service discovery and circuit breaking. Micronaut is a very promising entrant to the full stack framework for the JVM space and we're keenly watching it.
MockK(Apr 2019, 采纳)
MockK is our go-to tool for mocks when writing tests for Kotlin applications. We like to use this library because of its first-class support for Kotlin language features such as coroutines or lambda blocks. As a native library, it helps our teams to write clean and concise code on testing Kotlin applications instead of using the inconvenient wrappers of Mockito or PowerMock.
MockK(Nov 2018, 试验)
MockK is a library for mocking written in Kotlin. Its main philosophy is to provide first-class support for Kotlin language features such as Coroutines or lambda blocks. As a native library, it helps our teams to write clean and concise code on testing Kotlin applications instead of using incommodious wrappers of Mockito or PowerMock.
Secrets as a service(Apr 2019, 采纳)
Humans and machines use secrets throughout the value stream of building and operating software. The build pipelines need secrets to interface with secure infrastructures such as container registries, the applications use API keys as secrets to get access to business capabilities, and the service-to-service communications are secured using certificates and keys as secrets. You can set and retrieve these secrets in different ways. We've long cautioned developers about using source code management for storing secrets. We've recommended decoupling secret management from source code and using tools such as git-secrets and Talisman to avoid storing secrets in the source code. We've been using secrets as a service as a default technique for storing and accessing secrets. With this technique you can use tools such as Vault or AWS Key Management Service (KMS) to read/write secrets over an HTTPS endpoint with fine-grained levels of access control. Secrets as a service uses external identity providers such as AWS IAM to identify the actors who request access to secrets. Actors authenticate themselves with the secrets service. For this process to work, it's important to automate bootstrapping the identity of the actors, services and applications. Platforms based on SPIFFE have improved the automation of assigning identities to services.
Secrets as a service(Nov 2018, 试验)
We've long cautioned people about the temptation to check secrets into their source code repositories. Previously, we've recommended decoupling secret management from source code. However, now we're seeing a set of good tools emerge that offer secrets as a service. With this approach, rather than hardwiring secrets or configuring them as part of the environment, applications retrieve them from a separate process. Tools such as Vault by HashiCorp let you manage secrets separately from the application and enforce policies such as frequent rotation externally.
Cage(Apr 2019, 评估)
Cage is an open-source wrapper around Docker Compose that lets you configure and run multiple dependent components as a larger application. It lets you orchestrate the execution of components such as Docker images, service source code from repo, scripts to load datastores and pods, which are containers that run together as a unit. Cage uses the Docker Compose v2 configuration file format. It addresses some of the Docker Compose gaps such as supporting multiple environments, including the dev environment for running a distributed application on the local developer machine and the test environment for running integration tests and production.
Aeron(Apr 2019, 评估)
Aeron is an efficient and reliable peer-to-peer message transport. It provides a replicated persistent log of messages via a number of media drivers, including HTTP, UDP and TCP. It also supports persistent storage of message streams for later replay. For many applications, Aeron may be overkill because it operates at a pretty low level (OSI Layer 4 conceptually), but it's peer-to-peer design and low (and predictable) latency are useful in a number of use cases. Indeed, we've found it to be useful in certain machine learning applications as well as playing a part in event-driven architectures. We think it's worth pointing out that alternative messaging protocols exist that don't require additional services such as Apache Kafka to be run.
Polyglot programming(Apr 2019, 采纳)
We put polyglot programming on Trial in one of our first Radars to suggest that choosing the right language for the job could significantly boost productivity, and there were new language entrants that were worthy of consideration. We want to reraise this suggestion because we're seeing a new push to standardize language stacks by both developers and enterprises. While we acknowledge that placing no restrictions on language uses can create more problems than it solves, promoting a few languages that support different ecosystems or language features is important for both enterprises to accelerate processes and go live more quickly and developers to have the right tools to solve the problem at hand.
Polyglot programming(Aug 2010, 试验)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Polyglot programming(Apr 2010, 试验)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Taurus(Apr 2019, 评估)
Taurus is a handy application and service performance testing tool written in Python. It wraps many performance testing executors, including Gatling and Locust. You can run it from the command line and easily integrate it with continuous delivery pipelines to run performance tests at different stages of the pipeline. Taurus also has great reporting either as console text-based output or integrated with an interactive web UI. Our teams have found that configuring Taurus YAML files is easy because you can use multiple files to describe each test scenario and refer to underlying executer's scenario definitions.
Chaos Engineering(Apr 2019, 试验)
In the last year we've seen Chaos Engineering move from a much talked-about idea to an accepted, mainstream approach to improving and assuring distributed system resilience. As organizations large and small begin to implement Chaos Engineering as an operational process, we're learning how to apply these techniques safely at scale. The approach is definitely not for everyone, and to be effective and safe, it requires organizational support at scale. Industry acceptance and available expertise will definitely increase with the appearance of commercial services such as Gremlin and deployment tools such as Spinnaker implementing some Chaos Engineering tools.
Chaos Engineering(May 2018, 试验)
In previous editions of the Radar, we've talked about using Chaos Monkey from Netflix to test how a running system is able to cope with outages in production by randomly disabling instances and measuring the results. Chaos Engineering is the nascent term for the wider application of this technique. By running experiments on distributed systems in production, we're able to build confidence that those systems work as expected under turbulent conditions. A good place to start understanding this technique is the Principles of Chaos Engineering website.
Chaos Engineering(Nov 2017, 试验)
In previous editions of the Radar, we've talked about using Chaos Monkey from Netflix to test how a running system is able to cope with outages in production by randomly disabling instances and measuring the results. Chaos Engineering is the nascent term for the wider application of this technique. By running experiments on distributed systems in production, we're able to build confidence that those systems work as expected under turbulent conditions. A good place to start understanding this technique is the Principles of Chaos Engineering website.
Resilience4j(Apr 2019, 试验)
Resilience4j is a lightweight fault tolerance library inspired by Netflix Hystrix. We like its lightweight and modular structure where we pull in specific modules for specific capabilities such as circuit-breaking, rate-limiting, retry, and bulkhead. While service meshes are taking on some of the fault tolerance capabilities, fault tolerance libraries continue to remain a key component of our systems for more nuanced domain-specific fault tolerance behavior and for non-containerized services. With Hystrix going into maintenance mode, Resilience4j becomes a default choice in the Java ecosystem. It can work with synchronous APIs as well as reactive ones. It also surfaces metrics to dropwizard metrics, Prometheus and others using additional modules.
OpenAPM(Apr 2019, 评估)
One of the challenges in adopting an open-source alternative to popular commercial packages is sorting through the complicated landscape of projects to understand which components you need, which ones play nicely together and exactly which part of a total solution each component covers. This is particularly difficult in the world of observability, where the standard practice is to purchase one comprehensive but pricey package to do it all. OpenAPM makes the open-source selection process for observability tools easier. It displays the current crop of open-source packages classified by component roles, so you can interactively select compatible components. As long as you keep the tool up to date, it should help you navigate through the confusing array of possible tools.
Terraform provider GoCD(Apr 2019, 评估)
Terraform provider GoCD lets you build pipelines using Terraform, a mature and widely used tool in the infrastructure as code space. With this provider, you can write pipelines in the HashiCorp Configuration Language (HCL) that use all of the functionality Terraform provides, including workspaces, modules and remote state. This approach is an excellent alternative to Gomatic, which we highlighted in the Pipelines as code blip before. The Golang SDK used in this provider has automatic regression tests for the GoCD API which should minimize issues while upgrading.
Taiko(Apr 2019, 评估)
Taiko is a node.js library with a clear and concise API to assist with chrome or chromium browser automation. You can leverage Taiko's smart selectors and write reliable tests as the structure of the web application evolves. There's no need for ID, CSS or XPath selectors or adding explicit waits (for XHR requests) in test scripts. The interactive REPL recorder comes in handy when you want to develop the tests side by side as you explore the functionality. Although you could use Taiko independently, we've had good success using it with Gauge.
Infrastructure configuration scanner(Apr 2019, 试验)
For some time now we've recommended that delivery teams take ownership of their entire stack, including infrastructure. This means increased responsibility in the delivery team itself for configuring the infrastructure in a safe, secure and compliant way. When adopting cloud strategies, most organizations default to a tightly locked-down and centrally managed configuration to reduce risk, but this also creates substantial productivity bottlenecks. An alternative approach is to allow teams to manage their own configuration and use an infrastructure configuration scanner to ensure the configuration is safe and secure. Options include open-source scanners such as prowler for AWS and kube-bench for Kubernetes installations. For more continuous detection, take a look at cloud platforms such as AWS Config Rules among other commercial services.
Infrastructure configuration scanner(Nov 2018, 评估)
For some time now we've recommended increased delivery team ownership of their entire stack, including infrastructure. This means increased responsibility in the delivery team itself for configuring infrastructure in a safe, secure, and compliant way. When adopting cloud strategies, most organizations default to a tightly locked-down and centrally managed configuration to reduce risk, but this also creates substantial productivity bottlenecks. An alternative approach is to allow teams to manage their own configuration, and use an Infrastructure configuration scanner to ensure the configuration is set in a safe and secure way. Watchmen is an interesting tool, built to provide rule-driven assurance of AWS account configurations that are owned and operated independently by delivery teams. Scout2 is another example of configuration scanning to support secure compliance.
Infrastructure configuration scanner(May 2018, 评估)
For some time now we've recommended increased delivery team ownership of their entire stack, including infrastructure. This means increased responsibility in the delivery team itself for configuring infrastructure in a safe, secure, and compliant way. When adopting cloud strategies, most organizations default to a tightly locked-down and centrally managed configuration to reduce risk, but this also creates substantial productivity bottlenecks. An alternative approach is to allow teams to manage their own configuration, and use an Infrastructure configuration scanner to ensure the configuration is set in a safe and secure way. Watchmen is an interesting tool, built to provide rule-driven assurance of AWS account configurations that are owned and operated independently by delivery teams. Scout2 is another example of configuration scanning to support secure compliance.
Terraform(Apr 2019, 采纳)
Terraform, is rapidly becoming a de facto choice for creating and managing cloud infrastructures by writing declarative definitions. The configuration of the servers instantiated by Terraform is usually left to Puppet, Chef or Ansible. We like Terraform because the syntax of its files is quite readable and because it supports a number of cloud providers while making no attempt to provide an artificial abstraction across those providers. The active community will add support for the latest features from most cloud providers. Following our first, more cautious, mention of Terraform almost two years ago, it has seen continued development and has evolved into a stable product with a good ecosystem that has proven its value in our projects. The issue with state file management can now be sidestepped by using what Terraform calls a "remote state backend." We've successfully used AWS S3 for that purpose.
Terraform(Mar 2017, 试验)
With Terraform, you can manage cloud infrastructure by writing declarative definitions. The configuration of the servers instantiated by Terraform is usually left to tools like Puppet, Chef or Ansible. We like Terraform because the syntax of its files is quite readable and because it supports a number of cloud providers while making no attempt to provide an artificial abstraction across those providers. Following our first, more cautious, mention of Terraform almost two years ago, it has seen continued development and has evolved into a stable product that has proven its value in our projects. The issue with state file management can now be sidestepped by using what Terraform calls a "remote state backend." We've successfully used Consul for that purpose.
Terraform(Nov 2016, 试验)
With Terraform, you can manage cloud infrastructure by writing declarative definitions. The configuration of the servers instantiated by Terraform is usually left to tools like Puppet, Chef or Ansible. We like Terraform because the syntax of its files is quite readable and because it supports a number of cloud providers while making no attempt to provide an artificial abstraction across those providers. Following our first, more cautious, mention of Terraform almost two years ago, it has seen continued development and has evolved into a stable product that has proven its value in our projects. The issue with state file management can now be sidestepped by using what Terraform calls a "remote state backend." We’ve successfully used Consul for that purpose.
Terraform(Jan 2015, 评估)
With Terraform, cloud infrastructure can be managed by writing declarative definitions. The configuration of the servers instantiated by Terraform is usually left to tools like Puppet, Chef, or Ansible. We like Terraform because the syntax of its files is quite readable and because it supports multiple cloud providers while making no attempt to provide an artificial abstraction across these providers. At this stage, Terraform is new and not everything is implemented yet. We have also found its state management to be fragile, often needing awkward manual work to untangle.
AWS Fargate(Apr 2019, 试验)
AWS Fargate, the docker-as-a-service option on AWS, is now widely available across regions. It's a great solution for situations in which teams want to run Docker containers, because AWS Lambda functions aren't powerful enough, without having to manage EC2 instances or Kubernetes clusters. Our teams report generally positive experiences with Fargate; however, the convenience of this managed service can come at a cost, in financial terms.
AWS Fargate(May 2018, 评估)
AWS Fargate is a recent entry into the docker-as-a-service space, currently limited to the US-East-1 region. For teams using AWS Elastic Container Service (ECS), AWS Fargate is a good alternative without having to manage, provision and configure any underlying EC2 instances or clusters. Fargate allows defining (ECS or EKS – ECS for Kubernetes) tasks as a Fargate type, and they will run on the AWS Fargate infrastructure. If you like the focus on business functionality that AWS Lambda gives you, Fargate is the closest you can get when applications can't be deployed as single functions.
AnyStatus(Apr 2019, 试验)
As developers used to pushing many small commits daily, we rely on monitors to notify us when builds go green. AnyStatus is a lightweight Windows desktop app that rolls up metrics and events from various sources into one place. Examples include build results and releases, health checks for different services and OS metrics. Think of it as CCTray on steroids. It's also available as a Visual Studio plugin.
WebFlux(Apr 2019, 试验)
WebFlux is the Spring Framework implementation of Reactive Streams. We see a rise in reactive programming models across our teams in general and the use of WebFlux in teams who are working in the Spring ecosystem. It's best used in large microservices ecosystems where the high performance of the requests is a major concern. It allows overlapping request processing asynchronously without the complications of using multiple threads. WebFlux uses Reactor as its reactive library but it is interoperable with other reactive libraries via Reactive Streams. It uses Netty as its underlying high-performance communications engine. Although we encourage using Reactive Streams, adopting this programming model requires a significant shift in thinking.
WebFlux(Nov 2018, 评估)
Spring Framework 5, released over a year ago, embraces reactive streams, a standard for asynchronous stream processing with non-blocking backpressure. The WebFlux module introduces a reactive alternative to the traditional Spring MVC module for writing web applications in the Spring ecosystem. After working with it on a number of applications, our teams have come away impressed and report that the reactive (functional) approach improves code readability and system throughput. They do note, though, that adopting WebFlux requires a significant shift in thinking and recommend to factor this into the decision to choose WebFlux over Spring MVC.
Smart contracts(Apr 2019, 评估)
The more experience we gain with using distributed ledger technologies (DLTs), the more we encounter the rough edges around the current state of smart contracts. Committing automated, irrefutable, irreversible contracts on ledger sounds great in theory. The problems arise when you consider how to use modern software delivery techniques to developing them, as well as the differences between implementations. Immutable data is one thing, but immutable business logic is something else entirely! It's really important to think about whether to include logic in a smart contract. We've also found very different operational characteristics between different implementations. For example, even though contracts can evolve, different platforms support this evolution to a greater or lesser extent. Our advice is to think long and hard before committing business logic to a smart contract and to weigh the merits of the different platforms before you do.
ReasonML(Apr 2019, 评估)
ReasonML is an interesting new language based on OCaml with a sprinkling of C-like syntax and uses JavaScript as the default compilation target. Created by Facebook, it allows embedded JavaScript snippets and JSX templating with good React integration. It aims to be approachable for JavaScript developers and leverages that ecosystem, while providing type safety in a functional language.
Stolon(Apr 2019, 试验)
Setting up highly available PostgreSQL instances can be tricky, which is why we like Patroni — it helps us speed up the setup of PostgreSQL clusters. Stolon is another tool that we've used successfully to run high-availability (HA) clusters of PostgreSQL instances in production using Kubernetes. Although PostgreSQL supports streaming replication out of the box, the challenge in an HA setup is to assure that the clients always connect to the current master. We like that Stolon enforces the connection to the right PostgreSQL master by actively closing connections to unelected masters and routing requests to the active one.
InSpec(Apr 2019, 试验)
How does an organization give autonomy to delivery teams while still making sure their deployed solutions are safe and compliant? How do you ensure that servers, once deployed, maintain a consistent configuration without drift? InSpec is positioned as a solution for continuous compliance and security, but you can also use it for general infrastructure testing. InSpec allows the creation of declarative infrastructure tests, which can then be continuously run against provisioned environments including production. Our teams particularly praise its extensible design with resources and matchers for multiple platforms. We recommend trialling InSpec as a solution to the problem of assuring compliance and security.
InSpec(Nov 2017, 评估)
How does a business hand autonomy to delivery teams while still making sure their deployed solutions are safe and compliant? How do you ensure that servers, once deployed, remain secure and compliant over their operational lifetime? These are the problems that InSpec tries to address. InSpec is an infrastructure testing tool inspired by Serverspec, but with modifications that make the tool more useful for security professionals who need to ensure compliance across thousands of servers. Individual tests can be combined into complete security profiles and run remotely from a command line. InSpec is useful for developers but extends to testing deployed production infrastructure continuously, moving toward QA in production.
InSpec(Mar 2017, 评估)
How does a business hand autonomy to delivery teams while still making sure their deployed solutions are safe and compliant? How do you ensure that servers, once deployed, remain secure and compliant over their operational lifetime? These are the problems that InSpec tries to address. InSpec is an infrastructure testing tool inspired by Serverspec, but with modifications that make the tool more useful for security professionals who need to ensure compliance across thousands of servers. Individual tests can be combined into complete security profiles and run remotely from a command line. InSpec is useful for developers but extends to testing deployed production infrastructure continuously, moving toward QA in production.
joi(Apr 2019, 试验)
joi is a schema description language and validator for JavaScript objects. We like that joi is independent of any web application framework, so our teams can use the same schemas across different stacks. You can also use companion libraries to generate Swagger documentation for APIs that validate requests with joi schemas.
LocalStack(Apr 2019, 采纳)
One of the challenges of using cloud services is being able to develop and test locally. LocalStack solves this problem for AWS by providing local test double implementations of a wide range of AWS services, including S3, Kinesis, DynamoDB and Lambda. It builds on top of best-of-breed tools such as Kinesalite, dynalite and Moto and adds isolated processes and error injection functionality. LocalStack is very easy to use, ships with a simple JUnit runner and a JUnit 5 extension and can also run inside a docker container. For many teams, it has become the default for testing services that are deployed on AWS.
LocalStack(Nov 2018, 试验)
One of the challenges of using cloud services is being able to develop and test locally using those services. LocalStack solves this problem for AWS by providing local test double implementations of a wide range of AWS services, including S3, Kinesis, DynamoDB and Lambda. It builds on top of existing best-of-breed tools such as Kinesalite, Dynalite and Moto and adds isolated processes and error injection functionality. LocalStack is very easy to use and ships with a simple JUnit runner and a JUnit 5 extension. We're using it in a few of our projects and have been impressed with it.
Apollo(Apr 2019, 采纳)
Our teams report that Apollo has become the library of choice when building a React application that uses GraphQL to access data from a back-end service. Although the Apollo project also provides a server framework and a GraphQL gateway, the Apollo client gets our attention because it simplifies the problem of binding UI components to data served by any GraphQL backend. Put simply, this means less code needs to be written than using REST backends and redux.
Apollo(May 2018, 试验)
Since it was first introduced in the Radar, we’ve seen a steady adoption of GraphQL, particularly as a remote interface for a Backend for Frontend (BFF). As they gain more experience, our teams have reached consensus on Apollo, a GraphQL client, as the preferred way to access GraphQL data from a React application. Although the Apollo project also provides a server framework and a GraphQL gateway, the Apollo client simplifies the problem of binding UI components to data served by any GraphQL backend. Notably, Apollo is used by Amazon AWS in their recent launch of the new AWS AppSync service.
Release train(Apr 2019, 暂缓)
We've seen organizations successfully move from very infrequent releases to a higher cadence by using the release train concept. The release train is a technique for coordinating releases across multiple teams or components that have runtime dependencies. All releases happen on a fixed and reliable schedule regardless of whether all expected features are ready (the train doesn't wait for you — if you miss it you wait for the next one). Although we wholeheartedly endorse discipline around regularly releasing and demoing working software, we've experienced serious drawbacks with the approach over the medium to long term as it reinforces temporal coupling around sequencing of changes and can degrade quality as teams rush to complete features. We prefer to focus on the architectural and organizational approaches necessary to support independent releases. Although the train can be a useful forcing function for speeding up slower teams, we've also seen it as imposing an upper limit on how quickly faster-moving teams can move. We believe that it is a technique that should be approached with a good degree of caution, if at all.
Humio(Apr 2019, 评估)
Humio is a fairly new player in the log management space. It's been built from the ground up to be super fast at both log ingestion and query using its built-in query language on top of a custom-designed time series database. It integrates with just about everything out there from an ingestion, visualization and alerting perspective. The log management space has been dominated by Splunk and the ELK Stack, so having alternatives is a good thing. We'll be watching Humio's development with interest.
HiveRunner(Apr 2019, 试验)
HiveRunner is an open-source unit test framework for Apache Hadoop Hive queries based on JUnit4. When writing nontrivial analytics or data pipelines in Hive SQL, we found HiveRunner to be a good enabler for writing tests and even TDDing out some moderately complicated SQL. HiveRunner enables you to write Hive SQL as releasable tested artifacts.
Reactor(Apr 2019, 试验)
We've talked about Reactor in the previous Radars. It has continued to gain traction in many of our projects. With the Spring ecosystem embracing Reactor, it has become the dominant implementation of Reactive Streams. Reactive systems come with improved scalability and resilience but with increased cost of debugging and a steeper learning curve. For those projects where this tradeoff is acceptable, Reactor has proven to be a good choice. Some of our projects have observed significant improvements in scalability once they moved to Reactor and the rest of the Reactive stack. With R2DBC we are starting to get reactive support for RDBMS drivers which addresses one of the weaknesses of reactive services.
Reactor(May 2018, 评估)
Reactor is a library for building non-blocking applications on the JVM — version 8 and above — based on the Reactive Streams specification. Reactive programming emphasizes moving from imperative logic to asynchronous, non-blocking and functional style code, especially when dealing with external resources. Reactor implements the reactive stream specification and provides two publisher APIs — Flux (0 to N elements) and Mono (0 or 1 element) — to effectively model push-based stream processing. Reactor project is well suited for microservices architecture and offers back pressure–ready network engines for HTTP, WebSockets, TCP and UDP traffic.
Templating in YAML(Apr 2019, 暂缓)
As infrastructures grow in complexity, so do the configuration files that define them. Tools such as AWS CloudFormation, Kubernetes and Helm expect configuration files in JSON or YAML syntax, presumably in an attempt to make them easy to write and process. However, in most cases, teams quickly reach the point where they have some parts that are similar but not quite the same, for example, when the same service must be deployed in different regions with a slightly different setup. For such cases tools offer templating in YAML (or JSON), which has caused a huge amount of frustration with practitioners. The problem is that the syntax of JSON and YAML requires all sorts of awkward compromises to graft templating features such as conditionals and loops into the files. We recommend using an API from a programming language instead or, when this is not an option, a templating system in a programming language, either a general-purpose language such as Python or something specialized such as Jsonnet.
Handwritten CloudFormation(Apr 2019, 暂缓)
AWS CloudFormation is a proprietary declarative language to provision AWS infrastructure as code. Handwriting CloudFormation files is often a default approach to bootstrap AWS infrastructure automation. Although this might be a sensible way to start a small project, our teams, and the industry at large, have found that handwritten CloudFormation simply does not scale as the infrastructure grows. Noticeable pitfalls of handwritten CloudFormation files for large projects include poor readability, lack of imperative constructs, limited parameter definition and usage, and lack of type checking. Addressing these shortfalls has led to a rich ecosystem of both open-source and custom tooling. We find Terraform a sensible default that not only addresses shortfalls of CloudFormation but also has an active community to add the latest AWS features and fix bugs. In addition to Terraform, you can choose from many other tools and languages, including troposphere, sceptre, Stack Deployment Tool and Pulumi.
Gremlin(May 2013, 评估)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Gremlin(Oct 2012, 评估)
Gremlin is an imperative graph traversal language supported by multiple graph databases. Its concise constructs can be used in place of the native language of the database, leading to faster development times and, in some cases, faster execution. We recommend its use as a good alternative in simple scenarios.
Traefik(Apr 2019, 试验)
Traefik is an open-source reverse proxy and load balancer. If you're looking for an edge proxy that provides simple routing without all the features of NGINX and HAProxy, Traefik is a good choice. The router provides a reload-less reconfiguration, metrics, monitoring and circuit breakers that are essential when running microservices. It also integrates nicely with Let's Encrypt to provide SSL termination as well as infrastructure components such as Kubernetes, Docker Swarm or Amazon ECS to automatically pick up new services or instances to include in its load balancing.
Traefik(Nov 2018, 评估)
Traefik is an open-source reverse proxy and load balancer. If you're looking for an edge proxy that provides simple routing without all the features of NGINX and HAProxy, Traefik is a good choice. The router provides a reload-less reconfiguration, metrics, monitoring and circuit breakers that are essential when running microservices. It also integrates nicely with Let's Encrypt to provide SSL termination. When compared to Traefik, tools such as NGINX and HAProxy may require additional tooling to templatize configuration in response to scaling, adding or removing microservices and may, at times, require a restart which can be annoying in production environments.
MinIO(Apr 2019, 评估)
Object storage is a popular choice for storing unstructured data and in a few cases structured data in the cloud. We do discourage the use of generic cloud but if you want to minimize the risk of cloud stickiness for object storage, we've found MinIO quite helpful. With an S3-compatible API layer, MinIO abstracts object storage across cloud providers, including AWS, Azure and Google Cloud Platform (GCP), and we've used it successfully in products with flexible target infrastructures from data centers to cloud providers.
Kafka Streams(Apr 2019, 试验)
Kafka Streams is a lightweight library to build streaming applications. It supports basic streaming APIs such as join, filter, map and aggregate as well as local storage for common use cases such as windowing and sessions. Unlike other stream-processing platforms such as Apache Spark and Alpakka Kafka, Kafka Streams has been a good fit for scenarios that don't require large-scale distribution and parallel processing; hence we could get away without yet another piece of infrastructure such as cluster schedulers. Naturally, Kafka Streams has been a good choice when operating in the Kafka ecosystem. Kafka Streams is particularly useful when we have to process data strictly in order and exactly once. One particular use case of Kafka Streams is to build a change data capture (CDC) platform.
Kafka Streams(Nov 2017, 评估)
Kafka Streams is a lightweight library for building streaming applications. It's been designed with the goal of simplifying stream processing enough to make it easily accessible as a mainstream application programming model for asynchronous services. It can be a good alternative in scenarios where you want to apply a stream processing model to your problem, without embracing the complexity of running a cluster (usually introduced by full-fledged stream processing frameworks). New developments include ‘exactly once’ stream processing in a Kafka cluster. This was achieved by introducing idempotency in Kafka producers and allowing atomic writes across multiple partitions using the new Transactions API.
Kafka Streams(Mar 2017, 评估)
Kafka Streams is a lightweight library for building streaming applications. It's been designed with the goal of simplifying stream processing enough to make it easily accessible as a mainstream application programming model for asynchronous services. It can be a good alternative in scenarios where you want to apply a stream processing model to your problem without embracing the complexity of running a cluster (usually introduced by full-fledged stream processing frameworks).
Quorum(Apr 2019, 评估)
Quorum is "an enterprise-focused version of Ethereum" that aims to provide network permissioning and transaction privacy as well as higher performance. One of our teams has worked deeply with Quorum; however, their experience so far hasn't been great. Some challenges result from complex smart contract programming and some come from Quorum itself. For example, it doesn't work well with load balancers and only has partial database support, which will lead to significant deployment burden. We faced some stability and compatibility issues especially on private transactions. Quorum recently attracted a lot of attention because of JPM Coin. However, from a tech perspective, we recommend being cautious when implementing Quorum while keeping an eye on its development.
Quorum(Nov 2018, 评估)
Ethereum is the leading developer ecosystem in blockchain tech. We've seen emerging solutions that aim to spread this technology into enterprise environments that usually require network permissioning and transaction privacy as well as higher throughput and lower latency. Quorum is one of these solutions. Originally developed by J.P. Morgan, Quorum positions itself as "an enterprise-focused version of Ethereum." Unlike the Hyperledger Burrow node, which creates a new Ethereum virtual machine (EVM), Quorum forks code from Ethereum's official client so that it can evolve alongside Ethereum. Although it keeps most features of the Ethereum ledger, Quorum changes the consensus protocol from PoW to more efficient ones and adds private transaction support. With Quorum, developers can use their Ethereum knowledge of using, for example, Solidity and Truffle contracts to build enterprise blockchain applications. However, based on our experience, Quorum is not yet enterprise ready; for example, it lacks access control for private contracts, doesn't work well with load balancers and only has partial database support, all of which will lead to significant deployment and design burden. We recommend that you're cautious in implementing Quorum while keeping an eye on its development.
AVA(Apr 2019, 试验)
AVA is a test runner for Node.js. Even though JavaScript is single-threaded, IO in Node.js can happen in parallel because of its asynchronous nature. AVA takes advantage of this and runs your tests concurrently, which is especially beneficial for IO-heavy tests. In addition, test files are run in parallel as separate processes, giving you even better performance and an isolated environment for each test file. AVA is a lightweight option, when compared to full-featured frameworks such as Jest. It is opinionated and forces you to write atomic test cases.
SPIFFE(Apr 2019, 评估)
SPIFFE standardization of service identity has been an important step in enabling turnkey solutions for end-to-end encryption and mutual authentication between services. The SPIFFE standards are backed by the OSS SPIFFE Runtime Environment (SPIRE), which automatically delivers cryptographically provable identities to services. Istio also uses SPIFFE by default. SPIFFE enables many use cases, including identity translation, OAuth client authentication, mTLS "encryption everywhere" and workload observability. ThoughtWorks is actively working with the Istio and SPIFFE communities to bridge the gap between legacy service identity providers and SPIFFE-based identities so that mTLS can be used everywhere between services, inside a service mesh and outside.
SPIFFE(Nov 2018, 评估)
Making key elements of Google's groundbreaking, high-scale platform available as open source offerings appears to have become a trend. In the same way that HBASE drew on BigTable and Kubernetes drew on Borg, SPIFFE is now drawing upon Google's LOAS to bring to life a critical cloud-native concept called workload identity. The SPIFFE standards are backed by the OSS SPIFFE Runtime Environment (SPIRE), which automatically delivers cryptographically provable identities to software workloads. Although SPIRE isn't quite ready for production use, we see tremendous value in a platform-agnostic way to make strong identity assertions between workloads in modern, distributed IT infrastructures. SPIRE supports many use cases, including identity translation, OAuth client authentication, mTLS "encryption everywhere," and workload observability. Istio uses SPIFFE by default.
fastai(Apr 2019, 评估)
fastai is an open-source Python library that simplifies training fast and accurate neural nets. It is built on top of PyTorch and has become a popular tool for our data scientists. fastai simplifies painful aspects of model training such as preprocessing and loading data down to a few lines of code. It's built on deep learning best practices and has out-of-the-box support for computer vision, natural language processing (NLP) and more. The founders' motivation has been to create an easy-to-use library for deep learning and an improved successor to Keras. GCP, AWS and Azure all have already included fastai in their machine images. The creators of fastai, acknowledging the speed and safety limitations of Python, have announced embracing Swift as an alternative language for deep learning. We'll be closely watching this space.
Pose(Apr 2019, 评估)
Pose is a simple CSS-like animation library for React.js, React Native and Vue.js frameworks. It is a declarative motion system that combines the simplicity of CSS syntax with the power and flexibility of JavaScript animations and interactions.
Puncturing encapsulation with change data capture(Apr 2019, 暂缓)
Change data capture (CDC) is a very powerful technique for pulling database changes out of a system and performing some actions on that data. One of the most popular ways of doing this is to use the database's transaction log to identify changes and then publish those changes directly onto an event bus that can be consumed by other services. This works very well for use cases such as breaking monoliths into microservices but when used for first-class integration between microservices, this leads to puncturing encapsulation and leaking the source service's data layer into the event contract. We've talked about domain scoped events and other techniques that emphasize the importance of having our events model our domain properly. We're seeing some projects use CDC for publishing row-level change events and directly consuming these events in other services. This puncturing of encapsulation with change data capture can be a slippery slope leading to fragile integrations and we would like to call this out with this blip.
Laconia(Apr 2019, 试验)
Laconia is a framework for developing AWS Lambda functions in JavaScript. As interest and use of serverless tech has grown so has the complexity of the applications being built. Laconia is a small, lightweight framework that takes away some of the rough edges we often encounter. It uses dependency injection to isolate your application code from lower-level AWS APIs and provides adaptors for the different events that your application can respond too. It also plays nicely with the Serverless Framework at deploy time. We like small and simple frameworks and Laconia is just that.
Opinionated and automated code formatting(Apr 2019, 采纳)
For as long as we can remember, what style to use for formatting code has been a matter of personal taste, company policy and heated debate. Finally, the industry appears to be tiring of this endless argument and teams are freeing up surprisingly large amounts of time by forgoing these discussions and just adopting opinionated and automated code formatting tools. Even if you don't agree 100% with the opinions of the various tools, the benefits of focusing on what your code does rather than how it looks is something most teams should be able to get behind. Prettier has been getting our vote for JavaScript, but similar tools, such as Black for Python, are available for many other languages and are increasingly being built-in as we see with Golang and Elixir. The key here is not to spend hours discussing which rules to enforce, but instead pick a tool that is opinionated, minimally configurable and automated — ideally as a pre-commit hook.
Ktor(Apr 2019, 试验)
Kotlin has demonstrated its value beyond mobile app development. When building microservices and shipping software to production, our teams have had good experiences with Ktor. Ktor is a framework that, unlike other web frameworks that support Kotlin, is written in Kotlin, using language features such as coroutines which allow for an asynchronous nonblocking implementation. The flexibility to incorporate different tools for logging, DI or a template engine — in addition to its lightweight architecture — makes Ktor an interesting option for creating RESTful services.
Ktor(Nov 2018, 评估)
Kotlin is no longer just a great fit for mobile app development. New tools and frameworks have emerged that demonstrate the value of the language for web application development as well. Ktor is one such framework. In contrast to other web frameworks that support Kotlin, Ktor is written in Kotlin, using language features such as coroutines which allows for an asynchronous non-blocking implementation. The flexibility to incorporate different tools for logging, DI or a templates engine—in addition to its lightweight architecture—makes Ktor an interesting option for our teams for creating RESTful services.
EVM beyond Ethereum(Apr 2019, 试验)
Ethereum Virtual Machine (EVM) was originally designed for the Ethereum main network. Nowadays, however, most teams no longer want to reinvent blockchain from scratch; instead, they'd like to take EVM beyond Ethereum. We've seen a lot of blockchain teams choose to fork Ethereum (e.g., Quorum) or implement the EVM spec (e.g., Burrow, Pantheon), adding their own designs. The intention is to not only reuse the Ethereum design but also leverage its ecosystem and developer community. To many developers, the concept of "smart contract" is almost equivalent to a smart contract written in Solidity. Although Ethereum itself has some constraints, the technology around the EVM ecosystem is booming.
Cloudflare Workers(Apr 2019, 评估)
Most modern server-side or serverless code execution platforms are centered around containers or VMs. Cloudflare Workers, however, takes a different approach to hosting a serverless computing offering. It uses V8 Isolates, the open source JavaScript engine developed for Chrome, to run functions as a service (FaaS) on their extensive CDN network. Code can be written in JavaScript or anything that compiles to WebAssembly and data can be accessed from Cloudflare's cache or key-value store. The major benefit for developers is performance: by being on the edge network, close to end users, cold-starts take only five milliseconds. For the provider the benefits include both the ability to densely pack isolates because of their lower memory overhead and faster performance through reduced process context switching. This is definitely an intriguing approach to monitor and assess.
UI dev environments(Apr 2019, 采纳)
As more and more teams embrace DesignOps, practices and tooling in this space mature. UI dev environments provide a comprehensive environment for quickly iterating on UI components, focusing on collaboration between user experience designers and developers. We now have a few options in this space: Storybook, React Styleguidist, Compositor and MDX. You can use these tools standalone in component library or design system development as well as embedded in a web application project. Many teams were able to decrease their UI feedback cycles and improve timing of UI work in preparation for development work, which has made using UI dev environments a reasonable default for us.
UI dev environments(Nov 2018, 试验)
As more and more teams embrace DesignOps, practices and tooling in this space mature, too. Many of our teams now work with what could be called UI dev environments , which provide a comprehensive environment for quickly iterating on UI components, focusing on collaboration between user experience designers and developers. We now have a few options in this space: Storybook, react-styleguidist, Compositor and MDX. You can use these tools standalone in component library or design system development as well as embedded in a web application project. Rather than spinning up the app, plus a BFF, plus services simply to add a feature to a component, you can start up the Storybook dev server instead.
Room(Apr 2019, 试验)
Room is a persistence library to access SQLite on Android. It makes database access code much simpler, with minimal boilerplate code, and more robust, with compile-time verification of SQL queries. Our developers like its complete integration with observable queries, using LiveData. Room is one of the Android Jetpack components that were created to make application development on Android easier.
Jupyter(Apr 2019, 采纳)
Over the past couple of years, we've noticed a steady rise in the popularity of analytics notebooks. These are Mathematica-inspired applications that combine text, visualization and code in a living, computational document. Jupyter Notebooks are widely used by our teams for prototyping and exploration in analytics and machine learning. We've moved Jupyter to Adopt for this issue of the Radar to reflect that it has emerged as the current default for Python notebooks. However, we caution to use Jupyter Notebooks in production.
Jupyter(May 2018, 试验)
Over the last couple of years, we've noticed a steady rise in the popularity of analytics notebooks. These are Mathematica-inspired applications that combine text, visualization and code in a living, computational document. Increased interest in machine learning — along with the emergence of Python as the programming language of choice for practitioners in this field — has focused particular attention on Python notebooks, of which Jupyter seems to be gaining the most traction among ThoughtWorks teams. People seem to keep finding creative uses for Jupyter beyond a simple analytics tool. For example, see Jupyter for automated testing.
Jupyter(Nov 2017, 评估)
Over the last couple of years, we've noticed a steady rise in the popularity of analytics notebooks. These are Mathematica-inspired applications that combine text, visualization and code in a living, computational document. In a previous edition, we mentioned GorillaREPL, a Clojure variant of these. But increased interest in machine learning — along with the emergence of Python as the programming language of choice for practitioners in this field — has focused particular attention on Python notebooks, of which Jupyter seems to be gaining the most traction among ThoughtWorks teams.
Wardley mapping(Apr 2019, 评估)
We're usually wary of covering diagrammatic techniques, but Wardley mapping is an interesting approach to start conversations around the evolution of an organization's software estate. At their simplest, they're used to visualize the value chains that exist within an organization, starting with customers' needs and progressively plotting the different capabilities and systems used to deliver on those needs along with the evolution of those capabilities and systems. The value of this technique is the process of collaborating to create the maps rather than the artefact itself. We recommend getting the right people in the room to produce them, and then treat them as living, evolving things rather than a complete artefact.
TimescaleDB(Apr 2019, 评估)
In previous Radars we've discussed PostgreSQL for NoSQL. PostgreSQL's maturity and extensibility have led to a steady stream of innovative persistence stores built on the Postgres engine. One that caught our attention is TimescaleDB, a database that allows fast writes and optimized queries over time-series data. Albeit not (yet) as full-featured as InfluxDB, TimescaleDB offers an alternative data model and querying capability. You should evaluate TimescaleDB if you have modest scalability needs, prefer to use SQL and appreciate the stability and familiar administrative interface that PostgreSQL offers.
TypeScript(Apr 2019, 采纳)
TypeScript, a statically typed language and superset of JavaScript, has become our sensible default. Large-scale projects benefit most from the type safety. Our developers favor its minimal configuration management, well-integrated IDE support and its ability to refactor code safely and gradually adopt types. With its good repository of TypeScript-type definitions at hand, we benefit from all the rich JavaScript libraries while gaining type safety.
TypeScript(Nov 2018, 试验)
TypeScript is a carefully considered language and its consistently improving tools and IDE support continues to impress us. With a good repository of TypeScript-type definitions, we benefit from all the rich JavaScript libraries while gaining type safety. This is particularly important as our browser-based code base continues to grow. The type safety in TypeScript lets you use IDEs and other tools to provide deeper context into your code and make changes and refactor code with safety. TypeScript, being a superset of JavaScript, and documentation and the community has helped ease the learning curve.
TypeScript(Jul 2014, 评估)
TypeScript is an interesting approach to bringing a new programming language to the browser. With TypeScript, the new language features compile down to normal JavaScript, and yet as a superset of JavaScript it does not feel like a completely new language. It does not represent an either-or proposition and it does not relegate JavaScript to an intermediate execution platform. Many of the language features are based on planned future extensions of JavaScript.
Knative(Apr 2019, 评估)
The serverless architecture has popularized a FaaS style of programming among developers; it helps developers focus on solving core business problems with independently built and deployed functions that react to an event, run a business process, produce other events in the process and scale down to zero. Historically, proprietary serverless platforms such as AWS Lambda or Microsoft Azure Functions have enabled this programming paradigm. Knative is an open-source Kubernetes-based platform to run FaaS workloads. There are few things that stand out about Knative: it's open source and provider agnostic; it implements the serverless workflow as described in the CNCF Serverless Working Group whitepaper; it ensures cross-service interoperability by implementing its eventing interface consistent with CNCF CloudEvents specification; and, most importantly, it addresses a common challenge of operating a harmonized and yet hybrid FaaS and long-running container-based architecture. It easily integrates with both Istio and Kubernetes. For example, developers can take advantage of roll-out strategies that Istio implements by traffic splitting between different revisions of the functions. Developers can take benefit of Istio-provided observability not only for long-running container services but also for FaaS programs in the same Kubernetes environment. We anticipate that Knative open-source eventing interface will continue to enable new underlying source and destination event integrations.
Knative(Nov 2018, 评估)
As application developers, we love to focus on solving core business problems and let the underlying platform handle the boring but difficult tasks of deploying, scaling and managing applications. Although serverless architecture is a step in that direction, most of the popular offerings are tied to a proprietary implementation, which means vendor lock-in. Knative tries to address this by being an open source serverless platform that integrates well with the popular Kubernetes ecosystem. With Knative you can model computations on request in a supported framework of your choice (including Ruby on Rails, Django and Spring among others); subscribe, deliver and manage events; integrate with familiar CI and CD tools; and build containers from source. By providing a set of middleware components for building source-centric and container-based applications that can be elastically scaled, Knative is an attractive platform that deserves to be assessed for your serverless needs.
Tendermint(Apr 2019, 评估)
Byzantine fault tolerance (BFT) is one of the fundamental problems in cryptocurrency and blockchain systems. It requires overall system agreement on a single data value in the presence of a number of arbitrary faulty processes, which includes malicious fraud. Tendermint is a BFT state machine replication engine that lets you implement your own blockchain systems. The consensus engine, Tendermint Core, takes over the peer-to-peer communication and consensus part, you just need to implement the rest of the application (e.g., construct transaction and verify cryptographic signature) and communicate with Tendermint Core through ABCI. Some blockchain implementations have already chosen Tendermint as their consensus engine.
Systems(Apr 2019, 评估)
It's easy to think of many of the processes we work within as linear chains of cause and effect. Most of the time we are working within more complex systems where positive and negative feedback loops influence outcomes. Systems is a set of tools for describing, executing and visualizing systems diagrams. Using a compact DSL and running either standalone or within a Jupyter Notebook, it's super easy to describe fairly complex processes and the flow of information through them. It's pretty much a niche tool; but an interesting and fun one.
Service mesh(Apr 2019, 试验)
Service mesh is an approach to operating a secure, fast and reliable microservices ecosystem. It has been an important stepping stone in making it easier to adopt microservices at scale. It offers discovery, security, tracing, monitoring and failure handling. It provides these cross-functional capabilities without the need for a shared asset such as an API gateway or baking libraries into each service. A typical implementation involves lightweight reverse-proxy processes, aka sidecars, deployed alongside each service process in a separate container. Sidecars intercept the inbound and outbound traffic of each service and provide cross-functional capabilities mentioned above. This approach has relieved the distributed service teams from building and updating the capabilities that the mesh offers as code in their services. This has lead to an even easier adoption of polyglot programming in a microservices ecosystem. Our teams have been successfully using this approach with open source projects such as Istio and we will continue to monitor other open service mesh implementations such as Linkerd closely.
Service mesh(Nov 2018, 评估)
As large organizations transition to more autonomous teams owning and operating their own microservices, how can they ensure the necessary consistency and compatibility between those services without relying on a centralized hosting infrastructure? To work together efficiently, even autonomous microservices need to align with some organizational standards. A service mesh offers consistent discovery, security, tracing, monitoring and failure handling without the need for a shared asset such as an API gateway or ESB. A typical implementation involves lightweight reverse-proxy processes deployed alongside each service process, perhaps in a separate container. These proxies communicate with service registries, identity providers, log aggregators and other services. Service interoperability and observability are gained through a shared implementation of this proxy but not a shared runtime instance. We've advocated for a decentralized approach to microservices management for some time and are happy to see this consistent pattern emerge. Open source projects such as Linkerd and Istio will continue to mature and make service meshes even easier to implement.
Service mesh(May 2018, 评估)
As large organizations transition to more autonomous teams owning and operating their own microservices, how can they ensure the necessary consistency and compatibility between those services without relying on a centralized hosting infrastructure? To work together efficiently, even autonomous microservices need to align with some organizational standards. A service mesh offers consistent discovery, security, tracing, monitoring and failure handling without the need for a shared asset such as an API gateway or ESB. A typical implementation involves lightweight reverse-proxy processes deployed alongside each service process, perhaps in a separate container. These proxies communicate with service registries, identity providers, log aggregators, and so on. Service interoperability and observability are gained through a shared implementation of this proxy but not a shared runtime instance. We've advocated for a decentralized approach to microservice management for some time and are happy to see this consistent pattern emerge. Open source projects such as linkerd and Istio will continue to mature and make service meshes even easier to implement.
Service mesh(Nov 2017, 评估)
As large organizations transition to more autonomous teams owning and operating their own microservices, how can they ensure the necessary consistency and compatibility between those services without relying on a centralized hosting infrastructure? To work together efficiently, even autonomous microservices need to align with some organizational standards. A service mesh offers consistent discovery, security, tracing, monitoring and failure handling without the need for a shared asset such as an API gateway or ESB. A typical implementation involves lightweight reverse-proxy processes deployed alongside each service process, perhaps in a separate container. These proxies communicate with service registries, identity providers, log aggregators, and so on. Service interoperability and observability are gained through a shared implementation of this proxy but not a shared runtime instance. We've advocated for a decentralized approach to microservice management for some time and are happy to see this consistent pattern emerge. Open source projects such as linkerd and Istio will continue to mature and make service meshes even easier to implement.
TestCafe(Apr 2019, 试验)
We have good experience using "post-Selenium" web UI testing tools such as Cypress, TestCafe and Puppeteer. TestCafe lets you write tests in JavaScript or TypeScript and runs in-browser tests. TestCafe has several useful features that include out-of-the-box parallel execution and HTTP request mocking. TestCafe uses an asynchronous execution model with no explicit wait times, which results in much more stable test suites. Its selector API makes it easier to implement PageObject patterns. TestCafe recently released version 1.0.x, which improved stability and functionality.
TestCafe(Nov 2018, 评估)
Our teams are reporting good success with TestCafe, a JavaScript-based browser test automation tool. TestCafe allows you to write tests in JavaScript or TypeScript and runs tests in any browser that supports JavaScript. TestCafe has several useful features including out-of-the-box parallel execution and HTTP request mocking. TestCafe uses an asynchronous execution model with no explicit wait times, which results in much more stable test suites.
Apache Beam(Apr 2019, 试验)
Apache Beam is an open-source unified programming model for defining and executing both batch and streaming data parallel processing pipelines. The Beam model is based on the Dataflow model which allows us to express logic in an elegant way so that we can easily switch between batch, windowed batch or streaming. The big data-processing ecosystem has been evolving quite a lot which can make it difficult to choose the right data-processing engine. One of the key reasons to choose Beam is that it allows us to switch between different runners — a few months ago Apache Samza was added to the other runners it already supports, which include Apache Spark, Apache Flink and Google Cloud Dataflow. Different runners have different capabilities and providing a portable API is a difficult task. Beam tries to strike a delicate balance by actively pulling innovations from these runners into the Beam model and also working with the community to influence the roadmap of these runners. Beam has SDKs in multiple languages including Java, Python and Golang. We've also had success using Scio which provides a Scala wrapper around Beam.
Apache Beam(Nov 2018, 评估)
Apache Beam is an open source unified programming model for defining and executing both batch and streaming data-parallel processing pipelines. Beam provides a portable API layer for describing these pipelines independent of execution engines (or runners) such as Apache Spark, Apache Flink or Google Cloud Dataflow. Different runners have different capabilities and providing a portable API is a difficult task. Beam tries to strike a delicate balance by actively pulling innovations from these runners into the Beam model and also working with the community to influence the roadmap of these runners. Beam has a rich set of built-in I/O transformations that cover most of the data pipeline needs and it also provides a mechanism to implement custom transformations for specific use cases. The portable API and extensible IO transformations make a compelling case for assessing Apache Beam for data pipeline needs.
Dask(Apr 2019, 评估)
Data scientists and engineers often use libraries such as pandas to perform ad hoc data analysis. Although expressive and powerful, these libraries have one critical limitation: they only work on a single CPU and don't provide horizontal scalability for large data sets. Dask, however, includes a lightweight, high-performance scheduler that can scale from a laptop to a cluster of machines. And because it works with NumPy, pandas and Scikit-learn, Dask looks promising for further assessment.
Nomad(Apr 2019, 试验)
HashiCorp continues to release interesting software. We've featured HashiCorp Vault in March 2017, and tools related to Terraform are all over this edition of the Radar. We've moved Nomad to Trial because we've had positive experiences using it. While Kubernetes continues to gain traction, we like Nomad's general applicability. It's not just limited to running containerized workloads but can be used to schedule just about anything. Java and Golang are supported natively as well as batch and distributed cron jobs. We like its focus on multi- and hybrid-cloud operations, something likely to become more important to avoid sticky clouds and the fact that it does scheduling well.
Nomad(Nov 2016, 评估)
HashiCorp continues to turn out interesting software. The latest to catch our attention is Nomad, which is competing in the ever-more-populated scheduler arena. Major selling points include not just being limited to containerized workloads, and operating in multi–data center / multiregion deployments.
Puppeteer(Apr 2019, 试验)
Much like Cypress and TestCafe, Puppeteer is one of the web UI testing tools garnering praise from our teams. Puppeteer can have fine-grained control over headless browsers, obtain time-trace for performance diagnostics and more. Our teams have found Puppeteer to be stable as well as faster and more flexible than alternatives based on WebDriver.
Puppeteer(Nov 2018, 评估)
In the previous Radar we mentioned Headless Chrome for front-end test. With the adoption of Chrome DevTools Protocol (CDP) by other browsers a new set of libraries is emerging for browser automation and testing. CDP allows for fine-grained control over the browser even in headless mode. New high-level libraries are being created using CDP for testing and automation. Puppeteer is one of these new libraries. It can drive headless Chrome through a single-page application, obtain time-trace for performance diagnostics and more. Our teams found it faster and also more flexible than alternatives based on WebDriver.
Kubernetes Operators(Apr 2019, 评估)
We're excited about the impact Kubernetes has had on our industry but also concerned about the operational complexity that comes with it. Keeping a Kubernetes cluster up and running and then managing packages deployed on it requires special skills and time. Operational processes such as upgrades, migrations, backups, among others, can be a full-time job. We think that Kubernetes Operators will play a key role in reducing this complexity. The framework provides a standard mechanism to describe automated operational processes for packages running in a Kubernetes cluster. Although Operators were spearheaded and promoted by RedHat, several community-developed Operators for common open-source packages such as Jaeger, MongoDB and Redis have begun to emerge.
Crypto shredding(Apr 2019, 试验)
Maintaining proper control over sensitive data is difficult, especially when it's copied outside of a master system of record for backup and recovery purposes. Crypto shredding is the practice of rendering sensitive data unreadable by deliberately overwriting or deleting encryption keys used to secure that data. Considering there are systems, such as audit application or blockchain, that should not or could not delete historical records, this technique is quite useful for privacy protection and GDPR compliance.
Crypto shredding(Nov 2018, 试验)
Maintaining proper control over sensitive data is difficult, especially when—for backup and recovery purposes—data is copied outside of a master system of record. Crypto shredding is the practice of rendering sensitive data unreadable by deliberately overwriting or deleting encryption keys used to secure that data. For example, an entire table of customer personal details could be encrypted using random keys for each record, with a different table storing the keys. If a customer exercised their "right to be forgotten," we can simply delete the appropriate key, effectively "shredding" the encrypted data. This technique can be useful where we're confident of maintaining appropriate control of a smaller set of encryption keys but less confident about control over a larger data set.
Vapor(Apr 2019, 评估)
We're strong proponents of polyglot programming but recognize that in some cases it can make sense to focus on a single programming language. If you're heavily invested in Swift, most likely because of iOS development, and you find yourself looking for a technology to write server-side services, have a look at Vapor, a modern web framework for Swift that has gained a fair amount of popularity.
Prophet(Apr 2019, 评估)
Even in the era of deep learning, statistical models still play a role in business decision support. Time series models are widely used to forecast inventories, demand, customer traffic, and so on. Hand-crafting these models so that they're robust and flexible has typically been the role of either specialized statisticians or large commercial software vendors. Prophet is an open-source alternative to commercial forecasting packages that can be programmed in R or Python. Facebook claims to use Prophet internally for business forecasting at scale and has made it available as an open-source package for anyone to use. We like that Prophet removes some of the tedium of model construction, maintenance and data manipulation so that human analysts and subject matter experts can focus on doing what they do best.
Embark(Apr 2019, 评估)
We've recommended Truffle for decentralized application (dapp) development in the past. Embark too can make your work easier. Embark provides features such as scaffolding, building, testing and debugging and integrates with decentralized storages such as IPFS. Through its declarative configuration, you can manage smart contract configuration, dependencies, artifact and deployment quite easily. Embark's interactive CLI dashboard is also impressive. We keep seeing people use Remix to write smart contracts and manually deploy their apps without automated testing, source control management or artifact management. We'd like to draw people's attention to dapp engineering practice by promoting tools such as Truffle and Embark.
Lottie(Apr 2019, 试验)
Good UI animation could greatly improve user experience. However, to reproduce a designer's delicate animation on an app is usually a challenging task for developers. Lottie is a library for Android, iOS, web, and Windows that parses Adobe After Effects animations exported as JSON with Bodymovin and renders them natively on mobile and on the web. Both designers and developers can continue to use their familiar tools and have a fluent collaboration.
Chaos Toolkit(Apr 2019, 评估)
The Chaos Toolkit is one of a number of Chaos Engineering tools that made this edition of the Radar. You use the toolkit to describe and then run repeatable experiments on your infrastructure to understand its resilience in the event of failure. Many of our teams have been using homegrown tools to do this, so it's great to see an open-source project dedicated to the practice. The toolkit already has drivers for AWS, Azure Service Fabric and GCE (among others) and plays nicely with build tools which lets you experiment with automation. The usual caveats apply though, Chaos Engineering is a very powerful technique that is best used on resilience-aware systems, that is, systems that have been built to cope with failure. For that reason, we recommend starting using Chaos Toolkit in your nonproduction environments first.
Ethical OS(Apr 2019, 评估)
As developers at ThoughtWorks we're acutely aware of the ethics of the work we do. As society becomes ever more reliant on technology, it's important that we consider ethics when making decisions as software development teams. Several toolkits have emerged that can help us think through some of the future implications of the software we're building. They include Tarot Cards of Tech and Ethical OS, which we've had good feedback on. Ethical OS is a thinking framework and a set of tools that drive discussions around the ethics of building software. The framework is a collaboration between the Institute for the Future and the Tech and Society Solutions Lab. It's based on a practical set of risk zones, such as addiction and the dopamine economy, plus a number of scenarios to drive conversation and discussion.
Elasticsearch LTR(Apr 2019, 试验)
One of the challenges of search is ensuring the most relevant results for the user appear at the top of the list. This is where learning to rank (LTR) can help. LTR is the process of applying machine learning to rank documents retrieved by a search engine. If you're using Elasticsearch, you can achieve search-relevant ranking with the Elasticsearch LTR plugin. The plugin uses RankLib for generating the models during the training phase. Then, when querying Elasticsearch, you can use this plugin to "rescore" the top results. We've used it in a few projects and have been happy with the results. There's also an equivalent LTR solution for Solr users.
Flagr(Apr 2019, 评估)
Feature toggles are an important technique in continuous deployment scenarios. We've come across a number of good home-grown solutions, but we do like the approach Flagr takes: a complete feature toggle as a service, distributed as a Docker container. It comes with SDKs for all major languages, has a simple and well-documented REST API and provides a convenient frontend.
IPFS(Nov 2018, 评估)
In most cases, blockchain is not the right place to store a blob file (e.g., image or audio). When developing DApp, one option is to put blob files in some off-chain centralized data storage, which usually signals lack of trust. Another option is to store them on InterPlanetary File System (IPFS), which is a content-addressed, versioned, peer-to-peer file system. It’s designed to distribute high volumes of data with high efficiency and removed from any centralized authority. Files are stored on peers that don’t need to trust each other. IPFS keeps every version of a file so you never lose important files. We see IPFS as a good complement to blockchain technology. Beyond its blockchain application, IPFS has an ambitious goal to decentralize the Internet infrastructure.
Jepsen(Nov 2018, 试验)
With the increased adoption of a microservices architecture, we're building more distributed applications than before. Although there are many benefits of a decoupled architecture, the complexity and the effort involved in proving the correctness of the overall system has dramatically increased. Jepsen provides much needed tooling to verify correctness in coordination of task schedulers, test eventual consistency, linearizability and serializability characteristics of distributed databases. We've used Jepsen in a few projects and we like the fact that we can test drive configurations, inject and correct faults, and verify the state of the system after recovery.
Jepsen(Apr 2016, 评估)
With the growth in usage of NoSQL data stores, and the growth in popularity of polyglot approaches to persistence, teams now have many choices when it comes to storing their data. While this has brought many advantages, product behavior with flaky networks can introduce subtle (and not so subtle) issues that are often not well understood, even in some cases by the product developers themselves. The Jepsen toolkit and accompanying blog have become the de-facto reference for anyone looking to understand how different database and queuing technologies react under adverse conditions. Crucially, the approach to testing, which includes clients in the transactions, shines a spotlight on possible failure modes for many teams building microservices.
acs-engine(Nov 2018, 试验)
Azure Container Service Engine (acs-engine) is an Azure Resource Manager (ARM) template generator. The required configurations of the cluster are defined in a JSON file; acs-engine reads these cluster definitions and generates a number of files that can be consumed by ARM. The tool also provides flexibility to choose different orchestrators—including Kubernetes, DC/OS, OpenShift, Swarm mode and Swarm—and to configure features and agents of the cluster. We’ve been using acs-engine in a number of projects and would recommend it for managing clusters in Azure Container Service.
Data-hungry packages(Nov 2018, 暂缓)
Data-hungry packages are solutions that require absorption of data into themselves in order to function. In some cases they may even require that they become the "master" for that data. Once the data is owned by the package, that software becomes the only way to update, change or access the data. The data-hungry package might solve a particular business problem such as ERP. However, inventory or finance "data demands" placed upon an organization will often require complex integration and changes to systems that lie well outside of the original scope.
Generic cloud usage(Nov 2018, 暂缓)
The major cloud providers have become increasingly competitive in their pricing and the rapid pace of releasing new features. This leaves consumers in a difficult place when choosing and committing to a provider. Increasingly, we're seeing organizations prepare to use "any cloud" and to avoid vendor lock-in at all costs. This, of course, leads to generic cloud usage. We see organizations limiting their use of the cloud to only those features common across all cloud providers—thereby missing out on the providers' unique benefits. We see organizations making large investments in home-grown abstraction layers that are too complex to build and too costly to maintain to stay cloud agnostic. The problem of lock-in is real. We recommend approaching this problem with a multicloud strategy that evaluates the migration cost and effort of capabilities from one cloud to another, against the benefits of using cloud-specific features. We recommend increasing the portability of the workloads by shipping the applications as widely adopted Docker containers: use open source security and identity protocols to easily migrate the identity of the workloads, a risk-commensurate vendor strategy to maintain cloud independence only where necessary and Polycloud to mix and match services from different providers where it makes sense. In short, shift your approach from a generic cloud usage to a sensible multicloud strategy.
Generic cloud usage(May 2018, 暂缓)
The major cloud providers continue to add new features to their clouds at a rapid pace, and under the banner of Polycloud we've suggested using multiple clouds in parallel, to mix and match services based on the strengths of each provider’s offerings. Increasingly, we're seeing organizations prepare to use multiple clouds — not to benefit from individual provider’s strengths, though, but to avoid vendor "lock-in" at all costs. This, of course, leads to generic cloud usage , only using features that are present across all providers, which reminds us of the lowest common denominator scenario we saw 10 years ago when companies avoided many advanced features in relational databases in an effort to remain vendor neutral. The problem of lock-in is real. However, instead of treating it with a sledgehammer approach, we recommend looking at this problem from the perspective of exit costs and relate those to the benefits of using cloud-specific features.
Request-response events in user-facing workflows(Nov 2018, 暂缓)
On a number of occasions we have seen system designs that use request-response events in user-facing workflows. In these cases, the UI is blocked or the user has to wait for a new page to load until a corresponding response message to a request message is received. The main reasons cited for designs like this are performance or a unified approach to communication between backends for synchronous and asynchronous use cases. We feel that the increased complexity—in development, testing and operations—far outweighs the benefit of having a unified approach, and we strongly suggest to use synchronous HTTP requests when synchronous communication between backend services is needed. When implemented well, communication using HTTP rarely is a bottleneck in a distributed system.
SAFE stack(Nov 2018, 评估)
The SAFE stack —short for Suave, Azure, Fable, and Elmish—brings a number of technologies into a coherent stack for web development. It's built around the F# programming language, both on the server side and in the browser, and therefore has a focus on functional, type-safe programming with an asynchronous approach. It offers productivity features such as hot reloading and lets you substitute parts of the stack, for example, the server-side web framework or the cloud provider.
MMKV(Nov 2018, 试验)
An open source framework developed by WeChat, MMKV provides fast key-value storage for mobile apps. It uses iOS memory-mapping features to avoid the need to explicitly save changes and is extremely fast and performant. In the event of an unexpected crash, MMKV allows the app to restore the data quickly.
Multi-account cloud setup(Nov 2018, 试验)
On-demand self-service is a key characteristic (and benefit) of cloud computing. When large-scale service landscapes are deployed using a single account, rules and processes around usage of that account become necessary, often involving approval steps that increase turnaround time. A better approach is a multi-account cloud setup where several accounts are used, in the extreme one account per team. This does add overhead in other places, for example, ensuring shared billing, enabling communication between VPCs and managing the relationship with the cloud provider. However, it often accelerates development and it usually improves security, because single-service accounts are easier to audit and, in the case of a breach, the impact is greatly reduced. Having multiple accounts also reduces stickiness, because an account provides a good boundary for services that can be moved en bloc to another cloud provider.
AWS(Nov 2018, 试验)
We first placed AWS in Adopt seven years ago, and the breadth, depth and reliability of its services have improved in leaps and bounds since then. However, we're now moving AWS back into Trial, not because of any deficiencies in its offering, but because its competitors, GCP and Azure, have matured considerably and selecting a cloud provider has become increasingly complex. We reserve Adopt for when we see a clear winner in a field. For many years, AWS was the default choice, but we now feel that organizations should make a balanced selection across cloud providers that takes into account their geographic and regulatory footprint, their strategic alignment (or lack thereof) with the providers, and, of course, the fit between their most important needs and the cloud providers' differentiating products.
AWS(Mar 2012, 采纳)
While it can be all too easy to ignore geographical location of cloud-based services, for legal and technical reasons it can be a serious constraint when considering appropriate platforms. With the recently announced Brazil and Singapore regions, Amazon has made AWSbased systems more viable for people in areas previously poorly served by IaaS providers. In addition, they continue to add features to existing services, such as VPC. We remain confident in recommending AWS for those situations where flexibility in provisioning resources is key.
AWS(Jul 2011, 采纳)
Amazon continues to evolve the AWS cloud with services such as RDB, making it even easier to engineer and deploy cloud-based applications. Not every AWS feature is as mature as EC2 and S3, so you should carefully evaluate which AWS components to use. We feel comfortable recommending AWS where elasticity or on-demand computing are required.
Google Cloud Platform(Nov 2018, 试验)
As Google Cloud Platform (GCP) has expanded in terms of available geographic regions and maturity of services, customers globally can now seriously consider it for their cloud strategy. In some areas, GCP has reached feature parity with its main competitor, Amazon Web Services, while in other areas it has differentiated itself—notably with accessible machine learning platforms, data engineering tools, and a workable Kubernetes as a service solution (GKE). In practice, our teams have nothing but praise for the developer experience working with the GCP tools and APIs.
Google Cloud Platform(May 2018, 试验)
As Google Cloud Platform (GCP) has expanded in terms of available geographic regions and maturity of services, customers globally can now seriously consider it for their cloud strategy. In some areas, GCP has reached feature parity with its main competitor, Amazon Web Services, while in other areas it has differentiated itself — notably with accessible machine learning platforms, data engineering tools, and a workable Kubernetes as a service solution (GKE). In practice, our teams have nothing but praise for the developer experience working with the GCP tools and APIs.
Google Cloud Platform(Nov 2017, 试验)
As Google Cloud Platform (GCP) has expanded in terms of available geographic regions and maturity of services, customers globally can now seriously consider it for their cloud strategy. In some areas, GCP has reached feature parity with its main competitor, Amazon Web Services, while in other areas it has differentiated itself — notably with accessible machine learning platforms, data engineering tools, and a workable Kubernetes as a service solution (GKE). In practice, our teams have nothing but praise for the developer experience working with the GCP tools and APIs.
TICK Stack(Nov 2018, 试验)
TICK Stack is a collection of open source components that combine to deliver a platform for easily storing, visualizing and monitoring time series data such as metrics and events. The components are: Telegraf, a server agent for collecting and reporting metrics; InfluxDB, a high-performance time series database; Chronograf, a user interface for the platform; and Kapacitor, a data-processing engine that can process, stream and batch data from InfluxDB. Unlike Prometheus, which is based on the pull model, TICK Stack is based on the push model of collecting data. The heart of the system is the InfluxDB component, which is one of the best time series databases. The stack is backed by InfluxData and although you need the enterprise version for features such as database clustering, it's still a fairly good choice for monitoring. We're using it in a few places in production and have had good experiences with it.
TICK Stack(May 2018, 评估)
TICK Stack is a platform composed of open source components which makes collection, storage, graphing and alerting on-time series data such as metrics and events easy. The components of the TICK Stack are: Telegraf, a server agent for collecting and reporting metrics; InfluxDB, a high-performance time series database; Chronograf, a user interface for the platform; and Kapacitor, a data-processing engine that can process, stream and batch data from InfluxDB. Unlike Prometheus, which is based on the Pull model, the TICK Stack is based on the Push model of collecting data. The heart of the system is the InfluxDB component which is one of the best time series databases. This stack is backed by InfluxData and needs the enterprise version for features such as DB clustering, but it’s still a fairly good choice for monitoring. We’re using it in a few places in production and have had good experiences with it.
Grafeas(Nov 2018, 评估)
We're continually on the lookout for tools and techniques that allow delivery teams to work independently from the rest of a larger organization while staying within its security and risk guardrails. Grafeas is such a tool. It lets organizations publish authoritative metadata about software artifacts—Docker images, libraries, packages—that is then accessible from build scripts or other automated compliance controls. The access control mechanisms allow for a separation of responsibility between the teams that publish approvals or vulnerabilities and the teams that build and deploy software. Although several organizations, including Google and JFrog, use Grafeas in their workflows, note that the tool is still in alpha.
Risk-commensurate vendor strategy(Nov 2018, 试验)
Often, in an effort to outsource risk to their suppliers, businesses look for "one throat to choke" on their most critical and risky system implementations. Unfortunately, this gives them fewer solution choices and less flexibility. Instead, businesses should look to maintain the greatest vendor independence where the business risk exposure is highest. We see a new risk-commensurate vendor strategy emerging that encourages investment to maintain vendor independence for highly critical business systems. Less critical business functions can take advantage of the streamlined delivery of a vendor-native solution because it allows them to absorb more easily the impact of losing that vendor. This trade-off has become apparent as the major cloud providers have expanded their range of service offerings. For example, using AWS Secret Management Service can speed up initial development and has the benefit of ecosystem integration, but it will also add more inertia if you ever need to migrate to a different cloud provider than it would if you had implemented, for example, Vault.
Incremental delivery with COTS(Nov 2018, 评估)
At ThoughtWorks, as early adopters and leaders in the agile space, we've been proponents of the practice of incremental delivery. We've also advised many clients to look at off-the-shelf software through a "Can this be released incrementally?" lens. This has often been difficult because of the big-bang approach of most vendors which usually involves migrating large amounts of data. Recently, however, we've also had success using incremental delivery with COTS (commercial off-the-shelf), launching specific business processes incrementally to smaller subsets of users. We recommend you assess whether you can apply this practice to the vendor software of your choice, to help reduce the risks involved in big-bang deliveries.
Shared VPC(Nov 2018, 试验)
As we've gained more experience with the public cloud across organizations large and small, certain patterns have emerged. One of those patterns is a virtual private cloud network managed at the organizational level and divided into smaller subnets under the control of each delivery team. This is closely related to the idea of multiaccount cloud setup and helps to partition an infrastructure along team bounds. After configuring this setup many times using VPCs, subnets, security groups and NACLs, we really like Google's notion of the shared VPC. Shared VPC makes organizations, projects, VPCs and subnets first-class entities in network configurations. VPCs can be managed by an organization's administrators who can delegate subnet administration to projects. Projects can then be explicitly associated with subnets in the VPC. This simplifies configuration and makes security and access control more transparent.
Glitch(Nov 2018, 评估)
We've been intrigued by Glitch, which is a collaborative online development environment that lets you easily copy and adapt (or "remix") existing web apps or create your own. Rooted in the "tinkerer" ethos, it's ideal for people learning to code but it has the capability to support more complex applications. The main focus is on JavaScript and Node.js, but it also has limited support for other languages. With integrated live editing, hosting, sharing and automatic source versioning, Glitch offers a refreshing and distinctive take on collaborative programming.
Spek(Nov 2018, 评估)
The adoption of a new language typically spawns the emergence of new tools that support mature engineering practices such as test automation. Kotlin is no exception. Spek is a testing framework—inspired by well-known tools such as Cucumber, RSpec and Jasmine—that writes tests in Gherkin and Specification, allowing teams to bring mature practices such as behaviour-driven development into the Kotlin space.
Pre-commit downstream build checks(Nov 2018, 评估)
In more complex architectures and deployments, it may not be immediately obvious that a build that depends on the code currently being checked in is broken. Developers trying to fix a broken build could find themselves working against a moving target, as the build is continually triggered by upstream dependencies. Pre-commit downstream build checks is a very simple technique: have a pre-commit or pre-push script check the status of these downstream builds and alert the developer beforehand that a build is broken.
gVisor(Nov 2018, 评估)
gVisor is a user-space kernel for containers. It limits the host kernel surface accessible to the application without taking away access to all the features it expects. Unlike existing sandbox technologies, such as virtualized hardware (KVM and Xen) or rule-based execution (seccomp, SELinux and AppArmor), gVisor takes a distinct approach to container sandboxing by intercepting application system calls and acting as the guest kernel without the need for translation through virtualized hardware. gVisor includes an Open Container Initiative (OCI) runtime called runsc that integrates with Docker and provides experimental support for Kubernetes. gVisor is a relatively new project and we recommend assessing it for your container security landscape.
Rider(Nov 2018, 试验)
We've covered Visual Studio Code in the Radar since 2015, but it isn't the only cross-platform .NET Core IDE kid on the block anymore. Recently, Rider, which is part of the IDEA platform developed by JetBrains, has gained adoption, especially by those used to the speed and dexterity provided by ReSharper, which drives the refactoring in Rider. Rider, however, does more than ReSharper to bring the full IDEA platform to .NET and increase developer productivity. Regardless of your preferred platform, it's worth exploring Rider as it currently has the productivity edge on Visual Studio Code. It's also great to see the ecosystem alive and well, as competition ensures these tools continue to improve.
Microservice envy(Nov 2018, 暂缓)
Microservices has emerged as a leading architectural technique in modern cloud-based systems, but we still think teams should proceed carefully when making this choice. Microservice envy tempts teams to complicate their architecture by having lots of services simply because it's a fashionable architecture choice. Platforms such as Kubernetes make it much easier to deploy complex sets of microservices, and vendors are pushing their solutions to managing microservices, potentially leading teams further down this path. It's important to remember that microservices trade development complexity for operational complexity and require a solid foundation of automated testing, continuous delivery and DevOps culture.
Microservice envy(Nov 2015, 暂缓)
We remain convinced that microservices can offer significant advantages to organizations, in terms of improving team autonomy and faster frequency of change. The additional complexity that comes from distributed systems requires an additional level of maturity and investment. We are concerned that some teams are rushing in to adopting microservices without understanding the changes to development, test, and operations that are required to do them well. Our general advice remains simple. Avoid microservice envy  and start with one or two services before rushing headlong into developing more, to allow your teams time to adjust and understand the right level of granularity.
ArchUnit(Nov 2018, 试验)
ArchUnit is a Java testing library for checking architecture characteristics such as package and class dependencies, annotation verification and even layer consistency. We like that it runs as unit tests within your existing test setup, even though it supports only Java-based architectures. The ArchUnit test suite can be incorporated into a CI environment or a deployment pipeline, making it easier to implement fitness functions in an evolutionary architecture way.
ArchUnit(May 2018, 评估)
ArchUnit is a Java testing library for checking architecture characteristics such as package and class dependencies, annotation verification and even layer consistency. The fact that it runs as unit tests, within your existing test setup, pleases us, even though it's available for Java architectures only. The ArchUnit test suite can be incorporated into a CI environment or a deployment pipeline, making it easier to implement fitness functions in an evolutionary architecture way.
Resin.io(Nov 2018, 评估)
Resin.io is an Internet of Things (IoT) platform that does one thing and does it well: it deploys containers onto devices. Developers use a software as a service (SaaS) portal to manage devices and assign applications, defined by Dockerfiles, to them. The platform can build containers for various hardware types and deploys the images over the air. For the containers, Resin.io uses balena, an engine based on the Moby framework created by Docker. The platform is still under development, has some rough edges and lacks some features (e.g., working with private registries), but the current feature set, including the option to ssh into a container on a device from the web portal, points toward a promising future.
CockroachDB(Nov 2018, 评估)
CockroachDB is an open source distributed database inspired by the white paper Spanner: Google's distributed database. In CockroachDB, data is automatically divided into ranges, usually 64MB, and distributed across nodes in the cluster. Each range has a consensus group and, because it uses the Raft consensus algorithm, the data is always kept in sync. With its unique design, CockroachDB provides distributed transactions and geo-partitioning while still supporting SQL. Unlike Spanner, which relies on TrueTime with atomic clock for linearizability, CockroachDB uses NTP for clock synchronization and provides serializability as the default isolation level. If you're working with structured data that fits in a single node, then choose a traditional relational database. However, if your data needs to scale across nodes, be consistent and survive failures, then we recommend you take a closer look at CockroachDB.
Master data management(Nov 2018, 暂缓)
Master data management (MDM) is a classic example of the enterprise "silver bullet" solution: it promises to solve an apparently related class of problems in one go. Through creating a centralized single point of change, coordination, test and deployment, MDM solutions negatively impact an organization's ability to respond to business change. Implementations tend to be long and complex, as organizations try to capture and map all "master" data into the MDM while integrating the MDM solution into all consuming or producing systems.
Apache Atlas(Nov 2018, 试验)
With the growing and diverse data needs of enterprises comes a growing need for metadata management. Apache Atlas is a metadata management framework that fits the data governance needs of enterprises. Atlas provides capabilities to model types for metadata, classify data assets, track the data lineage and enable data discovery. However, when building a metadata management platform, we need to be careful not to repeat the mistakes of master data management.
"Handcranking" of Hadoop clusters using config management tools(Nov 2018, 暂缓)
When organizations choose a vanilla Hadoop or Spark distribution instead of one of the vendor distributions, they have to decide how they want to provision and manage the cluster. Occasionally, we see "handcranking" of Hadoop clusters using config management tools such as Ansible, Chef and others. Although these tools are great at provisioning immutable infrastructure components, they're not very useful when you have to manage stateful systems and can often lead to significant effort trying to manage and evolve clusters using these tools. We instead recommend using tools such as Ambari to provision and manage your stateful Hadoop or Spark clusters.
Stanford CoreNLP(Nov 2018, 评估)
We have more and more projects that require unstructured data processing. To extract meaningful business information from text data is a key technique. Stanford CoreNLP is a Java-based set of natural language processing tools. It supports named-entity recognition, relationship extraction, sentiment analysis and text classification as well as multiple languages, including English, Chinese and Arabic. We also find tools usable to label corpus and training models for our scenario. With Stanford CoreNLP, we were able to use the latest research in the field of NLP to solve various business problems.
Polly.js(Nov 2018, 评估)
Polly.js is a simple tool that helps teams test JavaScript websites and applications. Our teams particularly like that it enables them to intercept and stub HTTP interactions which allows for easier and faster testing of JavaScript code without having to spin up dependent services or components.
troposphere(Nov 2018, 评估)
We're trying out troposphere as a way of defining the infrastructure as code on AWS for our projects that use AWS CloudFormation instead of Terraform. troposphere is a Python library that allows us to write Python code to generate CloudFormation JSON descriptions. What we like about troposphere is that it facilitates catching JSON errors early, applying type checking, and unit testing and DRY composition of AWS resources.
troposphere(May 2018, 评估)
We’re trying out troposphere as a way of defining the infrastructure as code on AWS for our projects where AWS CloudFormation is used instead of Terraform. troposphere is a Python library that allows us to write Python code to generate CloudFormation JSON descriptions. What we like about troposphere is that it facilitates catching JSON errors early, applying type checking, and unit testing and DRY composition of AWS resources.
Visual Studio Code(Nov 2018, 试验)
Visual Studio Code is Microsoft's free IDE editor, available across platforms. We've had good experience using this for front-end development using React and TypeScript, and back-end languages such as GoLang, without having to switch between different editors. The tooling, language support and extensions for Visual Studio Code continue to soar and get better. We'd particularly like to call out Visual Studio Live Share for real-time collaboration and remote pairing. While complex projects in statically typed languages, such as Java, .NET or C++, will likely find better support from the more mature IDEs from Microsoft or Jetbrains, we find that Visual Studio Code is increasingly becoming a tool of choice among infrastructure and front-end development teams.
Visual Studio Code(Nov 2015, 评估)
Visual Studio Code is Microsoft’s free IDE editor, available across platforms. We find the version-control integration with Git very beneficial to promoting continuous integration practices. Visual Studio Code also provides a means of integrating with external tools via tasks, with autodetection of grunt/gulp tasks eliminating the need for running grunt/gulp tasks via terminals and simply using the editor. With the growth of the Docker ecosystem, this IDE offers support for the dockerfile with snippets and definitions of valid commands.
PredictionIO(Nov 2018, 评估)
PredictionIO is an open source machine-learning server. Developers and data scientists can use it to build intelligent applications for prediction. Like all intelligent applications, PredictionIO has three parts: data collection and storage, model training, and model deployment and expose service. Developers could focus on implementing data-processing logic, model algorithm and prediction logic based on the corresponding interfaces and liberate themselves from data storage and model training deployment. In our experience, PredictionIO can support both small and large volumes of data with low concurrency. We mostly use PredictionIO to build predictive services for small and medium-sized enterprises or as a proof of concept when building more complex, customized prediction engines.
Bounded Buy(Nov 2018, 试验)
Most organizations that don't have the resources to custom-build their software will select out-of-the-box or SaaS solutions to meet their requirements. All too often, however, these solutions tend to aggressively expand their scope to entangle themselves into every part of your business. This blurs integration boundaries and makes change less predictable and slow. To mitigate this risk, we recommend that organizations develop a clear target capability model and then employ a strategy we call Bounded Buy —that is, only select vendor products that are modular and decoupled and can be contained within the Bounded Context of a single business capability. This modularity and independent deliverability should be included in the acceptance criteria for a vendor selection process.
Observability as code(Nov 2018, 试验)
The observability is an integral part of operating a distributed and microservices architecture. We rely on different system outputs such as distributed tracing, aggregate logs and metrics to infer the internal state of the distributed components, diagnose where the problems are and get to the root cause. An important aspect of an observability ecosystem is monitoring—visualizing and analyzing the system's output—and alerting when unexpected conditions are detected. Traditionally, configuration of monitoring dashboards and setting up alerts is done through GUI-based point-and-click systems. This approach leads to nonrepeatable dashboard configurations, no ability to continuously test and adjust alerts to avoid alert fatigue or missing out on important alerts, and drift from organizational best practices. We highly recommend treating your observability ecosystem configurations as code, called observability as code , and adopt infrastructure as code for your monitoring and alerting infrastructure. Choose observability products that support configuration through version-controlled code and execution of APIs or commands via infrastructure CD pipelines. Observability as code is an often-forgotten aspect of infrastructure as code and, we believe, crucial enough to be called out.
Versioning data for reproducible analytics(Nov 2018, 试验)
When it comes to large-scale data analysis or machine intelligence problems, being able to reproduce different versions of analysis done on different data sets and parameters is immensely valuable. To achieve reproducible analysis, both the data and the model (including algorithm choice, parameters and hyperparameters) need to be version controlled. Versioning data for reproducible analytics is a relatively trickier problem than versioning models because of the data size. Tools such as DVC help in versioning data by allowing users to commit and push data files to a remote cloud storage bucket using a git-like workflow. This makes it easy for collaborators to pull a specific version of data to reproduce an analysis.
RPA(Nov 2018, 暂缓)
Robotic process automation ( RPA ) is a key part of many digital transformation initiatives, as it promises to deliver cost savings without having to modernize the underlying architecture and systems. The problem with this approach of focusing only on automating business processes, without addressing the underlying software systems or capabilities, is that this can make it even harder to change the underlying systems by introducing additional coupling. This makes any future attempts to address the legacy IT landscape even more difficult. Very few systems can afford to ignore change and hence RPA efforts need to be coupled with appropriate legacy modernization strategies.
Ocelot(Nov 2018, 评估)
Ocelot is a .NET API gateway. After three years of development, Ocelot has built a relatively complete feature set and an active community. Although there is no dearth of excellent API gateways (e.g., Kong), the .NET community appears to prefer Ocelot when building microservices. Part of the reason is that Ocelot integrates well with the .NET ecosystem (e.g., with IdentityServer). Another reason may be that the .NET community has extended Ocelot to support communication protocols such as gRPC, Orleans and WebSocket.
Event Storming(Nov 2018, 采纳)
When organizations move toward microservices, one of the main drivers is the hope for faster time to market. However, this aspiration only tends to be realized when services (and their supporting teams) are cleanly sliced along long-lived business domain boundaries. Otherwise meaningful features will naturally require tight coordination between multiple teams and services, introducing natural friction in competing roadmap prioritization. The solution to this problem is good domain modeling, and event storming has rapidly become one of our favorite methods for rapidly identifying the key concepts in a problem space and aligning a variety of stakeholders in the best way to slice potential solutions.
Event Storming(Apr 2016, 试验)
Event Storming is a useful way to do rapid "outside-in" domain modeling: starting with the events that occur in the domain rather than a static data model. Run as a facilitated workshop, it focuses on discovering key domain events, placing them along a timeline, identifying their triggers and then exploring their relationships. This approach is particularly useful for people taking an Event Sourced approach. Getting the right people in the room is important - a blend of business and technical people who bring both the questions and the answers. Ensuring that you have enough wall space for modeling is the second key to success. Look to discover the big picture, with the goal of collectively understanding the domain in all of its complexity, before diving into solutions.
Event Storming(Nov 2015, 试验)
Event Storming is a useful way to do rapid “outside-in” domain modeling: starting with the events that occur in the domain rather than a static data model. Run as a facilitated workshop, it focuses on discovering key domain events, placing them along a timeline, identifying their triggers and then exploring their relationships. This approach is particularly useful for people taking a CQRS or Event Sourcing approach. Getting the right people in the room is important - a blend of business and technical people who bring both the questions and the answers. Ensuring that you have enough wall space for modeling is the second key to success. Look to discover the big picture, with the goal of collectively understanding the domain in all of its complexity, before diving into solutions.
Q#(Nov 2018, 评估)
Quantum computing currently exists in a twilight zone of being available for testing without having arrived yet. While we're still waiting for the hardware to arrive, we can experiment with and learn from languages and simulators. Although IBM and others have been making good progress, we've paid particular attention to Microsoft's efforts based around the Q# language and its simulator (32 qubits locally and 40 on Azure). If you want to start wrapping your head around the potential future of programming, check out their set of samples on GitHub.
Azure(Nov 2018, 试验)
Microsoft has steadily improved Azure and today not much separates the core cloud experience provided by the major cloud providers—Amazon, Google and Microsoft. The cloud providers seem to agree and seek to differentiate themselves in other areas such as features, services and cost structure. Microsoft is the provider who shows real interest in the legal requirements of European companies. They’ve a nuanced and plausible strategy, including unique offerings such as Azure Germany and Azure Stack, which gives some certainty to European companies in anticipation of the GDPR and possible legislative changes in the United States.
Azure(May 2018, 试验)
Microsoft has steadily improved Azure and today not much separates the core cloud experience provided by the major cloud providers – Amazon, Google and Microsoft. The cloud providers seem to agree and seek to differentiate themselves in other areas such as features, services and cost structure. Microsoft is the provider who shows real interest in the legal requirements of European companies. They’ve a nuanced and plausible strategy, including unique offerings such as Azure Germany and Azure Stack, which gives some certainty to European companies in anticipation of the GDPR and possible legislative changes in the United States.
Azure(May 2013, 评估)
Microsoft’s Azure cloud platform continues to play catchup with more mature clouds such as AWS, but we’ve been impressed with how Microsoft has responded to market demands. As with most Microsoft solutions it continues to be a contender and worth evaluating.
Azure(Jan 2011, 评估)
The Cloud continues to be of interest to us, with Software as a Service the most mature cloud component. Platform and Infrastructure as service offerings have reached different levels of maturity, and we reflect that in our placement of EC2, Google App Engine and Azure.
Rook(Nov 2018, 评估)
Rook is an open source cloud native storage orchestrator for Kubernetes. Rook integrates with Ceph and brings File, Block and Object storage systems into the Kubernetes cluster, running them seamlessly alongside other applications and services that are consuming the storage. By using Kubernetes operators, Rook orchestrates Ceph at the control plane and stays clear of the data path between applications and Ceph. Storage is one of the important components of cloud-native computing and we believe that Rook, though still an incubating-level project at CNCF, takes us a step closer to self-sufficiency and portability across public cloud and on-premise deployments.
Archery(Nov 2018, 试验)
We're seeing significant advances in security tooling integration with modern software delivery processes. Archery is an open source tool with an active community that's doing a good job of pulling together a collection of other tools, including Zap. Designed primarily for web applications, Archery makes it easy to integrate security tooling into your build and deployment systems. Its dashboards also let you track vulnerabilities as well as application and network scans.
Codefresh(Nov 2018, 评估)
Codefresh is a hosted CI server similar to CircleCI or Buildkite. It's container-centric, making Dockerfiles and container-hosting clusters first-class entities. We like that the tool encourages a pipelined delivery approach and supports branching and merging. Early reports from our teams are positive, but we've yet to see how it works for larger projects and complex pipelines.
Nameko(Nov 2018, 评估)
One insight we gained after talking with our teams is that Python is making a comeback across many technology domains. In fact, it's well on its way to become the most-used programming language. In part, this is driven by its adoption by data scientists and in machine learning, but we also see teams adopting it to build microservices. Nameko is a super-lightweight microservices framework and an alternative to Flask for writing services. Unlike Flask, Nameko only has a limited set of features that includes WebSocket, HTTP and AMQP support. We also like its focus on testability. If you don't need features such as templating that Flask provides, then Nameko is worth a look.
Heptio Ark(Nov 2018, 评估)
Heptio Ark is a tool for managing disaster recovery for Kubernetes clusters and persistent volumes. Ark is easy to use and configure and lets you back up and restore your clusters through a series of checkpoints. With Ark you can significantly reduce recovery time in case of an infrastructure failure, easily migrate Kubernetes resources from one cluster to another and replicate the production environment for testing and troubleshooting. Ark supports key backup storage providers (including AWS, Azure and Google Cloud) and, as of version 0.6.0, a plugin system that adds compatibility for additional backup and volume storage platforms. Managed Kubernetes environments, such as GKE, provide these services out of the box. However, if you're operating Kubernetes either on premise or in the cloud, take a closer look at Heptio Ark for disaster recovery.
Headless Firefox(Nov 2018, 试验)
Headless Firefox has the same maturity as that of Headless Chrome for front-end test. Similar to Headless Chrome, with Firefox in headless mode we now get to enjoy browser tests without the visible UI components, executing the UI tests suite much faster.
Headless Firefox(May 2018, 评估)
When developing front-end applications, we've mentioned Headless Chrome as a better alternative to PhantomJS for front-end testing in a previous edition of the Radar. Now we suggest assessing Headless Firefox as a viable option in this area. In the same way as Headless Chrome, Firefox in a headless mode runs the browser without the visible UI components, executing the UI tests suite much faster.
Chaos Katas(Nov 2018, 评估)
Chaos Katas is a technique that our teams have developed to train and upskill infrastructure and platform engineers. It combines Chaos Engineering techniques—that is, creating failures and outages in a controlled environment—with the systematic teaching and training approach of Kata. Here, Kata refers to code patterns that trigger controlled failures, allowing engineers to discover the problem, recover from the failure, run postmortem and find the root cause. Repeated execution of Katas helps engineers to internalize their new skills.
Security Chaos Engineering(Nov 2018, 试验)
Although we've had mostly new blips in this edition of the Radar, we think it's worth continuing to call out the usefulness of Security Chaos Engineering. We've moved it to Trial because the teams using this technique are confident that the security policies they have in place are robust enough to handle common security failure modes. Still, proceed with caution when using this technique—we don't want our teams to become desensitized to these issues.
Security Chaos Engineering(May 2018, 评估)
We’ve previously talked about the technique of Chaos Engineering in the Radar and the Simian Army suite of tools from Netflix that we’ve used to run experiments to test the resilience of production infrastructure. Security Chaos Engineering broadens the scope of this technique to the realm of security. We deliberately introduce false positives into production networks and other infrastructure — build-time dependencies, for example — to check whether procedures in place are capable of identifying security failures under controlled conditions. Although useful, this technique should be used with care to avoid desensitizing teams to security problems.
Low-code platforms(Nov 2018, 暂缓)
Low-code platforms use graphical user interfaces and configuration in order to create applications. Unfortunately, low-code environments are promoted with the idea that this means you no longer need skilled development teams. Such suggestions ignore the fact that writing code is just a small part of what needs to happen to create high-quality software—practices such as source control, testing and careful design of solutions are just as important. Although these platforms have their uses, we suggest approaching them with caution, especially when they come with extravagant claims for lower cost and higher productivity.
git-secrets(Nov 2018, 试验)
Security continues to be paramount, and inadvertently checking credentials and other secrets into source control is a major attack vector. git-secrets is a simple tool that prevents you from committing passwords and other sensitive information to a git repository. It can also scan all historical revisions before making a repository public, if you want to ensure you've never accidentally checked in a credential. git-secrets comes with built-in support for common AWS keys and credentials and can be set up quickly for other providers too.
Wallaby.js(Nov 2018, 评估)
We all obsess about fast feedback during test-driven development and we're always looking for new ways to make this even faster. Wallaby.js is a commercial extension for popular editors that provides continuous execution of JavaScript unit tests, highlighting the results in line next to your code. The tool identifies and runs the minimum set of tests affected by each code change and lets you run tests continuously as you type.
Layered microservices architecture(Nov 2018, 暂缓)
A defining characteristic of a microservices architecture is that system components and services are organized around business capabilities. Regardless of size, microservices encapsulate a meaningful grouping of functionality and information to allow for the independent delivery of business value. This is in contrast to earlier approaches in service architecture which organized services according to technical characteristics. We've observed a number of organizations who've adopted a layered microservices architecture , which in some ways is a contradiction in terms. These organizations have fallen back to arranging services primarily according to a technical role, for example, experience APIs, process APIs or system APIs. It's too easy for technology teams to be assigned by layer, so delivering any valuable business change requires slow and expensive coordination between multiple teams. We caution against the effects of this layering and recommend arranging services and teams primarily according to business capability.
Prettier(Nov 2018, 试验)
Prettier is an opinionated, automated code formatter for JavaScript (with growing support for other languages). By enforcing its own opinionated formatting style it increases consistency and readability and reduces developer effort both on formatting and engaging in wasteful team debates about code style. Even though you may disagree with the stylistic choices enforced by Prettier, we find that the benefits to the team generally outweigh small style issues. Prettier can be used with a precommit hook or an IDE plugin. As with any formatter, a one-time reformatting of your codebase can confuse your version control history, but we feel that's a minor drawback. We particularly like the way Prettier flips the linter-based approach and, borrowing from gofmt, instead of validating your code, it ensures that your code will always be valid.
kube-bench(Nov 2018, 评估)
kube-bench is an example of an infrastructure configuration scanner that automates checking your Kubernetes configuration against the CIS benchmark for K8s. It covers user authentication, permissions and secure data among other areas. Our teams have found kube-bench valuable in the identification of vulnerable configurations.
Embedded mobile mocks(May 2018, 评估)
When developing mobile applications, our teams often find themselves without an external server for testing apps. Setting up an over-the-wire mock may be a good fit for this particular problem. Developing the HTTP mocks and compiling them into the mobile binary for testing — embedded mobile mocks — enables teams to test their mobile apps when disconnected and with no external dependencies. This technique may require creating an opinionated library based on both the networking library used by the mobile app and your usage of the underlying library.
Corda(May 2018, 评估)
After thorough exploration, R3, an important player in the blockchain space, realized that blockchain doesn't fit their purpose well, so they created Corda. Corda is a distributed ledger technology (DLT) platform focused on the financial field. R3 have a very clear value proposition and know that their problem requires a pragmatic technology approach. This matches our own experience; current blockchain solutions may not be the reasonable choice for some business cases, due to mining costs and operational inefficiency. Although the development experience we have on Corda thus far has not been the smoothest, APIs are still unstable after v1.0 release, we expect to see the DLT space mature further.
Corda(Nov 2017, 评估)
After thorough exploration, R3, an important player in the blockchain space, realized that blockchain doesn't fit their purpose well, so they created Corda. Corda is a distributed ledger technology (DLT) platform focused on the financial field. R3 have a very clear value proposition and know that their problem requires a pragmatic technology approach. This matches our own experience; current blockchain solutions may not be the reasonable choice for some business cases, due to mining costs and operational inefficiency. Although the development experience we have on Corda thus far has not been the smoothest, APIs are still unstable after v1.0 release, we expect to see the DLT space mature further.
Hyperapp(May 2018, 评估)
Given the number of JavaScript application frameworks we’ve featured in the Radar over the years we asked ourselves, do we really need to call out another one? We decided that Hyperapp is worth a look because of its minimalist approach. It has a very small footprint, less than 1KB, and yet covers all the essential functionality for writing a web application. This is only possible with an elegant design that reduces everything to the absolute minimum, which in turn makes it easier to understand and use the framework. Despite being relatively new, it has attracted a good-size community and we recommend to at least consider it when picking a framework for a new application.
Swashbuckle for .NET Core(May 2018, 评估)
In the current state of technology services, exposing RESTFul APIs is increasingly adopted and API documentation is very important for consumers. In this space, Swagger has been largely used across teams and we would like to highlight Swashbuckle for .NET Core. Swashbuckle for .NET Core is a tool that generates living API documentation in Swagger, based on the code for .NET Core projects. When using it, you can also explore and test operations of APIs through its UI.
OpenZeppelin(May 2018, 试验)
Security is the cornerstone of the blockchain economy. In the last issue of the Radar, we highlighted the importance of testing and auditing smart contracts dependencies. OpenZeppelin is a framework to help build secure smart contracts in Solidity. The team behind OpenZeppelin summed up a series of pitfalls and best practices around smart contracts' security and embedded these experiences into the source code. The framework is well reviewed and validated by the open source community. We recommend the use of OpenZeppelin instead of writing your own implementation of the ERC20/ERC721 token. OpenZeppelin is also integrated with Truffle.
BackstopJS(May 2018, 试验)
We've been enjoying BackstopJS for visual regression testing of web applications. The configurable viewports and ability to adjust tolerances are particularly useful, as is the visual comparison tool, which makes it easier to spot minor variations. It has good scriptability and the option to run in Headless Chrome, PhantomJS and SlimerJS. We find it particularly helpful when running it against living component style guides.
Ethereum for decentralized applications(May 2018, 评估)
Blockchains have been widely hyped as the panacea for all things fintech, from banking to digital currency to supply chain transparency. We’ve previously featured Ethereum because of its feature set, which includes smart contracts. Now, we're seeing more development using Ethereum for decentralized applications in other areas. Although this is still a very young technology, we're encouraged to see it being used to build decentralized applications beyond cryptocurrency and banking.
Ethereum for decentralized applications(Nov 2017, 评估)
Blockchains have been widely hyped as the panacea for all things fintech, from banking to digital currency to supply chain transparency. We’ve previously featured Ethereum because of its feature set, which includes smart contracts. Now, we're seeing more development using Ethereum for decentralized applications in other areas. Although this is still a very young technology, we're encouraged to see it being used to build decentralized applications beyond cryptocurrency and banking.
CVXPY(May 2018, 试验)
It’s surprising how many problems can be expressed as mathematical optimization problems and often convex problems that can be efficiently solved. CVXPY is an open source Python-embedded modeling language for convex optimization problems. It’s maintained by academics at Stanford University and offers a batteries-included install for several open source and commercial solvers. The documentation includes many examples which should inspire developers to use it. It’s particularly useful for prototyping solutions even though commercially licensed solvers, such Gurobi or IBM CPLEX, may be required. In most cases though, it suffices by itself. However, the same group has written many extension packages such as DCCP and related software such as CVXOPT based on recent advances in optimization.
Language Server Protocol(May 2018, 评估)
Much of the power of sophisticated IDEs comes from their ability to parse a program into an abstract syntax tree (AST) and then use that AST for program analysis and manipulation. This supports features such as autocomplete, finding callers and refactoring. Language servers pull this capability into a process that allows any text editor to access an API to work with the AST. Microsoft has led the creation of the Language Server Protocol (LSP), harvested from their OmniSharp and TypeScript Server projects.Any editor that uses this protocol can work with any language that has an LSP-compliant server. This means we can keep using our favorite editors without forgoing the rich text editing modes of many languages — much to the delight of our Emacs addicts.
Language Server Protocol(Nov 2017, 评估)
Much of the power of sophisticated IDEs comes from their ability to parse a program into an abstract syntax tree (AST) and then use that AST for program analysis and manipulation. This supports features such as autocomplete, finding callers and refactoring. Language servers pull this capability into a process that allows any text editor to access an API to work with the AST. Microsoft has led the creation of the Language Server Protocol (LSP), harvested from their OmniSharp and TypeScript Server projects.Any editor that uses this protocol can work with any language that has an LSP-compliant server. This means we can keep using our favorite editors without forgoing the rich text editing modes of many languages — much to the delight of our Emacs addicts.
Event streaming as the source of truth(May 2018, 评估)
As event streaming platforms, such as Apache Kafka, rise in popularity, many consider them as an advanced form of message queuing, used solely to transmit events. Even when used in this way, event streaming has its benefits over traditional message queuing. However, we're more interested in how people use event streaming as the source of truth with platforms (Kafka in particular) as the primary store for data as immutable events. A service with an Event Sourcing design, for example, can use Kafka as its event store; those events are then available for other services to consume. This technique has the potential to reduce duplicating efforts between local persistence and integration.
Event streaming as the source of truth(Nov 2017, 评估)
As event streaming platforms, such as Apache Kafka, rise in popularity, many consider them as an advanced form of message queuing, used solely to transmit events. Even when used in this way, event streaming has its benefits over traditional message queuing. However, we're more interested in how people use event streaming as the source of truth with platforms (Kafka in particular) as the primary store for data as immutable events. A service with an Event Sourcing design, for example, can use Kafka as its event store; those events are then available for other services to consume. This technique has the potential to reduce duplicating efforts between local persistence and integration.
Overambitious API gateways(May 2018, 暂缓)
We remain concerned about business logic and process orchestration implemented in middleware, especially where it requires expert skills and tooling while creating single points of scaling and control. Vendors in the highly competitive API gateway market are continuing this trend by adding features through which they attempt to differentiate their products. This results in overambitious API gateway products whose functionality — on top of what is essentially a reverse proxy — encourages designs that continue to be difficult to test and deploy. API gateways do provide utility in dealing with some specific concerns — such as authentication and rate limiting — but any domain smarts should live in applications or services.
Overambitious API gateways(Nov 2017, 暂缓)
We remain concerned about business logic and process orchestration implemented in middleware, especially where it requires expert skills and tooling while creating single points of scaling and control. Vendors in the highly competitive API gateway market are continuing this trend by adding features through which they attempt to differentiate their products. This results in overambitious API gateway products whose functionality — on top of what is essentially a reverse proxy — encourages designs that continue to be difficult to test and deploy. API gateways do provide utility in dealing with some specific concerns — such as authentication and rate limiting — but any domain smarts should live in applications or services.
Overambitious API gateways(Mar 2017, 暂缓)
One of our regular complaints is about business smarts implemented in middleware, resulting in transport software with ambitions to run critical application logic. Vendors in the highly competitive API gateway market continue to add features that differentiate their products. This results in overambitious API gateway products whose functionality—on top of what is essentially a reverse proxy—encourages designs that are difficult to test and deploy. API gateways can provide utility in dealing with some generic concerns—for example, authentication and rate-limiting—but any domain smarts such as data transformation or rule processing should live in applications or services where they can be controlled by product teams working closely with the domains they support.
Overambitious API gateways(Nov 2016, 暂缓)
One of our regular complaints is about business smarts implemented in middleware, resulting in transport software with ambitions to run critical application logic. Vendors in the highly competitive API gateway market continue to add features that differentiate their products. This results in overambitious API gateway products whose functionality—on top of what is essentially a reverse proxy—encourages designs that are difficult to test and deploy. API gateways can provide utility in dealing with some generic concerns—for example, authentication and rate-limiting—but any domain smarts such as data transformation or rule processing should live in applications or services where they can be controlled by product teams working closely with the domains they support.
Overambitious API gateways(Apr 2016, 暂缓)
One of our common complaints is the pushing of business smarts into middleware, resulting in application servers and enterprise service buses with ambitions to run critical application logic. These require complex programming in environments not well suited to the purpose. We're seeing a worrying re-emergence of this disease with overambitious API Gateway products. API Gateways can provide utility in dealing with some generic concerns - for example, authentication and rate-limiting - but any domain smarts such as data transformation or rule processing should live in applications or services where they can be controlled by product teams working closely with the domains they support.
kops(May 2018, 试验)
kops is a command line tool for creating and managing high-availability production Kubernetes clusters. kops has become our go-to tool to self-manage Kubernetes clusters on AWS, not the least because of its rapidly growing open source community. It also supports installing, upgrading and managing Kubernetes clusters on Google Cloud. Our experience with kops on Google, however, is very limited because of our preference for GKE, the managed Kubernetes offering. We recommend using kops in reusable scripts to create infrastructure as code. We're interested to see how kops continues to evolve to support managed Kubernetes clusters such as EKS, Amazon's own managed Kubernetes service.
kops(Nov 2017, 评估)
kops is a command line tool for creating and managing high-availability production Kubernetes clusters. Initially targeting AWS, it now has experimental support for other providers. It can get you up and running fast, and even though a few features (such as rolling upgrades) have yet to be fully developed, we've been impressed by the community.
Netlify(May 2018, 评估)
We like simple tools that solve one problem really well, and Netlify fits this description nicely. You can create static website content, check it into GitHub and then quickly and easily get your site live and available. There is a CLI available to control the process; content delivery networks (CDNs) are supported; it can work alongside tools such as Grunt; and, most importantly, Netlify supports HTTPS.
Netlify(Nov 2017, 评估)
We like simple tools that solve one problem really well, and Netlify fits this description nicely. You can create static website content, check it into GitHub and then quickly and easily get your site live and available. There is a CLI available to control the process; content delivery networks (CDNs) are supported; it can work alongside tools such as Grunt; and, most importantly, Netlify supports HTTPS.
Hosted identity management as a service(May 2018, 试验)
Identity management is a critical platform component. External users on mobile apps need to be authenticated, developers need to be given access to delivery infrastructure components, and microservices may need to identify themselves to other microservices. You should ask yourself whether identity management should be “self-hosted”. In our experience, a hosted identity management as a service (SaaS) solution is preferable. We believe that top-tier hosted providers such as Auth0 and Okta can provide better uptime and security SLAs. That said, sometimes self-hosting the solution is a realistic decision, especially for enterprises that have the operational discipline and resources to do so safely. Large enterprise identity solutions typically offer a much more expansive range of capabilities such as centralized entitlements, governance reporting and separation of duties management among others. However, these concerns are typically more relevant for employee identities, especially in regulated enterprises with legacy systems.
Clara rules(May 2018, 评估)
Our first rule of thumb in selecting a rules engine is normally: you don't need a rules engine. We've seen too many people tying themselves to a hard-to-test black-box rules engine for spurious reasons, when custom code would have been a better solution. That said, we've had success using Clara rules for scenarios where a rules engine does make sense. We like that it uses simple Clojure code to express and evaluate the rules, which means they are amenable to refactoring, testing and source control. Rather than chasing the illusion that business people should directly manipulate the rules, it drives collaboration between the business experts and developers.
Clara rules(Nov 2017, 评估)
Our first rule of thumb in selecting a rules engine is normally: you don't need a rules engine. We've seen too many people tying themselves to a hard-to-test black-box rules engine for spurious reasons, when custom code would have been a better solution. That said, we've had success using Clara rules for scenarios where a rules engine does make sense. We like that it uses simple Clojure code to express and evaluate the rules, which means they are amenable to refactoring, testing and source control. Rather than chasing the illusion that business people should directly manipulate the rules, it drives collaboration between the business experts and developers.
Buildkite(May 2018, 试验)
Our teams very much like the hosted CI/CD tool Buildkite for its simplicity and quick setup. With Buildkite, you provide your own machines to execute builds — on premise or in the cloud — and install a lightweight agent application to connect the build agent to the hosted service. In many cases, having this level of control over the configuration of your build agents is a plus when compared to using hosted agents.
Buildkite(Nov 2017, 试验)
Our teams very much like the hosted CI/CD tool Buildkite for its simplicity and quick setup. With Buildkite, you provide your own machines to execute builds — on premise or in the cloud — and install a lightweight agent application to connect the build agent to the hosted service. In many cases, having this level of control over the configuration of your build agents is a plus when compared to using hosted agents.
cfn_nag(May 2018, 评估)
The cloud and continuous delivery had a dramatic effect on infrastructure security. When following infrastructure as code, the entire infrastructure — which includes networks, firewalls and accounts — is defined in scripts and configuration files, and with Phoenix Servers and Environments, the infrastructure is recreated in each deployment, often many times a day. In such a scenario, testing the infrastructure after it's created is neither sufficient nor feasible. A tool that helps address this problem is cfn_nag. It scans the CloudFormation templates used with AWS for patterns that may indicate insecure infrastructure, and it does so before the infrastructure is created. Running a tool such as cfn_nag in a build pipeline is fast and it can detect a number of problems before they even reach a cloud environment.
Kong API Gateway(May 2018, 试验)
Kong is an open source API gateway which also comes as an enterprise product integrating with proprietary API analytics and a developer portal. Kong can be deployed, in a variety of configurations, as an edge API gateway, as an internal API proxy, or even as a sidecar in a service mesh configuration. OpenResty, through its Nginx modules, provides a strong and performant foundation, with Lua plugins for extensions. Kong can either use PostgreSQL for single-region deployments or Cassandra for multiregion configurations. Our developers have enjoyed Kong's high performance, its API-first approach (which enables automation of its configuration) and its ease of deployment as a container. Kong API Gateway , unlike overambitious API gateways, has a smaller set of features but it implements the essential set of API gateway capabilities such as traffic control, security, logging, monitoring and authentication.
Kong API Gateway(Nov 2017, 评估)
Kong is an open source API gateway built and sponsored by Mashape, who also provide an enterprise offering integrating Kong with their proprietary API analytics and developer portal tools. They can be deployed in a variety of configurations, as an edge API gateway or an internal API proxy. OpenResty, through its Nginx modules, provides a strong and performant foundation, with Lua plugins for extensions. Kong can either use PostgreSQL for single region deployments or Cassandra for multiregion configurations. Our developers have enjoyed Kong's high performance, its API-first approach (which enables automation of its configuration) and its ease of deployment as a container. Kong API Gateway , unlike overambitious API gateways, has a smaller set of features but it implements the essential set of API gateway capabilities such as traffic control, security, logging, monitoring and authentication. We're excited to assess Kong in a sidecar configuration in the near future.
WeChat(May 2018, 试验)
WeChat , often seen as a WhatsApp equivalent, is becoming the de facto business platform in China. Many people may not know but WeChat is also one of the most popular online payment platforms. With the app's built-in CMS and membership management, small businesses are now conducting their commerce entirely on WeChat. Through the Service Account feature, large organizations can interface their internal system to their employees. Given that more than 70 percent of Chinese people are using WeChat, it's an important consideration for businesses that want to expand into the China market.
WeChat(Nov 2017, 试验)
WeChat , often seen as a WhatsApp equivalent, is becoming the de facto business platform in China. Many people may not know but WeChat is also one of the most popular online payment platforms. With the app's built-in CMS and membership management, small businesses are now conducting their commerce entirely on WeChat. Through the Service Account feature, large organizations can interface their internal system to their employees. Given that more than 70 percent of Chinese people are using WeChat, it's an important consideration for businesses that want to expand into the China market.
Hyperledger Composer(May 2018, 试验)
The Hyperledger project has grown into a broader collaboration and now contains a series of subprojects. It supports Blockchain implementations for different purposes; for example, Burrow is dedicated to build a permissioned Ethereum and Indy is more focused on digital identity. Among these platforms, Fabric is the most mature one. Most of time when people talk about adopting Hyperledger they are actually thinking about Hyperledger Fabric. However, the programming abstraction of chaincode is relatively low level given it manipulates the state of the ledger directly. Moreover, it always takes a lot of time to set up infrastructure before writing the first line of blockchain code. Hyperledger Composer, which builds on top of Fabric, accelerates the process of turning ideas into software. Composer provides DSLs to model business assets, define access control and build a business network. By using Composer you could quickly validate your idea through a browser without setting up any infrastructure. Just remember that the Composer itself isn't Blockchain — you still need to deploy it on Fabric.
Kotlin(May 2018, 采纳)
Kotlin has experienced an accelerated rate of adoption and rapid growth of tooling support. Some of the reasons behind its popularity are its concise syntax, null safety, ease of transition from Java and interoperability with other JVM-based languages in general, and that it doubles as a great introductory language to functional programming. With JetBrains adding the ability to compile Kotlin to native binaries on multiple platforms, as well as transpile to JavaScript, we believe it has the potential of much wider use by the larger community of mobile and native application developers. Although at the time of writing, some of the tooling such as static and coverage code analysis have yet to mature, given our experience of using Kotlin in many production applications, we believe Kotlin is ready for general adoption.
Kotlin(Nov 2017, 试验)
The announcement of first-class Android support has given an extra boost to the rapidly progressing Kotlin language, and we're closely following the progress of Kotlin/Native — the LLVM-backed ability to compile to native executables. Null safety, data classes and the ease of creating DSLs are some of the benefits we've enjoyed, along with the Anko library for Android development. Despite the downsides of slow initial compilation and reliance on IntelliJ for first-class IDE support, we recommend giving this fresh and concise modern language a try.
Kotlin(Mar 2017, 评估)
The Kotlin programming language is on many of our developers' bucket lists to assess this year, and some have already used it successfully in production. It is an open source JVM language from JetBrains. Our Swift mobile developers like it as it is syntactically closer to Swift and equally concise. Our Java developers have enjoyed its seamless interoperability with the Java language and tools and found it easier to learn than Scala. Kotlin supports functional programming concepts but with less features than Scala. Developers on our teams who like static typing with the compiler catching null pointer defects found themselves writing fewer boilerplate tests.
Cloud Spanner(May 2018, 评估)
Cloud Spanner is a fully managed relational database service offering high availability and strong consistency without compromising latency. Google has been working on a globally distributed database called Spanner for quite some time. It has recently released the service to the outside world as Cloud Spanner. You can scale your database instance from one to thousands of nodes across the globe without worrying about data consistency. By levering TrueTime, a highly available and distributed clock, Cloud Spanner provides strong consistency for reads and snapshots. You can use standard SQL to read data from Cloud Spanner, but for write operations you have to use their RPC API. Although not all services would require a global-scale distributed database, the general availability of Cloud Spanner is a big shift in the way we think about databases. And its design is influencing open source products such as CockroachDB.
Cloud Spanner(Nov 2017, 评估)
Cloud Spanner is a fully managed relational database service offering high availability and strong consistency without compromising latency. Google has been working on a globally distributed database called Spanner for quite some time. It has recently released the service to the outside world as Cloud Spanner. You can scale your database instance from one to thousands of nodes across the globe without worrying about data consistency. By levering TrueTime, a highly available and distributed clock, Cloud Spanner provides strong consistency for reads and snapshots. You can use standard SQL to read data from Cloud Spanner, but for write operations you have to use their RPC API. Although not all services would require a global-scale distributed database, the general availability of Cloud Spanner is a big shift in the way we think about databases. And its design is influencing open source products such as CockroachDB.
Cosmos DB(May 2018, 评估)
Cosmos DB is Microsoft's globally distributed, multimodel database service, which became generally available earlier this year. While most modern NoSQL databases offer tunable consistency, Cosmos DB makes it a first-class citizen and offers five different consistency models. It's worth highlighting that it also supports multiple models — key value, document, column family and graph — all of which map to its internal data model, called atom-record-sequence (ARS). One interesting aspect of Cosmos DB is that it offers service level agreements (SLAs) on its latency, throughput, consistency and availability. With its wide range of applicability, it has set a high standard for other cloud vendors to match.
Cosmos DB(Nov 2017, 评估)
Cosmos DB is Microsoft's globally distributed, multimodel database service, which became generally available earlier this year. While most modern NoSQL databases offer tunable consistency, Cosmos DB makes it a first-class citizen and offers five different consistency models. It's worth highlighting that it also supports multiple models — key value, document, column family and graph — all of which map to its internal data model, called atom-record-sequence (ARS). One interesting aspect of Cosmos DB is that it offers service level agreements (SLAs) on its latency, throughput, consistency and availability. With its wide range of applicability, it has set a high standard for other cloud vendors to match.
Jupyter for automated testing(May 2018, 评估)
We're seeing some interesting reports of using Jupyter for automated testing. The ability to mix code, comments and output in the same document reminds us of FIT, FitNesse and Concordion. This flexible approach is particularly useful if your tests are data heavy or rely on some statistical analysis such as performance testing. Python provides all the power you need, but as tests grow in complexity, a way to manage suites of notebooks would be helpful.
Interledger(May 2018, 评估)
Most people may know the "Internet of money" through Bitcoin. In fact, this idea can be traced to the early stages of the Web. HTTP even reserved a status code for digital payment. The challenging part of this idea is to transfer value between different ledgers in different entities. Blockchain technology promotes this idea through building a distributed shared ledger. The current challenge is how to achieve interoperability between different blockchain ledgers and interoperability with traditional centralized ledgers. Interledger is a protocol to connect different ledgers. This protocol uses connectors and a cryptographic mechanism such as HTLC to route secure payments across ledgers. It’s not hard to join the payment network through its suites. Interledger was first initiated by Ripple and is now steadily developed by a W3C community group.
Rasa(May 2018, 评估)
Rasa is a new entrant in the area of chatbots. Instead of using a simple decision tree it uses neural networks to map intent and internal state to a response. Rasa integrates with natural language processing solutions such as spaCy; and, unlike other solutions we've featured in the Radar, Rasa is open source software and can be self-hosted, which makes it a viable solution when ownership of data is of concern. Our experiences with using Rasa Stack for an internal application have been positive.
SwiftNIO(May 2018, 评估)
We’re in favor of asynchronous and reactive styles of programming especially for network I/O-bound distributed systems. Reactive libraries often sit on top of a lower level nonblocking communication framework such as Netty. Recently SwiftNIO, an open source nonblocking networking framework from Apple, has grabbed our attention. SwiftNIO is similar to Netty but written in Swift. It’s currently supported on MacOS and Ubuntu and implements HTTP as a higher-level protocol. We’re excited to see the usage of this framework and integration of it into higher-level application frameworks and other protocols.
Architectural fitness function(May 2018, 试验)
Borrowed from evolutionary computing, a fitness function is used to summarize how close a given design solution is to achieving the set aims. When defining an evolutionary algorithm, the designer seeks a ‘better’ algorithm; the fitness function defines what ‘better’ means in this context. An architectural fitness function , as defined in Building Evolutionary Architectures, provides an objective integrity assessment of some architectural characteristics, which may encompass existing verification criteria, such as unit testing, metrics, monitors, and so on. We believe architects can communicate, validate and preserve architectural characteristics in an automated, continual manner, which is the key to building evolutionary architectures.
Architectural fitness function(Nov 2017, 试验)
Borrowed from evolutionary computing, a fitness function is used to summarize how close a given design solution is to achieving the set aims. When defining an evolutionary algorithm, the designer seeks a ‘better’ algorithm; the fitness function defines what ‘better’ means in this context. An architectural fitness function , as defined in Building Evolutionary Architectures, provides an objective integrity assessment of some architectural characteristics, which may encompass existing verification criteria, such as unit testing, metrics, monitors, and so on. We believe architects can communicate, validate and preserve architectural characteristics in an automated, continual manner, which is the key to building evolutionary architectures.
Atlas and BeeHive(May 2018, 评估)
A multi-app strategy is really controversial, particularly at a time when fewer and fewer users are downloading new apps. Instead of introducing a new app and struggling with the download numbers, multiteams have to deliver functionality via a single app that is already widely installed, which creates an architectural challenge. Atlas and BeeHive are modularization solutions for Android and iOS apps, respectively. Atlas and BeeHive enable multiteams working on physically isolated modules to reassemble or dynamically load these modules from a facade app. Both are Alibaba open source projects, since Alibaba encountered the same problem of dwindling downloads and single-app architectural challenges.
Atlas and BeeHive(Nov 2017, 评估)
A multi-app strategy is really controversial, particularly at a time when fewer and fewer users are downloading new apps. Instead of introducing a new app and struggling with the download numbers, multiteams have to deliver functionality via a single app that is already widely installed, which creates an architectural challenge. Atlas and BeeHive are modularization solutions for Android and iOS apps, respectively. Atlas and BeeHive enable multiteams working on physically isolated modules to reassemble or dynamically load these modules from a facade app. Both are Alibaba open source projects, since Alibaba encountered the same problem of dwindling downloads and single-app architectural challenges.
BeyondCorp(May 2018, 评估)
Previously in the Radar, we’ve discussed the rise of the perimeterless enterprise. Now, some organizations are doing away with implicitly trusted intranets altogether and treating all communication as if it was being transmitted through the public internet. A set of practices, collectively labeled BeyondCorp, have been described by Google engineers in a set of publications. Collectively, these practices — including managed devices, 802.1x networking and standard access proxies protecting individual services — make this a viable approach to network security in large enterprises.
Patroni(May 2018, 试验)
Patroni is a template for PostgreSQL high availability. Born out of the need to provide automatic failure for PostgreSQL, Patroni is a Python-based PostgreSQL controller that leverages a distributed configuration store (such as etcd, ZooKeeper, or Consul) to manage the state of the PostgreSQL cluster. Patroni supports both streaming and synchronous replication models and provides a rich set of REST APIs for dynamic configuration of the PostgreSQL cluster. If you want to achieve high availability in a distributed PostgreSQL setup, you have to consider many edge cases, and we like the fact that Patroni provides a template to achieve most of the common use cases.
Azure Stack(May 2018, 评估)
Cloud computing brings significant benefits over self-hosted virtualized solutions but sometimes data simply cannot leave an organization’s premises, usually for latency or regulatory reasons. For European companies, the current political climate also raises more concerns about placing data in the hands of US-based entities. With Azure Stack, Microsoft adds an interesting offering as a middle ground between full-featured public clouds and simple on-premises virtualization: a slimmed-down version of the software that runs Microsoft’s Azure Global cloud is combined with a rack of preconfigured commodity hardware from the usual suspects like HP and Lenovo, providing an organization with the core Azure experience on premises. By default, support is split between Microsoft and the hardware vendors (and they promise to cooperate), but system integrators can offer complete Azure Stack solutions, too.
Android Architecture Components(May 2018, 评估)
Historically, Google's Android documentation examples lacked architecture and structure. This changes with the release of Android Architecture Components , a set of opinionated libraries that help developers create Android applications with better architecture. They address longstanding pain points of Android development: handling lifecycles; pagination; SQLite databases; and data persistence over configuration changes. The libraries don't need to be used together — you can pick the ones you need most and integrate them into your existing project.
Android Architecture Components(Nov 2017, 评估)
Historically, Google's Android documentation examples lacked architecture and structure. This changes with the release of Android Architecture Components , a set of opinionated libraries that help developers create Android applications with better architecture. They address longstanding pain points of Android development: handling lifecycles; pagination; SQLite databases; and data persistence over configuration changes. The libraries don't need to be used together — you can pick the ones you need most and integrate them into your existing project.
Domain-scoped events(May 2018, 试验)
It’s important to remember that encapsulation applies to events and event-driven architectures just as it applies to other areas of software. In particular, think about the scope of an event and whether we expect it to be consumed within the same application, the same domain or across an entire organization. A domain-scoped event will be consumed within the same domain as it’s published, as such we expect the consumer to have access to a certain context, resources or references in order to act on the event. If the consumption is happening more widely within an organization, the contents of the event might well need to be different, and we need to take care not to "leak" implementation details that other domains then come to depend upon.
Truffle(May 2018, 评估)
Truffle is a development framework that brings a modern web development experience to the Ethereum platform. It takes over the job of smart contract compiling, library linking and deployment, as well as dealing with artifacts in different blockchain networks. One of the reasons we love Truffle is that it encourages people to write tests for their smart contracts. You need to take tests really seriously as smart contract programming is often related to money. With its built-in testing framework and integration with TestRPC, Truffle makes it possible to write the contract in a TDD way. We expect to see more technologies similar to Truffle to promote continuous integration in the blockchain area.
Truffle(Nov 2017, 评估)
Truffle is a development framework that brings a modern web development experience to the Ethereum platform. It takes over the job of smart contract compiling, library linking and deployment, as well as dealing with artifacts in different blockchain networks. One of the reasons we love Truffle is that it encourages people to write tests for their smart contracts. You need to take tests really seriously as smart contract programming is often related to money. With its built-in testing framework and integration with TestRPC, Truffle makes it possible to write the contract in a TDD way. We expect to see more technologies similar to Truffle to promote continuous integration in the blockchain area.
Appium Test Distribution(May 2018, 试验)
We've featured Appium in the Radar in the past. It's one of the most popular mobile test automation frameworks. As we scale our test suite, being able to run our tests in parallel against an array of devices is key in having short feedback loops. Appium Test Distribution solves this problem very effectively with its ability to run tests in parallel as well as run the same tests on multiple devices. Among other things, it distinguishes itself by its ability to add and remove devices in which tests run without any manual setup required and with its ability to run tests on remote devices. We've used it in a few projects at ThoughtWorks over the last couple of years and it worked very well for us.
RIBs(May 2018, 评估)
RIBs — which is short for router, interactor and builder — is a cross-platform architecture mobile framework from Uber. The key idea of RIBs is to decouple business logic from the view tree, and thus ensure the app is driven by business logic. By applying consistent architecture patterns across native Android and iOS, RIBs provides clear statement management and good testability. We advise putting business logic in the back-end service rather than leak it into the view, so if you do have a complicated mobile application, RIBs can help manage this complexity.
Headless Chrome for front-end test(May 2018, 试验)
Since mid-2017, Chrome users have had the option of running the browser in headless mode. This feature is ideally suited to running front-end browser tests without the overhead of displaying actions on a screen. Previously, this was largely the province of PhantomJS but Headless Chrome is rapidly replacing the JavaScript-driven WebKit approach. Tests in Headless Chrome should run much faster, and behave more like a real browser, but our teams have found that it does use more memory than PhantomJS. With all these advantages, Headless Chrome for front-end test is likely to become the de facto standard.
Headless Chrome for front-end test(Nov 2017, 试验)
Since mid-2017, Chrome users have had the option of running the browser in headless mode. This feature is ideally suited to running front-end browser tests without the overhead of displaying actions on a screen. Previously, this was largely the province of PhantomJS but Headless Chrome is rapidly replacing the JavaScript-driven WebKit approach. Tests in Headless Chrome should run much faster, and behave more like a real browser, but our teams have found that it does use more memory than PhantomJS. With all these advantages, Headless Chrome for front-end test is likely to become the de facto standard.
Conduit(May 2018, 评估)
Conduit is a lightweight service mesh for Kubernetes. Conduit embraces the out-of-process architecture with data plane proxy written in Rust and a control plane in Go. The data plane proxy runs as a sidecar for all TCP traffic in the Kubernetes cluster and the control plane runs in a separate namespace in Kubernetes exposing REST APIs to control the behavior of the data plane proxy. By proxying all requests, Conduit provides a wealth of metrics for monitoring and observability of interactions in the service mesh for HTTP, HTTP/2 and gRPC traffic. Even though Conduit is relatively new to this space, we recommend it because it’s simple to install and operate.
Apex(May 2018, 评估)
Apex is a tool to build, deploy and manage AWS Lambda functions with ease. With Apex, you can write functions in languages that are not yet natively supported in AWS, including Golang, Rust and others. This is made possible by a Node.js shim, which creates a child process and processes events through stdin and stdout. Apex has a lot of nice features that improve the developer experience, and we particularly like the ability to test functions locally and perform a dry run of the changes before they're applied to AWS resources.
Apex(Nov 2017, 评估)
Apex is a tool to build, deploy and manage AWS Lambda functions with ease. With Apex, you can write functions in languages that are not yet natively supported in AWS, including Golang, Rust and others. This is made possible by a Node.js shim, which creates a child process and processes events through stdin and stdout. Apex has a lot of nice features that improve the developer experience, and we particularly like the ability to test functions locally and perform a dry run of the changes before they're applied to AWS resources.
EMQ(May 2018, 试验)
EMQ is a scalable open source multiplatform MQTT broker. It’s written in Erlang/OTP for higher performance, handling millions of concurrent connections. It supports multiple protocols including MQTT, MQTT Sensor Networks, CoAP as well as WebSockets, making it suitable for both IoT and mobile devices. We’ve started using EMQ in our projects and have enjoyed its ease of installation and use, its ability to route messages to different destinations including Kafka and PostgreSQL, as well as its API-driven approach for its monitoring and configuration.
Flood IO(May 2018, 试验)
Load testing became easier with the maturity of tools such as Gatling and Locust. At the same time, elastic cloud infrastructures make it possible to simulate a large number of client instances. We're delighted to see Flood and other cloud platforms go further by leveraging these technologies. Flood IO is an SaaS load-testing service that helps to distribute and execute testing scripts across hundreds of servers in the cloud. Our teams find it simple to migrate performance testing to Flood by reusing existing Gatling scripts.
Flood IO(Nov 2017, 试验)
Load testing became easier with the maturity of tools such as Gatling and Locust. At the same time, elastic cloud infrastructures make it possible to simulate a large number of client instances. We're delighted to see Flood and other cloud platforms go further by leveraging these technologies. Flood IO is an SaaS load-testing service that helps to distribute and execute testing scripts across hundreds of servers in the cloud. Our teams find it simple to migrate performance testing to Flood by reusing existing Gatling scripts.
CSS Modules(May 2018, 试验)
Most large CSS codebases require complex naming schemes to help avoid naming conflicts in the global namespace. CSS Modules address these problems by creating a local scope for all class names in a single CSS file. This file is imported to a JavaScript module, where CSS classes are referenced as strings. Then, in the build pipeline (Webpack, Browserify, etc.), the class names are replaced with generated unique strings. This is a significant change in responsibilities. Previously, a human had to manage the global namespace, to avoid class naming conflicts; now that responsibility rests with the build tooling. A small downside we've encountered with CSS Modules: functional tests are usually out of the local scope and can therefore not reference classes by the name defined in the CSS file. We recommend using IDs or data attributes instead.
CSS Modules(Nov 2017, 试验)
Most large CSS codebases require complex naming schemes to help avoid naming conflicts in the global namespace. CSS Modules address these problems by creating a local scope for all class names in a single CSS file. This file is imported to a JavaScript module, where CSS classes are referenced as strings. Then, in the build pipeline (Webpack, Browserify, etc.), the class names are replaced with generated unique strings. This is a significant change in responsibilities. Previously, a human had to manage the global namespace, to avoid class naming conflicts; now that responsibility rests with the build tooling. A small downside we've encountered with CSS Modules: functional tests are usually out of the local scope and can therefore not reference classes by the name defined in the CSS file. We recommend using IDs or data attributes instead.
Parcel(May 2018, 评估)
Parcel is a web application bundler similar to Webpack or Browserify. We’ve featured Webpack previously in our Radar and it continues to be a great tool. Parcel distinguishes itself from its rivals through developer experience and speed. It has all the standard bundling features and provides true zero-configuration experience, making it really easy to get started with and use. It has fast bundle times and beats its competitors in many benchmarks. Parcel has gained a lot of community interest and is worth keeping an eye on.
Kubernetes(May 2018, 采纳)
Since we last mentioned Kubernetes in the Radar, it has become the default solution for most of our clients when deploying containers into a cluster of machines. The alternatives didn’t capture as much mindshare, and in some cases our clients are even changing their ‘engine’ to Kubernetes. Kubernetes has become the container orchestration platform of choice for major public cloud platforms, including Microsoft's Azure Container Service and Google Cloud (see the GKE blip). And there are many useful products enriching the fast-growing Kubernetes ecosystem. Platforms that try to hide Kubernetes under an abstraction layer, however, have yet to prove themselves.
Kubernetes(Nov 2017, 采纳)
Since we last mentioned Kubernetes in the Radar, it has become the default solution for most of our clients when deploying containers into a cluster of machines. The alternatives didn’t capture as much mindshare, and in some cases our clients are even changing their ‘engine’ to Kubernetes. Kubernetes has become the container orchestration platform of choice for major public cloud platforms, including Microsoft's Azure Container Service and Google Cloud (see the GKE blip). And there are many useful products enriching the fast-growing Kubernetes ecosystem. Platforms that try to hide Kubernetes under an abstraction layer, however, have yet to prove themselves.
Kubernetes(Nov 2016, 试验)
Kubernetes is Google's answer to the problem of deploying containers into a cluster of machines, which is becoming an increasingly common scenario. It is not the solution used by Google internally but an open source project that originated at Google and has seen a fair number of external contributions. Since we mentioned Kubernetes on the previous Radar, our initial positive impressions have been confirmed, and we are seeing successful use of Kubernetes in production at our clients.
Kubernetes(Nov 2015, 评估)
Kubernetes is Google's answer to the problem of deploying containers into a cluster of machines, which is becoming an increasingly common scenario. It is not the solution used by Google internally but an open source project that originated at Google and has seen a fair number of external contributions. Docker and Rocket are supported as container formats, and services offered include health management, replication and discovery. A similar solution in this space is Rancher.
Autonomous bubble pattern(May 2018, 试验)
Many organizations we work with are trying hard to use modern engineering approaches to build new capabilities and features, while also having to coexist with a long tail of legacy systems. An old strategy that, based on our experience, has turned out to be increasingly helpful in these scenarios is Eric Evans's Autonomous bubble pattern. This approach involves creating a fresh context for new application development that is shielded from the entanglements of the legacy world. This is a step beyond just using an anticorruption layer. It gives the new bubble context full control over its backing data, which is then asynchronously kept up-to-date with the legacy systems. It requires some work to protect the boundaries of the bubble and keep both worlds consistent, but the resulting autonomy and reduction in development friction is a first bold step toward a modernized future architecture.
Autonomous bubble pattern(Nov 2017, 试验)
Many organizations we work with are trying hard to use modern engineering approaches to build new capabilities and features, while also having to coexist with a long tail of legacy systems. An old strategy that, based on our experience, has turned out to be increasingly helpful in these scenarios is Eric Evans's Autonomous bubble pattern. This approach involves creating a fresh context for new application development that is shielded from the entanglements of the legacy world. This is a step beyond just using an anticorruption layer. It gives the new bubble context full control over its backing data, which is then asynchronously kept up-to-date with the legacy systems. It requires some work to protect the boundaries of the bubble and keep both worlds consistent, but the resulting autonomy and reduction in development friction is a first bold step toward a modernized future architecture.
CSS Grid Layout(May 2018, 试验)
CSS is the preferred choice for laying out web pages, even when it did not provide much explicit support for creating layouts. Flexbox helped with simpler, one-dimensional layouts, but developers usually reached for libraries and toolkits for more complex layouts. CSS Grid Layout is a two-dimensional grid-based layout system that provides a mechanism to divide available space for layout into columns and rows using a set of predictable sizing behaviors. Grid does not require any libraries and plays well with Flexbox and other CSS display elements. However, since IE11 is only partially supported, it ignores users who still depend on a Microsoft browser on Windows 7.
CSS Grid Layout(Nov 2017, 试验)
CSS is the preferred choice for laying out web pages, even when it did not provide much explicit support for creating layouts. Flexbox helped with simpler, one-dimensional layouts, but developers usually reached for libraries and toolkits for more complex layouts. CSS Grid Layout is a two-dimensional grid-based layout system that provides a mechanism to divide available space for layout into columns and rows using a set of predictable sizing behaviors. Grid does not require any libraries and plays well with Flexbox and other CSS display elements. However, since IE11 is only partially supported, it ignores users who still depend on a Microsoft browser on Windows 7.
AssertJ(May 2018, 采纳)
AssertJ is a Java library that provides a fluent interface for assertions, which makes it easy to convey intent within test code. AssertJ gives readable error messages, soft assertions and improved collections and exception support. Many of our teams choose AssertJ as their default assertion library instead of JUnit combined with Java Hamcrest.
AssertJ(Nov 2017, 试验)
AssertJ is a Java library that provides a fluent interface for assertions, which makes it easy to convey intent within test code. AssertJ gives readable error messages, soft assertions, and improved collections and exception support. We're seeing some teams default to its use instead of JUnit combined with Hamcrest.
Log level per request(May 2018, 评估)
One problem with observability in a highly distributed microservices architecture is the choice between logging everything — and taking up huge amounts of storage space — or randomly sampling logs and potentially missing important events. Recently, we’ve noticed a technique that offers a compromise between these two solutions. Set the log level per request via a parameter passed in through the tracing header. Using a tracing framework, possibly based on the OpenTracing standard, you can pass a correlation id from service to service in a single transaction. You can even inject other data, such as the desired log level, at the initiating transaction and pass it along with the tracing information. This ensures that the additional data collected corresponds to a single user transaction as it flows through the system. This is also a useful technique for debugging, since services might be paused or otherwise modified on a transaction-by-transaction basis.
Polycloud(May 2018, 试验)
Organizations are becoming more comfortable with the Polycloud strategy — rather than going "all-in" with one provider, they are passing different types of workloads to different providers based on their own strategy. Some of them apply the best-of-breed approach, for example: putting standard services on AWS, but using Google for machine learning and data-oriented applications and Azure for Microsoft Windows applications. For some organizations this is a cultural and business decision. Retail businesses, for example, often refuse to store their data on Amazon and they distribute load to different providers based on their data. This is different to a cloud-agnostic strategy of aiming for portability across providers, which is costly and forces lowest-common-denominator thinking. Polycloud instead focuses on using the best match that each cloud provider offers.
Polycloud(Nov 2017, 评估)
The major cloud providers (Amazon, Microsoft and Google) are locked in an aggressive race to maintain parity on core capabilities while their products are differentiated only marginally. This is causing a few organizations to adopt a Polycloud strategy — rather than going ‘all-in’ with one provider, they are passing different types of workloads to different providers in a best-of-breed approach. This may involve, for example, putting standard services on AWS, but using Google for machine learning, Azure for .NET applications that use SQLServer, or potentially using the Ethereum Consortium Blockchain solution. This is different than a cloud-agnostic strategy of aiming for portability across providers, which is costly and forces lowest-common-denominator thinking. Polycloud instead focuses on using the best that each cloud offers.
WireMock(May 2018, 试验)
A key driver for architectures based on microservices is independent evolvability of services. For example, when two services depend on each other, the testing process for one usually involves stubs and mocks for the other one. These can be written by hand, but as with mocking in unit tests, a framework helps developers focus on the actual test scenario. We have known of WireMock for a while but we’ve preferred running tests with mountebank. Over the past year, though, WireMock has really caught up and we now recommend it as a good alternative.
Solidity(May 2018, 评估)
Programming for smart contracts requires a more expressive language than a scripting system for transactions. Solidity is the most popular among the new programming languages designed for smart contracts. Solidity is a contract-oriented, statically typed language whose syntax is similar to JavaScript. It provides abstractions for writing self-enforcing business logic in smart contracts. The toolchain around Solidity is growing fast. Nowadays, Solidity is the primary choice on the Ethereum platform. Given the immutable nature of deployed smart contracts, it should go without saying that rigorous testing and audit of dependencies is vital.
Solidity(Nov 2017, 评估)
Programming for smart contracts requires a more expressive language than a scripting system for transactions. Solidity is the most popular among the new programming languages designed for smart contracts. Solidity is a contract-oriented, statically typed language whose syntax is similar to JavaScript. It provides abstractions for writing self-enforcing business logic in smart contracts. The toolchain around Solidity is growing fast. Nowadays, Solidity is the primary choice on the Ethereum platform. Given the immutable nature of deployed smart contracts, it should go without saying that rigorous testing and audit of dependencies is vital.
Godot(May 2018, 评估)
As AR and VR continue to gain traction, we continue to explore tools with which we can create immersive virtual worlds. Our positive experience with Unity, one of the two major gaming engines, led us to feature it in previous Radars. We still like Unity but are also excited about Godot, a relatively new entrant to the field. Godot is open source software and although not as fully featured as the big commercial engines, it comes with a more modern software design and less clutter. Offering C# and Python further lowers the barrier to entry for developers outside the gaming industry. Godot version 3, released earlier this year, adds support for VR and support for AR is on the horizon.
The three Rs of security(May 2018, 评估)
Traditional approaches to enterprise security often emphasize locking things down and slowing the pace of change. However, we know that the more time an attacker has to compromise a system, the greater the potential damage. The three Rs of enterprise security — rotate, repair and repave — take advantage of infrastructure automation and continuous delivery to eliminate opportunities for attack. Rotating credentials, applying patches as soon as they're available and rebuilding systems from a known, secure state — all within a matter of minutes or hours — makes it harder for attackers to succeed. The three Rs of security technique is made feasible with the advent of modern cloud-native architectures. When applications are deployed as containers, and built and tested via a completely automated pipeline, a security patch is just another small release that can be sent through the pipeline with one click. Of course, in keeping with best distributed systems practices, developers need to design their applications to be resilient to unexpected server outages. This is similar to the impact of implementing Chaos Monkey within your environment.
The three Rs of security(Nov 2017, 评估)
Traditional approaches to enterprise security often emphasize locking things down and slowing the pace of change. However, we know that the more time an attacker has to compromise a system, the greater the potential damage. The three Rs of enterprise security — rotate, repair and repave — take advantage of infrastructure automation and continuous delivery to eliminate opportunities for attack. Rotating credentials, applying patches as soon as they're available and rebuilding systems from a known, secure state — all within a matter of minutes or hours — makes it harder for attackers to succeed. The three Rs of security technique is made feasible with the advent of modern cloud-native architectures. When applications are deployed as containers, and built and tested via a completely automated pipeline, a security patch is just another small release that can be sent through the pipeline with one click. Of course, in keeping with best distributed systems practices, developers need to design their applications to be resilient to unexpected server outages. This is similar to the impact of implementing Chaos Monkey within your environment.
Gobot(May 2018, 评估)
The ability to compile the Go programming language to bare metal targets has raised interest among developers in using the language for embedded systems. Gobot is a framework for robotics, physical computing, and the Internet of Things, written in the Go programming language and supporting a variety of platforms. We've used the framework for experimental robotic projects where real-time response hasn't been a requirement, and we’ve created open source software drivers with Gobot. Gobot HTTP APIs enable simple hardware integration with mobile devices to create richer applications.
Gobot(Nov 2017, 评估)
The ability to compile the Go programming language to bare metal targets has raised interest among developers in using the language for embedded systems. Gobot is a framework for robotics, physical computing, and the Internet of Things, written in the Go programming language and supporting a variety of platforms. We've used the framework for experimental robotic projects where real-time response hasn't been a requirement, and we’ve created open source software drivers with Gobot. Gobot HTTP APIs enable simple hardware integration with mobile devices to create richer applications.
Lightweight Architecture Decision Records(May 2018, 采纳)
Much documentation can be replaced with highly readable code and tests. In a world of evolutionary architecture, however, it's important to record certain design decisions for the benefit of future team members as well as for external oversight. Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences. We recommend storing these details in source control, instead of a wiki or website, as then they can provide a record that remains in sync with the code itself. For most projects, we see no reason why you wouldn't want to use this technique.
Lightweight Architecture Decision Records(Nov 2017, 采纳)
Much documentation can be replaced with highly readable code and tests. In a world of evolutionary architecture, however, it's important to record certain design decisions for the benefit of future team members as well as for external oversight. Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences. We recommend storing these details in source control, instead of a wiki or website, as then they can provide a record that remains in sync with the code itself. For most projects, we see no reason why you wouldn't want to use this technique.
Lightweight Architecture Decision Records(Mar 2017, 试验)
Although much documentation can be replaced with highly readable code and tests, in a world of evolutionary architecture it's important to record certain design decisions for the benefit of future team members and for external oversight. Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences. Although these items are often stored in a wiki or collaboration tool, we generally prefer storing them in source control with simple markup.
Lightweight Architecture Decision Records(Nov 2016, 试验)
Although much documentation can be replaced with highly readable code and tests, in a world of evolutionary architecture it's important to record certain design decisions for the benefit of future team members and for external oversight. Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences. Although these items are often stored in a wiki or collaboration tool, we generally prefer storing them in source control with simple markup.
Sonobuoy(May 2018, 评估)
Sonobuoy is a diagnostic tool for running end-to-end conformance tests on any Kubernetes cluster in a nondestructive way. The team at Heptio, which was founded by two creators of the Kubernetes projects, built this tool to ensure that the wide array of Kubernetes distributions and configurations conform to the best practices, while following the open source standardization for interoperability of clusters. We're experimenting with Sonobuoy to run as part of our infrastructure as code build pipeline, as well as continuous monitoring of our Kubernetes installations, to validate the behavior and health of the whole cluster.
Sonobuoy(Nov 2017, 评估)
Sonobuoy is a diagnostic tool for running end-to-end conformance tests on any Kubernetes cluster in a nondestructive way. The team at Heptio, which was founded by two creators of the Kubernetes projects, built this tool to ensure that the wide array of Kubernetes distributions and configurations conform to the best practices, while following the open source standardization for interoperability of clusters. We're experimenting with Sonobuoy to run as part of our infrastructure as code build pipeline, as well as continuous monitoring of our Kubernetes installations, to validate the behavior and health of the whole cluster.
Windows Containers(May 2018, 评估)
Microsoft is catching up in the container space with Windows Containers enabling running Windows applications as containers on Windows-based environments. At the time of writing, Microsoft provides two Windows OS images as Docker containers — Windows Server 2016 Server Core and Windows Server 2016 Nano Server — that can run as a Windows Server Container with Docker. Our teams have started using Windows containers in scenarios where build agents and similar containers have been working successfully. Microsoft is aware that there’s room for improvements such as decreasing the large image sizes and enriching ecosystem support and documentation.
Windows Containers(Nov 2017, 评估)
Microsoft is catching up in the container space with Windows Containers. At the time of writing, Microsoft provides two Windows OS images as Docker containers, Windows Server 2016 Server Core and Windows Server 2016 Nano Server. Although there is room for improvement for Windows Containers, for instance, decreasing the large image sizes, and enriching ecosystem support and documentation, our teams have started using them in scenarios where other containers have been working successfully, such as build agents.
TensorFlow Serving(May 2018, 评估)
Machine-learning models are starting to creep into everyday business applications. When enough training data is available, these algorithms can address problems that might have previously required complex statistical models or heuristics. As we move from experimental use to production, we need a reliable way to host and deploy the models that can be accessed remotely and scale with the number of consumers. TensorFlow Serving addresses part of that problem by exposing a remote gRPC interface to an exported model; this allows a trained model to be deployed in a variety of ways. TensorFlow Serving also accepts a stream of models to incorporate continuous training updates, and its authors maintain a Dockerfile to ease the deployment process. Presumably, the choice of gRPC is to be consistent with the TensorFlow execution model; however, we’re generally wary of protocols that require code generation and native bindings.
TensorFlow Serving(Nov 2017, 评估)
Machine-learning models are starting to creep into everyday business applications. When enough training data is available, these algorithms can address problems that might have previously required complex statistical models or heuristics. As we move from experimental use to production, we need a reliable way to host and deploy the models that can be accessed remotely and scale with the number of consumers. TensorFlow Serving addresses part of that problem by exposing a remote gRPC interface to an exported model; this allows a trained model to be deployed in a variety of ways. TensorFlow Serving also accepts a stream of models to incorporate continuous training updates, and its authors maintain a Dockerfile to ease the deployment process. Presumably, the choice of gRPC is to be consistent with the TensorFlow execution model; however, we’re generally wary of protocols that require code generation and native bindings.
Tensorflow Eager Execution(May 2018, 评估)
In the last issue we featured PyTorch, a deep-learning modeling framework that allows an imperative programming style. Now TensorFlow Eager Execution provides this imperative style in TensorFlow by enabling execution of modeling statements outside of the context of a session. This improvement could provide the ease of debugging and finer-grained model control of PyTorch with the widespread popularity and performance of TensorFlow models. The feature is still quite new so we’re anxious to see how it performs and how it’ll be received by the TensorFlow community.
Recreating ESB antipatterns with Kafka(May 2018, 暂缓)
Kafka is becoming very popular as a messaging solution, and along with it, Kafka Streams is at the forefront of the wave of interest in streaming architectures. Unfortunately, as they start to embed Kafka at the heart of their data and application platforms, we're seeing some organizations recreating ESB antipatterns with Kafka by centralizing the Kafka ecosystem components — such as connectors and stream processors — instead of allowing these components to live with product or service teams. This reminds us of seriously problematic ESB antipatterns, where more and more logic, orchestration and transformation were thrust into a centrally managed ESB, creating a significant dependency on a centralized team. We're calling this out to dissuade further implementations of this flawed pattern.
Recreating ESB antipatterns with Kafka(Nov 2017, 暂缓)
Kafka is becoming very popular as a messaging solution, and along with it, Kafka Streams is at the forefront of the wave of interest in streaming architectures. Unfortunately, as they start to embed Kafka at the heart of their data and application platforms, we're seeing some organizations recreating ESB antipatterns with Kafka by centralizing the Kafka ecosystem components — such as connectors and stream processors — instead of allowing these components to live with product or service teams. This reminds us of seriously problematic ESB antipatterns, where more and more logic, orchestration and transformation were thrust into a centrally managed ESB, creating a significant dependency on a centralized team. We're calling this out to dissuade further implementations of this flawed pattern.
LoRaWAN(May 2018, 评估)
LoRaWAN is a low-power wide-area network, designed for low-power consumption and communication over long distances using low bitrates. It provides for communication between devices and gateways, which can then forward the data to, for example, applications or servers. A typical usage is for a distributed set of sensors, or for Internet of Things (IoT) devices, for which long battery life and long-range communication is a must. LoRaWAN addresses two of the key problems with attempting to use normal Wi-Fi for such applications: range and power consumption. There are several implementations, a notable one being The Things Network, a free, open source implementation.
LoRaWAN(Nov 2017, 评估)
LoRaWAN is a low-power wide-area network, designed for low-power consumption and communication over long distances using low bitrates. It provides for communication between devices and gateways, which can then forward the data to, for example, applications or servers. A typical usage is for a distributed set of sensors, or for Internet of Things (IoT) devices, for which long battery life and long-range communication is a must. LoRaWAN addresses two of the key problems with attempting to use normal Wi-Fi for such applications: range and power consumption. There are several implementations, a notable one being The Things Network, a free, open source implementation.
Keycloak(May 2018, 试验)
In a microservice, or any other distributed architecture, one of the most common needs is to secure the services or APIs through authentication and authorization features. This is where Keycloak comes in. Keycloak is an open source identity and access management solution that makes it easy to secure applications or microservices with little to no code. It supports single sign-on, social login and standard protocols such as OpenID Connect, OAuth 2.0 and SAML out of the box. Our teams have been using this tool and plan to keep using it for the foreseeable future. But it requires a little work to set up. Because configuration happens both at initialization and at runtime through APIs, it's necessary to write scripts to ensure deployments are repeatable.
Keycloak(Nov 2017, 试验)
In a microservice, or any other distributed architecture, one of the most common needs is to secure the services or APIs through authentication and authorization features. This is where Keycloak comes in. Keycloak is an open source identity and access management solution that makes it easy to secure applications or microservices with little to no code. It supports single sign-on, social login and standard protocols such as OpenID Connect, OAuth 2.0 and SAML out of the box. Our teams have been using this tool and plan to keep using it for the foreseeable future. But it requires a little work to set up. Because configuration happens both at initialization and at runtime through APIs, it's necessary to write scripts to ensure deployments are repeatable.
Keycloak(Mar 2017, 评估)
In a microservices or any other distributed architecture, one of the most common needs is to secure the services or APIs through authentication and authorization features. This is where Keycloak comes in. Keycloak is an open source identity and access management solution that makes it easy to secure applications or microservices with little to no code. Out of the box, it supports single sign-on, social login, and standard protocols such as OpenID Connect, OAuth2 and SAML.
Web Bluetooth(May 2018, 评估)
Web Bluetooth allows us to control any Bluetooth Low Energy device directly from the browser. This allows us to target scenarios that previously could only be solved with a native app. The specification is published by the Web Bluetooth Community Group and describes an API to discover and communicate with devices over the Bluetooth 4 wireless standard. Right now, Chrome is the only major browser which currently supports this specification. With Physical Web and Web Bluetooth, we now have other avenues for getting users to interact with devices without them having to install yet another app on their phone. This is an exciting space which is worth keeping an eye on.
Flow(May 2018, 评估)
Flow is a static type checker for JavaScript that allows you to add type checking across the codebase incrementally. Unlike Typescript, which is a different language, Flow can be added incrementally to an existing JavaScript codebase supporting the 5th, 6th and 7th editions of ECMAScript. We suggest adding Flow to your continuous integration pipeline, starting with the code that concerns you most. Flow adds to the clarity of the code, increases the reliability of refactoring and catches type-related bugs early during the build.
Flow(Nov 2017, 评估)
Flow is a static type checker for JavaScript that allows you to add type checking across the codebase incrementally. Unlike Typescript, which is a different language, Flow can be added incrementally to an existing JavaScript codebase supporting the 5th, 6th and 7th editions of ECMAScript. We suggest adding Flow to your continuous integration pipeline, starting with the code that concerns you most. Flow adds to the clarity of the code, increases the reliability of refactoring and catches type-related bugs early during the build.
PostCSS(Nov 2017, 评估)
PostCSS is a Node.js-based JavaScript framework for operating on an abstract syntax tree-based representation of CSS documents with a rich ecosystem of plugins. Often incorrectly thought of as a preprocessor (such as SASS or Less), we find that the real power of PostCSS comes from the number of things that can be done with the rich set of plugins which includes linting (the stylelint plugin), cross-compilation (the sugarss plugin), name-mangling to avoid selector collision (the modules plugin), boilerplate CSS code generation (the autoprefixer plugin), minification and many others. The different maturity levels of the plugins notwithstanding, PostCSS itself remains a simple and powerful framework for treating CSS like a full-fledged language for front-end development.
PostCSS(Mar 2017, 评估)
PostCSS is a Node.js-based JavaScript framework for operating on an abstract syntax tree-based representation of CSS documents with a rich ecosystem of plugins. Often incorrectly thought of as a preprocessor (such as SASS or Less), we find that the real power of PostCSS comes from the number of things that can be done with the rich set of plugins which includes linting (the stylelint plugin), cross-compilation (the sugarss plugin), name-mangling to avoid selector collision (the modules plugin), boilerplate CSS code generation (the autoprefixer plugin), minification and many others. The different maturity levels of the plugins notwithstanding, PostCSS itself remains a simple and powerful framework for treating CSS like a full-fledged language for front-end development.
Rendertron(Nov 2017, 评估)
A perennial problem for JavaScript-heavy web applications is how to make the dynamic portion of those pages available to search engines. Historically, developers have resorted to a variety of tricks, including server-side rendering with React, external services or prerendering content. Now Google Chrome's new headless mode adds a new ‘trick’ to the toolbox — Rendertron, a headless Chrome rendering solution. Rendertron wraps an instance of headless Chrome in a Docker container, ready to deploy as a standalone HTTP server. Bots that don't render JavaScript can be routed to this server to do the rendering for them. Although developers can always deploy their own headless Chrome proxy and associated routing machinery, Rendertron simplifies the configuration and deployment process, and provides example middleware code for detecting and routing bots.
Prometheus(Nov 2017, 试验)
We've seen both continuing improvements in and an uptick in adoption of Prometheus, the monitoring and time series database tool originally developed by Soundcloud. Prometheus primarily supports a pull-based HTTP model but it also supports alerts, making it an active part of your operational toolset. As of this writing, Prometheus 2.0 is in prerelease, and continues to evolve. Prometheus developers have focused their efforts on core time series databases and the variety of metrics available. Grafana has become the dashboard visualization tool of choice for Prometheus users and support for Grafana ships with the tool. Our teams also find that Prometheus monitoring nicely complements the indexing and search capabilities of an Elastic Stack.
Prometheus(Apr 2016, 评估)
SoundCloud has recently open sourced its monitoring and alerting toolkit, Prometheus. Developed in reaction to difficulties with Graphite in its production systems, Prometheus primarily supports a pull-based HTTP model (although a more Graphite-like push model is also supported). It also goes further by supporting alerts, making it an active part of your operational toolset. As of this writing, Prometheus is still only in release 0.15.1 but is evolving rapidly. We’re glad to see the recent product focus on core time-series DB and multidimensional indexing capabilities while allowing for export to a wider variety of front-end graphing tools.
Prometheus(May 2015, 评估)
SoundCloud have recently open sourced a Graphite replacement, Prometheus. Developed as a reaction to difficulties with Graphite in their production systems, Prometheus works differently to Graphite, by primarily supporting a pull-based HTTP model (although a more Graphite-like push model is also supported). It also goes beyond Graphite by being built to support alerting based on captured metrics, so it becomes a much more active part of your operational toolset. Some caution should be used in adopting new technology in the production monitoring space, but early reports are that SoundCloud are happy using it in production, and Docker are also contributing to ongoing development.
Weex(Nov 2017, 评估)
Weex is a framework for building cross-platform mobile apps by using the Vue.js component syntax. For those who prefer the simplicity of Vue.js, Weex is a viable option for native mobile apps, but it also works very well for more complicated apps. We see many successes for fairly complicated mobile apps built on this framework, including TMall and Taobao, two of the most popular mobile apps in China. Weex was developed by Alibaba, and is now an Apache incubator project.
Instana(Nov 2017, 评估)
Instana is yet another entrant into the crowded application performance management space. The fact that it's built from the ground up for cloud native architectures differentiates Instana from many of its competitors. Features include dynamic discovery, distributed tracing and service health plus the ability to "time shift" your view of your infrastructure to the moment an incident occurred. It remains to be seen whether this product can gain traction over the combination of open source projects—such as Consul, Prometheus and the implementations of OpenTracing—that do the same thing; however it's worth taking a look if you need an out-of-the-box solution.
Instana(Mar 2017, 评估)
Instana is yet another entrant into the crowded application performance management space. The fact that it's built from the ground up for cloud native architectures differentiates Instana from many of its competitors. Features include dynamic discovery, distributed tracing and service health plus the ability to "time shift" your view of your infrastructure to the moment an incident occurred. It remains to be seen whether this product can gain traction over the combination of open source projects—such as Consul, Prometheus and the implementations of OpenTracing—that do the same thing; however it's worth taking a look if you need an out-of-the-box solution.
Legacy in a box(Nov 2017, 试验)
Working with legacy code, especially large monoliths, is one of the most unsatisfying, high-friction experiences for developers. Although we caution against extending and actively maintaining legacy monoliths, they continue to be dependencies in our environments, and developers often underestimate the cost and time required to develop against these dependencies. To help reduce the friction, developers have used virtualized machine images or container images with Docker containers to create immutable images of legacy systems and their configurations. The intent is to contain the legacy in a box for developers to run locally and remove the need for rebuilding, reconfiguring or sharing environments. In an ideal scenario, teams that own legacy systems generate the corresponding boxed legacy images through their build pipelines, and developers can then run and orchestrate these images in their allocated sandbox more reliably. Although this approach has reduced the overall time spent by each developer, it has had limited success when the teams owning the downstream dependencies have been reluctant to create container images for others to use.
Legacy in a box(Mar 2017, 试验)
Working with legacy code, especially large monoliths, is one of the most unsatisfying, high-friction experiences for developers. Although we caution against extending and actively maintaining legacy monoliths, they continue to be dependencies in our environments, and developers often underestimate the cost and time required to develop against these dependencies. To help reduce the friction, developers have used virtualized machine images or container images with Docker containers to create immutable images of legacy systems and their configurations. The intent is to contain the legacy in a box for developers to run locally and remove the need for rebuilding, reconfiguring or sharing environments. In an ideal scenario, teams that own legacy systems generate the corresponding boxed legacy images through their build pipelines, and developers can then run and orchestrate these images in their allocated sandbox more reliably. Although this approach has reduced the overall time spent by each developer, it has had limited success when the teams owning the downstream dependencies have been reluctant to create container images for others to use.
TensorFlow Mobile(Nov 2017, 评估)
TensorFlow Mobile makes it possible for developers to incorporate a wide range of comprehension and classification techniques into their iOS or Android applications. This is particularly useful given the range of sensor data available on mobile phones. Pretrained TensorFlow models can be loaded into a mobile application and applied to inputs such as live video frames, text or speech. Mobile phones present a surprisingly opportune platform for implementing these computational models. TensorFlow models are exported and loaded as protobuf files, which can present some problems for implementers. Protobuf's binary format can make it hard to examine models and requires that you link the correct protobuf library version to your mobile app. But local model execution offers an attractive alternative to TensorFlow Serving without the communication overhead of remote execution.
Decoupling secret management from source code(Nov 2017, 试验)
In previous Radars issues we mentioned tools such as git-crypt and Blackbox that allow us to keep secrets safe inside the source code. Decoupling secret management from source code is our way to remind technologists that there are other options for storing secrets. For example, HashiCorp vault, CI servers and configuration management tools provide mechanisms for storing secrets that are not linked to the source code of an application. Both approaches are viable and we recommend you use at least one of them in your projects.
Decoupling secret management from source code(Mar 2017, 试验)
In previous Radars issues we mentioned tools such as git-crypt and Blackbox that allow us to keep secrets safe inside the source code. Decoupling secret management from source code is our way to remind technologists that there are other options for storing secrets. For example, HashiCorp vault, CI servers and configuration management tools provide mechanisms for storing secrets that are not linked to the source code of an application. Both approaches are viable and we recommend you use at least one of them in your projects.
Druid(Nov 2017, 评估)
Druid is a JDBC connection pool with rich monitoring features. It has a built-in SQL parser, which provides semantic monitoring of the SQL statements executing in the database. Injections or suspicious SQL statements will be blocked and logged directly from the JDBC layer. What’s more, queries can be merged based on their semantics. This is an Alibaba open source project, and reflects the lessons Alibaba learnt from operating their own database systems.
DialogFlow(Nov 2017, 评估)
In parallel with the recent surge of chatbots and voice platforms, we've seen a proliferation of tools and platforms that provide a service to extract intent from text and management of conversational flows that you can hook into. DialogFlow (formerly API.ai), which was acquired by Google, is one such ‘natural-language-understanding as a service’ offering that competes with wit.ai and Amazon Lex among other players in this space.
DialogFlow(Mar 2017, 评估)
In parallel with the recent surge of chatbots and voice platforms, we've seen a proliferation of tools and platforms such as api.ai that provide a service to extract intent from text and management of conversational flow that you can hook into. Recently acquired by Google, this "natural-language-understanding as a service" offering competes with other players in this space such as wit.ai and Amazon's Lex.
TDD'ing containers(Nov 2017, 试验)
Many development teams have adopted test-driven development practices for writing application code because of their benefits. Others have turned to containers to package and deploy their software, and it's accepted practice to use automated scripts to build the containers. What we’ve seen few teams do so far is combine the two trends and drive the writing of the container scripts using tests. With frameworks such as Serverspec and Goss, you can express the intended functionality for either isolated or orchestrated containers, with short feedback loops. This means that it’s possible to use the same principles we’ve championed for code by TDD'ing containers. Our initial experience doing so has been very positive.
ECharts(Nov 2017, 评估)
ECharts is a lightweight charting library with rich support for different types of charts and interactions. Since ECharts is entirely based on the Canvas API, it has incredible performance even when dealing with over 100k data points, and it's also been optimized for mobile usage. Together with its sibling project, ECharts-X, it can support 3D plotting. ECharts is a Baidu open source project.
Digdag(Nov 2017, 评估)
Digdag is a tool for building, running, scheduling and monitoring complex data pipelines in the cloud. You can define these pipelines in YAML, using either the rich set of out-of-the-box operators or building your own through the API. Digdag has most of the common features in a data pipeline solution such as dependency management, modular workflow to promote reuse, secured secret management and multilingual support. The feature we're most excited about is polycloud support, which lets you move and join data across AWS RedShift, S3, and Google BigQuery. As more and more cloud providers offer competing data-processing solutions, we think Digdag (and similar tools) will be useful in leveraging the best option for the task.
Spring Cloud(Nov 2017, 试验)
Spring Cloud continues to evolve and add interesting new features. Support for binding to Kafka Streams, for example, in the spring-cloud-streams project makes it relatively easy to build message driven applications with connectors for Kafka and RabbitMQ. The teams we have using it appreciate the simplicity it brings to using sometimes complex infrastructure, such as ZooKeeper, and support for common problems that we need to address when building distributed systems, tracing with the spring-cloud-sleuth for example. The usual caveats apply but we're successfully using it on multiple projects.
Spring Cloud(Mar 2017, 评估)
Teams building systems composed of microservices need to think about coordination techniques such as service discovery, load balancing, circuit breaking and health checking. Many of these techniques require teams to set up tooling, which is not always trivial. The Spring Cloud project provides tools for developers so they can use these coordination techniques in the familiar Spring environment. These tools support Consul, ZooKeeper and the Netflix OSS full stack, all tools that we like. Simply put, it makes it easy to do the right thing with these tool sets. Although our usual concerns with Spring still stand, namely that it hides too much of the complexity, you should consider Spring Cloud if you are in the ecosystem and need to solve these problems.
Mosquitto(Nov 2017, 评估)
In our experience—for Internet of Things (IoT) solutions where a lot of devices communicate with each other and/or a central data hub—the MQTT connectivity protocol has proven itself. We've also come to like the Mosquitto MQTT broker. It might not satisfy all demands, particularly with regard to scalability, but its compact nature and easy setup makes it ideal for development and testing purposes.
Mosquitto(Mar 2017, 评估)
In our experience—for Internet of Things (IoT) solutions where a lot of devices communicate with each other and/or a central data hub—the MQTT connectivity protocol has proven itself. We've also come to like the Mosquitto MQTT broker. It might not satisfy all demands, particularly with regard to scalability, but its compact nature and easy setup makes it ideal for development and testing purposes.
Scikit-learn(Nov 2017, 试验)
Scikit-learn is not a new tool (it is approaching its tenth birthday); what is new is the rate of adoption of machine-learning tools and techniques outside of academia and major tech companies. Providing a robust set of models and a rich set of functionality, Scikit-learn plays an important role in making machine-learning concepts and capabilities more accessible to a broader (and often non-expert) audience.
Scikit-learn(Mar 2017, 试验)
Scikit-learn is not a new tool (it is approaching its tenth birthday); what is new is the rate of adoption of machine-learning tools and techniques outside of academia and major tech companies. Providing a robust set of models and a rich set of functionality, Scikit-learn plays an important role in making machine-learning concepts and capabilities more accessible to a broader (and often non-expert) audience.
Scikit-learn(Nov 2016, 评估)
Scikit-learn is an increasingly popular machine-learning library written in Python. It provides a robust set of machine-learning models such as clustering, classification, regression and dimensionality reduction, and a rich set of functionality for companion tasks like model selection, model evaluation and data preparation. Since it is designed to be simple, reusable in various contexts and well documented, we see this tool accessible even to nonexperts to explore the machine-learning space.
Serverless architecture(Nov 2017, 试验)
The use of serverless architecture has very quickly become an accepted approach for organizations deploying cloud applications, with a plethora of choices available for deployment. Even traditionally conservative organizations are making partial use of some serverless technologies. Most of the discussion goes to Functions as a Service (e.g., AWS Lambda, Google Cloud Functions, Azure Functions) while the appropriate patterns for use are still emerging. Deploying serverless functions undeniably removes the nontrivial effort that traditionally goes into server and OS configuration and orchestration. Serverless functions, however, are not a fit for every requirement. At this stage, you must be prepared to fall back to deploying containers or even server instances for specific requirements. Meanwhile, the other components of a serverless architecture, such as Backend as a Service, have become almost a default choice.
Serverless architecture(Mar 2017, 试验)
A serverless architecture approach replaces long-running virtual machines with ephemeral compute power that comes into existence on request and disappears immediately after use. Our teams like the serverless approach; it's working well for us and we consider it a valid architectural choice. Note that serverless doesn't have to be an all-or-nothing approach: some of our teams have deployed a new chunk of their systems using serverless while sticking to a traditional architectural approach for other pieces. Although AWS Lambda is almost synonymous with serverless, the other major cloud providers all have similar offerings, and we also recommend assessing niche players such as webtask.
Serverless architecture(Nov 2016, 试验)
Serverless architecture is an approach that replaces long-running virtual machines with ephemeral compute power that comes into existence on request and disappears immediately after use. Since the last Radar, we have had several teams put applications into production using a "serverless" style. Our teams like the approach, it’s working well for them and we consider it a valid architectural choice. Note that serverless doesn’t have to be an all-or-nothing approach: some of our teams have deployed a new chunk of their systems using serverless while sticking to a traditional architectural approach for other pieces.
Serverless architecture(Apr 2016, 评估)
Serverless architecture replaces long-running virtual machines with ephemeral compute power that comes into existence on request and disappears immediately after use. Examples include Firebase and AWS Lambda. Use of this architecture can mitigate some security concerns such as security patching and SSH access control, and can make much more efficient use of compute resources. These systems cost very little to operate and can have inbuilt scaling features (this is especially true for AWS Lambda). An example architecture could be a JavaScript app with static assets served by a CDN or S3 coupled with AJAX calls served by the API Gateway and Lambda. While serverless architectures have significant benefits, there are drawbacks too: Deploying, managing and sharing code across services is more complex, and local or offline testing is more difficult if not impossible.
Spec-based codegen(Nov 2017, 暂缓)
Back in the days when SOAP held sway in the enterprise software industry, the practice of generating client code from WSDL specs was an accepted—even encouraged—practice. Unfortunately, the resulting code was often complex, untestable, difficult to modify and frequently didn't work across implementation platforms. With the advent of REST, we found it better to evolve API clients that use the tolerant reader pattern for extracting and processing only the fields needed. Recently we have observed a disturbing return to old habits with developers generating code from API specifications written in Swagger or RAML—a practice that we refer to as spec-based codegen. Although such tools are very useful for driving the design of APIs and for extracting documentation, we caution against the tempting shortcut of simply generating client code directly from these specifications. The chances are that such code will be difficult to test and maintain.
Spec-based codegen(Mar 2017, 暂缓)
Back in the days when SOAP held sway in the enterprise software industry, the practice of generating client code from WSDL specs was an accepted—even encouraged—practice. Unfortunately, the resulting code was often complex, untestable, difficult to modify and frequently didn't work across implementation platforms. With the advent of REST, we found it better to evolve API clients that use the tolerant reader pattern for extracting and processing only the fields needed. Recently we have observed a disturbing return to old habits with developers generating code from API specifications written in Swagger or RAML—a practice that we refer to as spec-based codegen. Although such tools are very useful for driving the design of APIs and for extracting documentation, we caution against the tempting shortcut of simply generating client code directly from these specifications. The chances are that such code will be difficult to test and maintain.
Hyperledger(Nov 2017, 评估)
Hyperledger is a platform built around blockchain technologies. It consists of a blockchain implementation named Fabric and other associated tools. Disregarding the hype surrounding blockchain, our teams have found it easy to get started with these tools. The fact that it is an open source platform supported by the Linux Foundation also adds to our excitement about Hyperledger.
Hyperledger(Mar 2017, 评估)
Hyperledger is a platform built around blockchain technologies. It consists of a blockchain implementation named Fabric and other associated tools. Disregarding the hype surrounding blockchain, our teams have found it easy to get started with these tools. The fact that it is an open source platform supported by the Linux Foundation also adds to our excitement about Hyperledger.
Keras(Nov 2017, 评估)
Keras is a high-level interface in Python for building neural networks. Created by a Google engineer, Keras is open source and runs on top of either TensorFlow or Theano. It provides an amazingly simple interface for creating powerful deep-learning algorithms to train on CPUs or GPUs. Keras is well designed with modularity, simplicity, and extensibility in mind. Unlike a library such as Caffe, Keras supports more general network architectures such as recurrent nets, making it overall more useful for text analysis, NLP and general machine learning. If computer vision, or any other specialized branch of machine learning, is your primary concern, Caffe may be a more appropriate choice. However, if you’re looking to learn a simple yet powerful framework, Keras should be your first choice.
Keras(Mar 2017, 评估)
Keras is a high-level interface in Python for building neural networks. Created by a Google engineer, Keras is open source and runs on top of either TensorFlow or Theano. It provides an amazingly simple interface for creating powerful deep-learning algorithms to train on CPUs or GPUs. Keras is well designed with modularity, simplicity, and extensibility in mind. Unlike a library such as Caffe, Keras supports more general network architectures such as recurrent nets, making it overall more useful for text analysis, NLP and general machine learning. If computer vision, or any other specialized branch of machine learning, is your primary concern, Caffe may be a more appropriate choice. However, if you're looking to learn a simple yet powerful framework, Keras should be your first choice.
Caffe(Nov 2017, 评估)
Caffe is an open source library for deep learning created by the Berkeley Vision and Learning Center. It mostly focusses on convolutional networks for computer vision applications. Caffe is a solid and popular choice for computer vision-related tasks and you can download many successful models made by Caffe users from the Caffe Model Zoo for out-of-the-box use. Like Keras, Caffe is a Python-based API. In Keras, however, models and components are objects created directly in Python code, whereas Caffe models are described by Protobuf configuration files. Either approach has its pros and cons, and converting between the two is also possible.
Caffe(Mar 2017, 评估)
Caffe is an open source library for deep learning created by the Berkeley Vision and Learning Center. It mostly focusses on convolutional networks for computer vision applications. Caffe is a solid and popular choice for computer vision-related tasks and you can download many successful models made by Caffe users from the Caffe Model Zoo for out-of-the-box use. Like Keras, Caffe is a Python-based API. In Keras, however, models and components are objects created directly in Python code, whereas Caffe models are described by Protobuf configuration files. Either approach has its pros and cons, and converting between the two is also possible.
Serverless Framework(Nov 2017, 试验)
The popular Serverless Framework provides tooling for scaffolding and deployment of serverless applications, primarily using AWS Lambda and other AWS offerings. Serverless Framework provides template support for JavaScript, Python, Java and C#, and has an active community that contributes plugins that extend the framework. The framework also supports the Apache incubator project OpenWhisk as an alternative to AWS Lambda.
Serverless Framework(Mar 2017, 试验)
The popular Serverless Framework provides tooling for scaffolding and deployment of serverless applications, primarily using AWS Lambda and other AWS offerings. Serverless Framework provides template support for JavaScript, Python, Java and C#, and has an active community that contributes plugins that extend the framework. The framework also supports the Apache incubator project OpenWhisk as an alternative to AWS Lambda.
CI theatre(Nov 2017, 暂缓)
We've long been advocates of continuous integration (CI), and we were pioneers in building CI server programs to automatically build projects on check-ins. Used well, these programs run as a daemon process on a shared project mainline that developers commit to daily. The CI server builds the project and runs comprehensive tests to ensure the whole software system is integrated and is in an always-releasable state, thus satisfying the principles of continuous delivery. Sadly, many developers simply set up a CI server and falsely assume they are "doing CI" when in reality they miss out on all the benefits. Common failure modes include: running CI against a shared mainline but with infrequent commits, so integration isn't really continuous; running a build with poor test coverage; allowing the build to stay red for long periods; or running CI against feature branches which results in continuous isolation. The ensuing " CI theatre" might make people feel good, but would fail any credible CI certification test.
CI theatre(Mar 2017, 暂缓)
We've long been advocates of continuous integration (CI), and we were pioneers in building CI server programs to automatically build projects on check-ins. Used well, these programs run as a daemon process on a shared project mainline that developers commit to daily. The CI server builds the project and runs comprehensive tests to ensure the whole software system is integrated and is in an always-releasable state, thus satisfying the principles of continuous delivery. Sadly, many developers simply set up a CI server and falsely assume they are "doing CI" when in reality they miss out on all the benefits. Common failure modes include: running CI against a shared mainline but with infrequent commits, so integration isn't really continuous; running a build with poor test coverage; allowing the build to stay red for long periods; or running CI against feature branches which results in continuous isolation. The ensuing " CI theatre" might make people feel good, but would fail any credible CI certification test.
assertj-swagger(Nov 2017, 评估)
An AssertJ library, assertj-swagger enables you to validate an API implementation's compliance with its contract specification. Our teams use assertj-swagger to catch problems when the API endpoint implementation changes without updating its Swagger specification, or fails to publish the updated documentation.
Unity beyond gaming(Nov 2017, 试验)
In previous Radars, we mentioned that Unity has become the platform of choice for VR and AR application development because it provides the abstractions and tooling of a mature platform, while being more accessible than its main alternative, the Unreal Engine. With the recent introductions of ARKit for iOS and ARCore for Android, the two main mobile platforms now have powerful native SDKs for building augmented reality applications. Yet, we feel that many teams, especially those without deep experience in building games, will benefit from using an abstraction such as Unity, which is why we're calling out Unity beyond gaming. This allows developers unfamiliar with the technology to focus on one SDK. It also offers a solution for the huge number of devices, especially on the Android side, that are not supported by the native SDKs.
Unity beyond gaming(Mar 2017, 试验)
After experiencing years of growth as a platform for game development, Unity has recently become the platform of choice for VR and AR application development. Whether you're creating a fully immersive world for the Oculus or HTC Vive headsets, a holographic layer for your newly spatial enterprise application or an AR feature set for your mobile app, Unity likely provides what you need to both prototype it and get it ready for prime time. Many of us at ThoughtWorks believe that VR and AR represent the next significant shift in the computing platform, and for now, Unity is the single most important tool in the toolbox we use to develop for this change. We've used Unity to develop all our VR prototypes, as well as AR functionality for headsets and phone/tablet applications.
Unity beyond gaming(Nov 2016, 试验)
After experiencing years of growth as a platform for game development, Unity has recently become the platform of choice for VR and AR application development. Whether you’re creating a fully immersive world for the Oculus or HTC Vive headsets, a holographic layer for your newly spatial enterprise application or an AR feature set for your mobile app, Unity likely provides what you need to both prototype it and get it ready for prime time. Many of us at ThoughtWorks believe that VR and AR represent the next significant shift in the computing platform, and for now, Unity is the single most important tool in the toolbox we use to develop for this change. We’ve used Unity to develop all our VR prototypes, as well as AR functionality for headsets and phone/tablet applications.
MapD(Nov 2017, 评估)
MapD is an in-memory columnar analytic database with SQL support that's built to run on GPU. We debated whether the database workload is actually I/O or computationally bound but there are instances where the parallelism of the GPU, combined with the large bandwidth of VRAM, can be quite useful. MapD transparently manages the most frequently used data in VRAM (such as columns involved in group-by, filters, calculations and join conditions) and stores the rest of the data in the main memory. With this memory management setup, MapD achieves significant query performance without the need of indexes. Although there are other GPU database vendors, MapD is leading this segment with the recent open source release of its core database and through the GPU Open Analytics Initiative. If your analytical workload is computationally heavy, can exploit GPU parallelism and can fit in the main memory, we recommend assessing MapD.
ARKit/ARCore(Nov 2017, 评估)
We've seen a flurry of activity in mobile augmented reality much of it fueled by ARKit and ARCore , the native AR libraries used by Apple and Google, respectively. These libraries are bringing mobile AR technologies to the mainstream. However, the challenge will be for companies to find use cases that go beyond gimmicky and provide genuine solutions that actually enhance the user experience.
spaCy(Nov 2017, 评估)
spaCy is a Natural Language Processing (NLP) library written in Python. It is a high-performance library, intended for use by developers in production, and applies NLP models suited for processing text that often mixes in emoticons and inconsistent punctuation marks. Unlike other NLP frameworks, spaCy is a pluggable library and not a platform; it is aimed at production applications rather than model training for research. It plays well with TensorFlow and the rest of the Python AI ecosystem. We've used spaCy in the enterprise context to build a search engine that takes human language queries and helps users make business decisions.
spaCy(Mar 2017, 评估)
spaCy is a Natural Language Processing (NLP) library written in Python. It is a high-performance library, intended for use by developers in production, and applies NLP models suited for processing text that often mixes in emoticons and inconsistent punctuation marks. Unlike other NLP frameworks, spaCy is a pluggable library and not a platform; it is aimed at production applications rather than model training for research. It plays well with TensorFlow and the rest of the Python AI ecosystem. We've used spaCy in the enterprise context to build a search engine that takes human language queries and helps users make business decisions.
PlatformIO(Nov 2017, 评估)
PlatformIO provides a rich ecosystem for IoT development by providing cross-platform builds, library management and good integration with existing IDEs. The intelligent code completion and Smart Code Linter with built-in terminal and serial port monitor greatly enhances the developer experience. It also organizes and maintains thousands of libraries and provides a clean dependency manager with semantic versioning to ease IoT development. We've started using PlatformIO in a few IoT projects and we really like it for its simplicity and wide support of platforms and boards.
PlatformIO(Mar 2017, 评估)
PlatformIO provides a rich ecosystem for IoT development by providing cross-platform builds, library management and good integration with existing IDEs. The intelligent code completion and Smart Code Linter with built-in terminal and serial port monitor greatly enhances the developer experience. It also organizes and maintains thousands of libraries and provides a clean dependency manager with semantic versioning to ease IoT development. We've started using PlatformIO in a few IoT projects and we really like it for its simplicity and wide support of platforms and boards.
Spring Cloud Contract(Nov 2017, 评估)
If you're implementing Java services using the Spring framework, you may want to consider Spring Cloud Contract for consumer-driven contract testing. The current ecosystem of this tool supports verification of the client calls and the server implementation against the contract. In comparison to Pact, an open source consumer-driven contract testing tool set, it lacks the brokering of the contracts and the support for other programming languages. However, it integrates well with the Spring ecosystem, for instance message routing with Spring Integration.
Python 3(Nov 2017, 采纳)
Python 3 introduced many useful features that are not backward compatible with Python 2.x. It also removed numerous Python 2.x features that were maintained for backward compatibility, making Python 3 easier to learn and use and more consistent with the rest of the language. Our experience using Python 3 in domains such as machine learning and web application development shows that both the language and most of its supporting libraries have matured for adoption. We were able to fork and patch minor issues of existing libraries or avoided using incompatible Python 2.x libraries that had been abandoned. If you are developing in Python we strongly encourage you to use Python 3.
Python 3(Mar 2017, 采纳)
Python 3 introduced many useful features that are not backward compatible with Python 2.x. It also removed numerous Python 2.x features that were maintained for backward compatibility, making Python 3 easier to learn and use and more consistent with the rest of the language. Our experience using Python 3 in domains such as machine learning and web application development shows that both the language and most of its supporting libraries have matured for adoption. We were able to fork and patch minor issues of existing libraries or avoided using incompatible Python 2.x libraries that had been abandoned. If you are developing in Python we strongly encourage you to use Python 3.
Python 3(Jul 2014, 评估)
Python 3 was a major change from the previous Python 2.x that introduced backwards incompatible changes. It was notable for actually removing languages features, making Python 3 easier to use and more consistent without reducing its power. This has led to problems in adoption as some widely used supporting libraries have not been ported, and Python developers often have to find new ways of doing things. Nonetheless the drive towards making a language simpler is to be applauded, and if you are actively developing in Python, then give Python 3 another look.
DesignOps(Nov 2017, 试验)
Inspired by the DevOps movement, DesignOps is a cultural shift and a set of practices that allows people across an organization to continuously redesign products without compromising quality, service coherency or team autonomy. DesignOps advocates for the creation and evolution of a design infrastructure that minimizes the effort necessary to create new UI concepts and variations, and to establish a rapid and reliable feedback loop with end users. With tools such as Storybook promoting close collaboration, the need for upfront analysis and specification handoffs is reduced to the absolute minimum. With DesignOps, design is shifting from being a specific practice to being a part of everyone's job.
Voice platforms(Nov 2017, 评估)
Voice platforms such as Amazon Alexa and Google Home are riding high on the hype cycle; some even herald the ubiquity of the conversational voice interface. We're already integrating conversational UIs into products and seeing the impact of this new interaction in how we design interfaces. Alexa specifically was built from the ground up without a screen and treats the conversational UI as first-class. But it's still too early to believe the hype, and we expect more big players to get in the game.
Voice platforms(Mar 2017, 评估)
Voice platforms such as Amazon Alexa and Google Home are riding high on the hype cycle; some even herald the ubiquity of the conversational voice interface. We're already integrating conversational UIs into products and seeing the impact of this new interaction in how we design interfaces. Alexa specifically was built from the ground up without a screen and treats the conversational UI as first-class. But it's still too early to believe the hype, and we expect more big players to get in the game.
Algorithmic IT operations(Nov 2017, 评估)
The amount of data collected by IT operations has been increasing for years. For example, the trend toward microservices means that more applications are generating their own operational data, and tools such as Splunk, Prometheus, or the ELK stack make it easier to store and process data later on, to gain operational insights. When combined with increasingly democratized machine learning tools, it’s inevitable that operators will start to incorporate statistical models and trained classification algorithms into their toolsets. Although these algorithms have been available for years, and various attempts have been made to automate service management, we're only just starting to understand how machines and humans can collaborate to identify outages earlier or pinpoint the source of failures. Although there is a risk of overhyping Algorithmic IT operations , steady improvement in machine learning algorithms will inevitably change the role of humans in operating tomorrow's data centers.
Jest(Nov 2017, 试验)
Our teams are delighted with the results of using Jest for front-end testing. It provides a ‘zero-configuration’ experience and has out-of-the-box features such as mocking and code coverage. You can apply this testing framework not only to React applications, but also to other JavaScript frameworks. One of Jest's often hyped features is UI snapshot testing. Snapshot testing would be a good addition to the upper layer of the test pyramid, but remember, unit testing is still the solid foundation.
jsoniter(Nov 2017, 试验)
If you're looking for a JSON encoder/decoder with high performance in Go and Java, check out the open source jsoniter library. The library is compatible with the standard JSON encoding package in Go.
A single CI instance for all teams(Nov 2017, 暂缓)
We're compelled to caution, again, against creating a single CI instance for all teams. While it's a nice idea in theory to consolidate and centralize Continuous Integration (CI) infrastructure, in reality we do not see enough maturity in the tools and products in this space to achieve the desired outcome. Software delivery teams which must use the centralized CI offering regularly have long delays depending on a central team to perform minor configuration tasks, or to troubleshoot problems in the shared infrastructure and tooling. At this stage, we continue to recommend that organizations limit their centralized investment to establishing patterns, guidelines and support for delivery teams to operate their own CI infrastructure.
A single CI instance for all teams(Mar 2017, 暂缓)
We're compelled to caution, again, against creating a single CI instance for all teams. While it's a nice idea in theory to consolidate and centralize Continuous Integration (CI) infrastructure, in reality we do not see enough maturity in the tools and products in this space to achieve the desired outcome. Software delivery teams which must use the centralized CI offering regularly have long delays depending on a central team to perform minor configuration tasks, or to troubleshoot problems in the shared infrastructure and tooling. At this stage, we continue to recommend that organizations limit their centralized investment to establishing patterns, guidelines and support for delivery teams to operate their own CI infrastructure.
A single CI instance for all teams(Nov 2016, 暂缓)
There might be the impression that it's easier to manage a single CI (Continuous Integration) instance for all teams because it gives them a single configuration and monitoring point. But a bloated instance that is shared by every team in an organization can cause a lot of damage. We have found that problems like build timeouts, configuration conflicts and gigantic build queues appear more frequently. Having this single point of failure can interrupt the work of many teams. Carefully consider the trade-off between these pitfalls and having a single point of configuration. In organizations with multiple teams, we recommend having CI instances distributed by teams, with enterprise decisions based not on the single CI installation but on defining guidelines about the instances' selection and configuration.
Angular(Nov 2017, 试验)
In previous Radar editions, we've been hesitant to give Angular a strong recommendation because it was essentially a new, and on the whole unexciting, framework, sharing only its name with AngularJS, an older framework we loved in days past. In the meantime, Angular, now in version 5, has improved steadily while providing backward compatibility along the way. Several of our teams have Angular applications in production and reportedly, they like what they see. For this reason, we're moving Angular into the Trial ring in this Radar, to signify that some of our teams now consider it a solid choice. Most of our teams, however, still prefer React, Vue or Ember over Angular.
Angular(Mar 2017, 评估)
In the previous Radar, we moved AngularJS into the Hold ring (where it remains in this edition). When it comes to Angular 2 , we're seeing mixed messages. Over the past year some teams at ThoughtWorks have used Angular 2 successfully and consider it a solid choice. However, Angular 2 is a rewrite, not an evolution, of AngularJS, and switching from AngularJS to Angular 2 is not much different than switching from AngularJS to another framework. Given the, in our experience, superior contenders such as React.js, Ember.js and Vue.js, we're still hesitant to give Angular 2 a strong recommendation. We do want to highlight, though, that it is not a bad choice, especially if you bought into TypeScript.
Avro(Nov 2017, 试验)
Avro is a framework for data serialization. By storing schema along with the message content, it encourages schema evolution. Producers can edit field names, add new fields or delete existing fields and Avro guarantees that the clients continue to consume the messages. Having a schema allows data to be written without overhead which results in compact data encoding and faster data processing. Although the exchange of structure-less messages between producer and consumer is flexible, we've seen teams facing issues with incompatible unprocessed messages in the queue during deployments. We've used Avro in a number of projects and would recommend using it over just sending unstructured messages.
Avro(Mar 2017, 试验)
Avro is a framework for data serialization. By storing schema along with the message content, it encourages schema evolution. Producers can edit field names, add new fields or delete existing fields and Avro guarantees that the clients continue to consume the messages. Having a schema allows data to be written without overhead which results in compact data encoding and faster data processing. Although the exchange of structure-less messages between producer and consumer is flexible, we've seen teams facing issues with incompatible unprocessed messages in the queue during deployments. We've used Avro in a number of projects and would recommend using it over just sending unstructured messages.
Linux Security Modules(Mar 2017, 采纳)
The Principle of Least Privilege encourages us to restrict software components to access only the resources that they need. By default, however, a Linux process can do anything its running user can do—from binding to arbitrary ports to spawning new shells. The Linux Security Modules (LSM) framework, which allows for security extensions to be plugged into the kernel, has been used to implement MAC on Linux. SELinux and AppArmor are the predominant and best-known LSM-compatible implementations that ship with the kernel. We recommend that teams learn to use one of these security frameworks (which is why we placed it in the Adopt ring). They help teams assess questions about who has access to what resources on shared hosts, including contained services. This conservative approach to access management will help teams build security into their SDLC processes.
Linux Security Modules(Nov 2016, 采纳)
Application whitelisting has proven to be one of the most effective ways to mitigate cyber intrusion attacks. A convenient way to implement this widely recommended practice is through Linux security modules. With SELinux or AppArmor included by default in most Linux distributions, and with more comprehensive tools such as Grsecurity readily available, we have moved this technology into the Adopt ring in this edition. These tools help teams assess questions about who has access to what resources on shared hosts, including contained services. This conservative approach to access management will help teams build security into their SDLC processes.
Linux Security Modules(Apr 2016, 试验)
In earlier versions of the Radar, we have highlighted the value of Linux security modules , talking about how they enable people to think about server hardening as a part of their development workflow. More recently, with LXC and Docker containers now shipping with default AppArmor profiles on certain Linux distributions, it has forced the hand of many teams to understand how these tools work. In the event that teams use container images to run any process that they did not themselves create, these tools help them assess questions about who has access to what resources on the shared host and the capabilities that these contained services have, and be conservative in managing levels of access.
Linux Security Modules(Nov 2015, 评估)
While server hardening is an old technique that is considered fairly commonplace by sysadmins who have had to manage production systems, it has not become commonplace among the developer community. However, the rise in the DevOps culture has resulted in renewed focus on tools like SELinux, AppArmor and Grsecurity that aim to make this simpler, at least on the Linux ecosystem. Each of these tools comes with their own strengths and weaknesses and it is currently hard to pick one as being the only one you will need. That said, we highly recommend that all teams at least assess which Linux security modules would be the right one for them and make security and server hardening a part of their development workflow.
Cassandra carefully(Mar 2017, 评估)
Apache's Cassandra database is a powerful, scalable Big Data solution for storing and processing large amounts of data, often using hundreds of nodes split over multiple worldwide locations. It's a great tool and we like it, but too often we see teams run into trouble using it. We recommend using Cassandra carefully. Teams often misunderstand the use case for Cassandra, attempting to use it as a general-purpose data store when in fact it is optimized for fast reads on large data sets based on predefined keys or indexes. Its dependence on the storage schema can also make it difficult to evolve over time. Cassandra also has significant operational complexity and some rough edges, so unless you absolutely need the scaling it provides, a simpler solution is usually better. If you don't need Cassandra's specific use-case and scaling characteristics, you might just be choosing it out of Big Data envy. Careful use of Cassandra will include extensive automated testing, and we're happy to recommend CassandraUnit as part of your testing strategy.
Cassandra carefully(Nov 2016, 评估)
Apache’s Cassandra database is a powerful, scalable Big Data solution for storing and processing large amounts of data, often using hundreds of nodes split over multiple worldwide locations. It’s a great tool and we like it, but too often we see teams run into trouble using it. We recommend using Cassandra carefully. Teams often misunderstand the use case for Cassandra, attempting to use it as a general-purpose data store when in fact it is optimized for fast reads on large data sets based on predefined keys or indexes. Its dependence on the storage schema can also make it difficult to evolve over time. Cassandra also has significant operational complexity and some rough edges, so unless you absolutely need the scaling it provides, a simpler solution is usually better. If you don’t need Cassandra’s specific use-case and scaling characteristics, you might just be choosing it out of Big Data envy. Careful use of Cassandra will include extensive automated testing, and we’re happy to recommend CassandraUnit as part of your testing strategy.
Differential privacy(Mar 2017, 评估)
It has long been known that "anonymized" bulk data sets can reveal information about individuals, especially when multiple data sets are cross-referenced together. With increasing concern over personal privacy, some companies—including Apple and Google—are turning to differential privacy techniques in order to improve individual privacy while retaining the ability to perform useful analytics on large numbers of users. Differential privacy is a cryptographic technique that attempts to maximize the accuracy of statistical queries from a database while minimizing the chances of identifying its records. These results can be achieved by introducing a low amount of "noise" to the data, but it's important to note that this is an ongoing research area. Apple has announced plans to incorporate differential privacy into its products—and we wholeheartedly applaud its commitment to customers' privacy—but the usual Apple secrecy has left some security experts scratching their heads. We continue to recommend Datensparsamkeit as an alternative approach: simply storing the minimum data you actually need will achieve better privacy results in most cases.
Differential privacy(Nov 2016, 评估)
It has long been known that "anonymized" bulk data sets can reveal information about individuals, especially when multiple data sets are cross-referenced together. With increasing concern over personal privacy, some companies—including Apple and Google—are turning to differential privacy techniques in order to improve individual privacy while retaining the ability to perform useful analytics on large numbers of users. Differential privacy is a cryptographic technique that attempts to maximize the accuracy of statistical queries from a database while minimizing the chances of identifying its records. These results can be achieved by introducing a low amount of "noise" to the data, but it’s important to note that this is an ongoing research area. Apple has announced plans to incorporate differential privacy into its products—and we wholeheartedly applaud its commitment to customers' privacy—but the usual Apple secrecy has left some security experts scratching their heads. We continue to recommend Datensparsamkeit as an alternative approach: simply storing the minimum data you actually need will achieve better privacy results in most cases.
HSTS(Mar 2017, 采纳)
HTTP Strict Transport Security ( HSTS ) is a now widely supported policy that allows websites to protect themselves from downgrade attacks. A downgrade attack in the context of HTTPS is one that can cause users of your site to fall back to HTTP rather than HTTPS, allowing for further attacks such as man-in-the-middle attacks. With HSTS, the server sends a header that informs the browser that it should only use HTTPS to access the website. Browser support is now widespread enough that this easy-to-implement feature should be added to any site using HTTPS. Mozilla's Observatory can help identify this and other useful headers and configuration options that improve security and privacy. When implementing HSTS, it is critical to verify that all resources load properly over HTTPS, because once HSTS is turned on, there is (almost) no turning back until the expiry time. The directive to include subdomains should be added but, again, a thorough verification that all subdomains support secure transport is required.
HSTS(Nov 2016, 采纳)
HTTP Strict Transport Security ( HSTS ) is a now widely supported policy that allows websites to protect themselves from downgrade attacks. A downgrade attack in the context of HTTPS is one that can cause users of your site to fall back to HTTP rather than HTTPS, allowing for further attacks such as man-in-the-middle attacks. With HSTS, the server sends a header that informs the browser that it should only use HTTPS to access the website. Browser support is now widespread enough that this easy-to-implement feature should be added to any site using HTTPS. Mozilla’s Observatory can help identify this and other useful headers and configuration options that improve security and privacy. When implementing HSTS, it is critical to verify that all resources load properly over HTTPS, because once HSTS is turned on, there is (almost) no turning back until the expiry time. The directive to include subdomains should be added but, again, a thorough verification that all subdomains support secure transport is required.
HSTS(Apr 2016, 试验)
HTTP Strict Transport Security ( HSTS ) is a now widely supported policy that allows websites to protect themselves from downgrade attacks. A downgrade attack in the context of HTTPS is one that can cause users of your site to fall back to HTTP rather than HTTPS, allowing for further attacks such as man-in-the-middle attacks. By using the server header, you inform browsers that they should only use HTTPS to access your website, and should ignore downgrade attempts to contact the site via HTTP. Browser support is now widespread enough that this easy-to-implement feature should be considered for any site using HTTPS.
Social code analysis(Mar 2017, 评估)
Social code analysis enriches our understanding of the code quality by overlaying a developer's behavior with the structural analysis of the code. It uses data from version control systems, such as frequency and time of the change as well as the person making the change. You can choose to write your own scripts to analyze such data or use tools such as CodeScene. CodeScene can help you gain a better understanding of your software systems by identifying hotspots and complex, hard-to-maintain subsystems, coupling between distributed subsystems through temporal coupling, as well as the view of Conway's law in your organization. We believe that with technology trends such as distributed systems, microservices and distributed teams the social dimension of our code is vital in our holistic understanding of our systems' health.
Cake and Fake(Mar 2017, 试验)
MSBuild has been the primary build system in the .NET ecosystem since its introduction in 2005; however, it suffers from many of the same weaknesses we've previously called out in Maven. The .NET community has started to develop alternatives to MSBuild which are easier to maintain and more flexible, and evolve more fluidly as a project grows. Two of these alternatives are Cake and Fake. Cake uses a DSL built in C#, while Fake uses F#. Each has seen significant growth over the last year and has proven to be a viable alternative to MSBuild for orchestrating common build tasks in .NET projects.
Molecule(Mar 2017, 评估)
Molecule is designed to aid in the development and testing of Ansible roles. By building the scaffolding for running Ansible role tests on a virtual machine or container of choice, we don't have to setup our testing environment manually. Molecule leverages Vagrant, Docker, and OpenStack to manage virtual machines or containers, and supports Serverspec, Testinfra, or Goss to run the tests. The default steps in the sequence facility model include: virtual machine management, Ansible linting, idempotence testing and convergence testing. Although it is a fairly young project, we see a great potential for its usage.
Physical Web(Mar 2017, 评估)
We have been intrigued by the Physical Web standard created by Google. The idea of Physical Web is simple—beacons broadcast a URL—but the possibilities are broad. Basically, this is a way to annotate the physical world, tying objects and locations into the digital realm. The current transport mechanism is Eddystone URLs over Bluetooth LE, and sample clients are available. Although there are obvious security concerns with following randomly discovered links, we are most interested in use cases with customized clients where you can filter or proxy the URLs as required.
Physical Web(Nov 2016, 评估)
We have been intrigued by the Physical Web standard created by Google. The idea of Physical Web is simple—beacons broadcast a URL—but the possibilities are broad. Basically, this is a way to annotate the physical world, tying objects and locations into the digital realm. The current transport mechanism is Eddystone URLs over Bluetooth LE, and sample clients are available. Although there are obvious security concerns with following randomly discovered links, we are most interested in use cases with customized clients where you can filter or proxy the URLs as required.
Talisman(Mar 2017, 试验)
With the maturity of tools such as Vault, there is no longer an excuse for storing secrets in code repositories, particularly since this often ends up being the soft underbelly of important systems. We've previously mentioned repository-scanning tools such as Gitrob, but we are now pushing proactive tools such as (the ThoughtWorks-created) Talisman, which is a prepush hook for Git that scans commits for secrets matching predefined patterns.
Talisman(Nov 2016, 试验)
With the maturity of tools such as Vault, there is no longer an excuse for storing secrets in code repositories, particularly since this often ends up being the soft underbelly of important systems. We’ve previously mentioned repository-scanning tools such as Gitrob, but we are now pushing proactive tools such as (the ThoughtWorks-created) Talisman, which is a prepush hook for Git that scans commits for secrets matching predefined patterns.
Mesosphere DCOS(Mar 2017, 评估)
Mesosphere DCOS is a platform built on top of Mesos that abstracts away your underlying infrastructure for containerized applications as well as for applications you don't want to run inside Docker. This may be overkill for more modest deployments, but we're beginning to see successes with both the commercial and open source versions. We particularly like that it facilitates portability between different cloud providers as well as dedicated hardware, and that for containerized workloads you're not tied into one container orchestration framework. Although upgrades can be a little more complex than we would like, the overall stack is stabilizing nicely.
Mesosphere DCOS(Apr 2016, 评估)
Mesosphere DCOS is a platform built on top of Mesos. It provides an abstraction over underling machines, giving you a pool of storage and compute that allows services built for DCOS to operate at massive scale (Support is already there for Hadoop, Spark and Cassandra, among others). This is probably overkill for more modest workloads at the moment (where plain old Mesos could still be a good fit), but it will be interesting to see if Mesosphere starts trying to position DCOS as a general-purpose system.
HashiCorp Vault(Mar 2017, 试验)
Having a way to securely manage secrets is increasingly becoming a huge project issue. The old practice of keeping secrets in a file or in environment variables is becoming hard to manage, especially in environments with multiple applications and large numbers of microservices. HashiCorp Vault addresses the problem by providing mechanisms for securely accessing secrets through a unified interface. It has served us well on a number of projects, and our teams liked how easy it was to integrate Vault with their services. Storing and updating secrets is a bit cumbersome, because it relies on a command-line tool and a fair amount of discipline from the team.
HashiCorp Vault(Nov 2016, 试验)
Having a way to securely manage secrets is increasingly becoming a huge project issue. The old practice of keeping secrets in a file or in environment variables is becoming hard to manage, especially in environments with multiple applications and large numbers of microservices. HashiCorp Vault addresses the problem by providing mechanisms for securely accessing secrets through a unified interface. It has served us well on a number of projects, and our teams liked how easy it was to integrate Vault with their services. Storing and updating secrets is a bit cumbersome, because it relies on a command-line tool and a fair amount of discipline from the team.
HashiCorp Vault(Apr 2016, 评估)
Having a way to securely manage secrets is increasingly becoming a huge project issue. The old idea of just having a file with secrets or environment variables is becoming hard to manage, especially in environments with multiple applications like microservices or microcontainer environments, where the applications need to access a multitude of secrets. HashiCorp Vault is a promising tool that tries to solve the problem by providing mechanisms for securely accessing secrets through an unified interface. It has some features that make life easier, such as encryption and automatically generating secrets for known tools, among others.
Tango(Mar 2017, 评估)
Alongside virtual reality (VR), which has a relatively high bar to entry due to hardware requirements and the effort to create virtual worlds, alternate reality (AR) and mixed reality (MR) also entered into the mainstream last year. Pokémon Go provided evidence that regular smartphones are sufficient to create compelling AR/MR experiences. Tango is a new hardware sensor technology for mobile phones that further enhances the possibilities for AR/MR on phones. It allows apps to acquire detailed 3-D measurements of the user's surroundings so that virtual objects can be placed and rendered more convincingly on the camera feed. The first phones with Tango technology are now available.
DeepLearning.scala(Mar 2017, 评估)
DeepLearning.scala is an open source deep-learning toolkit in Scala created by our colleagues at ThoughtWorks. We're excited about this project because it uses differentiable functional programming to create and compose neural networks; a developer simply writes code in Scala with static typing. DeepLearning.scala currently supports basic types such as float, double, GPU-accelerated N-dimensional arrays as well as algebraic data types. We're looking forward to future releases of the toolkit which are said to support higher order functions and distributed training on Spark.
Bottled Water(Mar 2017, 评估)
With the growth of interest in streaming data architectures and the downstream data lakes they feed, we have seen an increased reliance on "change data capture" tooling to connect transactional data stores to stream-processing systems. Bottled Water is a welcome addition to this field, converting changes in PostgreSQL's write-ahead log into Kafka events. One downside of this approach, however, is that you are tied to low-level database events rather than the higher-level business events we recommend as the foundation for an event-oriented architecture.
Bottled Water(Nov 2016, 评估)
With the growth of interest in streaming data architectures and the downstream data lakes they feed, we have seen an increased reliance on "change data capture" tooling to connect transactional data stores to stream-processing systems. Bottled Water is a welcome addition to this field, converting changes in PostgreSQL’s write-ahead log into Kafka events. One downside of this approach, however, is that you are tied to low-level database events rather than the higher-level business events we recommend as the foundation for an event-oriented architecture.
VR beyond gaming(Mar 2017, 评估)
The idea of virtual reality has been around for more than 50 years, and with successive advancements in computing technology many ideas have been hyped and explored. We believe that we've reached a tipping point. Reasonably affordable consumer-oriented VR headsets were shipped to the market last year, and modern graphics cards provide sufficient power to create immersive experiences with them. The headsets are mainly targeted at video game enthusiasts, but we're convinced that they'll open the doors to many possibilities for VR beyond gaming. Teams without experience in building video games should not underestimate the effort and skill required to create good 3-D models and convincing textures.
VR beyond gaming(Nov 2016, 评估)
The idea of virtual reality has been around for more than 50 years, and with successive improvements of computing technology many ideas have been hyped and explored. We believe that we're reaching a tipping point now. Modern graphics cards provide sufficient compute power to render detailed, realistic scenes in high resolutions, and at the same time at least two consumer-oriented VR headsets (the HTC Vive and Facebook's Oculus Rift) are coming to market. These headsets are affordable, they have high-resolution displays, and they eliminate perceivable motion-tracking lag, which was causing issues such as headaches and nausea before. The headsets are mainly targeted at enthusiast video gaming, but we are convinced that they will open many possibilities for VR beyond gaming , particularly as the low-fi approaches, such as Google Cardboard, are driving greater awareness.
AngularJS(Mar 2017, 暂缓)
AngularJS helped revolutionize the world of single-page JavaScript applications, and we have delivered many projects successfully with it over the years. However, we are no longer recommending it (v1) for teams starting fresh projects. We prefer the ramp-up speed and more maintainable codebases we are seeing with Ember and React, particularly in conjunction with Redux.
AngularJS(Nov 2016, 暂缓)
AngularJS helped revolutionize the world of single-page JavaScript applications, and we have delivered many projects successfully with it over the years. However, we are no longer recommending it (v1) for teams starting fresh projects. We prefer the ramp-up speed and more maintainable codebases we are seeing with Ember and React, particularly in conjunction with Redux.
AngularJS(Apr 2016, 评估)
While we have delivered many successful projects using AngularJS and are seeing an acceleration of adoption in corporate settings, we have decided to move Angular back to Assess on this edition of the Radar. This move is intended as a note of caution: React.js and Ember offer strong alternatives; the migration path from Angular version 1 to version 2 is causing uncertainty; and we see some organizations adopting the framework without really thinking through whether a single-page application fits their needs. We have passionate internal debates about this topic but have certainly seen codebases become overly complex from a combination of two-way binding and inconsistent state-management patterns. We believe that rather than requiring that a solid framework be jettisoned, these issues can be solved through careful design and use of Redux or Flux from the outset.
AngularJS(Jan 2015, 试验)
We continue to see JavaScript frameworks as a useful way to structure code and bring better coding techniques to JavaScript. AngularJS is used widely by Thoughtworks projects. However, we are a bit concerned about the future of the framework.  The 2.0 version currently under development represents a ground-up redesign that some might not be happy with.  Without an evolutionary migration path, maintainers of existing AngularJS applications will be forced to either live with an unsupported version or undertake a large rewrite.  We advise teams to first assess their requirements to understand if a single-page JavaScript application is really necessary.  In many cases, a traditional page-model app is simpler to write and easier to maintain.  Remember that there are other good alternatives to AngularJS, such as Ember.js, Knockout.js, and React.js.
AngularJS(Jul 2014, 试验)
We continue to see JavaScript frameworks as a useful way to structure code and bring better coding techniques to JavaScript. AngularJS is used widely by Thoughtworks projects. However we do advise teams to assess other good alternatives such as Ember.js and Knockout.js.
Testinfra(Mar 2017, 评估)
Given the wide use of infrastructure tools today, it should come as no surprise that infrastructure as code has increased in current projects. With this tendency comes the need for testing this code. With Testinfra you can test the actual state of your servers configured manually or by tools such as Ansible, Puppet and Docker. Testinfra aims to be a Serverspec equivalent in Python and is written as a plugin to the Pytest test engine.
ReactiveX(Mar 2017, 采纳)
Distributed systems often utilize multithreading, event-based communication and nonblocking I/O to improve the overall system efficiency. These programming techniques impose challenges such as low-level threading, synchronization, thread safety, concurrent data structures, and non-blocking I/O. The open source ReactiveX library beautifully abstracts away these concerns, provides the required application plumbing, and extends the observable pattern on streams of asynchronous events. ReactiveX also has an active developer community and supports a growing list of languages, the most recent addition being RxSwift. It also implements binding to mobile and desktop platforms.
ReactiveX(Jul 2014, 采纳)
The reactive architecture keeps spreading across platforms and paradigms simply because it solves a common problem in an elegant way, hiding inevitable application plumbing in a nice encapsulation.
ReactiveX(Jan 2014, 试验)
Reactive Programming deals with streams or values that change over time. Using elements of data flow, implicit concurrency and transparent event propagation, these techniques enable efficient handling of events on a large scale with a high degree of efficiency and low latency. In the previous radar, we mentioned Reactive Extensions in .NET due to the extensive work done by Microsoft in making Rx a core part of the .NET framework. Since then, with the introduction of the Reactive Cocoa library for Objective C, the Java port of Reactive Extensions, the React JavaScript library, the Elm language based on Haskell & the Flapjax JavaScript library, we are extending this blip to include Reactive Extensions across languages.
Clojure.spec(Mar 2017, 评估)
One of those perpetual developer debates involves language typing: How much is just right? Clojure, the dynamically typed functional Lisp on the JVM, added a new entry into this discussion that blurs the lines. Clojure.spec is a new facility built into Clojure that allows developers to wrap type and other verification criteria around data structures, such as allowable value ranges. Once they are established, Clojure uses these specifications to provide a slew of benefits: generated tests, validation, destructuring of data structures and others. Clojure.spec is a promising way to have the benefits of types and ranges where developers need them but not everywhere.
Clojure.spec(Nov 2016, 评估)
One of those perpetual developer debates involves language typing: How much is just right? Clojure, the dynamically typed functional Lisp on the JVM, added a new entry into this discussion that blurs the lines. Clojure.spec is a new facility built into Clojure that allows developers to wrap type and other verification criteria around data structures, such as allowable value ranges. Once they are established, Clojure uses these specifications to provide a slew of benefits: generated tests, validation, destructuring of data structures and others. Clojure.spec is a promising way to have the benefits of types and ranges where developers need them but not everywhere.
WebVR(Mar 2017, 评估)
WebVR is an experimental JavaScript API that enables you to access VR devices through your browser. It has garnered support from the community and is available through nightly builds as well as in some release versions. If you are looking to build VR experiences in your browser, then this is a great place to start. This technology alongside complementary tools such Three.js, A-Frame, ReactVR, Argon.js and Awe.js brings AR experiences to the browser. The flurry of tools in this space, alongside Internet commission standards, could help promote stronger adoption of AR and VR.
Big Data envy(Mar 2017, 暂缓)
We continue to see organizations chasing "cool" technologies, taking on unnecessary complexity and risk when a simpler choice would be better. One particular theme is using distributed, Big Data systems for relatively small data sets. This behavior prompts us to put Big Data envy on hold once more, with some additional data points from our recent experience. The Apache Cassandra database promises massive scalability on commodity hardware, but we have seen teams overwhelmed by its architectural and operational complexity. Unless you have data volumes that require a 100+ node cluster, we recommend against using Cassandra. The operational team you'll need to keep the thing running just isn't worth it. While creating this edition of the Radar, we discussed several new database technologies, many offering "10x" performance improvements over existing systems. We're always skeptical until new technology—especially something as critical as a database—has been properly proven. Jepsen provides analysis of database performance under difficult conditions and has found numerous bugs in various NoSQL databases. We recommend maintaining a healthy dose of skepticism and keeping an eye on sites such as Jepsen when you evaluate database tech.
Big Data envy(Nov 2016, 暂缓)
We continue to see organizations chasing "cool" technologies, taking on unnecessary complexity and risk when a simpler choice would be better. One particular theme is using distributed, Big Data systems for relatively small data sets. This behavior prompts us to put Big Data envy on hold once more, with some additional data points from our recent experience. The Apache Cassandra database promises massive scalability on commodity hardware, but we have seen teams overwhelmed by its architectural and operational complexity. Unless you have data volumes that require a 100+ node cluster, we recommend against using Cassandra. The operational team you’ll need to keep the thing running just isn’t worth it. While creating this edition of the Radar, we discussed several new database technologies, many offering "10x" performance improvements over existing systems. We’re always skeptical until new technology—especially something as critical as a database—has been properly proven. Jepsen provides analysis of database performance under difficult conditions and has found numerous bugs in various NoSQL databases. We recommend maintaining a healthy dose of skepticism and keeping an eye on sites such as Jepsen when you evaluate database tech.
Big Data envy(Apr 2016, 暂缓)
While we've long understood the value of Big Data to better understand how people interact with us, we've noticed an alarming trend of Big Data envy : organizations using complex tools to handle "not-really-that-big” Data. Distributed map-reduce algorithms are a handy technique for large data sets, but many data sets we see could easily fit in a single-node relational or graph database. Even if you do have more data than that, usually the best thing to do is to first pick out the data you need, which can often then be processed on such a single node. So we urge that before you spin up your clusters, take a realistic assessment of what you need to process, and if it fits—maybe in RAM—use the simple option.
Auth0(Mar 2017, 试验)
We have a growing belief that for most scenarios it is rarely worth rolling your own authentication code. Outsourced identity management speeds up delivery, reduces mistakes and tends to enable a faster response to newly discovered vulnerabilities. Auth0 has particularly impressed us in this field for its ease of integration, range of protocols and connectors supported, and rich management API.
Auth0(Nov 2016, 试验)
We have a growing belief that for most scenarios it is rarely worth rolling your own authentication code. Outsourced identity management speeds up delivery, reduces mistakes and tends to enable a faster response to newly discovered vulnerabilities. Auth0 has particularly impressed us in this field for its ease of integration, range of protocols and connectors supported, and rich management API.
Knet.jl(Mar 2017, 评估)
Knet.jl is the Koç University deep-learning framework implemented in Julia by Deniz Yuret and collaborators. Unlike gradient-generating compilers such as Theano and TensorFlow which force users into a restricted mini-language, Knet allows the definition and training of machine-learning models using the full power and expressiveness of Julia. Knet uses dynamic computational graphs generated at runtime for the automatic differentiation of almost any Julia code. We really like the support of GPU operations through the KnetArray type, and in case you don't have access to a GPU machine, the team behind Knet also maintains a preconfigured Amazon Machine Image (AMI) so you can evaluate it in the cloud.
Client-directed query(Mar 2017, 评估)
Although many problems that people encounter with RESTful approaches to APIs can be attributed to the anemic REST antipattern, some use cases warrant exploration of other approaches. In particular, organizations that have to support a long tail of client applications (and thus a likely proliferation of API versions even if they employ consumer-driven contracts)—and have a large portion of their APIs supporting the endless-list style of activity feeds—may hit some limits in RESTful architectures. These can sometimes be mitigated by employing the client-directed query approach to client-server interaction. We see this approach being successfully used in both GraphQL and Falcor, where clients have more control over both the contents and the granularity of the data returned to them. This does put more responsibility onto the service layer and can still lead to tight coupling to the underlying data model, but the benefits may be worth exploring if well-modeled RESTful APIs aren't working for you.
Client-directed query(Nov 2016, 评估)
Although many problems that people encounter with RESTful approaches to APIs can be attributed to the anemic REST antipattern, some use cases warrant exploration of other approaches. In particular, organizations that have to support a long tail of client applications (and thus a likely proliferation of API versions even if they employ consumer-driven contracts)—and have a large portion of their APIs supporting the endless-list style of activity feeds—may hit some limits in RESTful architectures. These can sometimes be mitigated by employing the client-directed query approach to client-server interaction. We see this approach being successfully used in both GraphQL and Falcor, where clients have more control over both the contents and the granularity of the data returned to them. This does put more responsibility onto the service layer and can still lead to tight coupling to the underlying data model, but the benefits may be worth exploring if well-modeled RESTful APIs aren’t working for you.
wit.ai(Mar 2017, 评估)
Hype surrounding machine intelligence has reached a crescendo, but as with Big Data, useful frameworks and tools are waiting to be discovered among all the hot air. One such tool is wit.ai, a SaaS platform that allows developers to create conversational interfaces using natural language processing (NLP). Wit works with either text or speech inputs, helps developers manage conversational intent and allows custom business logic to be implemented using JavaScript. The system is free for commercial and noncommercial use and encourages the creation of open applications. Be aware that you must agree to let Wit use your data in order to improve the service and for its own analysis, so read the terms and conditions carefully. Another contender in this space is the Microsoft Bot Framework, but it's available only in limited preview form as of this writing. As with most things Microsoft, we expect the Bot Framework to evolve quickly, so it's worth keeping an eye on.
wit.ai(Nov 2016, 评估)
Hype surrounding machine intelligence has reached a crescendo, but as with Big Data, useful frameworks and tools are waiting to be discovered among all the hot air. One such tool is wit.ai, a SaaS platform that allows developers to create conversational interfaces using natural language processing (NLP). Wit works with either text or speech inputs, helps developers manage conversational intent and allows custom business logic to be implemented using JavaScript. The system is free for commercial and noncommercial use and encourages the creation of open applications. Be aware that you must agree to let Wit use your data in order to improve the service and for its own analysis, so read the terms and conditions carefully. Another contender in this space is the Microsoft Bot Framework, but it’s available only in limited preview form as of this writing. As with most things Microsoft, we expect the Bot Framework to evolve quickly, so it’s worth keeping an eye on.
Apache Mesos(Mar 2017, 试验)
We've continued to have positive experiences deploying the Apache Mesos platform to manage cluster resources for highly distributed systems. Mesos abstracts out underlying computing resources such as CPU and storage, aiming to provide efficient utilization while maintaining isolation. Mesos includes Chronos for distributed and fault-tolerant execution of scheduled jobs, and Marathon for orchestrating long-running processes in containers.
Apache Mesos(Nov 2016, 试验)
We've continued to have positive experiences deploying the Apache Mesos platform to manage cluster resources for highly distributed systems. Mesos abstracts out underlying computing resources such as CPU and storage, aiming to provide efficient utilization while maintaining isolation. Mesos includes Chronos for distributed and fault-tolerant execution of scheduled jobs, and Marathon for orchestrating long-running processes in containers.
Apache Mesos(Apr 2016, 试验)
Mesos is a platform that abstracts out underlying computing resources to make it easier to build massively scalable distributed systems. It can be used to provide a scheduling layer for Docker, or to act as an abstraction layer to things like AWS. Twitter has used it to great effect to help it scale its infrastructure. Tools built on top of Mesos are starting to appear, such as Chronos, which is a distributed, fault-tolerant cron replacement. Prominent success stories are appearing, such as Apple's Siri rearchitecting to use Mesos.
Apache Mesos(May 2015, 评估)
Mesos is a platform that abstracts out underlying computing resources to make it easier to build massively scalable distributed systems. It can be used to provide a scheduling layer for Docker, or to act as an abstraction layer to things like AWS. Twitter has used it to great effect to help them scale their infrastructure. Tools build on top of Mesos are starting to appear such as Chronos, which is a distributed, fault tolerant cron replacement.
AWS Lambda(Mar 2017, 试验)
Our teams continue to enjoy using AWS Lambda and are beginning to use it to experiment with serverless architectures, combining Lambda with the API Gateway. We do recommend that Lambda functions contain only a moderate amount of code. Ensuring the quality of a solution based on a tangle of many large Lambda functions is difficult, and such a solution may not be cost-effective. For more complex needs, deployments based on containers or VMs are still preferable. In addition, we have run into significant problems using Java for Lambda functions, with erratic latencies up to several seconds as the Lambda container is started. Of course, you can sidestep this issue by using JavaScript or Python, and if Lambda functions do not contain a lot of code, the choice of programming language should not matter too much.
AWS Lambda(Nov 2016, 试验)
Our teams continue to enjoy using AWS Lambda and are beginning to use it to experiment with serverless architectures, combining Lambda with the API Gateway. We do recommend that Lambda functions contain only a moderate amount of code. Ensuring the quality of a solution based on a tangle of many large Lambda functions is difficult, and such a solution may not be cost-effective. For more complex needs, deployments based on containers or VMs are still preferable. In addition, we have run into significant problems using Java for Lambda functions, with erratic latencies up to several seconds as the Lambda container is started. Of course, you can sidestep this issue by using JavaScript or Python, and if Lambda functions do not contain a lot of code, the choice of programming language should not matter too much.
AWS Lambda(Apr 2016, 试验)
Our teams continue to enjoy using AWS Lambda and are beginning to use it to experiment with Serverless architectures, combining Lambda with the API Gateway to produce highly scalable systems with invisible infrastructure. We have run into significant problems using Java for Lambda functions, with erratic latencies up to several seconds as the Lambda container is started. We recommend sticking with JavaScript or Python for the time being.
AWS Lambda(Nov 2015, 试验)
AWS releases a huge number of new features on what seems like a monthly basis, so it can sometimes be hard for any new service offering to rise above the noise, but Lambda certainly manages to attract notice. Initially just supporting JavaScript, but now adding support for JVM-based applications (with more no doubt to follow), Lambda allows you to fire up very short-lived processes either in reaction to an event, or via a call from the related API Gateway. For stateless services, this means you don’t need to worry about running any long-lived machines, potentially reducing costs and improving security. Despite other forays into the PaaS space by AWS, Lambda looks the closest to getting this right.
Amazon Rekognition(Mar 2017, 评估)
Amazon Rekognition is one of the cloud-based image comprehension tools we've mentioned elsewhere in this Radar. What we like about it is that Amazon has taken a somewhat novel approach to making faces anonymous (using GUIDs) from AWS to accommodate some of the privacy concerns that come with facial recognition.
ECMAScript 2017(Mar 2017, 评估)
ECMAScript 2017 —not to be confused with ES7 (a.k.a. ECMAScript 2016)—brings several noteworthy improvements to the language. Browsers are expected to implement this standard fully in the summer of 2017, but the Babel JavaScript compiler already supports a number of the features today. If you make extensive use of JavaScript and your codebase is under active development, we recommend that you add Babel to your build pipeline and begin using the supported features.
ECMAScript 2017(Nov 2016, 评估)
ECMAScript 2017 —not to be confused with ES7 (a.k.a. ECMAScript 2016)—brings several noteworthy improvements to the language. Browsers are expected to implement this standard fully in the summer of 2017, but the Babel JavaScript compiler already supports a number of the features today. If you make extensive use of JavaScript and your codebase is under active development, we recommend that you add Babel to your build pipeline and begin using the supported features\n.
Anemic REST(Mar 2017, 暂缓)
With the increasing popularity of the BFF - Backend for frontends pattern and use of one-way data-binding frameworks like React.js, we've noticed a backlash against REST-style architectures. Critics accuse REST of causing chatty, inefficient interactions among systems and failing to adapt as client needs evolve. They offer frameworks such as GraphQL or Falcor as alternative data-fetch mechanisms that let the client specify the format of the data returned. But in our experience, it isn't REST that causes these problems. Rather, they stem from a failure to properly model the domain as a set of resources. Naively developing services that simply expose static, hierarchical data models via templated URLs result in an anemic REST implementation. In a richly modeled domain, REST should enable more than simple repetitive data fetching. In a fully evolved RESTful architecture, business events and abstract concepts are also modeled as resources, and the implementation should make effective use of hypertext, link relations and media types to maximize decoupling between services. This antipattern is closely related to the Anemic Domain Model pattern and results in services that rank low in Richardson Maturity Model. We have more advice for designing effective REST APIs in our Insights article\n.
Anemic REST(Nov 2016, 暂缓)
With the increasing popularity of the BFF - Backend for frontends pattern and use of one-way data-binding frameworks like React.js, we’ve noticed a backlash against REST-style architectures. Critics accuse REST of causing chatty, inefficient interactions among systems and failing to adapt as client needs evolve. They offer frameworks such as GraphQL or Falcor as alternative data-fetch mechanisms that let the client specify the format of the data returned. But in our experience, it isn’t REST that causes these problems. Rather, they stem from a failure to properly model the domain as a set of resources. Naively developing services that simply expose static, hierarchical data models via templated URLs result in an anemic REST implementation. In a richly modeled domain, REST should enable more than simple repetitive data fetching. In a fully evolved RESTful architecture, business events and abstract concepts are also modeled as resources, and the implementation should make effective use of hypertext, link relations and media types to maximize decoupling between services. This antipattern is closely related to the Anemic Domain Model pattern and results in services that rank low in Richardson Maturity Model. We have more advice for designing effective REST APIs in our Insights article.
IndiaStack(Mar 2017, 评估)
IndiaStack is a set of Open APIs designed with the goal of transforming India from a data-poor to a data-rich country. The stack emphasizes layered innovation by specifying a minimal set of APIs and encourages the rest of the ecosystem to build custom applications on top of these APIs. Aadhaar serves as one of the foundation layers, providing authentication services for more than a billion Indian citizens. In addition, there are services to provide paperless transactions through digital signatures (eSign), unified online payment (UPI) and an electronic consent layer ((e-KYC)[https://uidai.gov.in/ecosystem/authentication-devices-documents/about-aadhaar-paperless-offline-e-kyc.html]) to securely provide Aadhaar details to service providers. We believe in the Open API–driven initiative to bring digital innovation, and the design principles behind IndiaStack could be used as a change agent for other regions/countries.
IndiaStack(Nov 2016, 评估)
IndiaStack is a set of Open APIs designed with the goal of transforming India from a data-poor to a data-rich country. The stack emphasizes layered innovation by specifying a minimal set of APIs and encourages the rest of the ecosystem to build custom applications on top of these APIs. Aadhaar serves as one of the foundation layers, providing authentication services for more than a billion Indian citizens. In addition, there are services to provide paperless transactions through digital signatures (eSign), unified online payment (UPI) and an electronic consent layer ((e-KYC)[https://uidai.gov.in/ecosystem/authentication-devices-documents/about-aadhaar-paperless-offline-e-kyc.html]) to securely provide Aadhaar details to service providers. We believe in the Open API–driven initiative to bring digital innovation, and the design principles behind IndiaStack could be used as a change agent for other regions/countries.
Galen(Mar 2017, 试验)
Testing that layout and styling of responsive websites is working as expected across various form factors can be a slow and often manual process. Galen helps ease this problem by providing a simple language, running on top of Selenium, that allows you to specify expectations for the appearance of your website in various screen sizes. Although Galen suffers from the typical brittleness and speed issues of any end-to-end testing approach, we have found benefit in the early feedback on design issues.
Galen(Nov 2016, 试验)
Testing that layout and styling of responsive websites is working as expected across various form factors can be a slow and often manual process. Galen helps ease this problem by providing a simple language, running on top of Selenium, that allows you to specify expectations for the appearance of your website in various screen sizes. Although Galen suffers from the typical brittleness and speed issues of any end-to-end testing approach, we have found benefit in the early feedback on design issues.
Electron(Mar 2017, 评估)
Electron is a solid framework for building native desktop clients using web technologies such as HTML, CSS and JavaScript. Teams can leverage their web know-how to deliver polished cross-platform desktop clients without spending time learning another set of technologies.
Electron(Nov 2016, 评估)
Electron is a solid framework for building native desktop clients using web technologies such as HTML, CSS and JavaScript. Teams can leverage their web know-how to deliver polished cross-platform desktop clients without spending time learning another set of technologies.
Spacemacs(Mar 2017, 评估)
As any Emacs fan will tell you, Emacs is more than a text editor; it is a platform for character-mapped applications. Over the past few years, there has been an explosion of new developments on this platform, but we think Spacemacs deserves particular attention. Spacemacs provides an introduction to the Emacs platform, with a new keyboard user-interface, simplified customization layers, and a curated distribution of Emacs packages. One of the project's aims is to be the best of worlds by combining the Vim UI with the internal reprogrammability of Emacs. We consider developer productivity tools to be a vital part of effective software development, and if you haven't considered Emacs for a while, we suggest you take a look at how Spacemacs rethinks this classic development platform.
Elixir(Mar 2017, 试验)
Interest in the Elixir programming language continues to build. Increasingly, we see it used in serious projects and hear feedback from developers who find its Actor model to be robust and very fast. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the IEx interactive shell and the ExUnit unit-testing framework.
Elixir(Nov 2016, 试验)
Interest in the Elixir programming language continues to build. Increasingly, we see it used in serious projects and hear feedback from developers who find its Actor model to be robust and very fast. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the IEx interactive shell and the ExUnit unit-testing framework.
Elixir(Apr 2016, 评估)
We continue to see a lot of excitement from people using the Elixir programming language. Elixir, which is built on top of the Erlang virtual machine, is showing promise for creating highly concurrent and fault-tolerant systems. Elixir has distinctive features such as the Pipe operator, which allows developers to build a pipeline of functions as you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the Iex interactive shell and the ExUnit unit testing framework.
Elixir(Jan 2014, 评估)
Elixir is a dynamic, functional, homoiconic programming language built on top of the Erlang virtual machine with a powerful macro system that makes it ideal for building Domain Specific Languages. Elixir has distinctive features such as the Pipe operator that allows developers to build a pipeline of functions like you would in the UNIX command shell. The shared byte code allows Elixir to interoperate with Erlang and leverage existing libraries while supporting tools such as the Mix build tool, the Iex interactive shell and the ExUnit unit testing framework. It is a practical alternative to Erlang for building DSLs.
Amazon API Gateway(Mar 2017, 评估)
Amazon API Gateway enables developers to expose API services to Internet clients. It offers the usual API gateway features including traffic management, monitoring, authentication and authorization. Our teams have had positive experiences using this service to front AWS Lambda as part of serverless architectures. On the other hand, we have had more challenges using it as a more general purpose gateway to front HTTP/HTTPS endpoints running on EC2—where we have been stymied by a lack of interoperability with VPCs and difficulty in establishing client cert authentication with the gateway. Due to this mixed experience, we would like to advise teams to trial using AWS API Gateway with Lambda but assess suitability when using it in a more general setting.
Amazon API Gateway(Nov 2016, 评估)
Amazon API Gateway is Amazon's offering enabling developers to expose API services to Internet clients. It offers the usual API gateway features like traffic management, monitoring, authentication and authorization. Our teams have been using this service to front other AWS capabilities like AWS Lambda as part of serverless architectures. We continue to monitor for the challenges presented by overambitious API gateways, but at this stage Amazon's offering appears to be lightweight enough to avoid those problems.
Amazon API Gateway(Apr 2016, 评估)
Amazon API Gateway is Amazon's offering enabling developers to expose API services to Internet clients, offering the usual API gateway features like traffic management, monitoring, authentication and authorization. Our teams have been using this service to front other AWS capabilities like AWS Lambda as part of serverless architectures. We continue to monitor for the challenges presented by overambitious API gateways, but at this stage Amazon's offering appears to be lightweight enough to avoid those problems.
Hangfire(Mar 2017, 试验)
One common problem in application development is how to schedule tasks that run outside the main process periodically or when certain conditions are met. The problem gets more complicated when unexpected events, such as application shutdowns, occur. The Hangfire framework, as our teams discovered, can do this and much more in the .NET environment. Hangfire is both easy to use and flexible, and it embraces a functional style. Particularly interesting is its ability to save a task's state so it can resume when an application restarts after a crash or shutdown.
OpenVR(Mar 2017, 评估)
OpenVR is the underlying SDK in making many of the VR head-mounted displays (HMDs) work with Unity and will likely keep growing in importance. Much of the VR work at ThoughtWorks was built on top of OpenVR, because it will run on any HMD, unlike the other SDKs. Though it is not open source, it is free via the license. The Oculus SDK is more restrictive in its licensing and only works on Oculus devices. OSVR, while truly open source, doesn't seem to have as much adoption yet. If you're going to develop a VR application and target as many devices as possible—and not use Unity or Unreal to develop them—OpenVR is the most concrete and pragmatic solution right now.
OpenVR(Nov 2016, 评估)
OpenVR is the underlying SDK in making many of the VR head-mounted displays (HMDs) work with Unity and will likely keep growing in importance. Much of the VR work at ThoughtWorks was built on top of OpenVR, because it will run on any HMD, unlike the other SDKs. Though it is not open source, it is free via the license. The Oculus SDK is more restrictive in its licensing and only works on Oculus devices. OSVR, while truly open source, doesn't seem to have as much adoption yet. If you're going to develop a VR application and target as many devices as possible—and not use Unity or Unreal to develop them—OpenVR is the most concrete and pragmatic solution right now.
Prototyping with InVision and Sketch(Mar 2017, 试验)
The combined use of InVision and Sketch has changed the way some people approach web application development. Although these are tools, it is really the technique of prototyping with InVision and Sketch that makes this blip significant. Creating rich, clickable prototypes as the starting point for implementing front-end and back-end behavior helps speed up the development and eliminates churn in the implementation details. This combined use of these tools strikes the right balance between premature elaboration of visual detail and capturing early user feedback on the interactive experience.
Conversationally aware APIs(Mar 2017, 评估)
Technologies such as Amazon Alexa, Google Voice and Siri have dramatically lowered the bar for voice-based interaction with software. However, a more conversational style of input (voice or text) can be hard to build on top of many existing APIs, especially when it comes to a more stateful style of interaction where a follow-up interaction needs to be aware of the overall conversational context. In this style of interaction, for example, we'd like to inquire about trains from Manchester to Glasgow and then being able to ask "What time is the first departure?" without having to give the context of the conversation again. Normally this context would be present in the initial response we send back to a browser, but in the case of voice interfaces we need to handle this context elsewhere. Conversationally aware APIs can be an example of the backend for front-end pattern where the front-end is a voice or chat platform. This type of API can handle the specifics of this style of interaction by managing conversation states while calling underlying services on behalf of the voice front-end.
APIs as a product(Mar 2017, 试验)
Companies have wholeheartedly embraced APIs as a way to expose business capabilities to both external and internal developers. APIs promise the ability to experiment quickly with new business ideas by recombining core capabilities. But what differentiates an API from an ordinary enterprise integration service? One difference lies in treating APIs as a product , even when the consumer is an internal system or fellow developer. Teams that build APIs should understand the needs of their customers and make the product compelling to them. Usability testing and UX research can lead to a better design and understanding of the API usage patterns and help bring a product mindset to APIs. APIs, like products, should be actively maintained and supported, and, easy to use. They should have an owner who advocates for the customer and strives for continual improvement. In our experience, product orientation is the missing ingredient that makes the difference between ordinary enterprise integration and an agile business built on a platform of APIs.
APIs as a product(Nov 2016, 试验)
Businesses have wholeheartedly embraced APIs as a way to expose business capabilities to both external and internal developers. APIs promise the ability to experiment quickly with new business ideas by recombining core capabilities. But what differentiates an API from an ordinary enterprise integration service? One difference lies in treating APIs as a product , even when the consumer is an internal system. Teams that build APIs should understand the needs of their customers and make the product compelling to them. Products are also improved, maintained and supported over the long term. They should have an owner who advocates for the customer and strives for continual improvement. Products are actively maintained and supported, easy to find and easy to use. In our experience, a product orientation is the missing ingredient that makes the difference between ordinary enterprise integration and an agile business built on a platform of APIs.
Phoenix(Mar 2017, 试验)
Some of our ThoughtWorks teams have had very positive experiences with Phoenix , a server-side web MVC framework written in Elixir. In addition to being streamlined and easy to use, Phoenix takes advantage of Elixir to be extremely fast. For some developers, Phoenix evokes the joy they experienced when first discovering Ruby and Rails. Although the ecosystem of libraries for Phoenix is not as extensive as for some more mature frameworks, it should benefit from the continuing success and growth of support for Elixir.
Phoenix(Nov 2016, 试验)
Some of our ThoughtWorks teams have had very positive experiences with Phoenix , a server-side web MVC framework written in Elixir. In addition to being streamlined and easy to use, Phoenix takes advantage of Elixir to be extremely fast. For some developers, Phoenix evokes the joy they experienced when first discovering Ruby and Rails. Although the ecosystem of libraries for Phoenix is not as extensive as for some more mature frameworks, it should benefit from the continuing success and growth of support for Elixir.
Pa11y(Mar 2017, 试验)
Pa11y is an automatic accessibility tester that can run from the command line and be embedded into a build pipeline. Our teams have had success using Pa11y on a highly dynamic site by first creating a static HTML version, then running the accessibility tests against that. For many systems—especially government websites—accessibility testing is a requirement, and Pa11y makes it all a lot easier.
Pa11y(Nov 2016, 试验)
Pa11y is an automatic accessibility tester that can run from the command line and be embedded into a build pipeline. Our teams have had success using Pa11y on a highly dynamic site by first creating a static HTML version, then running the accessibility tests against that. For many systems—especially government websites—accessibility testing is a requirement, and Pa11y makes it all a lot easier.
Nuance Mix(Mar 2017, 评估)
Nuance Mix is a framework for natural language processing from the company that created the speech-to-text technology behind Dragon Speaking and the first roll-out of Siri. This framework supports the creation of grammars that allow for free-form user interaction via voice. The developer defines a domain-specific grammar that the framework can train itself to understand. The outcomes are responses to user input that identify the user's intents and interaction concepts. At first, it is limited to phrases close to the ones used to train it, but over time it can start to identify meaning from more divergent phrasing. Though it is still in beta, the accuracy from early exploration has been compelling, and the eventual product is one to watch for application forms that could benefit from hands-free user interaction—including mobile, IoT, AR, VR and interactive spaces.
Nuance Mix(Nov 2016, 评估)
Nuance Mix is a framework for natural language processing from the company that created the speech-to-text technology behind Dragon Speaking and the first roll-out of Siri. This framework supports the creation of grammars that allow for free-form user interaction via voice. The developer defines a domain-specific grammar that the framework can train itself to understand. The outcomes are responses to user input that identify the user's intents and interaction concepts. At first, it is limited to phrases close to the ones used to train it, but over time it can start to identify meaning from more divergent phrasing. Though it is still in beta, the accuracy from early exploration has been compelling, and the eventual product is one to watch for application forms that could benefit from hands-free user interaction—including mobile, IoT, AR, VR and interactive spaces.
Claudia(Mar 2017, 评估)
The combination of AWS Lambda with Amazon API Gateway has had a big impact on how we deploy services and APIs. However, even in this serverless configuration, the amount of configuration required to wire things together is not trivial. Claudia is a tool which automates deployment of AWS Lambda functions written in JavaScript and associated API Gateway configurations. It provides reasonable defaults, and our teams have found it allows them to get started quickly with Lambda-based microservices.
Progressive Web Applications(Mar 2017, 试验)
The increase in Progressive Web Applications (PWAs) is the latest attempt to bring back the mobile web in response to users' "app fatigue". Originally proposed by Google in 2015, PWAs are web applications that take advantage of the latest technologies to combine the best of web and native mobile applications. Using a set of open standard technologies such as, service workers, the app manifest, and cache and push APIs, we can create applications that are platform independent and deliver app-like user experiences. This brings parity to web and native applications and helps mobile developers reach users beyond the walled garden of the app stores. Think of PWAs as websites that act and feel like native apps.
DataStax Enterprise Graph(Mar 2017, 评估)
We've had some early successes with DataStax Enterprise Graph (DSE Graph) for handling large graph databases. Built on top of Cassandra, DSE Graph targets the type of large data sets where our longtime favorite Neo4j begins to show some limitations. This scale has its trade-offs; for example, you lose the ACID transactions and run-time schema-free nature of Neo4j, but access to the underlying Cassandra tables, the integration of Spark for analytical workloads, and the powerful TinkerPop/Gremlin query language make this an option worth considering.
Quick and Nimble(Mar 2017, 试验)
Most of our iOS teams are now using the Quick and Nimble pairing for their unit tests. In the RSpec family of behavior-driven development (BDD) testing tools, it provides very readable tests (with describe blocks) across Swift and Objective-C and has good support for asynchronous testing.
Quick and Nimble(Nov 2016, 试验)
Most of our iOS teams are now using the Quick and Nimble pairing for their unit tests. In the RSpec family of behavior-driven development (BDD) testing tools, it provides very readable tests (with describe blocks) across Swift and Objective-C and has good support for asynchronous testing.
Nightwatch(Mar 2017, 试验)
Nightwatch is a framework that allows automated acceptance tests for browser-based apps to be created in JavaScript and run in Node.js. Nightwatch allows tests to be defined using a fluent API which can then be executed against a Selenium/WebDriver server. In the case of single page apps or other JavaScript-heavy pages, this allows the automated tests to be created and run within the same language and environment as the bulk of the code.
Hosting PII data in the EU(Mar 2017, 试验)
In a number of countries, we see government agencies seeking broad access to private, personally identifiable information (PII). The increased use of public cloud solutions makes it more difficult for organizations to protect the data entrusted to them by their users while also respecting all relevant laws. The European Union has some of the most progressive privacy laws, and all the major cloud providers—Amazon, Google and Microsoft—offer multiple data centers and regions within the European Union. Therefore, we recommend that companies, especially those with a global user base, assess the feasibility of a safe haven for their users' data by hosting PII data in the EU. Since we wrote about this technique in the last Radar, we have rolled out a new internal system that handles sensitive information relating to all our employees, and we have chosen to host it in a data center located in the European Union.
Hosting PII data in the EU(Nov 2016, 试验)
In a number of countries, we see government agencies seeking broad access to private, personally identifiable information (PII). The increased use of public cloud solutions makes it more difficult for organizations to protect the data entrusted to them by their users while also respecting all relevant laws. The European Union has some of the most progressive privacy laws, and all the major cloud providers—Amazon, Google and Microsoft—offer multiple data centers and regions within the European Union. Therefore, we recommend that companies, especially those with a global user base, assess the feasibility of a safe haven for their users' data by hosting PII data in the EU. Since we wrote about this technique in the last Radar, we have rolled out a new internal system that handles sensitive information relating to all our employees, and we have chosen to host it in a data center located in the European Union.
Hosting PII data in the EU(Apr 2016, 评估)
In a number of countries around the world, we see government agencies seeking broad access to private, personally identifiable information (PII). In the EU, the highest court has invalidated the Safe Harbor framework, and Privacy Shield, its successor, is expected to be challenged too. At the same time, the use of cloud computing is increasing, and all the major cloud providers—Amazon, Google and Microsoft—offer multiple data centers and regions within the European Union. Therefore, we recommend that companies, especially those with a global user base, assess the feasibility of a safe haven for their users' data, protected by the most progressive privacy laws, by Hosting PII in the EU.
CMS as a platform(Mar 2017, 暂缓)
We are seeing too many organizations run into trouble as they attempt to use their CMS as a platform for delivering large and complex digital applications. This is often driven by the vendor-fueled hope of bypassing unresponsive IT organizations and enabling the business to drag and drop changes directly to production. While we are very supportive of providing content producers with the right tools and workflows, for applications with complex business logic we tend to recommend treating your CMS as a component of your platform (often in a hybrid or headless mode) cooperating cleanly with other services, rather than attempting to implement all of your functionality in the CMS itself.
CMS as a platform(Nov 2016, 暂缓)
We are seeing too many organizations run into trouble as they attempt to use their CMS as a platform for delivering large and complex digital applications. This is often driven by the vendor-fueled hope of bypassing unresponsive IT organizations and enabling the business to drag and drop changes directly to production. While we are very supportive of providing content producers with the right tools and workflows, for applications with complex business logic we tend to recommend treating your CMS as a component of your platform (often in a hybrid or headless mode) cooperating cleanly with other services, rather than attempting to implement all of your functionality in the CMS itself.
CMS as a platform(Jan 2015, 暂缓)
In previous editions of the radar, we have written about the pitfalls of trying to use a CMS as a platform and we continue to see this problematic approach “in the wild.” CMS as an editing, collaboration and workflow platform can work well, and we certainly do not discount these features. We have had success using Two Stack CMS, an approach that separates the concerns of editing and publishing content.
CMS as a platform(Jul 2014, 暂缓)
Content Management Systems (CMS) have their place. In many cases it is unreasonable to write editing and workflow functionality from scratch. However, we have experienced serious problems when CMS as a platform becomes an IT solution that grows beyond managing simple content.
Ember.js(Mar 2017, 采纳)
If you are faced with building a single-page application (SPA) and trying to choose a framework to build with, Ember.js has emerged as a leading choice. Our teams praise Ember for its highly productive developer experience, with far fewer surprises than other frameworks such as AngularJS. The Ember CLI build tooling is a haven in the storm of JavaScript build tools, and the Ember core team and community are highly active and responsive.
Ember.js(Nov 2016, 采纳)
If you are faced with building a single-page application (SPA) and trying to choose a framework to build with, Ember.js has emerged as a leading choice. Our teams praise Ember for its highly productive developer experience, with far fewer surprises than other frameworks such as AngularJS. The Ember CLI build tooling is a haven in the storm of JavaScript build tools, and the Ember core team and community are highly active and responsive.
Ember.js(Apr 2016, 试验)
Ember.js has developed further support based on project experiences and is clearly a strong contender in the field of JavaScript application frameworks. Ember is praised for its developer experience, with far fewer surprises than other frameworks such as AngularJS. The Ember CLI build tooling, convention-over-configuration approach and ES6 support also gain positive feedback.
Ember.js(Nov 2015, 评估)
Widespread usage of AngularJS continues on ThoughtWorks projects, although not every experience is positive. We continue to advise teams to assess whether the additional complexity of a single-page JavaScript application is necessary to meet their requirements.  We also recommend assessing alternative frameworks, and in this radar edition we highlight Ember.js which is growing in popularity within ThoughtWorks.  Ember is praised for its approach of opinionated convention over configuration, responsive core team of committers, performance, and build tooling support via Ember CLI.
Android-x86(Mar 2017, 评估)
Android-x86 is a port of the Android open source project to x86 platforms. The project started by hosting various patches from the community for x86 support but then later created its own codebase to provide support for different x86 platforms. We have seen significant time savings by utilizing Android-x86 in our CI servers instead of emulators for hermetic UI testing. However, for UI-specific tests targeting a particular device resolution—simulating low memory, bandwidth and battery—it is better to stick with emulators.
Android-x86(Nov 2016, 评估)
Android-x86 is a port of the Android open source project to x86 platforms. The project started by hosting various patches from the community for x86 support but then later created its own codebase to provide support for different x86 platforms. We have seen significant time savings by utilizing Android-x86 in our CI servers instead of emulators for hermetic UI testing. However, for UI-specific tests targeting a particular device resolution—simulating low memory, bandwidth and battery—it is better to stick with emulators.
JuMP(Mar 2017, 评估)
JuMP is a domain-specific language for mathematical optimizations in Julia. JuMP defines a common API called MathProgBase and enables users to write solver-agnostic code in Julia. Currently supported solvers include Artelys Knitro, Bonmin, Cbc, Clp, Couenne, CPLEX, ECOS, FICO Xpress, GLPK, Gurobi, Ipopt, MOSEK, NLopt and SCS. One other benefit is the implementation of automatic differentiation technique in reverse mode to compute derivatives so users are not limited to the standard operators like sin, cos, log and sqrt but can also implement their own custom objective functions in Julia.
JuMP(Nov 2016, 评估)
JuMP is a domain-specific language for mathematical optimizations in Julia. JuMP defines a common API called MathProgBase and enables users to write solver-agnostic code in Julia. Currently supported solvers include Artelys Knitro, Bonmin, Cbc, Clp, Couenne, CPLEX, ECOS, FICO Xpress, GLPK, Gurobi, Ipopt, MOSEK, NLopt and SCS. One other benefit is the implementation of automatic differentiation technique in reverse mode to compute derivatives so users are not limited to the standard operators like sin, cos, log and sqrt but can also implement their own custom objective functions in Julia.
WebRTC(Mar 2017, 评估)
Widespread adoption of AR/VR as a collaboration and communication medium requires a modern and readily available video streaming platform. WebRTC is an emerging standard for real-time communication between browsers that enables video streaming within commonly available web technologies. The range of browsers that support this standard is increasing, but Microsoft and Apple have been slow to adopt WebRTC in their proprietary browsers. If momentum continues to build, WebRTC could form the future foundation for AR/VR collaboration on the web.
WebRTC(Nov 2016, 评估)
Widespread adoption of AR/VR as a collaboration and communication medium requires a modern and readily available video streaming platform. WebRTC is an emerging standard for real-time communication between browsers that enables video streaming within commonly available web technologies. The range of browsers that support this standard is increasing, but Microsoft and Apple have been slow to adopt WebRTC in their proprietary browsers. If momentum continues to build, WebRTC could form the future foundation for AR/VR collaboration on the web.
Ethereum(Mar 2017, 评估)
The hype seems to have peaked for blockchains and cryptocurrencies, as evidenced by the slowdown of previous firehose-scale announcements in this area, and we expect some of the more speculative efforts to die out over time. One of the blockchains, Ethereum, while not universally popular among diehard blockchain aficionados, appears in increasing numbers in new initiatives. Ethereum is a public blockchain with a built-in programming language allowing developers to build "smart contracts", which are algorithmic movements of ether (the Ethereum cryptocurrency) in response to activity happening on the blockchain. R3CEV, the consortium building blockchain tech for banks, built its first proofs of concept on Ethereum. Ethereum has been used to build a distributed autonomous organization (DAO)—one of the first "algorithmic corporations"—although a recent heist of $150 million in the ether demonstrates that the blockchains and cryptocurrencies are still the Wild West of the technology world.
Ethereum(Nov 2016, 评估)
The hype seems to have peaked for blockchain and cryptocurrencies, as evidenced by the previous firehose-scale announcements in this area slowing to a trickle, and we expect some of the more speculative efforts to die out over time. One of the blockchains, Ethereum, is making good progress and is worth watching. Ethereum is a public blockchain with a built-in programming language that allows "smart contracts" to be built into it. These are algorithmic movements of "ether" (the Ethereum cryptocurrency) in response to activity happening on the blockchain. R3Cev, the consortium building blockchain tech for banks, built its first proofs of concept on Ethereum. Ethereum has been used to build a Distributed Autonomous Organization (DAO)—one of the first "algorithmic corporations"—although a recent heist of $150m worth of Ether demonstrates that the blockchain and cryptocurrencies are still the Wild West of the technology world.
Cloud-based image comprehension(Mar 2017, 评估)
Image comprehension used to be a dark art and required a team of onsite data scientists. In recent years, however, we've come closer to solving problems such as image and facial classification/categorization, facial comparisons, facial landmark identification, and facial recognition. Cloud-based image comprehension provides access to machine-learning capabilities through services such as AmazonRekognition, Microsoft Computer Vision API and Google Cloud Vision API which can supplement AR applications and anything involving photo tagging and classification.
Grafana(Mar 2017, 采纳)
When combining modern techniques and architecture styles, such as microservices, DevOps and QA in production, development teams need increasingly sophisticated monitoring. Simply looking a graphs of disk usage and CPU utilization is not sufficient anymore, and many teams collect application and business-specific metrics using tools such a Graphite and Kibana. Grafana makes it easy to create useful and elegant dashboards for data from a number of sources. A particularly useful feature allows timescales of different graphs to be synchronized, which helps with spotting correlations in the underlying data. The templating system that is being added shows a lot promise and will likely make managing sets of similar services even easier. Based on its strengths, Grafana has become our default choice in this category.
Grafana(Nov 2016, 采纳)
When combining modern techniques and architecture styles, such as microservices, DevOps and QA in production, development teams need increasingly sophisticated monitoring. Simply looking a graphs of disk usage and CPU utilization is not sufficient anymore, and many teams collect application and business-specific metrics using tools such a Graphite and Kibana. Grafana makes it easy to create useful and elegant dashboards for data from a number of sources. A particularly useful feature allows timescales of different graphs to be synchronized, which helps with spotting correlations in the underlying data. The templating system that is being added shows a lot promise and will likely make managing sets of similar services even easier. Based on its strengths, Grafana has become our default choice in this category.
Superficial private cloud(Nov 2016, 暂缓)
We've seen the indisputable productivity gains that come from deployment of applications and services into mature cloud providers. Much of that gain comes from the ability of teams to deploy and operate their own services with a high degree of autonomy and responsibility. We are now regularly coming across Superficial Private Cloud offerings within organizations, where basic virtualization platforms are being given the “cloud” label. Often teams can self-provision a restricted set of fixed service types with limited access and little ability to customize the centrally governed “enterprise blueprints,” leading to kludge solutions. Deployment pace regularly remains constrained by manually provisioned infrastructure such as network, firewall and storage. We encourage organizations to more fully consider the costs of mandating the use of an inadequate private cloud offering.
OWASP Dependency-Check(Nov 2016, 试验)
In a world full of libraries and tools that simplify the life of many software developers, deficiencies in their security have become visible and have increased the vulnerability surface in the applications that use them. OWASP Dependency-Check automatically identifies potential security problems in the code, checking if there are any known publicly disclosed vulnerabilities, then using methods to constantly update the database of public vulnerabilities. Dependency-Check has some interfaces and plugins to automate this verification in Java and .NET (which we have used successfully) as well as Ruby, Node.js and Python.
Pinpoint(Nov 2016, 评估)
Teams using the Phoenix Server or Phoenix Environment techniques have found little in the way of support from Application Performance Management (APM) tools. Their licensing models, based on long-running, limited amounts of tin, and their difficulty in dealing with ephemeral hardware, have meant that they are often more trouble than they are worth. However, distributed systems need monitoring, and at some point many teams recognize the need for an APM tool. We think Pinpoint, an open source tool in this space, is worth investigating as an alternative to AppDynamics and Dynatrace. Pinpoint is written in Java, with plugins available for many servers, databases and frameworks. While we think you can go a long way using a combination of other lightweight open source tools—Zipkin, for example—if you are in the market for an APM, Pinpoint is worth considering.
Babel(Nov 2016, 采纳)
Babel.js has become the default compiler for writing next-generation JavaScript. Its ecosystem is really taking off, thanks to its restructured plugin system. It allows developers to write ES6 (and even ES7) code that runs in the browser or in the server without sacrificing backward compatibility for older browsers, and with very little configuration. It has first-class support for different build-and-test systems, which makes integration with any current workflow simple. It is a great piece of software that has become the main driver of ES6 (and ES7) adoption and innovation.
Apache Kafka(Nov 2016, 试验)
Many organizations are now looking closely at new data architectures that capture information as immutable sequences of events at scale. Apache Kafka continues to build momentum as an open source messaging framework that provides a solution for publishing ordered event feeds to large numbers of independent, lightweight consumers. Configuring Kafka is nontrivial, but our teams are reporting positive experiences with the framework.
Apache Kafka(Nov 2015, 评估)
Many recent developments in enterprise software revolve around asynchronous sequences of immutable event sequences as opposed to synchronous, point-to-point requests that modify state. Apache Kafka is an open-source messaging framework that supports this architectural style by publishing ordered message feeds to many independent, lightweight consumers. Kafka’s unique design allows the number of consumers to scale while maintaining strong ordering on the messages.
Realm(Nov 2016, 试验)
Realm is a database designed for use on mobile devices, with its own persistence engine to achieve high performance. Realm is marketed as a replacement for SQLite and Core Data. Note that migrations are not quite as straightforward as the Realm documentation would have you believe. However, more and more teams are choosing Realm as the persistence mechanism in production environments for mobile applications.
Realm(Apr 2016, 评估)
Realm is a database designed for use on mobile devices, with its own persistence engine to achieve high performance. Realm is marketed as a replacement for SQLite and Core Data, and our teams have enjoyed using it. Note that migrations are not quite as straightforward as the Realm documentation would have you believe. Still, Realm has us excited, and we suggest you take a look.
Load Impact(Nov 2016, 试验)
Load Impact is a SaaS load-testing tool that can generate highly realistic loads of up to 1.2 million concurrent users. Record and playback web interactions using a Chrome plugin simulate network connections for mobile or desktop users and generate load from up to 10 different locations around the world. While not the only on-demand load-testing tool we've used—we also like BlazeMeter—our teams were very enthusiastic about Load Impact.
ReSwift(Nov 2016, 评估)
We are excited that the Redux paradigm has made its way to Swift-land in the form of ReSwift. We’ve found real benefits in the simplicity and readability of codebases once state and state changes are managed in a central place and common idiom. This also helps with building "offline first" applications.
Immutable.js(Nov 2016, 试验)
Immutability is often emphasized in the functional programming paradigm, and most languages have the ability to create immutable objects—objects that can't be changed once created. Immutable.js is a library for JavaScript that provides many persistent immutable data structures, which are highly efficient on modern JavaScript virtual machines. Immutable.js objects are, however, not normal JavaScript objects, so references to JavaScript objects from immutable objects should be avoided. More teams are using this library for tracking mutation and maintaining state in production. We recommend that developers investigate this library, especially when it's combined with the rest of the Facebook stack.
Immutable.js(Apr 2016, 评估)
Immutability is often emphasized in the functional programming paradigm, and most languages have the ability to create immutable objects, which cannot be changed once created. Immutable.js is a library for JavaScript that provides many persistent immutable data structures, which are highly efficient on modern JavaScript virtual machines. Immutable.js objects are, however, not normal JavaScript objects, so references to JavaScript objects from immutable objects should be avoided. Our teams have had value using this library for tracking mutation and maintaining state, and it is a library we encourage developers to investigate, especially when it's combined with the rest of the Facebook stack.
Data Lake(Nov 2016, 试验)
A Data Lake is an immutable data store of largely unprocessed "raw" data, acting as a source for data analytics. While the technique can clearly be misused, we have used it successfully at clients, hence motivating its move to trial. We continue to recommend other approaches for operational collaborations, limiting the use of the data lake to reporting, analytics and feeding data into data marts.
Data Lake(Nov 2015, 评估)
A Data Lake is an immutable data store of largely unprocessed 'raw' data, acting as a source for data analytics. Whereas the more familiar Data Warehouse filters and processes the data before storing it, the lake just captures the raw data, leaving it to the users of that data to carry out the particular analysis that they need. Examples include HDFS or HBase within a Hadoop, Spark or Storm processing framework. Usually only a small group of data scientists work on the raw data, developing streams of processed data into lakeshore data marts for most users to query. A Data Lake should only be used for analytics and reporting. For collaboration between operational systems we prefer using services designed for that purpose.
Data Lake(May 2015, 评估)
An Enterprise Data Lake is an immutable data store of largely un-processed “raw” data, acting as a source for other processing streams but also made directly available to a significant number of internal, technical consumers using some efficient processing engine. Examples include HDFS or HBase within a Hadoop, Spark or Storm processing framework. We can contrast this with a typical system that collects raw data into some highly restricted space that is only made available to these consumers as the end result of a highly controlled ETL process.\nEmbracing the concept of the data lake is about eliminating bottlenecks due to lack of ETL developer staffing or excessive up front data model design. It is about empowering developers to create their own data processing pipelines in an agile fashion when they need it and how they need it—within reasonable limits—and so has much in common with another model that we think highly of, the DevOps model.
Bug bounties(Nov 2016, 试验)
The use of bug bounties continues to grow in popularity for many organizations, including enterprises and notable government bodies. A bug-bounty program encourages participants to identify potentially damaging vulnerabilities in return for reward or recognition. Companies like HackerOne and Bugcrowd offer services to help organizations manage this process more easily, and we're seeing these services gather adoption.
Bug bounties(Nov 2015, 评估)
More and more organizations are starting to use bug bounties to encourage reporting of what are often security-related bugs, and in general help improve the quality of their software. To support these programs, companies like HackerOne and BugCrowd can help organizations manage this process more easily. We have limited experience with these offerings ourselves, but we like the idea of encouraging people to help come forward and highlight what can often be damaging vulnerabilities in an open and transparent way. It's worth noting that there might be some legal issues with encouraging users to find vulnerabilities in your software, so please do check that out first.
tmate(Nov 2016, 试验)
Pair programming is an essential technique for us, and—given that we’re seeing more and more teams whose members are distributed across multiple locations—we have experimented with a number of tools to support remote pairing. We certainly liked ScreenHero but are concerned about its future. For teams that don’t rely on a graphical IDE, using tmate for pairing has turned out to be a great solution. tmate is a fork of the popular tmux tool, and compared to tmux for remote pairing, the setup is much easier. Compared to graphical screen-sharing solutions, the bandwidth and resource requirements are modest, and it obviously never suffers from blurry screens. Teams can also set up their own server, thus retaining full control of the privacy and integrity of the solution.
Let's Encrypt(Nov 2016, 试验)
Let's Encrypt first appeared on the Radar last edition, and since December 2015 this project has moved its beta status from private to public, meaning users will no longer be required to have an invitation in order to try it. Let's Encrypt grants access to a simpler mechanism to obtain and manage certificates for a larger set of users who are seeking a way to secure their websites. It also promotes a big step forward in terms of security and privacy. This trend has already begun within ThoughtWorks, and many of our projects now have certificates verified by Let's Encrypt.
Let's Encrypt(Nov 2015, 评估)
Although more sites every day are implementing HTTPS to help protect their own users and improve the integrity of the web as a whole, there are many more sites to go. In addition, we see more and more people using HTTPS within their enterprises, to provide additional security guarantees. One of the main blockers to wider adoption has been the process of getting a certificate in the first place. Aside from the cost, the process itself is far from slick. Let’s Encrypt, a new Certificate Authority, aims to solve all this. First, it provides certificates for free. Second, and arguably more important, it also provides an extremely easy-to-use command-line API, making it easy to fully automate the process of issuing, upgrading and installing certificates. We think that Let’s Encrypt, in beta at the moment, has the chance to be revolutionary in terms of helping more of the web get on to HTTPS, and at the same time showing what good, automatable tools for the security-conscious should look like.
Espresso(Nov 2016, 试验)
At the top of the testing pyramid for Android application development, our teams are increasingly using Espresso as the functional-testing tool. Its small-core API hides the messy implementation details and helps in writing concise tests, with faster and reliable test execution. With Espresso, you can run automated UI tests simulating user interactions within a single target app on both emulators and real devices across different Android versions.
Espresso(Nov 2015, 评估)
Espresso is an Android functional-testing tool. Its small-core API hides the messy implementation details and helps in writing concise tests, with faster and reliable test execution.
FBSnapshotTestcase(Nov 2016, 评估)
Testing the visual portion of iOS applications can be painful, slow and flakey, which is why we’re happy to include FBSnapshotTestcase in our toolkit. It automates taking, storing and diff-ing snapshots of UI components so you can keep your interfaces pixel-perfect. Since it runs as a unit test (in the simulator), it is faster and more reliable than functional-testing approaches.
Zipkin(Nov 2016, 试验)
Development on Zipkin has continued apace, and since the middle of 2015 it has moved to the openzipkin/zipkin organization at GitHub. There are now bindings for Python, Go, Java, Ruby, Scala and C#; and there are Docker images available for those wanting to get started quickly. We still like this tool. There is an active and growing community around usage of it, and implementation is getting easier. If you need a way of measuring the end-to-end latency of many logical requests, Zipkin continues to be a strong choice.
Zipkin(Oct 2012, 评估)
When building distributed applications to address web-scale or big data requirements, setting up appropriate monitoring tools becomes a non-trivial exercise. Zipkin is a tool that instruments the different components of a service-based system and visualizes the breakdown of logical requests passing through multiple services using a ‘firebug-like’ view. The raw data can be stored in Hadoop for more advanced reporting and data mining.
HoloLens(Nov 2016, 评估)
In the HoloLens, Microsoft has delivered the first truly usable AR headset. Not only is it a beautiful piece of industrial design and an eminently comfortable device to wear, but it also clearly demonstrates the promise of AR for the enterprise via its gorgeous optics and deep Windows 10 integration. We expect HoloLens to be the first AR platform on which we deliver substantial application functionality to our clients in the near term, and we look forward to its evolution as it gains broader traction.
Unikernels(Nov 2016, 评估)
With the continued rise to domination of the container model led by Docker adoption, we think it's worth calling attention to the continued rapid development in the Unikernel space. Unikernels are single-purpose library operating systems that can be compiled down from high-level languages to run directly on the hypervisors used by commodity cloud platforms. They promise a number of advantages over containers, not least their superfast startup time and very small attack surface area. Many are still at the research-project phase—Drawbridge from Microsoft Research, MirageOS and HaLVM amongst others—but we think the ideas are very interesting and combine nicely with the technique of serverless architecture.
Jenkins as a deployment pipeline(Nov 2016, 暂缓)
We know we're in perilous territory here, since we build a competing tool, but we feel we have to address a persistent problem. Continuous Integration tools like CruiseControl and Jenkins are valuable for software development, but as your build process gets more complex it requires something beyond just Continuous Integration: It requires a deployment pipeline. We frequently see people trying to use Jenkins as a Deployment Pipeline with the aid of plugins, but our experience is that these quickly become a tangle. Jenkins 2.0 introduces "Pipeline as Code" but continues to model pipelines using plugins and fails to change the core Jenkins product to model pipelines directly. In our experience, tools that are built around a first-class representation of deployment pipelines are much more suitable, and this is what drove us to replace CruiseControl with GoCD. Today we see several products that embrace deployment pipelines, including ConcourseCI, LambdaCD, Spinnaker, Drone and GoCD.
Recharts(Nov 2016, 评估)
We've been enjoying how Recharts integrates D3 charts into React.js in a clean and declarative manner.
Repsheet(Nov 2016, 评估)
Attacks on web properties using bots are becoming more sophisticated. Identifying these bad actors and their behaviors is the goal of the Repsheet project. It's a plugin for either Apache or NGINX that records user activity, fingerprints actors using predefined and user-defined rules, and then allows action to be taken, including the ability to block offensive actors. It includes a utility that visualizes current actors; this puts the ability to manage bot-based threats in the hands of team members, increasing security awareness for teams. We like this since it's a good example of a simple tool solving a very real but often invisible problem—bot-based attacks.
Grasp(Nov 2016, 评估)
We had our collective minds blown by a little JavaScript command-line refactoring tool called Grasp. Providing a rich set of selectors and operating against the abstract syntax tree, it is leagues ahead of fiddling with sed and grep. A useful addition to the toolkit in our ongoing quest to treat JavaScript as a first-class language.
Elm(Nov 2016, 评估)
We have been prompted to reconsider Elm because of the rapid adoption of Redux framework. Elm—the original inspiration for Redux—offers the view componentization and reactiveness of React.js along with the predictable state of Redux in a compiled, strongly typed functional language. Elm is written in Haskell and has a Haskell-like syntax but compiles down to HTML, CSS and JavaScript for the browser. JavaScript programmers rushing to embrace React.js and Redux might want to also consider Elm as a type-safe alternative for some applications.
Elm(Jul 2014, 评估)
Elm is a functional programming language that is used to build web based user interfaces in a functional reactive style. Elm is strongly statically typed and built on the Haskell platform. Elm has a Haskell-like syntax but compiles down to HTML, CSS and JavaScript. While still in its very early days, individuals and teams interested in exploring highly interactive web-based GUIs should look into this interesting little language.
Webpack(Nov 2016, 试验)
Webpack has solidified itself as our go-to JavaScript module bundler. With its ever-growing list of loaders, it provides a single dependency tree for all your static assets, allowing flexible manipulation of JavaScript, CSS, etc. and minimizing what needs to be sent to the browser and when. Of particular relevance is the smooth integration among AMD, CommonJS and ES6 modules and how it has enabled teams to work in ES6 and seamlessly transpile (using Babel) to earlier versions for browser compatibility. Many of our teams also value Browserify, which covers a similar space but is more focused on making Node.js modules available for client-side use.
React.js(Nov 2016, 采纳)
In the avalanche of front-end JavaScript frameworks, React.js stands out due to its design around a reactive data flow. Allowing only one-way data binding greatly simplifies the rendering logic and avoids many of the issues that commonly plague applications written with other frameworks. We're seeing the benefits of React.js on a growing number of projects, large and small, while at the same time we continue to be concerned about the state and the future of other popular frameworks like AngularJS. This has led to React.js becoming our default choice for JavaScript frameworks.
React.js(Nov 2015, 试验)
One benefit of the ongoing avalanche of front-end JavaScript frameworks is that occasionally a new idea crops up that makes us think. React.js is a UI/view framework in which JavaScript functions generate HTML in a reactive data flow. It differs significantly from frameworks like AngularJS in that it only allows one-way data bindings, greatly simplifying the rendering logic. We have seen several smaller projects achieve success with React.js, and developers are drawn to its clean, composable approach to componentization.
React.js(May 2015, 试验)
One benefit to the ongoing avalanche of front-end JavaScript frameworks is that occasionally, a new idea crops up that makes us think. React.js is a UI/View framework in which JavaScript functions generate HTML in a reactive data flow. We have seen several smaller projects achieve success with React.js and developers are drawn to its clean, composeable approach to componentization.
React.js(Jan 2015, 评估)
One benefit to the ongoing avalanche of front-end JavaScript frameworks is that occasionally, a new idea crops up that makes us think.  React.js is a UI/View framework in which JavaScript functions generate HTML in a reactive data flow.  Although we are wary of mixing code and markup, it results in UI components that are nicely encapsulated and composable.  React.js is getting a lot of developer attention and will benefit from more tools and examples becoming available.
LambdaCD(Nov 2016, 评估)
LambdaCD provides teams with a way to define Continuous Delivery pipelines in Clojure. This brings the benefits of Infrastructure as code to the configuration of CD servers: source-control management, unit testing, refactoring and code reuse. In the "pipelines as code" space, LambdaCD stands out for being lightweight, self-contained and fully programmable, allowing teams to work with their pipelines in the same way that they do with their code.
Rancher(Nov 2016, 试验)
The emerging Containers as a Service (CaaS) space is seeing a lot of movement and provides a useful option between basic IaaS (Infrastructure as a Service) and more opinionated PaaS (Platform as a Service). While Rancher creates less noise than some other players, we have enjoyed the simplicity that it brings to running Docker containers in production. It can run stand-alone as a full solution or in conjunction with tools like Kubernetes.
Rancher(Nov 2015, 评估)
Rancher is an open source solution that allows deployment of containers into a cluster of machines, which is becoming an increasingly common scenario. It provides services such lifecycle management, monitoring, health checks and discovery. Also included is a completely containerized operating system based on Docker. The broad focus on containerization and very small footprint are key advantages for Rancher. A similar solution in this space is Kubernetes.
Docker(Nov 2016, 采纳)
We remain excited about Docker as it evolves from a tool to a complex platform of technologies. Development teams love Docker, as the Docker image format makes it easier to achieve parity between development and production, making for reliable deployments. It is a natural fit in a microservices-style application as a packaging mechanism for self-contained services. On the operational front, Docker support in monitoring tools (Sensu, Prometheus, cAdvisor, etc.), orchestration tools (Kubernetes, Marathon, etc.) and deployment-automation tools reflect the growing maturity of the platform and its readiness for production use. A word of caution, though: There is a prevalent view of Docker and Linux containers in general as being "lightweight virtualization," but we would not recommend using Docker as a secure process-isolation mechanism, though we are paying attention to the introduction of user namespaces and seccomp profiles in version 1.10 in this regard.
Docker(Jan 2015, 试验)
Since our last radar, Docker has hit 1.0 and has been declared production ready by the authors. During this same period we have seen an explosion of tools based on Docker. We now have PAAS solutions in the form of Deis, cluster management in CoreOS and Kubernetes, and Microsoft, Google, AWS and a host of smaller players are offering or will shortly offer Docker hosting. Microsoft is even looking to support Docker in their next version of Windows Server. Aside from all this change, Docker is being used in anger now by many people, for dev & test and for production loads. We fully expect to see a large pace of change in the Docker ecosystem over the next year, and strongly suggest you take a look at what Docker could offer your own organisation.
Docker(Jul 2014, 试验)
Docker continues to gain momentum, and is seeing use on projects although mostly in non-production environments. Docker provides a set of tools to efficiently package and distribute executable machine images, which can then be launched as lightweight containers. A considerable community is growing around the tool. Notable is CoreOS which is an operating system based on ChromeOS built for deploying Docker containers across a cluster with tools for deployment, service discovery and configuration.
Docker(Jan 2014, 评估)
The Docker open-source project has generated a great deal of interest within Thoughtworks, and is growing in momentum and maturity. Docker allows applications to be packaged and published as portable lightweight containers that run identically on a laptop or a production cluster. It provides tooling for the creation and management of application containers, and a run-time environment based on LXC (LinuX Containers).
Aurelia(Nov 2016, 评估)
Aurelia is considered the next-generation JavaScript client framework and was written using a modern version of JavaScript: ECMAScript 2016. Aurelia was created by Rob Eisenberg, the creator of Durandal. He left the Angular 2.0 core team to dedicate his time to this project. The great thing about Aurelia is that it's highly modular, contains simple small libraries and is designed to be customized easily. Aurelia follows the pattern of convention over configuration, which enables easier production and consumption of modules, but there are no strong conventions that you have to adhere to. Aurelia has a large community, and in the project website you can learn more by using the tutorials.
JSPatch(Nov 2016, 暂缓)
Many iOS developers are using JSPatch to dynamically patch their apps. When a JSPatch-enabled app runs, it loads a chunk of JavaScript (potentially via an insecure HTTP connection) and then bridges to the main Objective-C application code to change behavior, fix bugs, and so on. While convenient, we think monkey-patching live apps is a bad idea and should be avoided. When doing any amount of incremental patching, it's very important that your testing process matches what end users will experience, in order to properly validate functionality. An alternative approach is to use React Native for the app and AppHub and CodePush to push small updates and new features.
OWASP ASVS(Nov 2016, 评估)
As more development teams incorporate security earlier in the development life cycle, figuring out requirements to limit security risks can seem like a daunting task. Few people have the extensive technical knowledge needed to identify all the risks that an application might face, and teams might struggle just trying to decide where to begin. Relying on frameworks such as OWASP's ASVS (Application Security Verification Standard) can help make this easier. Although somewhat lengthy, it contains a thorough list of requirements categorized by functions such as authentication, access control, and error handling and logging, which can be reviewed as needed. It is also helpful as a resource for testers when it comes time to verify software.
React Native(Nov 2016, 试验)
We are seeing continued success with React Native for rapid cross-platform mobile development. Despite some churn as it undergoes continuing development, the advantages of trivial integration between native and nonnative code and views, the rapid development cycle (instant reload, chrome debugging, Flexbox layout) and general growth of the React style is winning us over. As with many frameworks, care needs to be taken to keep your code well structured, but diligent use of a tool like Redux really helps here.
React Native(Nov 2015, 评估)
Yet another entrant into the cross-platform mobile development world, Facebook’s React Native brings the React.js programming model to iOS and Android developers. React Native programs are written in JavaScript, but unlike a hybrid framework such as Ionic, React Native gives developers access to native UI components on the target platform. This is an approach we’ve seen before (e.g., Calatrava), but React Native has already inspired a substantial developer community and builds on the momentum generated by React.js. This framework could play a significant role in the future of mobile app development.
Robolectric(Nov 2016, 试验)
In the Android application-development world, Robolectric is a unit-testing framework that has been used by multiple teams within our technical community. It offers the best option among those available for writing real unit tests that extend or interact directly with Android components and support JUnit tests. We caution, though, that because it is an implementation of the Android SDK, there might be device-specific issues for some tests that pass in Robolectric. To manually mock all the Android dependencies, ensuring only test of the system-in-test will require a lot of complex code, and this framework addresses this effectively.
JSONassert(Nov 2016, 试验)
More projects are emitting and consuming information formatted as JSON. Writing tests in Java for JSON can be laborious. JSONassert is a small library to help write smaller tests dealing with JSON by simplifying assertions and providing better error messages.
Consumer-driven contract testing(Nov 2016, 采纳)
We’ve decided to bring consumer-driven contract testing back from the archive for this edition even though we had allowed it to fade in the past. The concept isn’t new, but with the mainstream acceptance of microservices, we need to remind people that consumer-driven contracts are an essential part of a mature microservice testing portfolio, enabling independent service deployments. But in addition, we want to point out that consumer-driven contract testing is a technique and an attitude that requires no special tool to implement. We love frameworks like Pact because they make proper contract tests easier to implement in certain contexts. But we have noticed a tendency for teams to focus on the framework rather than on the general practice. Writing Pact tests is not a guarantee that you are creating consumer-driven contracts; likewise, in many situations you should be creating good consumer-driven contracts even where no pre-built testing tool exists.
Consumer-driven contract testing(Nov 2015, 采纳)
When two independently developed services are collaborating, changes to the supplier’s API can cause failures for all its consumers. Consuming services usually cannot test against live suppliers since such tests are slow and brittle, so it’s best to use Test Doubles, leading to the danger that the test doubles get out of sync with the real supplier service. Consumer teams can protect themselves from these failures by using integration contract tests – tests that compare actual service responses with test values. While such contract tests are valuable, they are even more useful when consuming services provide these tests to the supplier, who can then run all their consumers’ contract tests to determine if their changes are likely to cause problems – adopting consumer-driven contracts. Such consumer-driven contract tests are an essential part of a mature microservice testing portfolio.
Content Security Policies(Nov 2016, 评估)
We are finding Content Security Policies to be a helpful addition to our security toolkit when dealing with websites that pull assets from mixed contexts. The policy defines a set of rules about where assets can come from (and whether to allow inline script tags). The browser then refuses to load or execute JavaScript, CSS or images that violate those rules. When used in conjunction with good practices, such as output encoding, it provides good mitigation for XSS attacks. Interestingly, the optional endpoint for posting JSON reports of violations is how Twitter discovered that ISPs were injecting HTML or JavaScript into their pages.
Butterknife(Nov 2016, 试验)
Butterknife is a field and method binding view-injection library. It allows the injection of arbitrary objects, views and listeners, thereby ensuring cleaner code with reduced glue code for Android development. With Butterknife, multiple views can be grouped into a list or array with common actions applied to the views simultaneously, without heavy reliance on XML configurations. Our project teams have used this library and benefited from its simplicity and ease of use.
axios(Nov 2016, 评估)
Our teams have had success with axios, a promises-based HTTP client in JavaScript that they describe as "better than Fetch." The project has lots of endorsements and activity on GitHub, and it gets a thumbs-up from us.
Rapidoid(Nov 2016, 评估)
Rapidoid is a collection of web framework modules, including a fast low-level HTTP server implemented from scratch on top of Java NIO. Clever usage of off-heap input/output buffers, object pools and thread-local data structures provide Rapidoid an edge over other NIO-based servers like Netty. Being a fairly new project, Rapidoid has yet to implement a few features like built-in cache and SSL support; we suggest you check the roadmap for updates.
Reactive architectures(Nov 2016, 试验)
We see continued adoption and success of reactive architectures , with reactive language extensions and reactive frameworks being very popular (we added several such blips in this edition of the Radar). User interfaces, in particular, benefit greatly from a reactive style of programming. Our caveats last time still hold true: Architectures based on asynchronous message passing introduce complexity and make the overall system harder to understand—it's no longer possible to simply read the program code and understand what the system does. We recommend assessing the performance and scalability needs of your system before committing to this architectural style.
Reactive architectures(Nov 2015, 评估)
The techniques of functional reactive programming have steadily gained in popularity over recent years, and we’re seeing increased interest in extending this concept to distributed systems architectures. Partly inspired by “The Reactive Manifesto”, these reactive architectures are based on a one-way, asynchronous flow of immutable events through a network of independent processes (perhaps implemented as microservices). In the right setting, these systems are scalable and resilient and decrease the coupling between individual processing units. However, architectures based entirely on asynchronous message passing introduce complexity and often rely on proprietary frameworks. We recommend assessing the performance and scalability needs of your system before committing to this as a default architectural style.
Tarantool(Nov 2016, 评估)
Tarantool is an open source NoSQL solution that combines database and cache into one entity and provides APIs for writing application logic in Lua. Both in-memory and disk-based engines are supported, and users can create multiple indexes (HASH, TREE, RTREE, BITSET) based on their use cases. The data itself is stored in MessagePack format and uses the same protocol to communicate between clients and server. Tarantool supports write-ahead logs, transactions and asynchronous master-master replication. We are happy with the architectural decision of embracing single-writer policy and cooperative multitasking to handle concurrent connections.
Dapper(Nov 2016, 试验)
Dapper is a minimal, lightweight ORM of sorts for .NET. Rather than trying to write the SQL queries for you, Dapper maps SQL queries to dynamic objects. Though it's not brand new, Dapper has steadily gained acceptance from ThoughtWorks teams working in .NET. For the C# programmer, it removes some of the drudgery of mapping relational queries to objects while still allowing complete control over the SQL or stored procedures.
AWS Application Load Balancer(Nov 2016, 评估)
Amazon recently launched the AWS Application Load Balancer (ALB), a direct replacement for Elastic Load Balancers introduced back in 2009. ALB supports Layer 7 traffic inspection and is built to support modern cloud architecture. If you’re building a microservices-based system using ECS, the new load balancers will directly understand container hosting and scaling, with multiple containers and ports per EC2 instance. Content-based routing allows segmentation of requests onto groups of target servers, along with independent scaling of those groups. Health checks performed by the load balancers are much improved, with the ability to capture detailed metrics about application performance. We like everything that we see here, and teams have begun to report successful usage of ALB.
Spring Boot(Nov 2016, 采纳)
A lot of work has gone into Spring Boot to reduce complexity and dependencies, which largely alleviates our previous reservations. If you live in a Spring ecosystem and are moving to microservices, Spring Boot is now the obvious choice. For those not in Springland, Dropwizard is also worthy of serious consideration.
Spring Boot(Nov 2015, 试验)
Spring Boot allows easy setup of standalone Spring-based applications. It's ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain, thanks to the JPA mappings through Spring Data. We like that Spring Boot simplifies Java services built with Spring but have learned to be cautious of the many dependencies. Spring still lurks just beneath the surface. If you’re writing microservices with Java, you might also consider using Dropwizard or a microframework like Spark to get the benefits of Spring Boot without the enormous weight of Spring.
Spring Boot(May 2015, 试验)
Spring Boot allows easy set up of standalone Spring-based applications. It's ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code. We like that Spring Boot simplifies Java services built with Spring, but have learned to be cautious of the many dependencies. Spring still lurks just beneath the surface.
Spring Boot(Jan 2015, 评估)
Spring boot allows easy set up of standalone Spring-based applications. It's ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code.
Spring Boot(Jul 2014, 评估)
Spring Boot allows easy set up of standalone Spring-based applications. It's ideal for pulling up new microservices and easy to deploy. It also makes data access less of a pain due to the hibernate mappings with much less boilerplate code.
Pivotal Cloud Foundry(Nov 2016, 试验)
The PaaS space has seen a lot of movement since we last mentioned Cloud Foundry in 2012. While there are various distributions of the open source core, we have been impressed by the offering and ecosystem assembled as Pivotal Cloud Foundry. While we expect continued convergence between the unstructured approach (Docker, Mesos, Kubernetes, etc.) and the more structured and opinionated buildpack style offered by Cloud Foundry and others, we see real benefit for organizations that are willing to accept the constraints and rate of evolution to adopt a PaaS. Of particular interest is the speed of development that comes from the simplification and standardization of the interaction between development teams and platform operations.
Packer(Nov 2016, 采纳)
Machine images have become a staple of modern deployment pipelines, and there are a number of tools and techniques to create the images. Because of its comprehensive feature set and the positive experiences we've had with it, we recommend Packer over the alternatives. We also recommend against trying to write custom scripts to do what Packer does out of the box.
Packer(Jan 2015, 试验)
We featured 'Machine image as a build artifact' in the last Radar, as an excellent way to implement fast spin-up, immutable servers. The thing holding this technique back was the difficulty in building images, especially when targeting more than one platform. Packer solves this, using your configuration management tool of choice to create images for a number of platforms including AWS, Rackspace, DigitalOcean and even Docker and Vagrant, although we have found the VMWare support to be problematic.
Packer(Jul 2014, 试验)
We featured 'Machine image as a build artifact' in the last Radar, as an excellent way to implement fast spin-up, immutable servers. The thing holding this technique back was the difficulty in building images, especially when targeting more than one platform. Packer solves this, using your configuration management tool of choice to create images for a number of platforms including AWS, Rackspace, DigitalOcean and even Docker and Vagrant, although we have found the VMWare support to be problematic.
Consul(Nov 2016, 采纳)
We have moved Consul, the service-discovery tool supporting both DNS- and HTTP-based discovery mechanisms, into Adopt. It goes beyond other discovery tools by providing customizable health checks for registered services, ensuring that unhealthy instances are marked accordingly. More tools have emerged to work with Consul to make it even more powerful. Consul Template enables configuration files to be populated with information from Consul, making things like client-side load balancing using mod_proxy much easier. In the world of Docker, registrator can automatically register Docker containers as they appear with Consul with extremely little effort, making it much easier to manage container-based setups. You should still think long and hard about whether you need a tool like this or whether something simpler will do, but if you decide you need service discovery, you won't go far wrong with Consul.
Consul(Nov 2015, 试验)
We continue to be impressed with Consul, a service discovery tool supporting both DNS and HTTP-based discovery mechanisms. It goes beyond other discovery tools by providing customizable health-checks for registered services, ensuring that unhealthy instances are marked accordingly. More tools have emerged to work with Consul to make it even more powerful. Consul Template enables configuration files to be populated with information from Consul, making things like client-side load balancing using mod_proxy much easier. In the world of Docker, registrator can automatically register docker containers as they appear with Consul with extremely little effort, making it much easier to manage container-based setups.
Consul(Jan 2015, 评估)
Consul makes it simple for services to register themselves and discover other services via DNS or HTTP. It scales automatically, with service look up locally or across data centers. Consul also provides a flexible key/value store for dynamic configuration, with notification of configuration changes. The internal gossip protocol used by Consul is powered by the Serf library, leveraging and building upon the membership and failure detection features.
Dagger(Nov 2016, 试验)
With the increased need for Android-based applications, Dagger offers a fully static, compile-time dependency-injection framework. Dagger's strictly generated implementation and nonreliance on reflection-based solutions addresses many of the performance and development issues, thereby making it suitable for Android development. With Dagger, there is full traceability with easy debugging because the entire call stack for provision and creation is made available.
Serverspec(Nov 2016, 试验)
In the past we have included automated Provisioning Testing as a recommended technique, and in this issue we highlight Serverspec as a popular tool for implementing those tests. Although this tool is not new, we are seeing its use become more common as more cross-functional delivery teams take on responsibility for infrastructure provisioning. Serverspec is built on the Ruby library RSpec and comes with a comprehensive set of helpers for asserting that server configuration is correct.
ievms(Apr 2016, 评估)
Despite the shrinking usage of Internet Explorer, for many products the IE user base is not an insignificant share of the market, and browser compatibility needs to be tested. This is particularly troublesome if you prefer the joys of a UNIX-based system for development. To aid in this dilemma, ievms provides a utility script that brings together Windows-distributed VM images and VirtualBox to automate the setup and testability of various IE versions, from 6 up to Edge.
RAML(Apr 2016, 评估)
With a growing landscape of services providing RESTful APIs, it is becoming increasingly important to document them. We have previously mentioned Swagger, and in this Technology Radar we’d like to highlight the RESTful API modeling language (RAML). Our teams feel that in comparison to Swagger it is more lightweight and moves the focus from adding documentation to existing APIs to designing APIs.
AWS ECS(Apr 2016, 评估)
The Elastic Container Service (ECS) is AWS’ entry into the multihost Docker space. Although there is a lot of competition in this area, there aren’t many off-premises managed solutions out there yet. Although ECS seems like a good first step, we are worried that it is overly complicated at the moment and lacks a good abstraction layer. If you want to run Docker on AWS, though, this tool should certainly be high on your list. Just don’t expect it to be easy to get started with.
Idempotency filter(Apr 2016, 试验)
Many services, especially legacy services, are written with the assumption that any request will occur only once. Networks being what they are, this can be difficult to arrange. An idempotency filter is a simple component that merely checks for duplicate requests and ensures that they are sent to the supplier service only once. Such a filter should do only this one task and be used as a decorator over existing service calls.
Monitoring of invariants(Apr 2016, 评估)
In monitoring, the common approach is to conceive of erroneous conditions and set alerts when these appear. But it’s often difficult to enumerate the myriad failure modes in a software system. Monitoring of invariants is a complementary approach to setting expected normal ranges, often by examining historical behavior, and alerting whenever a system goes outside those bounds.
Sleepy Puppy(Apr 2016, 评估)
Sleepy Puppy is a delayed cross-site scripting (XSS) payload-management framework recently open sourced by Netflix. It enables you to test vulnerabilities for XSS past the target application when the perpetrator intends to attack a secondary underlying system. With XSS being one of the OWASP Top10, we see this framework assisting with automated security checks for several applications. It simplifies the capturing, managing and tracking of XSS propagation over long periods of time, with customizable payloads. Sleepy puppy also exposes an API that can be integrated with vulnerability tools like ZAP, for automated security checks.
Alamofire(Apr 2016, 评估)
Networking and decoding in iOS applications have been a difficult endeavor for many years. There have been many libraries and attempts to solve this ongoing problem. It looks as though Alamofire is the most robust and developer-friendly library to handle decoding JSON. It was written by the same creator as its Objective-C counterpart (AFNetworking), which was used at great length during the Objective-C days.
iFrames for sandboxing(Apr 2016, 试验)
Modern web pages tend to contain a plethora of JavaScript widgets and snippets coming from a variety of third-party sources. This can have a negative impact on both security and performance. While we are still waiting for fuller JavaScript isolation with web components, our teams have benefited from using HTML5 iFrames for sandboxing untrusted JavaScript.
ESP8266(Apr 2016, 评估)
Our growing ranks of hardware hackers have been excited by the ESP8266 Wi-Fi microcontroller. Rather than a specific technology innovation, it is the combination of low price point and small form factor that has sparked an inflection point in people's thinking about what is now feasible to achieve with custom hardware devices. Its main characteristics are: Wi-Fi capabilities (it can act as station, access point or a combination of both), low power, open hardware, Arduino SDK programmability, Lua programmability, huge community support and low cost compared with other IoT modules.
Swift(Apr 2016, 采纳)
Swift is now our default choice for development in the Apple ecosystem. With the release of Swift 2, the language approached a level of maturity that provides the stability and performance required for most projects. A good number of libraries that support iOS development—SwiftyJSON, Quick, etc.—are now migrated over to Swift, which is where the rest of the applications should follow. Swift has now been open sourced, and we are seeing a community of developers dedicated to continuously improving development in iOS.
Swift(Nov 2015, 采纳)
A year after its public debut, Swift is now our default choice for development in the Apple ecosystem. With the recent release of Swift 2, the language approaches a level of maturity that provides the stability and performance required for most projects. Swift still has issues, especially around tool support, refactoring and testing. However, we feel that these are not substantial enough to warrant avoiding Swift. At the same time, porting large, existing Objective-C codebases is unlikely to pay off. The announcement that Swift will become open source software is a further positive sign. We are hopeful that this will not just be another dumping of internally developed code into a public repository, because Apple has clearly stated that community contributions are encouraged and will be accepted.
Swift(May 2015, 评估)
With some real-world experience under our belt, Swift still shows a lot of promise. Some of the problems, like long compile times, are being addressed. However, continued language changes cause extra development effort and make building older versions of your own software burdensome. Testing and refactoring also remain painful. On balance, though, you should still consider Swift when starting new development projects for the Apple ecosystem.
Swift(Jan 2015, 评估)
Swift, Apple’s new development language, contains many improvements over the perennial Objective-C, including emphasis on functional programming and modern syntax. In most ways, this is an upgrade if you are coding on the Apple platform.
Products over projects(Apr 2016, 采纳)
We’ve long been championing the idea that thinking of software development as a project - something budgeted and delivered during a limited time slot - doesn’t fit the needs of the modern business. Important software efforts need to be an ongoing product that supports and rethinks the business process it is supporting. Such efforts are not complete until the business process, and its software, cease to be useful. Our observation of this products over projects approach, both with our own projects and outside, makes us determine that it is the approach to use for all but exceptional cases.
Products over projects(May 2015, 试验)
Most software development efforts are done using the mental model of a project, something that is planned, executed, and delivered within defined time-slots. Agile development challenged much of this model, replacing an up-front determination of requirements with an on-going discovery process that runs concurrently with development. Lean startup techniques, such as A/B testing of observed requirements, further erode this mindset. We consider that most software efforts should follow the lead of Lean Enterprise and consider themselves to be building products that support underlying business processes. Such products do not have a final delivery, rather an on-going process of exploring how best to support and optimize that business process which continues as long as the business is worthwhile. For these reasons we encourage organizations to think in terms of products rather than projects.
SignalR(Apr 2016, 试验)
We have a number of reservations about the use of HTML5 WebSockets. By allowing the server to initiate actions on the browser, WebSockets departs from the connectionless, request/response model that underpins the World Wide Web today. Security is another big risk with WebSockets. For example, the standard does not impose any cross-origin request policy. However, we do recognize that in certain monitoring or alerting applications, WebSockets can be very useful. If you need to build a .NET WebSockets server, SignalR conveniently implements much of the additional code you need for a robust production application. This includes some recommended security practices such as validating connection tokens and activating SSL when encryption is needed. Although ThoughtWorks teams have been very happy with SignalR, there are still fundamental issues with WebSockets that you should consider before diving in.
QA in production(Apr 2016, 试验)
Traditionally, QA roles have focused on assessing the quality of a software product in a pre-production environment. With the rise of Continuous Delivery, the QA role is shifting to include analyzing software product quality in production. This involves monitoring of the production systems, coming up with alert conditions to detect urgent errors, determining ongoing quality issues and figuring out what measurements you can use in the production environment to make this work. While there is a danger that some organizations will go too far and neglect pre-production QA, our experience shows that QA in production is a valuable tool for organizations that have already progressed to a reasonable degree of Continuous Delivery.
Browsersync(Apr 2016, 试验)
We've had rave reviews from a number of ThoughtWorks teams using Browsersync. As the number of devices we deliver web applications to grows, so does the amount of effort that must be devoted to testing across these different devices. Browsersync is a free, open source tool that can dramatically reduce this effort by synchronizing manual browser testing across multiple mobile or desktop browsers. Providing both a CLI and a UI option, the tool is build-pipeline friendly and automates repetitive tasks such as form filling.
Decoupling deployment from release(Apr 2016, 采纳)
Implementing Continuous Delivery continues to be a challenge for many organizations, and it remains important to highlight useful techniques such as decoupling deployment from release. We recommend strictly using the term Deployment when referring to the act of deploying a change to application components or infrastructure. The term Release should be used when a feature change is released to end users, with a business impact. Using techniques such as feature toggles and dark launches, we can deploy changes to production systems more frequently without releasing features. More-frequent deployments reduce the risk associated with change, while business stakeholders retain control over when features are released to end users.
Sandstorm(Apr 2016, 评估)
For people who want the benefit of cloud-based collaboration tools but don't want to inadvertently "become the product" of a major cloud provider, Sandstorm provides an interesting open source alternative with the potential for self-hosting. Of particular interest is the isolation approach, whereby containerization is applied per document rather than per application, and syscall whitelisting is added to further secure the sandbox.
Gitflow(Apr 2016, 暂缓)
We firmly believe that long-lived version-control branches harm valuable engineering practices such as continuous integration, and this belief underlies our dislike for Gitflow. We love the flexibility of Git underneath but abhor tools that encourage bad engineering practices. Very short-lived branches hurt less, but most teams we see using Gitflow feel empowered to abuse its branch-heavy workflow, which encourages late integration (therefore discouraging true continuous integration).
Flux(Apr 2016, 试验)
Flux is an application architecture introduced by Facebook. Usually mentioned in conjunction with React.js , Flux is based on a one-way flow of data up through the rendering pipeline. Flux embraces the modern web landscape of client-side JavaScript applications in a way that avoids the venerable MV* clichés. ThoughtWorks teams are now starting to gain some experience with this architectural style and find that it meshes well with service orientation and solves some of the problems inherent in two-way data binding.
Flux(May 2015, 评估)
Flux is an application architecture that Facebook has adopted for its web application development. Usually mentioned in conjunction with react.js , Flux is based on a one-way flow of data up through the rendering pipeline triggered by users or other external events modifying data stores. It’s been a while since we’ve seen any alternatives to the venerable model-view-* architectures and Flux embraces the modern web landscape of client-side JavaScript applications talking to multiple back-end services.
Bluetooth Mesh(Apr 2016, 评估)
While many deployments of smart devices rely on Wi-Fi connectivity, we have been seeing success with Bluetooth Mesh networks that don't necessitate a hub or gateway. With better energy usage than Wi-Fi and better smartphone adoption than ZigBee, Bluetooth LE deployed as a self-healing mesh provides interesting new approaches for connecting local device-area networks. We are still waiting for the formal approach to emerge from the Bluetooth SIG but have already had successful deployments. We particularly like the lack of infrastructure required to stand up a decentralized network but still retain the option to "progressively enhance" the system with the addition of a gateway and cloud services.
Fetch(Apr 2016, 试验)
Our teams are moving away from JQuery or raw XHR for remote JavaScript calls and instead are using the new Fetch API and the Fetch polyfill in particular. The semantics remain similar but have cleaner support for promises and CORS support. We are seeing this as the new de-facto approach.
BFF - Backend for frontends(Apr 2016, 试验)
Valuable services support many variations in clients, such as mobile versus web and different forms of web interface. It’s tempting to design a single back-end API to support all clients with a reusable API. But client needs vary, as do constraints such as bandwidth for mobile devices versus the desire for lots of data on fast web connections. Consequently it’s often best to define different back-end services for each kind of front-end client. These back ends should be developed by teams aligned with each front end to ensure that each back end properly meets the needs of its client.
Enlive(Apr 2016, 试验)
Most templating frameworks like Mustache or FreeMarker mix code with markup in a single file to implement complex, dynamic content. Enlive is a Clojure-based templating framework that completely separates programming language from HTML markup and employs CSS selectors to find and replace parts of the document. Enlive demonstrates the power of functional programming to implement complex behavior through a series of simple, composable functions acting on a common abstraction. Our teams working in Clojure have found it to be a very useful and straightforward tool.
Ceph(Apr 2016, 评估)
Ceph is a storage platform that can be used as object storage, as block storage, and as a file system, typically running on a cluster of commodity servers. With its first major release having been in July 2012, Ceph is certainly not a new product. We do want to highlight it on this Technology Radar as an important building block for private clouds. It is particularly attractive because its RADOS Gateway component can expose the object store through a RESTful interface that is compatible with Amazon S3 and the OpenStack Swift APIs.
NPM for all the things(Apr 2016, 试验)
The JavaScript world has a plethora of dependency and package-management tools, all of which rely on the Node Package Manager (NPM). Teams are starting to see these extra tools as redundant and are recommending that if you can use solely NPM for package and dependency management, you should. The simplification of using NPM for all the things helps reduce some of the churn in the JavaScript tools space.
Gauge(Apr 2016, 试验)
Gauge is a lightweight cross-platform test-automation tool. Specifications are written in free-form Markdown so test cases can be written in the business language, as opposed to using the more common but restrictive "given-when-then" format. Language and IDE support are implemented as plugins to a single core implementation, allowing testers to use the same IDEs as the rest of the team, with powerful capabilities such as autocompletion and refactoring. This tool, open sourced by ThoughtWorks, also supports parallel execution out of the box for all supported platforms.
Gauge(Nov 2015, 评估)
Gauge is a lightweight cross-platform test-automation tool. Specifications are written in free-form Markdown, so test cases can be written in the business language and can be incorporated into any existing documentation format. Supported languages are implemented as plugins to a single core implementation, which ensures consistency across language implementations. This tool, open sourced by ThoughtWorks, also supports parallel execution out of the box for all supported platforms.
Carthage(Apr 2016, 试验)
Dependency management in iOS and OS X projects used to be either completely manual or completely automatic as part of using CocoaPods. With Carthage , a new middle ground has become available. Carthage manages dependencies - it downloads, builds and updates frameworks - but it leaves the integration of the frameworks into the build of the project to the project. This is in contrast to CocoaPods, which basically takes over the project structure and build setup. It should be noted that Carthage can only deal with dynamic frameworks, which are not available on iOS 7 and below.
Application Servers(Apr 2016, 暂缓)
The rise of containers, phoenix servers and continuous delivery has seen a move away from the usual approach to deploying web applications. Traditionally we have built an artifact and then installed that artifact into an application server. The result was long feedback loops for changes, increased build times and the not insignificant overhead of managing these application servers in production. Many of them are a pain to automate too. Most teams we work with favor bundling an embedded http server within your web application. There are plenty of options available: Jetty, SimpleWeb, Webbit and Owin Self-Host amongst others. Easier automation, easier deployment and a reduction in the amount of infrastructure you have to manage lead us to recommend embedded servers over application servers for future projects.
SysDig(Apr 2016, 试验)
Although SysDig isn’t the newest tool on the Technology Radar, we’re still surprised by how many people haven’t heard of it. A pluggable open source CLI for Linux system troubleshooting, SysDig has some pretty powerful features. One of the key things we like is the ability to generate a system trace on a machine that is experiencing difficulties, which you can then interrogate afterward to find out what was happening. SysDig also contains support for working with containers, something that makes a previously useful tool even more powerful.
H2O(Apr 2016, 试验)
Predictive analytics are used in more and more products, often directly in end user-facing functionality. H2O is an interesting open source package (with a startup behind it) that makes predictive analytics accessible to development teams, offering straightforward use of a wide variety of analytics, great performance and easy integration on JVM-based platforms. At the same time it integrates with the data scientists’ favorite tools, R and Python, as well as Hadoop and Spark.
H2O(Nov 2015, 试验)
Predictive analytics are used in more and more products, often directly in end user-facing functionality. H2O is an interesting open source package (with a startup behind it) that makes predictive analytics accessible to development teams, offering straightforward use of a wide variety of analytics, great performance and easy integration on JVM-based platforms. At the same time it integrates with the data scientists’ favorite tools, R and Python, as well as Hadoop and Spark.
H2O(May 2015, 评估)
Predictive analytics are used in more and more products, often directly in end-user facing functionality. H2O is an interesting new open source package (with a startup behind it) that makes predictive analytics accessible to project teams due to its easy-to-use user interface. At the same time it integrates with the data scientists’ favourite tools, R and Python, as well as Hadoop and Spark. It offers great performance and, in our experience, easy integration at runtime, especially on JVM-based platforms.
High performance envy/web scale envy(Apr 2016, 暂缓)
We see many teams run into trouble because they have chosen complex tools, frameworks or architectures because they "might need to scale". Companies such as Twitter and Netflix need to be able to support extreme loads and so need these architectures, but they also have extremely skilled development teams able to handle the complexity. Most situations do not require these kinds of engineering feats; teams should keep their  web scale envy in check in favor of simpler solutions that still get the job done.
ES6(Apr 2016, 采纳)
Over many years, JavaScript has grown to become probably the most widely used programming language in the world. Nevertheless, the language itself has a few problems that many have attempted to address by using libraries or even by implementing their own languages that run on top of JavaScript (of which we’ve mentioned both CoffeeScript and ClojureScript before). ES6 (aka ECMAScript 6 or ECMAScript 2015), the new version of JavaScript, addresses many of the concerns of the older versions currently in use. Although browser support is scarce, support from mature transpilers like Babel allows you to write ES6 and have it supported in older browsers. For new projects, we strongly suggest starting with ES6 from day one.
Presto(Apr 2016, 评估)
Presto is an open source distributed SQL query engine designed and optimized for running interactive analytics workloads. Presto's massively parallel processing architecture - combined with advanced code-generation techniques and in-memory processing pipelines - makes it highly scalable. It supports a large subset of ANSI SQL including complex queries, joins, aggregations and window functions. Presto comes with support for a wide range of data sources including Hive , Cassandra , MySQL and PostgreSQL , thereby unifying the interactive analytics interface across data stores of an organization. Applications can connect to Presto using its JDBC interface.
GitUp(Apr 2016, 试验)
Git can be confusing. Really confusing. And even when it’s used in a simple trunk-based development process, there are still enough nuances to how it works that people can tie themselves in knots from time to time. When this happens, having an understanding of how Git works under the hood is very useful, and GitUp is a Mac-based tool that gives you exactly that. GitUp provides a graphical representation of what is happening as you type normal Git commands into the terminal. You can learn the various Git commands while also understanding what each one does as you use it. GitUp is a useful tool for both people new to Git and those with more Git experience.
Gitrob(Apr 2016, 评估)
Attackers continue to use automated software to crawl public GitHub repositories to find AWS credentials and spin up EC2 instances to mine Bitcoins or for other nefarious purposes. Although adoption of tools like git-crypt and Blackbox to safely store secrets such as passwords and access tokens in code repositories is increasing, it is still all too common that secrets are stored unprotected. It is also not uncommon to see project secrets accidentally checked in to developers' personal repositories. Gitrob can help minimize the damage of exposing secrets. It scans an organization's GitHub repositories, flagging all files that might contain sensitive information that shouldn't have been pushed to the repository. The current release of the tool has some limitations: It can only be used to scan public GitHub organizations and their members, it doesn't inspect the contents of files, it doesn't review the entire commit history, and it fully scans all repositories each time it is run. Despite these limitations, it can be a helpful reactive tool to help alert teams before it is too late. It should be considered a complementary approach to a proactive tool such as Talisman.
Gitrob(Nov 2015, 试验)
Safely storing secrets such as passwords and access tokens in code repositories is now supported by a growing number of tools - for example, git-crypt and Blackbox, which we mentioned in the previous Technology Radar. Despite the availability of these tools, it is still, unfortunately, all too common that secrets are stored unprotected. In fact, it is so common that automated exploit software is used to find AWS credentials and spin up EC2 instances to mine Bitcoins, leaving the attacker with the Bitcoins and the account owner with the bill. Gitrob takes a similar approach and scans an organization’s GitHub repositories, flagging all files that might contain sensitive information that shouldn’t have been pushed to the repository. This is obviously a reactive approach. Gitrob can only alert teams when it is (almost) too late. For this reason, Gitrob can only ever be a complementary tool, to minimize damage.
OkHttp(Apr 2016, 评估)
OkHttp is a Java HTTP connection library from Square that provides a fluent interface for creating connections, as well as support for the faster HTTP/2 protocol. Even when using HTTP/1.1, OkHttp can provide performance improvements via connection pooling and transparent gzip compression. Supporting both blocking synchronous and nonblocking asynchronous calls, it can also be used as a drop-in replacement for the widely used Apache HttpClient.
TOTP Two-Factor Authentication(Apr 2016, 采纳)
Password security is still a hotly debated topic with the UK government advocating technical controls that let users remember simpler passwords and Edward Snowden’s password advice being described as only "borderline secure". Passwords are generally one of the weakest links in the security chain, so we recommend employing two-factor authentication , which can significantly improve security. Time-based One-Time Password ( TOTP ) is the standard algorithm in this space, with straightforward server-side implementations and free smartphone authenticator apps from Google and Microsoft.
TOTP Two-Factor Authentication(May 2015, 试验)
Passwords continue to be a poor mechanism for authenticating users and we’ve recently seen companies such as Yahoo! move to a “no passwords” solution—a one-time code is texted to your phone whenever you need to log in from a new browser. If you are still using passwords we recommend employing two-factor authentication which can significantly improve security. Time-based One-Time Password ( TOTP ) is the standard algorithm in this space, with free smartphone authenticator apps from Google and Microsoft.
TOTP Two-Factor Authentication(Jan 2015, 评估)
Two-factor authentication significantly improves security over simple password-based systems. RFC 6238 -- Time-based One-Time Password Algorithm -- is a standard for two-factor authentication. 'Standard' authenticator apps from Google and Microsoft provide tokens to smartphone users, and there are a number of other client and server implementations readily available. With providers such as Google, Facebook, Dropbox and Evernote using TOTP, there really is no excuse to continue using simple password-based authentication where stronger security would be appropriate.
TOTP Two-Factor Authentication(Jul 2014, 评估)
Two-factor authentication significantly improves security over simple password-based systems. RFC 6238 -- Time-based One-Time Password Algorithm -- is a standard for two-factor authentication. "Standard" authenticator apps from Google and Microsoft provide tokens to smartphone users, and there are a number of other client and server implementations readily available. With providers such as Google, Facebook, Dropbox and Evernote using TOTP, there really is no excuse to continue using simple password-based authentication where stronger security would be appropriate.
MemSQL(Apr 2016, 评估)
As Moore's Law predicts, we continue to increase the capacity of computer systems and reduce their cost, and so new processing techniques become possible that only a few years ago would have seemed out of reach. One of these techniques is the in-memory database: Instead of using slow disks or relatively slow SSDs to store data, we can keep it in memory for high performance. One such in-memory database, MemSQL, is making waves because it is horizontally scalable across a cluster and provides a familiar SQL-based query language. MemSQL also connects to Spark for analytics against real-time data, rather than stale data in a warehouse.
Cylon.js(Apr 2016, 评估)
The intersection between IoT devices and the JavaScript ecosystem offers interesting possibilities. Cylon.js is a JavaScript library for building interfaces for robotics and the Internet of Things, which has excited our technical community. It offers support for 50+ platform devices, as well as general-purpose input/output support with a shared set of drivers provided by the cylon-gpio module. Control of the devices is then possible through a web browser interface.
Hosted IDE's(Apr 2016, 评估)
Many organizations want to leverage distributed or offshore development but have security concerns with their code and other intellectual property sitting outside their control. The result is often to use high-latency remote-desktop solutions for development, adhering to an organization’s security controls but crippling developer productivity. An alternative is to use a Hosted IDE delivered to a browser via VPN. The IDE, code and build environment are hosted within the organization's private cloud, easing security concerns, and the developer experience is significantly improved. Tools in this space include Orion and Che from the Eclipse Foundation, Cloud9 and Code Envy.
Deis(Nov 2015, 评估)
Heroku, with its 12-factor application model, has changed the way we think about building, deploying, and hosting web applications.  Deis encapsulates the Heroku PaaS model in an open-source framework that deploys onto Docker containers hosted anywhere.  Deis is still evolving, but for applications that fit the 12-factor model it has the potential to greatly simplify deployment and hosting in the environment of your choice.  Deis is yet another example of the rich ecosystem of platforms and tools emerging around Docker.
Pageify(Nov 2015, 评估)
Pageify is a Ruby library for building page objects for UI automation tests, focusing on faster test execution and code readability. It offers simple APIs to dynamically define, operate and assert on the page objects, allowing readable code even when handling elements with complex hierarchies in the DOM. It bundles integration for WebDriver and Capybara.
Apache Kylin(Nov 2015, 评估)
Apache Kylin is an open source analytics solution from eBay Inc. that enables SQL based multidimensional analysis (OLAP) on very large datasets. Kylin is intended to be a Hadoop based hybrid OLAP (HOLAP) solution that will eventually support both MOLAP and ROLAP style multidimensional analysis. With Kylin you can define cubes using a Cube Designer and initiate an offline process that builds these cubes. The offline process performs a pre-join step to join facts and dimension tables into a flattened out structure. This is followed by a pre-aggregation phase where individual cuboids are built using Map Reduce jobs. The results are stored in HDFS sequence files and are later loaded into HBase. The data requests can originate from SQL submitted using a SQL-based tool. The query engine (based on Apache Calcite ), determines if the target dataset exists in HBase. If so, the engine directly accesses the target data from HBase and returns the result with sub-second latency. If not, the engine routes the queries to Hive (or any other SQL on Hadoop solution enabled on the cluster).
Apache Spark(Nov 2015, 试验)
Apache Spark has been steadily gaining ground as a fast and general engine for large-scale data processing. The engine is written in Scala and is well suited for applications that reuse a working set of data across multiple parallel operations. It’s designed to work as a standalone cluster or as part of Hadoop YARN cluster. It can access data from sources such as HDFS, Cassandra, S3 etc. Spark also offers many higher level operators in order to ease the development of data parallel applications. As a generic data processing platform it has enabled development of many higher level tools such as interactive SQL (Spark SQL), real time streaming (Spark Streaming), machine learning library (MLib), R-on-Spark etc.
Apache Spark(Jan 2015, 评估)
For iterative processing such as machine learning and interactive analysis, Hadoop map-reduce does not work very well because of its batch-oriented nature. Spark is a fast and general engine for large-scale data processing. It aims to extend map-reduce for iterative algorithms and interactive low latency data mining. It also ships with a machine learning library.
Apache Spark(Jul 2014, 评估)
For iterative processing such as machine learning and interactive analysis, Hadoop map-reduce does not work very well because of its batch-oriented nature. Spark is a fast and general engine for large-scale data processing. It aims to extend map-reduce for iterative algorithms and interactive low latency data mining. It also ships with a machine learning library.
Citrix for development(Nov 2015, 暂缓)
Many organizations are still forcing distributed or offshore development teams to use Citrix remote desktop for development. Although this provides a simple security model – assets supposedly never leave the organization’s servers - using remote desktops for development absolutely cripples developer productivity. There’s not much point paying a cheaper hourly rate for developers if you’re going to impose both the distribution and remote-desktop burdens on them, and we wish more offshore vendors would admit these drawbacks to their clients. It’s much better to use either a 'clean room' secured offshore environment where local development can be done, or a Hosted IDE (e.g. ievms)
Citrix for development(May 2015, 暂缓)
For security and compliance reasons, offshore teams are sometimes asked to use Citrix to connect to an onshore virtual desktop, where they do development. While a good tool for some use cases, Citrix provides an extremely poor remote development experience and often cripples an offshore team. There are many better technical solutions, such as the NoMachine remote desktop or Cloud9 IDE, which can provide a more workable experience. An even better solution is to tackle the underlying security and compliance concerns. Since you are trusting the remote team to work on your source code and check in to your code repository, you should try to get to a point where you also trust them to have source code on their machines. They will be much more productive!
HyperResource(Nov 2015, 评估)
HyperResource is a Ruby framework for building a RESTful API client. The framework accepts JSON in HAL format and dynamically generates a model object complete with hypermedia links. Although the framework is still in its infancy, we like that it embraces Richardson level 3 REST for better service discoverability and self-documenting protocols.
Time series databases(Nov 2015, 评估)
A time series database (TSDB) is a system that is optimized for handling time series data. It allows users to perform CRUD operations on various time series organized as database objects. It also provides the ability to perform statistical calculations on the series as a whole. Although TSDBs are not entirely a new technology we are seeing a renewed interest in the these databases primarily in the realm of IoT applications. This is being facilitated by many open source and commercial platforms (such as  OpenTSDB , InfluxDB , Druid , BlueFloodDB etc.) that have mushroomed recently. Its also worth mentioning that some of these systems use other distributed databases such Cassandra and HBase as their underlying storage engine.
Docker Toolbox(Nov 2015, 试验)
Previously, we recommended boot2docker as a way of easily running Docker on your local Windows or OS X machine. Docker Toolbox now replaces boot2docker, adding some tooling as well. Now included is Kitematic for managing your containers, as well as Docker Compose for managing multi-Docker setup (Mac only). It can be used safely as a drop-in replacement for boot2docker, and it will even handle the upgrade for you.
Mountebank(Nov 2015, 采纳)
Good testing of components in an enterprise system is critical and with increased emphasis on service-based separation and deployment automation—critical factors for success with microservices—better tooling in this space is needed. The industry term “service virtualization” refers to tools that can emulate specific components in such an environment. We have seen great success with Mountebank, a lightweight tool for stubbing and mocking HTTP, HTTPS, SMTP and TCP.
Mountebank(Jan 2015, 评估)
When testing services, we commonly need to stub out downstream collaborating services. Written by a Thoughtworker, Mountebank is a lightweight service which you can configure via HTTP that is capable of stubbing and mocking HTTP, HTTPS, SMTP and TCP.
Mountebank(Jul 2014, 评估)
When testing services, we commonly need to stub out downstream collaborating services. Written by a Thoughtworker, Mountebank is a lightweight service which you can configure via HTTP that is capable of stubbing and mocking HTTP, HTTPS, SMTP and TCP.
NoPSD(Nov 2015, 采纳)
'Just In Time Design' is an important and useful concept for visual design that the NoPSD movement attempts to capture. You don't need to design the whole application or every UI element up front. Design things as you need them with as lightweight tools as you can use. We have seen a corresponding growth in simpler tools with faster learning curves, such as Sketch, as well as an increasing return to pen-and-paper (especially when paired with an existing robust digital style guide). Because of the limitations of flat mock-ups when you’re designing for screens, creating prototypes of varying fidelity with tools such as Invision, FramerJS and Origami - or simply HTML/CSS and a bit of JavaScript - has also become increasingly common and valuable for communicating design intent.
NoPSD(May 2015, 试验)
NoPSD is a movement to integrate design activities into the iterative feedback cycles required to build great software. The name aims to dislodge the PSD as the final canonical design artifact rather than taking a dig at the Adobe software. Instead of signing off on a pixel-perfect design specification at the start of a project, teams are urged to embrace Continuous Design: embedding designers into delivery teams, using lo-fi techniques for prototyping, and collaborating to refine the design in the target UI technology (normally HTML and CSS). This approach speeds responding to real user feedback, allows testing designs across multiple devices and form-factors, and embraces the dynamic nature of both digital products and the product creation process.
Cloudera Impala(Nov 2015, 试验)
For a while now the Hadoop community has been trying to bring low-latency, interactive SQL capability to the Hadoop platform (better known as SQL-on-Hadoop). This has led to a few open source systems such as Cloudera Impala, Apache Drill, Facebook’s Presto etc being developed actively through 2014. We think the SQL-on-Hadoop trend signals an important shift as it changes Hadoop's proposition from being a batch oriented technology that was complementary to databases into something that could compete with them.  Cloudera Impala was one of the first SQL-on-Hadoop platforms. It is a distributed, massively-parallel, C++ based query engine. The core component of this platform is the Impala daemon that coordinates the execution of the SQL query across one or more nodes of the Impala cluster. Impala is designed to read data from files stored on HDFS in all popular file formats. It leverages Hive's metadata catalog, in order to share databases and tables between the two database platforms. Impala comes with a shell as well as JDBC and ODBC drivers for applications to use.
Pace-layered Application Strategy(Nov 2015, 暂缓)
Gartner's Pace-layered Application Strategy approach appears to be creating an unhelpful focus on the idea of layers within an architecture. We find thinking about the pace of change within different business capabilities (which can be made up of several architectural layers) to be a more useful concept. The danger in focusing on layers is that many types of change cut across multiple layers. For example, being able to add new class of stock to a website is not just about having an easy-to-change CMS; you also need to update the database, integration points, warehouse systems, etc. The recognition that some parts of an architecture need to be more maneuverable than others is useful. However, a focus on layers is proving unhelpful.
Pace-layered Application Strategy(Jan 2015, 评估)
Gartner's Pace-layered Application Strategy approach to architecture attempts to articulate the fact that decisions about architecture should not be a one-size fits all approach. Instead, it is important to take a balanced view of your technology portfolio. We have qualms about some of the prescriptive recommendations that come with Pace. In particular, we have found some situations where the layering concept is too simplistic. That said, we believe the core idea that different components and systems within an architecture need to change at different paces is sound.
Pace-layered Application Strategy(Jul 2014, 评估)
Gartner's Pace-layered Application Strategy approach to architecture attempts to articulate the fact that decisions about architecture shouldn't be a one-size-fits-all approach. Instead, it is important to take a balanced view to your technology portfolio in terms of where to be conservative, and where to take risks. While we have qualms about some of the more prescriptive recommendations that seem to come with Pace, in general we like the concept and many organizations could benefit from adapting similar models.
Quick(Nov 2015, 评估)
Quick is a testing framework for Swift and Objective-C, which comes bundled with Nimble , a matcher framework for tests. Quick helps verify the behavior of Swift and Objective-C programs. Quick has the same syntactic flavour as RSpec and Jasmine and is easy to set up. It is very organized, allows for assertion of types and makes it easy to test asynchronous code.
BEM(Nov 2015, 试验)
Debugging CSS problems can be painful. How many times have you had to trawl through thousands of overridden styles to work out the source of your problem? This has led many of our teams to introduce various guidelines such as avoiding cascading and overrides, making styles opt-in and emphasizing thoughtful naming. BEM is a simple CSS naming convention (standing for Block, Element, Modifier) that helps give semantic clarity and structure to your CSS. By using BEM, it becomes much easier to understand which CSS rules are influencing the appearance of an element and, more importantly, the intent of those rules. This approach can be seen as moving the OO lesson of favoring composition over inheritance to the world of CSS.
Separate DevOps team(Nov 2015, 暂缓)
In the last radar issue we advised against creating a separate DevOps team , as DevOps is about creating a culture of shared responsibility in delivery teams. We recommend embedding operations skills into delivery teams to reduce friction and deliver better outcomes. However where there is a need for significant investment in tooling and automation, we do see a role for a Delivery Engineering team.  Rather than being a helpdesk, these teams build tooling and enable teams to deploy, monitor, and maintain their own production environments.
Separate DevOps team(Jul 2014, 暂缓)
Some companies with good intentions create a separate DevOps team, which misconstrues the definition of DevOps. Rather than a role, DevOps is a cultural movement encouraging collaboration between operations specialists and developers. Rather than create yet another silo and suffer the consequences of Conway's Law, we advise you to embed these skills into teams, improving feedback loops and communication pathways by removing friction.
Offline first web applications(Nov 2015, 试验)
Offline first web applications provide the ability to design web applications for offline access by employing caching and updating mechanisms. The implementation requires a flag in the DOM to check whether the accessing device is offline or online, accessing local storage when offline, and synchronising data when online. All the major browsers now support an offline mode, which bootstraps the process of downloading and caching the resources such as HTML, CSS, JavaScript, images and other kinds of resources. There are some tools which help simplify offline first implementation such as Hoodie, and CouchDB also offers ability to work with a locally deployed application on a local data storage.
Postman(Nov 2015, 采纳)
Postman is a Chrome extension that acts as a REST client in your browser, allowing you to create requests and inspect responses.  It is a useful tool when developing an API or implementing a client to call an existing API. Postman supports OAuth1 and OAuth2 tokens allowing addition of them to requests where necessary. The response is available as a prettified JSON or XML. With Postman you are able to retrieve a history of requests performed to quickly edit and test the API response to different data. It offers a suite of extensions that allow you to use it as a full-blown test runner too, although we discourage the record and replay style of testing it promotes.
Postman(Jan 2015, 试验)
Postman is a Chrome extension that acts as a REST client in your browser, allowing you to create requests and inspect responses.  It is a useful tool when developing an API or implementing a client to call an existing API. It offers a suite of extensions that allow you to use it as a full-blown test runner too, although we discourage the record and replay style of testing it promotes.
Docker for builds(Nov 2015, 试验)
One of the many innovative uses of Docker that we’ve seen on our projects is a technique to manage build-time dependencies. In the past, it was common to run build agents on an OS, augmented with dependencies needed for the target build. But with Docker it is possible to run the compilation step in an isolated environment complete with dependencies without contaminating the build agent. This technique of using Docker for builds  has proven particularly useful for compiling Golang binaries, and the golang-builder container is available for this very purpose.
Material UI(Nov 2015, 评估)
Material UI provides reusable components for use in React applications that implement Google's Material Design language. Filling a similar space to Twitter Bootstrap, it gets you up and running quickly but doesn't have the same drawbacks as your application grows. Elemental UI is worth investigating as an alternative.
Frege(Nov 2015, 评估)
Following many other programming languages, one of the language geeks’ absolute favourites, Haskell, is now also available on the JVM in the form of Frege. This brings a purely functional programming language onto the platform, allowing for easy interoperability with other JVM languages and libraries.
Axon(Nov 2015, 评估)
While we still have some reservations about CQRS as a general pattern, the approach can work very well in specific places. In those specific situations, however, a lot of work is left to the developer to properly execute CQRS. Axon is a framework that can help with this on the JVM, and we’ve used it with some success. Although it certainly can’t be considered a perfect solution right now, it continues to evolve and may make much more sense than trying to write everything from scratch.
IndexedDB(Nov 2015, 试验)
As single page applications and offline-first become more viable and widespread there is a growing need to persist data in the web browser. Local Storage is very easy to use and well supported by the web browsers. For more complex use cases, there is IndexedDB. While it can be a good solution we recommend to only use it when absolutely necessary, due to the increase in complexity and a somewhat clumsy API. We have also had positive experience with the localForage framework that provides an abstraction layer over the various persistence solutions.
Sensu(Nov 2015, 试验)
Many monitoring tools are built around the concept of the machine or instance. The increasing use of patterns like Phoenix Server and tools like Docker mean this is an increasingly unhelpful way to model infrastructure: Instances are becoming transient while services are the things that persist. Sensu allows an instance to register itself as playing a particular role, and Sensu then monitors it on that basis. Over time, different instances playing that role may come and go. Given these factors and the increasing maturity of the tool, we felt it was time to bring Sensu back on to the radar.
Sensu(Jan 2014, 评估)
Many monitoring tools are built around the idea of the machine. We monitor what the machine is doing and which software is running on it. When it comes to cloud based infrastructure, especially patterns like Phoenix and Immutable servers this is a problematic approach. Machines come and go, but what is important is that the services remain working. Sensu allows a machine to register itself as playing a particular role and Sensu then monitors it on that basis. When we are finished with the machine we can simply de-register it.
Hamms(Nov 2015, 试验)
Many many wonderful stories of failure in our industry are caused by the assumption that networks are always reliable and servers respond quickly and correctly all the time. Hamms is an interesting open-source tool which acts as a badly behaved HTTP server, triggering a number of failures including connection failures or slow and/or malformed responses. It may be useful for testing that your software handles failures gracefully.
Gor(Nov 2015, 评估)
Gor is an open-source tool for capturing and replaying live HTTP traffic into a test environment in order to continuously test your system with real data. It can be used to increase confidence in code deployments, configuration changes and infrastructure changes.
Microsoft Nano Server(Nov 2015, 评估)
In contrast to modern cloud and container solutions based on Linux, even Windows Server Core is large and unwieldy. Microsoft is reacting and has provided the first previews of Nano Server, a further-stripped-down version of Windows Server that drops the GUI stack, 32-bit Win32 support, local logins and remote desktop support, resulting in an on-disk size of about 400MB. The early previews are difficult to work with, and the final solution will be restricted to using the CoreCLR, but for companies that are interested in running .NET-based solutions, Nano Server is definitely worth a look at this stage.
Nancy(Nov 2015, 采纳)
Since we last talked about Nancy on the technology radar it has become the default choice on our .NET projects. Architectures centred around small, vertical slices and microservices simply require light-weight deployment options and low ceremony tooling.
Nancy(Jul 2014, 试验)
Nancy continues to gain traction in the Alt.NET community and we have found it particularly useful for deploying low-ceremony, lightweight fakes for testing in a microservices environment.
Nancy(Jan 2014, 评估)
Nancy is a lightweight, open-source web framework for .NET.  In the spirit of Sinatra for Ruby, Nancy provides just the essentials necessary to implement web applications with minimal extraneous code.  Because the framework is independent of any particular hosting environment, the developer is freed from the IIS and ASP.NET environment.  This makes Nancy an excellent complement to OWIN and compatible with other OWIN modules.  We are really happy to see the emergence of lightweight web frameworks in a number of other languages as well; Spark for Java, Flask for Python, etc..
Generated infrastructure diagrams(Nov 2015, 采纳)
When we need a diagram that describes the current infrastructure or physical architecture we usually take to our favorite technical diagramming tool. If you are using the cloud or virtualization technologies this no longer makes sense, we can use the provided APIs to interrogate the actual infrastructure and generate a live, automated infrastructure diagram using simple tools like GraphViz or by outputting SVG.
TLA+(Nov 2015, 评估)
Building systems using microservices requires us to think more deeply about failure isolation and testing. *TLA+ *is a formal specification language that can be useful in both these scenarios. For failure isolation, TLA+ can be used to identify invariants in your system that can be monitored directly. An invariant can be the ratio of number of requests to one service to the number of requests to a second service, for example. Any change in this ratio would lead to an alert. TLA+ is also being used to identify subtle design flaws in distributed systems. Amazon, for example, used model-checking based on a formal specification written in TLA+ to identify subtle bugs in Dynamo DB before it was released to the public. For most systems, the investment required to create the formal specification and then perform model checking is probably too great; however, for critical systems - complex ones, or those with many users - we think it’s very valuable to have another tool in our toolbox.
SPDY(Nov 2015, 暂缓)
The SPDY protocol was developed by Google from 2009 as an experiment to provide an alternative protocol to address performance shortcomings of HTTP/1.1. The new HTTP/2 standard protocol includes many of the key performance features of SPDY, and Google has announced it will drop browser SPDY support in early 2016. If your application requires the features of SPDY, we recommend you look instead at HTTP/2.
SPDY(Jul 2014, 评估)
SPDY is an open networking protocol for low-latency transport of web content proposed for HTTP 2.0 that has seen a rise in modern browser support. SPDY reduces page load time by prioritizing the transfer of subresources so that only one connection is required per client. Transport layer security is used in SPDY implementations with the transmission headers gzip or deflate compressed instead of human-readable text as in HTTP. It is great for high-latency environments.
Fastly(Nov 2015, 试验)
Fastly, one of a number of CDNs on the market, has a large and growing following on ThoughtWorks projects and is used by many web-scale household names, such as GitHub and Twitter. Its feature set, speed and price point combine to make it a very attractive option when you’re looking for an edge caching solution. We have also seen significant cost savings on projects that move to this platform from another CDN. If you are in the market for a CDN, you could do worse than investigate this one.
Particle Photon/Particle Electron(Nov 2015, 评估)
Particle (formally Spark.io) is a full stack solution for cloud connected devices. Particle Photon is a microcontroller with wifi module. Particle Electron is a variant that connects to a cellular network. Particle OS adds REST API to the devices. This simplifies the entry to IoT and building your own connected devices.
Particle Photon/Particle Electron(May 2015, 评估)
Spark is a full stack solution for cloud connected devices. Spark Photon is a microcontroller with wifi module. Spark Electron is a variant that connects to a cellular network. Spark OS adds REST API to the devices. This simplifies the entry to IoT and building your own connected devices.
Composer(Nov 2015, 采纳)
Although the idea of dependency management is not new and considered to be a fundamental development practice, it is not widely adopted by the PHP community. Composer is a tool for dependency management in PHP. It is strongly influenced by tools from other technology stacks like Node's npm and Ruby's Bundler. We are now seeing wide adoption across PHP projects and it is fairly mature. You can still have to do some shims for internal libraries, you can use it for most external libraries.
Composer(Jan 2015, 试验)
Although the idea of dependency management is not new and considered to be a fundamental development practice, it is not widely adopted by the PHP community. Composer is a tool for dependency management in PHP. It is strongly influenced by tools from other technology stacks like Node's npm and Ruby's Bundler.
Traveling Ruby(Nov 2015, 评估)
Traveling Ruby makes it possible to distribute portable, ready-to-run, platform-agnostic Ruby binaries without the need to install an interpreter, packages or additional gems. It decouples running Ruby applications from the development environment they run in.
Programming in your CI/CD tool(Nov 2015, 暂缓)
We still see teams configure their CI and CD tools by directly embedding complex multi-line commands directly into the configuration of the tool. Often these embedded commands also contains steps that would only ever take effect in the build environment including things such as CI specific environment variables, steps that would create/modify files and templates only in the CI environment etc. This makes the build environment a special beast - whose results cannot be duplicated locally on a developer's machine.\nThis is extremely problematic because the CI/CD tool, which is supposed to expose problems in your code, itself becomes a complex beast whose behavior is hard to debug and whose results are hard to replicate.\nThe way to avoid programming in your CI/CD tool is to extract the complexities of the build process from the guts of the tool and into a simple script which can be invoked by a single command. This script can then be executed on any developer workstation and therefore eliminates the privileged/singular status of the build environment.
Accumulate-only data(Nov 2015, 评估)
Immutable data structures are becoming more popular, with functional languages such as Clojure and Scala providing immutability by default. Immutability allows code to be more easily written, read and reasoned about. Using an accumulate-only data store can confer some of these benefits in the database layer, as well as make audit and historical querying simple. Implementation options vary, from specific accumulative data stores such as Datomic to simply using an “append-don’t-update” approach with a traditional database. Accumulate-only is a design strategy whereby data is removed via retraction rather than update; append-only is an implementation technique.
Accumulate-only data(May 2015, 评估)
Immutable data structures are becoming more popular with functional languages such as Clojure providing immutability by default. Immutability allows code to be more easily written, read, and reasoned about. Using an append-only data store can confer some of these benefits in the database layer, as well as making audit and historical querying simple. Implementation options vary, from specific append-only data stores such as Datomic to simply using an “append-don’t-update” approach with a traditional database.
REST-assured(Nov 2015, 试验)
REST-assured is a Java domain specific language for testing and validating RESTful services. It simplifies the testing of REST based services built on top of HTTP Builder. REST-assured supports the different REST requests and can be used to validate and verify the responses from the APIs. It also provides a JSON schema validation and can thus be used to verify that the endpoints are returning the right types of expected data.
Security Monkey(Nov 2015, 评估)
Security Monkey is another tool in Netflix’s Simian Army, which is a suite of tools designed to ensure that systems are being built in a resilient fashion. As well as providing a (configurable) assessment of any potential security vulnerabilities in your AWS setup, it can also be used to monitor changes on an ongoing basis, alerting different groups as required. It does overlap in some ways with AWS’ own Trusted Advisor Report and CloudTrail service, as it was developed prior to both these services being made generally available, but its capabilities do go beyond these offerings. If either of those services don’t quite meet your requirements, Security Monkey is worth a look.
ZAP(Nov 2015, 试验)
The ZED Attack Proxy (ZAP) is a project from OWASP which allows you to probe an existing site for security vulnerabilities in an automated fashion. It can be used as part of periodic security testing, or else integrated into a CD pipeline to provide ongoing checks for common vulnerabilities. The use of a tool like ZAP doesn’t replace the need to think carefully about security and do other sorts of more thorough testing, but as another tool to help ensure our systems are more secure it’s a good addition to the toolbox.
Security sandwich(May 2015, 暂缓)
Traditional approaches to security have relied on up-front specification followed by validation at the end. This “Security Sandwich” approach is hard to integrate into Agile teams, since much of the design happens throughout the process, and it does not leverage the automation opportunities provided by continuous delivery. Organizations should look at how they can inject security practices throughout the agile development cycle. This includes: evaluating the right level of Threat Modeling to do up-front; when to classify security concerns as their own stories, acceptance criteria, or cross-cutting non-functional requirements; including automatic static and dynamic security testing into your build pipeline; and how to include deeper testing, such as penetration testing, into releases in a continuous delivery model. In much the same way that DevOps has recast how historically adversarial groups can work together, the same is happening for security and development professionals. (But despite our dislike of the Security Sandwich model, it is much better than not considering security at all, which is sadly still a common circumstance.)
Security sandwich(Jan 2015, 暂缓)
Traditional approaches to security have relied on up-front specification followed by validation at the end. This “Security Sandwich” approach is hard to integrate into Agile teams, since much of the design happens throughout the process, and it does not leverage the automation opportunities provided by continuous delivery. Organizations should look at how they can inject security practices throughout the agile development cycle. This includes: evaluating the right level of Threat Modeling to do up-front; when to classify security concerns as their own stories, acceptance criteria, or cross-cutting non-functional requirements; including automatic static and dynamic security testing into your build pipeline; and how to include deeper testing, such as penetration testing, into releases in a continuous delivery model. In much the same way that DevOps has recast how historically adversarial groups can work together, the same is happening for security and development professionals.
GitLab(May 2015, 试验)
GitLab is an on-premise Git repository hosting platform that gives proprietary software development teams the familiar and ubiquitous workflow that hosted version control services like GitHub and BitBucket provide OSS developers. While it is available as free community edition software, the commercial enterprise option provides support and deep integration with LDAP servers.
CoreOS(May 2015, 评估)
CoreOS is a Linux distribution designed to run large, scalable systems. All applications deployed on a CoreOS instance are run in separate Docker containers, and CoreOS provides a suite of tools to help manage them, including etcd their own distributed configuration store. Newer services, such as fleet, help cluster management by ensuring that a specific number of service instances are always kept running. FastPatch allows atomic CoreOS upgrades using an active-passive root partition scheme and helps with quick rollback in case of problems. These new developments make CoreOS well worth looking into if you are already comfortable with Docker.
Datensparsamkeit(May 2015, 试验)
The term Datensparsamkeit is taken from German privacy legislation and describes the idea to only store as much personal information as is absolutely required for the business or applicable laws. Customer privacy continues to be a hot topic. Companies such as Uber are apparently collecting highly personal customer data, as well as being quite lax with security. This is a disaster waiting to happen. Following datensparsamkeit or using de-identification techniques even in jurisdictions where it is not legally mandated, can allow you to reduce the information you store. If you never store the information, you do not need to worry about someone stealing it.
Datensparsamkeit(Jul 2014, 评估)
In our desire to support ever-changing business models, learn from past behavior and provide the best experience for every individual visitor, we are tempted to record as much data as possible. At the same time hackers are more ferocious than ever, with one spectacular security breach after another, and we now know of unprecedented mass-surveillance by government agencies. The term Datensparsamkeit is taken from German privacy legislation and describes the idea to only store as much personal information as is absolutely required for the business or applicable laws. Some examples are instead of storing a customer's full IP address in access logs, just using the first two or three octets and instead of logging transit journeys with a username using an anonymous token. If you never store the information, you do not need to worry about someone stealing it.
U2F(May 2015, 评估)
Securing online accounts is at the same time extremely important and notoriously difficult. Two-factor authentication does greatly increase security and we have recommended TOTP as a good solution. A new entrant in this field is Universal 2nd Factor ( U2F ), a solution based on public key cryptography and inexpensive USB hardware tokens. While developed at Google, it has now become a standard managed by the FIDO Alliance. We do like the promise of better protection against phishing and man-in-the-middle attacks, but are concerned because the standard currently references a specific elliptic curve digital signature algorithm that is considered to be flawed.
MariaDB(May 2015, 评估)
After Oracle's acquisition of MySQL, more and more close sourced modules are bundled into its enterprise edition. There are concerns over the future of MySQL. MariaDB is a community-developed GPL-only fork of MySQL intended to remain truly open source, yet fully compatible and competitive with MySQL. High-profile adopters include large-scale internet organizations Google and Wikipedia, as well as key Linux distributors RedHat and SUSE.
Ionic Framework(May 2015, 试验)
Ionic framework is an open-source front-end framework that offers a library of mobile-optimized HTML, CSS and JavaScript components and tools for building highly interactive applications. It is built with SASS and optimized for AngularJS. We have seen success in several of our projects employing this framework, with its ease to install and test. We recommend investigating this framework when you are performance obsessed and looking for a seamlessly integrated front-end framework.
Haskell Hadoop library(May 2015, 评估)
While there are lots of fans of Haskell among ThoughtWorks' language devotees, we rarely see it on the kinds of projects we work on—until recently. Several open source projects now marry Hadoop ’s map/reduce jobs to Haskell’s syntax, which some developers and/or data scientists find appealing.
SDN(May 2015, 评估)
Software Defined Networking ( SDN ) is a broad topic, but is becoming ever more important. The ability to configure our networking devices using software is blurring the lines of where our application deployments end. It encompasses everything from virtual networking appliances like AWS’ Load Balancers or CoreOS’ Flannel, to networking equipment that supports standards like OpenFlow. Where cloud providers have previously focused on compute and storage, we expect the growing array of SDN tools to deliver further efficiencies to how we handle our systems both off and on premise.
Dashing(May 2015, 试验)
The importance of big, visible displays in team areas has been written about many times before, and we certainly value the approach of helping everyone see and understand key pieces of information about how our software or our teams are doing. Dashing is a Ruby-based dashboard system we have been using for many years to create clear, visible displays optimized for large monitors. It is very hackable, allowing you to pull in information from a variety of sources from build systems, ticket or story tracking tools, or production monitoring systems.
GoCD(May 2015, 采纳)
Continuously delivering high quality software to production in a rapid and reliable manner requires coordinating many automated steps. GoCD is an open-source tool built by ThoughtWorks to handle exactly this scenario, with the concept of deployment pipelines at its core, it handles complex workflows over many nodes and enables transparent, traceable promotion of trusted artifacts across environments. While it is possible to craft deployment pipelines on top of continuous integration tools, our teams see the benefit derived from a tool purpose built for this job.
GoCD(Jul 2014, 试验)
Owing to the increasing interest in Continuous Delivery and deployment pipelines, we see many teams trying to extend their Continuous Integration tooling with plugins that provide deployment pipelines at a visual level. GoCD is a tool that was built with the concept of deployment pipelines at its core. GoCD has the ability to sequence workflows both sequentially and in parallel at many levels, to execute specific tasks only on certain machines as well as to deterministically promote and propagate artifacts, which is a key enabler for Continuous Delivery. These are capabilities that most Continuous Integration tools lack, and we recommend that teams who might have otherwise tried to build a deployment pipeline from their Continuous Integration server try GoCD instead. GoCD was built by Thoughtworks, is open-source, and is available for free for all teams. The source code is available under the Apache 2.0 license.
Nashorn(May 2015, 试验)
Nashorn is a new JavaScript engine for Java that has been released with Java 8. When the exact same code should be run in the web browser and on the server, which is often the case for validation and data migration logic, it is the tool of choice in the Java world, and that is the case despite some rough edges. We are not convinced that using Nashorn to host entire applications, via Node support or the Avatar project, is a good idea.
Origami(May 2015, 评估)
Origami is a free tool for designing user prototypes with a variety of keyboard shortcuts for common functions. It provides the possibility of exporting the prototypes as code snippets to Objective-C for iOS, Java for Android and JavaScript for Web. This tool can be used to rapidly build interactive user facing prototypes and testing user flows. We recommend investigating this tool if the use case fits from the experience we have gathered from several of our teams.
Netflix OSS Full stack(May 2015, 评估)
While we are reluctant to recommend wholesale adoption of the Netflix OSS Full Stack unless you happen to be entering the globally distributed video streaming business, the stack is chock full of interesting ideas, complete with open source implementations. Some of the tools, Asgard for example, are highly coupled into a virtually turnkey architecture, making them challenging to use individually. Other tools like Ice and Hystrix, which we featured on the radar previously, can be used stand-alone. We think teams should understand the ideas and approaches encapsulated within the tools even when they choose not to leverage the full stack.
Reagent(May 2015, 评估)
Reagent has emerged as a lightweight minimalist alternative to Om for wrapping React.js in ClojureScript. Whereas Om provides a comprehensive Clojure-idiomatic front-end programming framework, Reagent takes advantage of Clojure’s expressiveness to focus on simple components and a readable DSL for writing HTML. By representing HTML in Clojure data, Reagent retains the performance and understandability of React.js without embedding foreign markup in the code.
Blockchain beyond bitcoin(May 2015, 评估)
While the currency aspect of Bitcoin and other cryptocurrencies gets most of the news, we are equally excited about possibilities for using the Blockchain beyond bitcoin and financial transactions. The Blockchain is a mechanism for verifying the contents of a shared ledger without relying on a centralized service. We already see the Blockchain (either the underlying technology or the public Bitcoin Blockchain) being used at the heart of systems as varied as identity, ownership, record-keeping, voting, cloud storage and even managing networks of smart devices. If you are building systems that require trust over decentralized networks, then the Blockchain is a technology worth assessing.
Structured logging(May 2015, 采纳)
Treating logs as data gives us greater insight into the operational activity of the systems we build. Structured logging , which is using a consistent, predetermined message format containing semantic information, builds on this technique and enables tools such as Graylog2 and Splunk to yield deeper insights. We recommend adopting structured logging because the benefits outweigh the minimal effort involved and the practice is becoming the default standard.
Structured logging(Jul 2014, 试验)
Treating logs as data gives us greater insight into the operational activity of the systems we build. Structured logging, which is using a consistent, predetermined message format containing semantic information, builds on this technique and enables tools such as Graylog2 and Splunk to yield deeper insights.
Django REST(May 2015, 试验)
We have used the Django REST framework, which is a flexible and customizable framework that makes it easy to build web APIs, in several of our projects. It allows you to build RESTful APIs in Python with Django, exposing API endpoints which are accessible from a consumer front-end. Django REST gives a browsable web API that allows developers to visualize data being transferred through the API and returns response examples, which the consumer application will receive. It provides a number of authentication schemes out of the box, and allows implementation of custom schemes.
Xamarin(May 2015, 试验)
We are excited by the progress made by Xamarin in offering a solid choice for building cross-platform mobile apps. It supports C# and F# as the primary languages with bindings to platform specific SDKs and the Mono runtime environment that works across iOS, Android and Windows Phone. Applications are compiled to native code giving apps a more native look and feel. When using this toolset, it is imperative that the platform specific UI tier be separated from the rest of the tiers to ensure code reuse across different platforms. The recent open-sourcing of the .NET platform should be beneficial for Xamarin both in allowing access to a broader set of .NET tooling and also making development easier on other operating systems.
Xamarin(Jul 2014, 评估)
Among the various choices available for building cross-platform mobile apps, Xamarin offers a fairly unique toolset. It supports C# and F# as the primary language with bindings to platform-specific SDKs and the Mono runtime environment that works across iOS, Android and Windows Phone. Applications are compiled to native code instead of the typical cross-platform approach that renders HTML-based UI in an embedded browser. This gives apps a more native look and feel. When using this toolset, it is imperative that the platform-specific UI tier be separated from the rest of the tiers to ensure code reuse across different platforms. The application binary tends to be a bit bigger due to the runtime environment that is included.
Lotus(May 2015, 评估)
We don’t know who named Lotus, but we can only assume they are too young to have worked with a certain office collaboration product. Lotus is a new Rack-based MVC framework written in Ruby that can be deployed modularly so that you are free to use only the portions of the framework you need. It is a modern alternative to the monolithic Ruby-on-Rails framework (that turned 10 this year). Lotus has the potential to make full-stack Ruby MVC development as easy as 1-2-3.
Jackrabbit Oak(May 2015, 评估)
Jackrabbit Oak, formerly named Jackrabbit 3, is a scalable and performant implementation of hierarchical content repository for use as the foundation of content management system. In addition to file based storage solution, MongoDB and RDMS storage are also supported, and preferred in large volume use scenarios. Although implemented in Java, it can be easily accessed from various platforms via standards like JCR.
DigitalOcean(May 2015, 试验)
We have been using DigitalOcean for basic compute infrastructure, and the service continues to impress us. If you need developer-friendly cloud infrastructure, it is worth a look.
DigitalOcean(Jul 2014, 评估)
Although the IaaS space is crowded, there is room for new competitors to enter the market. DigitalOcean has impressed us recently with its cost, speed and simplicity. If all you need is basic compute infrastructure, it is well worth a look.
Packetbeat(May 2015, 评估)
As distributed systems become more complex, it can be useful to have tools that help you understand how your system is behaving in production. Packetbeat is an open source tool which uses agents to sniff traffic between nodes, allowing you to see traffic patterns, error rates and other useful information. It requires Elasticsearch and Kibana to work, but if you are already using these tools as part of log aggregation, it could be an easy drop-in to give you more insight into your production system.
OpenAM(May 2015, 评估)
When Oracle ceased development on Sun’s OpenSSO—an open source access management platform—It was picked up by ForgeRock and integrated into their Open Identity Suite. Now named OpenAM, it fills the niche for a scalable, open-source platform that supports OpenID Connect and SAML 2.0. However, OpenAM’s long history has resulted in a sprawling codebase whose documentation can be inscrutable. Hopefully, a slimmed-down alternative with better support for automated deployment and provisioning will emerge soon.
OpenAM(Jan 2015, 评估)
When Oracle ceased development on Sun’s OpenSSO—an open source access management platform—It was picked up by ForgeRock and integrated into their Open Identity Suite.  Now named OpenAM, it fills the niche for a scalable, open-source platform that supports a variety of federated identity standards, including OpenID Connect and SAML 2.0.  These standards are a necessary enabler for secure microservice implementations.
Swagger(May 2015, 试验)
Swagger2.0 is a standard way to describe a RESTful API so that human-readable documentation and client examples can be generated automatically. The update to version 2.0 provides some significant flexibility enhancements and the list of tools for generating documentation continues to expand. There are also several alternatives to Swagger emerging from the vendor community, most significantly RAML and API Blueprint.
Swagger(Jul 2014, 评估)
Swagger is a standard way to describe a RESTful API so that documentation and client examples can be generated automatically. We think there's a need for some standards in this area and hope that this approach embraces Postel's law and avoids the tight-coupling and inflexibility of standards like WSDL. A number of tools are now available to render documentation and client pages from swagger-compliant descriptions.
OSGi(May 2015, 暂缓)
OSGi (Open Service Gateway initiative) is a specification that aims to remedy the lack of a module system for Java, allowing for dynamic reloading of components. While some projects (notably Eclipse) use OSGi successfully, other uses have exposed the hazards of adding abstractions to platforms never designed for them. Projects that rely on OSGi to define a component system quickly realize that it solves only a small part of the overall problem, and often adds its own accidental complexity to projects such as more complex builds. Most projects now either use old-fashioned JAR files or microservice architectures to manage components, and await the native solution in Java in the Jigsaw module specification.
Retrofit(May 2015, 试验)
Retrofit offers a reliable way to build HTTP clients on Android projects by converting a REST API into a Java interface. Retrofit integrates with OkHttp and allows developers to provide custom error handling for requests. It does JSON parsing automatically using Gson and has a very well supported community.
Local storage sync(May 2015, 试验)
When implementing single-page applications, sooner or later the question of offline use will come up. Given how hard it is to get this right when retrofitting an offline mode into an existing application, there is a trend towards implementing single-page applications with an “offline-first” mindset. An important implementation technique that we have used successfully is local storage sync. With this technique, the user facing code never makes requests to the backend. It retrieves data solely from local storage. A background worker synchronises the data in local storage with the backend systems, usually employing calls to some form of REST API.
Git based CMS/Git for non-code(May 2015, 评估)
These days, most software developers are used to working with Git for source code control and collaboration. But Git can be used as a base mechanism for other circumstances where a group of people need to collaborate on textual documents (that can easily be merged). We’ve seen increasing amounts of projects use Git as the basis for a lightweight CMS , with text-based editing formats. Git has powerful features for tracking changes and exploring alternatives, with a distributed storage model that is fast in use and tolerant of networking issues. The biggest problem with wider adoption is that Git isn’t very easy to learn for non-programmers, but we expect to see more tools that build on top of the core Git plumbing. Such tools simplify the workflow for specific audiences, such as content authors. We would also welcome more tools to support diffing and merging for non-textual documents.
NaCl(May 2015, 评估)
The NaCl library (pronounced 'Salt') provides a set of features for encryption, decryption, and signatures designed to make it easier to implement secure network communication or other cryptography requirements. Although these functions exist in other libraries, NaCl promises higher speed and easier to use APIs. Current support is for C and C++ with Python wrappers in progress.
Text it as a service / Rapidpro.io(May 2015, 评估)
Text-it-as-a-service / Rapidpro offers ability to easily set up or modify complex short message service application for business without extensive need of a developer. With the lower costs of text messages compared to USSD sessions, this provides a more affordable way to build scalable applications targeting feature phones and we have seen success in our projects. Flows are very simple to build and actions can be triggered at any point such as sending an sms, email or even calling an external api.
Cursive(May 2015, 试验)
Cursive is a Clojure IDE that works as a plugin for IntelliJ. While still in early access, we have found it very useful when working with larger Clojure codebases. Cursive provides strong renaming and navigation support, has shown itself to be stable and reliable, and is great for environments with mixed JVM languages. For organizations adopting Clojure, Cursive has helped lower the barrier to entry for existing developers.
JSF(May 2015, 暂缓)
We continue to see teams run into trouble using JSF - JavaServer Faces - and are recommending you avoid this technology. Teams seem to choose JSF because it is a Java EE standard without really evaluating whether the programming model suits them. We think JSF is flawed because its programming model encourages use of its own abstractions rather than fully embracing the underlying web model. JSF, like ASP.NET webforms, attempts to create stateful component trees on top HTML markup and the stateless HTTP protocol. The improvements in JSF 2.0 and 2.2, such as the introduction of stateless views and the promotion of GET, are steps in the right direction, maybe even an acknowledgement that the original model was flawed, but we feel this is a too little too late. Rather than dealing with the complexity of JSF we recommend teams use simple frameworks and work closely with web technologies including HTTP, HTML and CSS.
JSF(Jul 2014, 暂缓)
We continue to see teams run into trouble using JSF - JavaServer Faces - and are recommending you avoid this technology. Teams seem to choose JSF because it is a Java EE standard without really evaluating whether the programming model suits them. We think JSF is flawed because its programming model encourages use of its own abstractions rather than fully embracing the underlying web model. JSF, like ASP.NET webforms, attempts to create stateful component trees on top HTML markup and the stateless HTTP protocol. The improvements in JSF 2.0 and 2.2, such as the introduction of stateless views and the promotion of GET, are steps in the right direction, maybe even an acknowledgement that the original model was flawed, but we feel this is a too little too late. Rather than dealing with the complexity of JSF we recommend teams use simple frameworks and work closely with web technologies including HTTP, HTML and CSS.
Blackbox(May 2015, 评估)
Blackbox is a simple tool for encrypting specific files while at rest in your source repository. This is particularly useful if you need to store passwords or private keys. Blackbox works with Git, Mercurial and Subversion and uses GPG for the encryption. Each user has their own key, which makes it easy to revoke access on a granular level. There is a lot happening in this space and a few other players to consider including git-crypt and Trousseau.
Blackbox(Jan 2015, 评估)
Blackbox is a simple tool for encrypting specific files while at rest in your source repository. This is particularly useful if you need to store passwords or private keys. Blackbox works with Git, Mercurial and Subversion and uses GPG for the encryption.  Each user has their own key, which makes it easy to revoke access on a granular level.
Canary builds(May 2015, 试验)
Many projects have external code dependencies, a large amount of which is provided by open source projects. In order to ensure our builds are reproducible, we integrate against known versions of them, but that can mean that it takes a while for us to integrate against newer versions of these libraries leading to a larger merge effort down the line. One approach we have seen to avoid this is to have a nightly Canary Build which tries to pull in the latest version of all dependencies. If the build is green, we know we can change which versions we depend on.
pdfmake(May 2015, 评估)
pdfmake is a JavaScript library which allows for creation and printing of PDF documents directly in the browser. To use pdfmake you construct a document object that supports structural elements such as tables, columns, and rich styling, then helper methods can create and print or download a PDF without leaving client-side JavaScript.
Boot2docker(May 2015, 试验)
Boot2docker is a lightweight linux distribution running Docker, packaged as a VM for OSX and Windows. This is a great way to get started experimenting with Docker. For teams using microservices, it can also be an effective way to run multiple services on a local machine for dev and test purposes, where the overhead of multiple vagrant VMs may be too much.
Om(May 2015, 试验)
We have seen continued interest in Om , a ClojureScript wrapper around Facebook's ReactJS front-end programming framework. Om leverages the inherent immutability of ClojureScript, allowing automatic features like snapshots of UI state and undo. And due to the efficiency of ClojureScript's data structures, some Om applications run faster than identical ones based on the raw underlying React framework. The ecosystem of components and applications around Om is growing and our teams are starting to pick it up.
Om(Jul 2014, 评估)
Adopting the entire Clojure stack (the Clojure and ClojureScript languages, and optionally the Datomic database) offers some advantages like immutable data structures from user interface to backend. Several frameworks have appeared in the Clojure space to leverage its unique features, but the most promising so far is Om. Om is a ClojureScript wrapper around Facebook's React JavaScript reactive programming framework. Yet Om leverages the inherent immutability of ClojureScript, allowing automatic features like snapshots of UI state and undo. And due to the efficiency of ClojureScript's data structures, some Om applications run faster than identical ones based on the raw underlying React framework. We expect significant evolution and innovation to continue around Om.
Flight.js(May 2015, 评估)
In the crowded space of JavaScript frameworks, we want to highlight Flight.js as a lightweight framework to build components. Flight gets by without much magic when adding behavior to DOM nodes. Its event-driven and component-based nature promotes writing decoupled code. This makes testing individual components comparatively easy. Care must be taken, however, when components need to interact with each other. There is little support for testing and a real danger to get into event hell. We do like that it uses functional mixins for behavior, like composition instead of inheritance.
Flight.js(Jan 2015, 评估)
In the crowded space of JavaScript frameworks, we want to highlight Flight.js as an alternative to consider. Flight is extremely lightweight and gets by without much magic when adding behavior to DOM nodes. Its event-driven and component-based nature promotes writing decoupled code. This makes testing individual components comparatively easy. Care must be taken, however, when components need to interact with each other.  There is little support for testing and a real danger to get into event hell. We do like that it uses functional mixins for behaviour, like composition instead of inheritance.
Focus on mean time to recovery(May 2015, 采纳)
Traditionally operations groups look to improve the mean time between failures. While avoiding failures is obviously still important, lessons from cloud computing have taught us to expect failure and instead to focus on mean time to recovery. Continuous Delivery automation makes rolling out rapid fixes easier and we are also seeing a growth in monitoring techniques to spot failures quickly through a ‘production immune system’. Teams are also successfully using semantic monitoring and synthetic transactions to exercise production systems in non-destructive ways. This combined focus allows teams to move rapidly with higher confidence, it can also reduce the emphasis on expensive test-execution in pre-production environments and is particularly important in responding to the ever-growing list of security vulnerabilities that are being discovered.
Focus on mean time to recovery(Jul 2014, 试验)
In DevOps-savvy organizations delivery teams often configure production monitoring and respond to incidents themselves. This visibility and access into production environments allows those teams to make changes to their systems to improve their ability to recover quickly when something goes wrong. This focus on mean time to recovery improves quality of service overall, and allows teams to safely deploy more frequently. This can also reduce the emphasis on expensive test execution in non-production environments. Techniques we've used include end-to-end 'semantic monitoring' or reconciliation of real business transactions, and the injection of 'synthetic transactions' which exercise systems in non-destructive ways in production.
Focus on mean time to recovery(Jan 2014, 评估)
In previous radars we recommended arranging automated acceptance tests into longer journeys and, in what we call semantic monitoring, running these tests continuously against a production environment. We still believe that this is an important technique for scenarios the team can anticipate in advance. A variation of this approach, seen especially with startups, is to reduce the number of tests while increasing  monitoring and automatic alarms.  This shifts the focus from avoiding problems that can be anticipated to reducing mean time to recovery for all problems.
Roslyn(Jan 2015, 评估)
Roslyn, a .NET compiler platform under the Apache License 2.0, is a next-generation set of compilers for C# and VB.NET written entirely as managed code. It provides access to the compiler as a service and includes code analysis APIs allowing developers to access information from the compiler that was previously treated as a black box, for example syntactic and semantic models. The most immediate impact should be seen in enhancements to .NET IDEs through refactoring and code generation tools. We also expect to see improved code diagnostics and static analysis, although it will be interesting to see what the community comes up with. Meanwhile Xamarin has a Mono-compatible copy of Roslyn source code hosted on GitHub and plans to bundle Roslyn’s compilers with Mono as it stabilizes, in addition to integrating the best parts into their code base.
Roslyn(Jul 2014, 评估)
Roslyn, a .NET compiler platform under the Apache License 2.0, is a next-generation set of compilers for C# and VB.NET written entirely as managed code. It provides access to the compiler as a service and includes code analysis APIs allowing developers to access information from the compiler that was previously treated as a black box, for example syntactic and semantic models. The most immediate impact should be seen in enhancements to .NET IDEs through refactoring and code generation tools. We also expect to see improved code diagnostics and static analysis, although it will be interesting to see what the community comes up with. Meanwhile Xamarin has a Mono-compatible copy of Roslyn source code hosted on GitHub and plans to bundle Roslyn’s compilers with Mono as it stabilizes, in addition to integrating the best parts into their code base.
Java 8(Jan 2015, 采纳)
The team behind Java 8 had to fight two battles: the community forces encouraging forever backwards compatibility (a long hallmark of Java) and the technical challenge of making a deep language change mesh with existing libraries and features. They succeeded on both fronts, breathing new life into the Java Language and placing it on par with other mainstream languages in terms of functional programming features. In particular, Java 8 has excellent syntactic magic that allows seamless interoperability between Lambda blocks, the new higher-order function feature, and SAM (Single Abstract Method) interfaces, the traditional way of passing behavior.
Java 8(Jul 2014, 采纳)
The team behind Java 8 had to fight two battles: the community forces encouraging forever backwards compatibility (a long hallmark of Java) and the technical challenge of making a deep language change mesh with existing libraries and features. They succeeded on both fronts, breathing new life into the Java Language and placing it on par with other mainstream languages in terms of functional programming features. In particular, Java 8 has excellent syntactic magic that allows seamless interoperability between Lambda blocks, the new higher-order function feature, and SAM (Single Abstract Method) interfaces, the traditional way of passing behavior.
Snowplow Analytics & Piwik(Jan 2015, 试验)
With increasing scrutiny over the privacy of data, more companies are concerned about sharing web analytics with third parties. Snowplow Analytics and Piwik are examples of open-source analytics platforms that can be self-hosted and provide a promising feature set and roadmap.
Snowplow Analytics & Piwik(Jul 2014, 试验)
With increasing scrutiny over the privacy of data, more companies are concerned about sharing web analytics with third parties. Snowplow Analytics and Piwik are examples of open-source analytics platforms that can be self-hosted and provide a promising feature set and roadmap.
Snowplow Analytics & Piwik(May 2013, 评估)
We see great promise in Snowplow Analytics, an open source web analytics platform that derives intelligent information from regular web analytics, based on open data principles and cloud Storage.
Flyway(Jan 2015, 采纳)
With techniques such as continuous delivery becoming more mainstream, automated database migrations are a baseline capability for many software teams. While there are many tools in this space, we continue to recommend Flyway for its low-friction approach. Flyway has a vibrant open-source community behind it, and support for both traditional and cloud-based databases such as Amazon Redshift and Google Cloud SQL.
Flyway(Jul 2014, 试验)
Automated database migrations are common on agile projects, and we are happy to see advances in the tools for this space. Flyway makes it as painless as possible to automate changes to databases. While not as feature-rich as some competing tools, we have used it on multiple projects and appreciate its low friction.
Partition infrastructure along team bounds(Jan 2015, 试验)
Many of our customers have made DevOps a reality in their organization with delivery teams that build, deploy, and support their own applications and services.  Unfortunately, a regular roadblock on that journey is allowing teams to have superuser privileges in production environments.  In most organizations, the production environment is shared, and therefore risky to provide access widely.  It is effective when we can partition infrastructure along team bounds, so that those teams can have safe isolated access to do their work, without risking impact to other systems.  Where cloud environments are used, this is much easier to implement, aligning account structures to team boundaries.
Go language(Jan 2015, 采纳)
The Go language gradually changed status from "Just Another Language" to a valuable tool in many projects. While steadfastly single paradigm in a world of increasingly complex languages, it seems to keep a nice balance between expressiveness, power, and simplicity.
Go language(Jul 2014, 采纳)
The Go language gradually changed status from "Just Another Language" to a valuable tool in many projects. While steadfastly single paradigm in a world of increasingly complex languages, it seems to keep a nice balance between expressiveness, power, and simplicity.
Go language(Jan 2014, 试验)
The Go language was originally developed by Google as a system programming language to replace C & C++. Four years out, Go is gaining traction in other areas. The combination of very small, statically linked binaries combined with an excellent HTTP library means Go has been popular with organizations making use of finer-grained, microservice architectures.
Papertrail(Jan 2015, 试验)
In the previous radar, we mentioned the log aggregation service Papertrail as a way to collect and analyze logs from a variety of sources including web servers, routers, databases and PaaS services. Our subsequent experiences using it and the integrations from PaaS providers such as Heroku nudge it into something we would happily recommend as a convenient and expedient option, notwithstanding our concerns about widespread adoption of services that centralize large quantities of data aggregated from multiple parties.
Papertrail(Jul 2014, 评估)
Papertrail is a log aggregation service that aggregates data from a variety of sources including web-servers, routers, databases and PaaS services. In addition to aggregation it provides search, filtering, and alerts and notifications out of the box. While undeniably convenient and expedient in many cases, we remain concerned about widespread adoption of services that centralize large quantities of data aggregated from multiple parties.
R as Compute Platform(Jan 2015, 试验)
R is traditionally used as stand alone analysis tool by research teams. With improvements in packages like Rook and RJSONIO, it has become trivial to wrap the computational logic and expose it as an API. Thoughtworks teams are using R as Compute platform to crunch large datasets in real time, using in-memory storage integrated with enterprise systems.
R as Compute Platform(Jul 2014, 试验)
R is traditionally used as stand alone analysis tool by research teams. With improvements in packages like Rook and RJSONIO, it has become trivial to wrap the computational logic and expose it as an API. Thoughtworks teams are using R as Compute platform to crunch large datasets in real time, using in-memory storage integrated with enterprise systems.
HAL(Jan 2015, 试验)
We see lots of teams creating RESTful interfaces without paying any attention to hypermedia. HAL is a simple format for incorporating hyperlinks into JSON representations which is easy to implement and consume. HAL is well supported by libraries for parsing and representing JSON, and there are HAL-aware REST client libraries such as Hyperclient which make it easy to navigate resources by following links.
HAL(Jul 2014, 试验)
We see lots of teams creating RESTful interfaces without paying any attention to hypermedia. HAL is a simple format for incorporating hyperlinks into JSON representations which is easy to implement and consume. HAL is well supported by libraries for parsing and representing JSON, and there are HAL-aware REST client libraries such as Hyperclient which make it easy to navigate resources by following links.
Humane registry(Jan 2015, 试验)
A Microservice architecture by its very nature increases significantly the number of applications, services, and interactions in your deployed environments. Our projects are showing renewed focus on building Humane Registries which aggregate information about running services from the live environment and present it in a form for humans to comprehend. These registries favor up-to-date information from running services instead of human-curated documentation.
Humane registry(Jul 2014, 试验)
A Microservice architecture by its very nature increases significantly the number of applications, services, and interactions in your deployed environments. Our projects are showing renewed focus on building Humane Registries which aggregate information about running services from the live environment and present it in a form for humans to comprehend. These registries favor up-to-date information from running services instead of human-curated documentation.
GenyMotion(Jan 2015, 试验)
Device fragmentation in the Android world is often cited as a problem because it can be difficult to understand how your applications will behave on a large number of disparate platforms. GenyMotion is an emulator which can mimic the characteristics of a number of different Android devices. Our teams have found this very effective in giving fast feedback for our Android applications.
GenyMotion(Jul 2014, 试验)
Device fragmentation in the Android world is often cited as a problem because it can be difficult to understand how your applications will behave on a large number of disparate platforms. GenyMotion is an emulator which can mimic the characteristics of a number of different Android devices. Our teams have found this very effective in giving fast feedback for our Android applications.
Testing as a separate organization(Jan 2015, 暂缓)
We continue to see organizations create separate Development and QA teams. Fast feedback is a core tenet of Agile and critical to the success of a project. Using a separate QA team slows down this feedback, creates an "us and them" mentality and makes it more difficult to build quality into the software. Testing should be a tightly integrated activity and isn't something the team can outsource. We recommend integrated teams where testers work closely with developers instead of having testing as a separate organization.
Testing as a separate organization(Jul 2014, 暂缓)
We continue to see organizations create separate Development and QA teams. Fast feedback is a core tenet of Agile and critical to the success of a project. Using a separate QA team slows down this feedback, creates an "us and them" mentality and makes it more difficult to build quality into the software. Testing should be a tightly integrated activity and isn't something the team can outsource. We recommend integrated teams where testers work closely with developers instead of having testing as a separate organization.
Hipster batch(Jan 2015, 试验)
There has been a lot of recent attention to the use of ATOM-style event feeds over HTTP as a method of integration.  Instead of maintaining a live service to expose those feeds, it is often acceptable to use old-style scheduled batch processing to create and publish feed files.  When combined with cloud technology like Amazon's S3 file storage and hypermedia linking, this can create a highly available, yet simple and testable solution.  Our teams have started to call this old-meets-new approach 'Hipster batch'.
Grunt.js(Jan 2015, 试验)
Grunt is rapidly becoming the de facto JavaScript build tool with high adoption and a growing ecosystem. While slower than newer alternatives, such as Gulp, in terms of file processing, Grunt covers a broader set of build-related activities, has a proliferation of plugins and makes it easy to author and publish self-written plugins to npm.
Grunt.js(Jul 2014, 试验)
We have seen a growth in the Grunt ecosystem and it is currently being used in several of our projects. With the proliferation of plugins and the ease to author and publish self-written plugins to npm, automation using Grunt can be done with little effort. We suggest choosing a task runner that best meets the needs of the project and Grunt is one of the task runners you should consider.
Grunt.js(Jan 2014, 试验)
Several of our Thoughtworks teams developing Node.js apps are using Grunt to automate most of the development activities like minification, compilation, and linting. Many of the common tasks are available as Grunt plugins. You can even programmatically generate the configuration if necessary.
EventStore(Jan 2015, 评估)
Given the popularity of event sourcing, it is no surprise that tools in this space are maturing. EventStore is an open source functional database for storing immutable events and performing complex event processing on the event streams. Unlike other tools in this space, EventStore exposes event streams as Atom collections which therefore require no special infrastructure such as message buses or highly specialized clients to use.
EventStore(Jul 2014, 评估)
Given the popularity of event sourcing, it is no surprise that tools in this space are maturing. EventStore is an open source functional database for storing immutable events and performing complex event processing on the event streams. Unlike other tools in this space, EventStore exposes event streams as Atom collections which therefore require no special infrastructure such as message buses or highly specialized clients to use.
Mapbox(Jan 2015, 评估)
Mapbox is an open mapping platform we have used on several projects. It allows a developer to quickly add a map to an application and to style the map. Mapbox can serve as an alternative to conventional mapping platforms, and it also allows for mobile friendly maps.
Mapbox(Jul 2014, 评估)
Mapbox is an open mapping platform we have used on several projects. It allows a developer to quickly add a map to an application and to style the map. Mapbox can serve as an alternative to conventional mapping platforms, and it also allows for mobile friendly maps.
Living CSS Style Guides(Jan 2015, 试验)
A living CSS style guide is a page on your site that uses your current CSS styles and acts as a reference for all the currently available visual elements and design patterns. This helps to tightly integrate design into your delivery process by promoting co-ownership of the UI and avoids duplication of styling across your application. Styling changes are visible in the guide immediately and changes propagate across your site from a central location. A sensible way to do this is with a well organized SASS/LESS file structure with semantically named elements that separates structure, aesthetics, and interaction.
Living CSS Style Guides(Jul 2014, 试验)
A living CSS style guide is a page on your site that uses your current CSS styles and acts as a reference for all the currently available visual elements and design patterns. This helps to tightly integrate design into your delivery process by promoting co-ownership of the UI and avoids duplication of styling across your application. Styling changes are visible in the guide immediately and changes propagate across your site from a central location. A sensible way to do this is with a well organized SASS/LESS file structure with semantically named elements that separates structure, aesthetics, and interaction.
Forward Secrecy(Jan 2015, 采纳)
Forward Secrecy (sometimes known as 'Perfect Forward Secrecy' or PFS) is a cryptographic technique that protects previous communications sessions even if a server’s master keys are later compromised. Despite being simple to enable for HTTPS connections, many servers are not configured this way, and we recommend enabling forward secrecy to improve security. Note that we don't generally like the word 'perfect' when used to describe cryptographic protocols -- even the best protocol can be broken by a flaw in implementation, random number generator, or by advances in cryptanalytic techniques. Even so, it is important to enable the best security available, while keeping informed of new attacks and protocol improvements.
Forward Secrecy(Jul 2014, 采纳)
Forward Secrecy (sometimes known as "Perfect Forward Secrecy" or PFS) is a cryptographic technique that protects previous communications sessions even if a server’s master keys are later compromised. Despite being simple to enable for HTTPS connections, many servers are not configured this way, and we recommend enabling forward secrecy to improve security. Note that we don't generally like the word "perfect" when used to describe cryptographic protocols - even the best protocol can be broken by a flaw in implementation, random number generator, or by advances in cryptanalytic techniques. Even so, it's important to enable the best security available, whilst keeping informed of new attacks and protocol improvements.
SnapCI(Jan 2015, 试验)
We mentioned Thoughtworks' SnapCI -- a hosted service that provides deployment pipelines -- on the last edition of the Radar. Since then, we have seen many teams successfully use SnapCI on their projects. If you need a simple continuous delivery solution in the cloud, SnapCI can provide it with one click. No hardware, no hassle.
SnapCI(Jul 2014, 试验)
We mentioned Thoughtworks' SnapCI - a hosted service that provides deployment pipelines - on the last edition of the Radar. Since then, we have seen many teams successfully use SnapCI on their projects. If you need a simple continuous delivery solution in the cloud, SnapCI can provide it with one click. No hardware, no hassle.
Gulp(Jan 2015, 评估)
In the last radar we called out Gulp as a strong competitor to Grunt, with a clean API and fast builds thanks to its streaming approach. While we still like it as a tool, we are moving it out from trial back to assess since Grunt has both a broader usage model and better industry adoption and tooling. We do see some teams successfully using Gulp inside Grunt, when the speed of intermediate result caching is required, but we are not recommending it as the default JavaScript build tool.
Gulp(Jul 2014, 试验)
Gulp is an alternative to Grunt. It is a command-line task automation tool that helps developers with SaaS compilation, autoprefixing, minification, concatenation and so on. Gulp's central idea is the use of streams, and its plugins are designed to do only one task.
CoAP(Jan 2015, 评估)
CoAP is an open standards communication protocol for the Internet of Things (IoT). While there is currently a proliferation of competing standards in the IoT space, we particularly like CoAP. It is specifically designed for resource-constrained devices and local radio networks. It uses UDP for transport, but is semantically compatible with HTTP. CoAP uses a web-based model of devices with their own URLs and a request-response paradigm that supports RESTful and decentralized approaches.
CoAP(Jul 2014, 评估)
CoAP is an open standards communication protocol for the Internet of Things (IoT). While there is currently a proliferation of competing standards in the IoT space, we particularly like CoAP. It is specifically designed for resource-constrained devices and local radio networks. It uses UDP for transport, but is semantically compatible with HTTP. CoAP uses a web-based model of devices with their own URLs and a request-response paradigm that supports RESTful and decentralized approaches.
Pact & Pacto(Jan 2015, 试验)
Consumer-Driven Contracts are a testing approach to help service interfaces evolve with confidence without unknowingly breaking consumers. The similarly named Pact and Pacto are two new open-source tools which allow testing interactions between service providers and consumers in isolation against a contract. Both have grown out of projects which are building RESTful microservices and show great promise.
Pact & Pacto(Jul 2014, 试验)
Consumer-Driven Contracts are a testing approach to help service interfaces evolve with confidence without unknowingly breaking consumers. The similarly named Pact and Pacto are two new open-source tools which allow testing interactions between service providers and consumers in isolation against a contract. Both have grown out of projects which are building RESTful microservices and show great promise.
ARM Server SoC(Jan 2015, 评估)
AMD recently released an 8-core ARM SoC (System on a Chip) designed for servers and has committed to releasing an ARM SoC with integrated graphics in 2015. ARM-based servers are an interesting alternative to x86 because they are significantly more energy efficient. For some workloads, building an ARM-powered Cloud is preferable.
ARM Server SoC(Jul 2014, 评估)
AMD recently released an 8-core ARM SoC (System on a Chip) designed for servers and has committed to releasing an ARM SoC with integrated graphics in 2015. ARM-based servers are an interesting alternative to x86 because they are significantly more energy efficient. For some workloads, building an ARM-powered Cloud is preferable.
Machine image pipelines(Jan 2015, 评估)
Many deployments requires machine images for different server roles like applications and services, databases, and reverse proxies. Because building a machine image from scratch, using an operating system ISO and provisioning scripts, can take a considerable amount of time it can be useful to create a build pipeline for machine images. The first stage in the pipeline sets up a base image according to general standards in the organization. Subsequent stages can then enhance the base image for different purposes. If several applications or services have similar requirements, an application server for example, the pipeline can be extended by an intermediate stage, which takes the base image and provides an image with an application server but no application/service. These pipelines are not linear, they are trees that are branching out from the base image.
Machine image pipelines(Jul 2014, 评估)
Many deployments require machine images for different server roles like applications and services, databases, and reverse proxies. Because building a machine image from scratch, using an operating system ISO and provisioning scripts, can take a considerable amount of time it can be useful to create a build pipeline for machine images. The first stage in the pipeline sets up a base image according to general standards in the organization. Subsequent stages can then enhance the base image for different purposes. If several applications or services have similar requirements, an application server for example, the pipeline can be extended by an intermediate stage, which takes the base image and provides an image with an application server but no application/service. These pipelines are not linear, they are trees that are branching out from the base image.
leaflet.js(Jan 2015, 评估)
Leaflet.js is a JavaScript library for mobile-friendly interactive maps. The library places a huge emphasis on performance, usability and simplicity, and as such works efficiently across mobile platforms and desktop browsers. It is a viable library to consider when building interactive maps for mobiles.
leaflet.js(Jul 2014, 评估)
Leaflet.js is a JavaScript library for mobile-friendly interactive maps. The library places a huge emphasis on performance, usability and simplicity, and as such works efficiently across mobile platforms and desktop browsers. It is a viable library to consider when building interactive maps for mobiles.
OpenID Connect(Jan 2015, 评估)
OpenID Connect is a standard protocol for federated identity built on OAuth 2.0. It addresses a long-standing need for a simple, web-based protocol to exchange trusted authentication and authorization information. Previous standards like SAML or generic OAuth 2.0 have proven too broad and complex to ensure universal compatibility. Our hope is that OpenID Connect can provide a useful basis for secure access to RESTful microservices with authenticated end-user identity.
OpenID Connect(Jul 2014, 评估)
OpenID Connect is a standard protocol for federated identity built on OAuth 2.0. It addresses a long-standing need for a simple, web-based protocol to exchange trusted authentication and authorization information. Previous standards like SAML or generic OAuth 2.0 have proven too broad and complex to ensure universal compatibility. Our hope is that OpenID Connect can provide a useful basis for secure access to RESTful microservices with authenticated end-user identity.
Static site generators(Jan 2015, 试验)
Static site generators like Middleman or Jekyll have become popular for creating simple websites or blogs, but we are increasingly seeing their use as part of more complex application stacks. The default assumption that all content delivered over HTTP has to be dynamically created on request is shifting, with more teams looking to use static pre-generated content.
Front end instrumentation(Jan 2015, 试验)
With the proliferation of complex JavaScript websites and applications, we are finding that browser-side issues such as slow network calls, poor render times, and JavaScript errors can have a big impact on user experience. Server-side monitoring clearly does not help in these scenarios and often these types of issues are being missed. Front end instrumentation extends the types of monitoring we are used to with server-side code to the browser, allowing for early warning of potential issues and far easier diagnosis should production issues occur.
Front end instrumentation(Jul 2014, 试验)
With the proliferation of single-page JavaScript applications, we have found that slow Ajax calls, excessive DOM manipulation, and unexpected JavaScript errors in the browser can have a big impact on perceived website responsiveness. It is very useful to collect and aggregate this profiling information from real end-users' browsers. Real user monitoring provides early warning and diagnosis of production issues, and helps pinpoint them to a specific locality.
REST without PUT(Jan 2015, 试验)
In the last radar we talked about Capturing Explicit Domain Events, putting emphasis on recording the business-meaningful events that have triggered state transitions instead of just CRUD'ing entities. REST interfaces commonly use PUT to update resource state, however it's often better to POST to record a new event resource which captures intent. REST without PUT has a side-benefit of separating command and query interfaces and forces consumers to allow for eventual consistency.
REST without PUT(Jul 2014, 试验)
In the last radar we talked about Capturing Explicit Domain Events, putting emphasis on recording the business-meaningful events that have triggered state transitions instead of just CRUD'ing entities. REST interfaces commonly use PUT to update resource state, however it's often better to POST to record a new event resource which captures intent. REST without PUT has a side-benefit of separating command and query interfaces and forces consumers to allow for eventual consistency.
Core Async(Jan 2015, 试验)
The Clojure core.async library allows asynchronous communication using channels, with similar syntax and capabilities to Google's Go language. The core.async library solves many common problems in an elegant way, cleaning up event callback setup and adding simple concurrency primitives. It also highlights one of the advantages of the Lisp nature of Clojure: channels add operators that are consistent with existing Clojure operators, seamlessly weaving new functionality into the language core. In addition, core.async is supported in both Clojure and ClojureScript (despite JavaScript's lack of threads), utilizing underlying platform abstractions to provide a consistent interface to both languages.
Core Async(Jul 2014, 试验)
The Clojure core.async library allows asynchronous communication using channels, with similar syntax and capabilities to Google's Go language. The core.async library solves many common problems in an elegant way, cleaning up event callback setup and adding simple concurrency primitives. It also highlights one of the advantages of the Lisp nature of Clojure: channels add operators that are consistent with existing Clojure operators, seamlessly weaving new functionality into the language core. In addition, core.async is supported in both Clojure and ClojureScript (despite JavaScript's lack of threads), utilizing underlying platform abstractions to provide a consistent interface to both languages.
Velocity as productivity(Jan 2015, 暂缓)
We continue to see teams and organizations equating velocity with productivity. When properly used, velocity allows the incorporation of \\”yesterday's weather\\” into a team’s internal iteration planning process. The key here is that velocity is an internal measure for a team, it is just a capacity estimate for that given team at that given time. Organizations and managers who equate internal velocity with external productivity start to set targets for velocity, forgetting that what actually matters is working software in production. Treating velocity as productivity leads to unproductive team behaviors that optimize this metric at the expense of actual working software.
Velocity as productivity(Jul 2014, 暂缓)
Of all the approaches that we might disagree with, equating velocity with productivity has become so prevalent that we felt it important to call it out in our hold ring. When properly used, velocity allows the incorporation of "yesterday's weather" into the iteration planning process. Velocity is simply a capacity estimate for a given team at a given time. It can improve as a team gels or by fixing problems like technical debt or a flaky build server. However, like all metrics, it can be misused. For example, over-zealous project managers attempt to insist on continual improvement of velocity. Treating velocity as productivity leads to unproductive team behaviors that optimize the metric at the expense of actual working software.
Dc.js(Jan 2015, 评估)
We have recommended D3.js before and in this radar we want to extend our recommendation to Dc.js, a charting library based on D3 for exploring large multi-dimensional datasets. With D3, it shares the ease with which beautiful interactive graphs can be created. It is different in that it trades the flexibility to create almost any kind of data visualization for a simpler programming model to create common chart types.
Appium(Jan 2015, 试验)
Mobile test automation is becoming increasingly important. Appium is a test automation framework that can test mobile web, mobile native and mobile hybrid applications on iOS and Android. We have used this in multiple projects and have seen significant gains. At the core, Appium is a webserver that exposes a REST API, receiving connections from a client, listening for commands, executing those commands on a mobile device and responding with an HTTP response representing the result of the command execution. It allows tests to be written against iOS and Android using the same API. Appium is open source with easy setup using npm.
Appium(Jul 2014, 评估)
Mobile test automation is becoming increasingly important. Appium is a test automation framework which can be used to test mobile web, mobile native and mobile hybrid applications on iOS and Android. At the core, Appium is a webserver that exposes a REST API, receiving connections from a client, listening for commands, executing those commands on a mobile device and responding with an HTTP response representing the result of the command execution. It allows tests to be written against multiple platforms (iOS, Android) using the same API. Appium is open source with easy set up using npm.
Foreman(Jan 2015, 试验)
The big Cloud providers have clearly raised the bar for provisioning, monitoring, and configuration, simplifying these tasks dramatically through powerful tools. Organizations that want to keep their compute and storage resources in-house are looking for similar solutions that work within their organizational context. Foreman has worked really well for us, and it is open-source software, too.
Foreman(Jul 2014, 试验)
The big Cloud providers have clearly raised the bar for provisioning, monitoring, and configuration, simplifying these tasks dramatically through powerful tools. Organizations that want to keep their compute and storage resources in-house are looking for similar solutions that work within their organizational context. Foreman has worked really well for us, and it is open-source software, too.
iBeacon(Jan 2015, 试验)
iBeacons are the Apple implementation of the broader category of beacons, which are small devices that use low energy Bluetooth (BLE) to provide fine-grained proximity information for mobile phones and other devices. Despite the hype surrounding iBeacons and the limitations to the accuracy and reliability of the information they provide, we do feel that they open interesting opportunities as trigger points for interacting with your users in a contextually relevant manner.
iBeacon(Jul 2014, 试验)
iBeacons are the Apple implementation of the broader category of beacons, which are small devices that use low energy Bluetooth (BLE) to provide fine-grained proximity information for mobile phones and other devices. Despite the hype surrounding iBeacons and the limitations to the accuracy and reliability of the information they provide, we do feel that they open interesting opportunities as trigger points for interacting with your users in a contextually relevant manner.
Q & Bluebird(Jan 2015, 试验)
Q is a fully Promises/A+ compliant implementation in JavaScript that lets users compose promises arbitrarily deeply without the need for the deeply nested callbacks that obscure control flow. Q takes care of threading fulfilled values and rejected promises through the appropriate code paths. The space of Promises/A+ compliant libraries is currently very active with alternatives like Bluebird also rapidly gaining mindshare.
Q & Bluebird(Jul 2014, 试验)
Q is a fully Promises/A+ compliant implementation in JavaScript that lets users compose promises arbitrarily deeply without the need for the deeply nested callbacks that obscure control flow. Q takes care of threading fulfilled values and rejected promises through the appropriate code paths. The space of Promises/A+ compliant libraries is currently very active with alternatives like Bluebird also rapidly gaining mindshare.
Gorilla REPL(Jan 2015, 评估)
GorillaREPL is a tool for creating nicely-rendered documents consisting of text, live Clojure code, and plots.  In some ways similar to iPython notebooks, GorillaREPL should be particularly useful for data analysts or code tutorials.  But beyond that, GorillaREPL is fun!.  It is a creative way to demonstrate the power of Clojure’s simple abstractions over immutable values.
Inverse Conway Maneuver(Jan 2015, 试验)
Conway's Law asserts that organizations are constrained to produce application designs which are copies of their communication structures. This often leads to unintended friction points. The 'Inverse Conway Maneuver' recommends evolving your team and organizational structure to promote your desired architecture. Ideally your technology architecture will display isomorphism with your business architecture.
Inverse Conway Maneuver(Jul 2014, 试验)
Conway's Law asserts that organizations are constrained to produce application designs which are copies of their communication structures. This often leads to unintended friction points. The 'Inverse Conway Maneuver' recommends evolving your team and organizational structure to promote your desired architecture. Ideally your technology architecture will display isomorphism with your business architecture.
Private Clouds(Jul 2014, 试验)
The number and maturity of on-premise private cloud options continue to increase. From OpenStack-based options like Rackspace's private cloud to PAAS options like CloudFoundry, for those organizations seeking to make use of existing infrastructure or for whom an increased level of control is needed over off-premise cloud, then these solutions are well worth a look.
Private Clouds(Jan 2014, 评估)
The need for physically storing data within nations or organizations has increased significantly in recent years. There is concern around sensitivity of information hosted in cloud environments. Organizations are looking into private cloud as an alternative when data that needs to be housed in close proximity with control over access and distribution. Private cloud offers cloud infrastructure provisioned for exclusive use by a single organization with the following characteristics; on-demand self-service, broad network access, resource pooling, rapid elasticity and measured service.
Private Clouds(Oct 2012, 试验)
Because of concerns over privacy and security, or a need to repurpose existing hardware investments, many businesses are choosing to implement their own private cloud. There are are a variety of products, both open source and commercial for this purpose, but it should be noted that compute, storage, and network management are only the starting points for a useful private cloud. There are many services and processes that must be custom implemented to provide a cloud facility that rivals the public offerings from Amazon, Rackspace, or others.
Hadoop 2.0(Jul 2014, 采纳)
Hadoop's initial architecture was based on the paradigm of scaling data horizontally and metadata vertically. While data storage and processing were handled by the slave nodes reasonably well, the masters that managed metadata were a single point of failure and limiting for web scale usage. Hadoop 2.0 has significantly re-architected both HDFS and the Map Reduce framework to address these issues. The HDFS namespace can be federated now using multiple name nodes on the same cluster and deployed in a HA mode. MapReduce has been replaced with YARN, which decouples cluster resource management from job state management and eliminates the scale/performance issues with the JobTracker. Most importantly, this change encourages deploying new distributed programming paradigms in addition to MapReduce on Hadoop clusters.
CartoDB(Jul 2014, 试验)
CartoDB is an open-source GIS tool built on PostGIS and PostgreSQL. It allows for storage and searching of geospatial data using SQL. It also provides a handy JavaScript library, CartoDB.js, for map styling and data visualization.
Big enterprise solutions(Jul 2014, 暂缓)
The gap between what "enterprise-class" commercial packages provide and what is actually needed is widening. This is especially true for internet facing applications. Innovative solutions that really scale and easily support modern techniques such as continuous delivery are written by practitioners for practitioners. They originate with many internet scale companies and are refined as open source software. Big enterprise solutions often obstruct effective delivery due to their accumulated bloat, cumbersome licensing restrictions, and feature sets that are driven by check-lists and imaginary requirements far removed from the realities of most development teams.
Machine image as a build artifact(Jul 2014, 试验)
Many of our teams are getting great benefit from publishing virtual machine images as a build artifact during their automated build processes. These machine images are published with the application and all dependencies, often in an immutable state. With minimal additional configuration the image can be used to create identical virtual machines in all environments eliminating many common sources of error and waste. Tools are emerging to make this approach simpler, for example Packer in the tools section of the Radar. This approach is working well in companies that take a mature approach to cloud and virtualization, and where delivery teams have responsibility and access right through to production.
Machine image as a build artifact(Jan 2014, 评估)
Most virtualization technologies provide a way to launch a machine from an image. By creating a machine image as a build artifact early in your build pipeline and promoting it through the pipeline as it passes further suites of tests, you can reliably deploy the exact machine that passed the tests into production. This technique eliminates most causes of the snowflake server anti-pattern.
Dropwizard(Jul 2014, 采纳)
Dropwizard is an opinionated combination of several lightweight Java tools and frameworks, many of which would merit mention in their own right. The package embodies many of our favorite techniques, including an embedded HTTP server, support for RESTful endpoints, built-in operational metrics and health-checks, and straightforward deployments. Dropwizard makes it easy to do the right thing, allowing you to concentrate on the essential complexity of a problem rather than the plumbing.
Espruino(Jul 2014, 评估)
Espruino is a microcontroller that natively executes JavaScript and thus lets the large number of JavaScript programmers get started very quickly. Using an event-based model similar to Node.js, Espurino devices can be very power efficient while still being responsive. Less powerful than a Raspberry Pi and slightly slower than an Arduino, Espruino makes an interesting alternative in low-power environments that need responsive behavior but can sacrifice some of the raw high level features and execution speed of those platforms.
Masterless Chef/Puppet(Jul 2014, 试验)
Chef and Puppet servers are a central place to store recipes/manifests that propagate configuration changes to managed machines. They are also a central database of node information and provide access control for manifests/recipes. The disadvantage of having these servers is that they become a bottleneck when multiple clients simultaneously connect to them. They are a single point of failure and take effort to be robust and reliable. In light of this, we recommend chef-solo or standalone puppet in conjunction with a version control system when the server is primarily used to store recipes/manifests. Teams can always introduce the servers as the need arises or if they find themselves reinventing solutions to the problems the servers have already solved.
Prototype On Paper(Jul 2014, 试验)
We have long favored the use of hand-drawn, low fidelity prototypes to illustrate user interactions without getting caught up in the nitty-gritty of the graphic design. Prototype On Paper is a tool that allows individual mockups drawn on paper to be captured via camera on iOS or Android and linked together to allow for testing of user interaction. This bridges the gap nicely between the static, lo-fi paper prototypes and more hi-fi prototyping techniques.
Enterprise Data Warehouse(Jul 2014, 暂缓)
While centralized integration of data for analysis and reporting remains a good strategy, traditional Enterprise Data Warehouse (EDW) initiatives have a higher than 50% failure rate. Big up-front data modeling results in overbuilt warehouses that take years to deliver and are expensive to maintain. We are placing these old-style EDWs and techniques on hold in this edition of the radar. Instead, we advocate evolving towards an EDW. Test and learn by building small, valuable increments that are frequently released to production. Nontraditional tools and techniques can help, for example using a Data Vault schema design or even a NoSQL document store such as HDFS.
Perimeterless enterprise(Jul 2014, 试验)
Technology trends have broken down the garden walls that used to surround corporate IT networks and lead to a perimeterless enterprise. Employees frequently use their own consumer devices to access corporate data through cloud services and web APIs, often without the organization's knowledge. As devices continue to proliferate and more applications move to the cloud, businesses are being forced to rethink fundamental assumptions about data access and network security.
Web Components standard(Jul 2014, 评估)
In the previous radar we cautioned against the use of traditional web component frameworks that provide a component model on the server side. The Web Components standard that originated at Google is something quite different. It provides an easier way to create recyclable widgets by helping with encapsulation of HTML, CSS and JavaScript, so they do not interfere with the rest of the page and the page does not interfere with them. Developers can use as much or as little of the framework as needed. Early support is provided by the Polymer Project.
Chaos Monkey(Jul 2014, 试验)
Following our recommendation in the last radar to consider a focus on reducing mean time to recovery, we want to highlight Chaos Monkey from Netflix's Simian Army suite. It is a tool that randomly disables instances in the production environment during normal operation. When run with comprehensive monitoring and a team on stand by, it helps to uncover unexpected weaknesses in the system, which in turn allows the development team to build automatic recovery mechanisms ahead of time, rather than struggling to respond to an outage that caught everyone by surprise.
PostgreSQL for NoSQL(Jul 2014, 试验)
PostgreSQL is expanding to become the NoSQL choice of SQL databases. Version 9.2 includes the ability to store JSON data with full querying capabilities on the content of the JSON document. Other extensions let the user store and query data in the form of key/value pairs. This lets you take advantage of the underlying storage and transactional capabilities of a time-tested database without being tied to a relational data model. This is ideal for those who want both SQL and NoSQL applications but prefer a single reliable infrastructure that they already know how to support.
Segregated DOM plus node for JS Testing(Jul 2014, 采纳)
As client-side JavaScript applications grow in sophistication, we see an increased need for engineering sophistication to match. A common architectural flaw is unfettered access to the DOM from across the codebase - mixing DOM manipulation with application logic and AJAX calls. This makes the code difficult to understand and extend. Thinking about separation of concerns is a useful antidote, aggressively restricting all DOM access (usually jQuery usage) to a thin 'segregation layer'. One pleasant side-effect of this approach is that everything outside of the segregated DOM layer can be tested rapidly in isolation from the browser using a lean JavaScript engine such as node.js.
Flume(Jul 2014, 评估)
When using techniques such as 'instrument all the things' and semantic logging, you may end up with huge amount of log data. Collecting, aggregating and moving this data can be problematic. Flume is a distributed system for exactly this purpose. It has a flexible architecture based on streaming data flows. With built-in support for HDFS, Flume can easily move multi-terabyte log data from many different sources to a centralized data store for further processing.
Provisioning testing(Jul 2014, 试验)
Virtualization and Cloud Computing have made it easy to procure and provision hardware and virtual servers. But with this flexibility comes scale and complexity, and managing our virtual estates has become increasingly difficult. Using techniques more familiar in the software development world such as TDD, BDD and CI offers an approach to managing this complexity and gives us the confidence to make changes to our infrastructure in a safe, repeatable and automatable manner. Provisioning testing tools, like rspec-puppet, Test Kitchen and serverspec, are available for most platforms.
Play Framework 2(Jul 2014, 试验)
The Play Framework 2 blip has generated many internal discussions. We had competing suggestions to move it to adopt and hold. These differences relate primarily to the specific applications for which it is used, how it is used, and what expectations people have for it. While none of these issues are unique for Play, Play has generated far more controversy than is typical in the standard library versus framework debate. We reiterate the cautions stated in the previous radar, and we will monitor how Play continues to mature to support its sweet spot.
Play Framework 2(May 2013, 试验)
The recent release of Play Framework 2.1.1 with support for controller dependency injection, asynchronous, non-blocking I/O, a code-reload workflow, database migrations, asset pipelining, and flexible deployment options has made it more attractive to developers. For this reason Play re-appears on the radar as something for teams to seriously consider when building web applications and services on the JVM. A word of caution however, Play embraces a functional programming style which, when working with the Java language, still translates into a plethora of static methods that may be difficult to unit test outside a running server.
Ignoring OWASP Top 10(Jul 2014, 暂缓)
Barely a week goes by without the IT industry being embarrassed by yet another high profile loss of data, leak of passwords, or breach of a supposedly secure system. There are good resources to help with making sure security gets treated as a first-class concern during software development and we need to stop ignoring them; the OWASP Top 10 is a good place to start.
Wolfram Language(Jul 2014, 评估)
We are intrigued by the possibilities offered by the Wolfram language. Building on the symbolic approaches of the Mathematica language it also has access to a vast array of algorithms and data from the Wolfram Alpha project, which means that very succinct programs can analyze and visualize powerful combinations of real-world data.
Ant(Jul 2014, 暂缓)
We continue to see teams expend significant effort on un-maintainable Ant and Nant build scripts. These are hard to understand and extend due to the inherent lack of expressiveness and clean modularity provided by the tools. Alternatives like Gradle, Buildr, and PSake have clearly demonstrated superior maintainability and productivity.
Capture domain events explicitly(Jul 2014, 试验)
When using techniques such as "instrument all the things" and semantic logging, it can be very useful to capture domain events explicitly. You can avoid having to infer user intent behind state transitions by modeling these transitions as first-class concerns. One method of achieving this outcome is to use an event sourced architecture with application events being mapped to business meaningful events.
Tangible interaction(Jul 2014, 评估)
As the lines between hardware and software continue to blur, we see traditional computing increasingly embedded in everyday objects. Although connected devices are now ubiquitous in retail spaces, automobiles, homes, and workplaces, we still do not understand how to blend them into a useful computing experience that goes beyond a simple glass screen. Tangible interaction is a discipline that blends software and hardware technology, architecture, user experience, and industrial design. The goal is to provide natural environments made up of physical objects where humans can manipulate and understand digital data.
Julia(Jul 2014, 评估)
Julia is a dynamic, procedural and homoiconic programming language designed to address the needs of high performance scientific computing. The implementation of the language is organized around the concept of generic functions and dynamic method dispatch. Julia programs are largely functions that can contain multiple definitions for different combinations of argument types. The combination of these language features and the LLVM based just-in-time compiler help Julia achieve a high level of performance. Julia also supports a multiprocessing environment based on message passing to allow programs to run on multiple processes. This enables programmers to create distributed programs based on any of the models for parallel programming.
Pester(Jul 2014, 试验)
PowerShell remains a widely used option for doing low-level automation on Windows machines. Pester is a testing library that makes it possible to execute and validate PowerShell commands. Pester simplifies testing of scripts during development with a powerful mocking system that makes it possible to setup stubs and doubles in tests. Pester tests can also be integrated into a continuous integration system to prevent regression defects.
Event Sourcing(Jul 2014, 试验)
Event Sourcing ensures that all changes to application state are stored as a sequence of events. Not only can we query these events, we can also use the event log to reconstruct past states, and as a foundation to automatically adjust the state to cope with retroactive changes. Complementary to the capture of business meaningful events, the technique has positive implications for analytics in driving greater customer insight.
Event Sourcing(Mar 2012, 评估)
Event sourcing is an approach to thinking about persistent data where the primary record is a log of all events that make updates. A traditional representation of database state can be entirely recreated by reprocessing this event log. Event sourcing’s benefits include strong auditing, creation of historic state, and replaying of events for debugging and analysis. Event sourcing has been around for a while, but we think it is used much less than it should be.
Low-cost robotics(Jul 2014, 评估)
With the cost of industrial robots dropping and their safety and ease of use increasing, the world of useful, commercial robotics is opening up. Robots like Rethink Robotics' Baxter or Universal Robotics' U5, make it feasible for small to medium-sized businesses to automate repetitive tasks previously performed by humans. Increasingly, enterprise software will have to integrate with low-cost robotics as another participant in the value stream. The challenge lies in making the experience easy and productive for the human co-workers as well.
Development environments in the cloud(Jul 2014, 试验)
Development environments in the cloud allow you to entirely outsource development infrastructure, leaving your team with nothing more than laptops and an internet connection. By using a combination of best-of-breed services such as private GitHub repositories and Snap CI's continuous integration in the cloud, your teams may never need to bother in-house IT for infrastructure again.
Scala, the good parts(Jul 2014, 采纳)
Scala is a large language that is popular because of its approachability for new developers. This banquet of features is a problem because many aspects of Scala, like implicit conversions and dynamics, can get you into trouble. To successfully use Scala, you need to research the language and have a very strong opinion on which parts are right for you, creating your own definition of Scala, the good parts. You can disable the parts you do not want using a system called feature flags.
Scala, the good parts(May 2013, 采纳)
In the previous radar we had two JVMbased functional programming languages, Clojure and Scala, in our Assess category. We had expressed a slight preference for Clojure because it is the smaller and more focused language. Since the last radar we have realized that the wider applicability of Scala makes it more approachable for enterprise developers, and we have witnessed great successes in the adoption of Scala. Consequently we have moved Scala into our Trial category. Pay careful attention to the idiomatic use of Scala if it is introduced to a new team to avoid "Java without semicolons" or Perl styles.
Scala, the good parts(Aug 2010, 评估)
The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion.
Scala, the good parts(Apr 2010, 评估)
In the previous radar, we lumped functional languages together in a group. For this version, we’ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears “in the box” in Visual Studio 2010.
Handwritten CSS(Jul 2014, 暂缓)
Along with JavaScript and HTML, CSS is a core technology for creating websites. Unfortunately, the language itself lacks key features, which leads to a high level of duplication and a lack of meaningful abstractions. While CSS3 aims to rectify some of these issues, it will be years before the modules that make up CSS3 will be properly supported in most browsers. Fortunately, there is a solution today using CSS preprocessors like SASS and LESS. Due to their quality and support, we believe that the days of handwritten CSS, for anything apart from trivial work, are over.
Vumi(Jul 2014, 采纳)
In the last technology radar, we spoke about Vumi as a platform for using USSD as a UI for feature phones. Vumi has become very stable and its open source nature gives it appeal. In our projects, we have been able to integrate with telecommunication networks seamlessly and rapidly due to the simplicity of configuration. The platform is also readily available and scalable.
Vumi(Jan 2014, 试验)
Vumi is a scalable open source messaging engine driving conversations through frugal methods on mobile devices. Vumi facilitates SMS, IM and USSD interactions between companies and their clients, health services and their patients, governments and citzens, and more. Vumi integrates with telcos and allows you to build apps on top of it easily. You only have to pay for carrier charges.
Property-based unit testing(Jul 2014, 评估)
We value unit testing on projects and we like techniques such as property-based unit testing which augment it. This is a practice of using data generators to create randomized inputs within defined ranges. It allows a quick check for boundary conditions and other unanticipated failure modes and has burgeoning support on multiple platforms.
Hive(Jul 2014, 试验)
Hive is a data warehouse built on top of Hadoop which provides a SQL-like query and data definition language. Hive converts queries into MapReduce jobs that can be run across the entire Hadoop cluster. Like all useful abstractions, Hive does not try to deny the existence of the underlying mechanics of Hadoop and supports custom map-reduce operations as a powerful extension mechanism. Despite the superficial similarities to SQL, Hive does not try to be a replacement for low-latency, real-time query engines found on relational database systems. We strongly advise against using Hive for online ad-hoc querying purposes.
Bridging physical and digital worlds with simple hardware(Jul 2014, 评估)
The reduction in cost, size, power consumption and simplicity of physical devices has led to an explosion in devices that open physical domains to software. These devices often contain little more than a sensor and a communication component like Bluetooth Low Energy or WiFi. As software engineers, we need to expand our thinking to include bridging physical and digital worlds with simple hardware. We are already seeing this in the car, the home, the human body, agriculture and other physical environments. The cost and time required to prototype such devices is shrinking to match the fast iterations possible in software.
Pointer Events(Jul 2014, 评估)
After some delays, mainly caused by patent claims from Apple, the W3C has now finalized the Touch Events recommendation. However, in the meantime, Pointer Events, a newer, broader, and richer standard, is picking up momentum. We recommend considering Pointer Events for HTML interfaces that must work across different input methods.
TFS(Jul 2014, 暂缓)
We continue to see teams run into productivity problems attempting to use TFS as a version control system. Teams that want to practice frequent code check-ins, a core part of continuous integration, have found its heavyweight approach significantly drains productivity. This often leads to teams checking in less frequently, causing more problematic merges. We recommend tools such as Git, Perforce, and Subversion instead.
Storm(Jul 2014, 评估)
Heterogeneous and overwhelmingly large amounts of data is not the only theme of big data. In certain circumstances, speed of processing can be as important as the volume. Storm is a distributed realtime computation system. It has similar scalability to Hadoop, with throughput as fast as a million tuples per second. It enables for real time processing what Hadoop does for batch.
Protractor for AngularJS(Jul 2014, 试验)
Protractor is a testing framework based on Jasmine that wraps WebDriverJS with functionality specifically designed to execute end-to-end tests for Angular.JS applications. We've found it to be a standout in the rapidly evolving space of JavaScript testing frameworks. Despite being designed to run end-to-end tests with a real backend, Protractor tests can also be made to work with a stubbed HTTP gateway to run purely client side tests.
Moco(Jul 2014, 试验)
Testing HTTP-based micro-services can be painful and tricky. Particularly in two scenarios, the consumption of a group of micro-services from front-end, and the communication between micro-services. To deal with these, Moco can be handy. It is a lightweight stub framework for testing HTTP-based endpoints. You can have an embedded stubbed service up and running with 2 lines of Java or Groovy code, or a standalone one with few lines of JSON to describe the required behavior.
Spray/akka-http(Jul 2014, 评估)
Spray/akka-http is a suite of lightweight Scala libraries providing client/server RESTful support on top of Akka. It fully embraces the Actor-, Future-, and Stream-based programming models used by the underlying platform. This lets you work on RESTful applications with idiomatic Scala code without worrying about wrapping around other Java libraries.
Dependency management for JavaScript(Jul 2014, 采纳)
Using Dependency management tools for JavaScript has helped our delivery teams handle large amounts of JavaScript by structuring their code and loading the dependencies at runtime. Though this simplified the effort in most cases, lazy loading complicates supporting offline mode. Different dependency management tools have different strengths, so choose based on your context.
Hosted solutions for testing iOS(Jul 2014, 评估)
All development for iOS must be carried out on OS X. Due to technical and licensing restrictions running server farms with OS X is neither easy nor common. In spite of these difficulties, Travis CI, with support from Sauce Labs, now provides cloud-based continuous integration services for iOS and OS X projects.
Yeoman(Jan 2014, 评估)
Yeoman attempts to make web application developers more productive by simplifying activities like scaffold, build and package management. It is a collection of the tools Yo, Grunt and Bower that work well as a set.
PhantomJS(Jan 2014, 试验)
We see interest on Thoughtworks projects around PhantomJS, a headless web testing tool that allows functional testing against a realistic target.
CoffeeScript(Jan 2014, 试验)
The expansion of single-page and mobile browser-based applications into mainstream use, along with continued growth of node.js for server-side applications, have led to increased adoption of CoffeeScript to simplify JavaScript codebases. As a language that compiles into JavaScript code for runtime execution, many concerns have been raised about the difficulty of debugging applications written in CoffeeScript. The introduction of Source Maps in CoffeeScript 1.6.1 is helping producers of development tools address this concern.  We expect this will lead to further adoption of the language following the lead of highly visible technology firms such as Dropbox.
CoffeeScript(Mar 2012, 试验)
JavaScript is a powerful, ubiquitous programming language with tricky and error prone syntax. Coffeescript fixes many of the warts of JavaScript in a clean, simple syntax that generates readable JavaScript. For example, creating true private variables in JavaScript is a syntactic nightmare; CoffeeScript generates the technically correct but hideous syntax. Some readers may be confused by our advocacy of Coffeescript given our general dislike for GWT, because on the surface they seem similar: tools that generate JavaScript. However, it is the level of abstraction that differs. GWT has an elaborate component model, which tries to hide details about the underlying language (JavaScript) and platform (the web). Coffeescript tries to make it easier to write proper JavaScript, avoiding pathological but default “features” of JavaScript, and does not build a layer that tries to insulate you from the platform.
Calabash(Jan 2014, 试验)
On mobile projects, we have been impressed with the functionality and gradually evolving capabilities and maturity of Calabash. It is an automated acceptance test tool for both Android and iOS applications that supports common ecosystem tools like Cucumber. It is an attractive choice on heterogeneous projects.
D3(Jan 2014, 采纳)
D3 continues to gain traction as a library for creating rich visualisations in the browser. Previously, it was somewhat low-level, requiring more work for the creation of commonly used visualisations than less sophisticated, more targeted libraries. Since the last radar, libraries like Rickshaw for charting and Crossfilter for in-browser dataset exploration have helped make D3 even more accessible than before.
D3(Oct 2012, 试验)
D3 is a JavaScript library for binding datasets into the DOM, and then declaratively transforming the document to create rich visualizations - ranging from graphs to heatmaps. With support for HTML, CSS and SVG, and an extensible plug-in model, we like the fact that this library allows us to deliver information in more intuitive ways.
Microservices(Jan 2014, 试验)
We are seeing an uptick in adoption of microservices as a technique for distributed system design, both in Thoughtworks and in the wider community. Frameworks such as Dropwizard and practices like declarative provisioning point to a maturing of the technologies and tools. Avoiding the usual monolithic approach and being sympathetic to the need to replace parts of systems individually has important positive implications for the total cost of ownership of systems. We see this as having greatest impact in the mid-to-long term, specifically with respect to the two-to-five year rewrite cycle.
Microservices(Mar 2012, 评估)
Microservices, often deployed out-of-container or using an embedded HTTP server, are a move away from traditional large technical services. This approach trades benefits such as maintainability for additional operational complexity. These drawbacks are typically addressed using infrastructure automation and continuous deployment techniques. On balance, microservices are an effective way of managing technical debt and handling different scaling characteristics especially when deployed in a service oriented architecture built around business capabilities.
OWIN(Jan 2014, 评估)
One thing that has slowed the evolution of a rich, open source web development ecosystem on the .NET platform has been over-dependence on IIS and the ASP.NET framework.  OWIN specifies an open HTTP handling interface that decouples web server from application much like Rack has done for the Ruby community.  We are excited about OWIN because it opens up the possibility of new .NET web development tools composed of simple, independently-developed modules.  Nancy is the perfect example of this.  We also hope it will increase the practice of deploying web applications as standalone, self-hosted services on the .NET platform.
Octopus(Jan 2014, 评估)
Windows infrastructure automation should be adopted, however it still remains more difficult than automation on a Unix platform. Tools like Chef and Puppet are increasing their support, but there are also Windows specific solutions being developed like Octopus. Octopus allows automated deployment of your ASP.NET applications and Windows services and decreases dependency on PowerShell. It can be used with both NuGet using Octopak and TeamCity to create a full build, package, and deployment pipeline.
Sinatra(Jan 2014, 采纳)
Micro-frameworks are emerging as a way to handle increasing complexity in applications both on client- and server-side. Sinatra was one of the first examples of that trend in the server-side space, exposing a lightweight DSL to build fast services that can be easily composed. Similar offerings are available for other languages, including Spark for Java, Flask for Python, Sclatra for Scala, Compojure for Clojure and Nancy for .NET.
Sinatra(Oct 2012, 试验)
Micro-frameworks are emerging as a way to handle increasing complexity in applications both on client- and server-side. Sinatra was one of the early precursors of that trend in server-side space, exposing a lightweight DSL to build fast services that can be easily composed. Flask, Scalatra and Compojure are similar offerings for Python, Scala and Clojure respectively.
Client and server rendering with same code(Jan 2014, 试验)
Increasingly, HTML is rendered not only on the server but also on the client, in the web browser. In many cases this split rendering will remain a necessity but with the growing maturity of JavaScript templating libraries an interesting approach has become viable: client and server rendering with same code.
Siloed metrics(Jan 2014, 暂缓)
As more businesses move online we have noted a tendency to end up with siloed metrics. Specific tools are implemented to gather and display specific metrics: one tool for page-views and browser behavior, another for operational data and another to consolidate log messages. This leads to data silos and the need to swivel-chair integrate between the tools in order to gather business intelligence that is crucial to running the business. This is a tool-led split in the analytics domain that hurts the team’s ability to make decisions. A much better solution is to have a consolidated view of near-real time analytics using integrated dashboards displaying time-sensitive domain and team relevant information.
Continuous delivery for mobile devices(Jan 2014, 采纳)
Since the last radar a few advances have made continuous delivery for native apps on mobile devices less painful. Xctool, the recently open-sourced 'better xcodebuild' improves iOS build automation and unit testing. The arrival of automatic updates in iOS7 reduces the friction of regular releases. Travis-CI now supports OS X agents, removing another hurdle in seamless CD pipelines for mobile platforms. Our advice from the last radar on the value of hybrid approaches and the importance of test automation for mobile still applies.
Continuous delivery for mobile devices(May 2013, 试验)
With HTML5 blurring the line between traditional native apps and web apps, we are beginning to experiment with continuous delivery for mobile devices. Services such as TestFlight allow you to deploy native apps to real devices multiple times per day. With a wholly or partially HTML5-based application changes can be deployed without submitting a new app to an app store. If your organization has an enterprise app store, you may be able to easily push builds to it. While the techniques for implementing CD to mobile devices are improving, we note that testing practices are lagging behind. To be successful you will need to increase your focus on automated testing to ensure that everything actually works once it gets to the device.
Collaborative analytics and data science(Jan 2014, 评估)
For years, teams and organizations have seen the dangers of siloing expertise around technical disciplines. While we value input from experts on advanced applications, developers should have basic knowledge of user interfaces, databases, and data science, the newest industry darling. While advanced applications requires deep expertise, we are pushing for collaborative analytics and data science, where all developers use basic statistical analysis and tools to make better decisions, and work closely with experts when things get complicated.
HTML5 storage instead of cookies(Jan 2014, 试验)
HTML5 storage, also known as local storage or web storage, is a mechanism for storing client side data in modern browsers, including iOS and Android mobile browsers. We recommend using HTML5 storage instead of cookies in almost all cases. HTML5 Storage can accommodate up to 5MB of data while cookies are limited to 4KB. Cookie data is transmitted in every request, which slows down your application and potentially exposes data over insecure HTTP connections. In contrast, HTML5 storage data remains securely in the browser. Cookies should be reserved for storing small simple pieces of data like a session ID.
OpenStack(Jan 2014, 试验)
The open source OpenStack project is gathering steam, and in recent months is becoming a more viable platform for deploying your own private clouds. Many issues which made OpenStack hard to get up and running have been addressed, and new features are being added all the time. It is clear that the OpenStack consortium and its members like Rackspace, Redhat, and HP are committed to the project as the basis for their own OpenStack-based cloud services.
OpenStack(Jul 2011, 评估)
OpenStack is a new cloud operating system that promises a complete open-source solution. OpenStack is a fabric cloud controller which leverages existing virtualization technologies such as KVM and will integrate with other virtualisation tools such as Xen and OpenVZ. Currently under heavy development, OpenStack is expected to provide a stable production-ready solution by the end of Q2 2011.
Librarian-puppet and Librarian-Chef(Jan 2014, 试验)
Both Puppet and Chef have had to deal with sharing community-contributed modules and manifests for commonly used services and tasks. Both the Puppet Forge and Chef’s Cookbook repository have helped, but people ended up copying and pasting these recipes into their own codebases, preventing them from taking advantage of later bugfixes and improvements. Librarian-puppet and Librarian-Chef attempt to solve this by making it easy to declare your module dependencies, including pulling in known versions of code from these community sites.
Akka(Jan 2014, 评估)
Akka is a toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications on the JVM. It offers very lightweight event-driven processes with approximately 2.7 million actors per GB RAM and a 'let-it-crash'model of fault-tolerance designed to work in a distributed environment. Akka can be used as a library for web-apps or as a stand-alone kernel to drop an application into.
Hadoop as a service(Jan 2014, 试验)
We observe organizations that have piloted Hadoop successfully starting to consolidate their Hadoop infrastructure services into a centralized, managed platform before rolling it out across the enterprise.These Hadoop as a service platforms are characterized by the control tier that interfaces with and coordinates among different core Hadoop infrastructure components. The capabilities of the platform are usually exposed via higher-level abstractions to the enterprise. Such a managed platform gives organizations the ability to deploy processes, infrastructure and datasets in a fairly consistent way across the organization. These services are built in private data centers and public cloud infrastructure.
Node.js(Jan 2014, 采纳)
Node.js is a lightweight web container that is a strong option for development of micro services and as a server to mobile and single-page web applications. Due to the asynchronous nature of node.js, developers are turning to promise libraries to simplify their application code. As the use of promises mature within the node.js community, we expect to see more applications developed for node.js. For those teams that are reluctant to try node.js in production, it is still worthwhile to consider node.js for development tasks like running JavaScript tests outside of the browser or generating static web content from tools like CoffeeScript, SASS, and LESS.
Node.js(Oct 2012, 试验)
For many years JavaScript was predominantly used as a client side Web programming language, but a lightweight language such as JavaScript can easily be embedded in different environments, including the server side. Node.js allows developers to write applications in JavaScript on both client and server sides. Since most servers spend the majority of their time waiting for I/O operations, Node.js’ event driven non-blocking architecture is very efficient. Unlike threadbased solutions, Node.js does not need to wait for I/O operations to complete while processing incoming requests, making it a good choice when implementing high performance services.
Neo4J(Jan 2014, 采纳)
Graph databases store information as arbitrarily interconnected nodes linked by named relations, rather than as tables and joins. Schema-less and highly extensible, they are an excellent choice for modelling semi-structured data in complex domains. Neo4j is the front-runner in the space both its REST API and its Cypher query language support simple and fast storage and traversal of graphs.
Neo4J(Aug 2010, 试验)
Graph databases store information as interconnected nodes with arbitrary relations rather than tables and nameless relations. Graph databases are an excellent choice for complex domains with semi-structured data since they’re schema-less and highly extensible. Neo4j is the front-runner in the graph database space being an embedded Java component, which supports fast storage and search of graphs for Java solutions (including server applications). The Neo4j community is highly active and now has a basic REST API enabling it as more general purpose database engine. Neo4j moving into the trial category is representative of our experience trialling it in real-world scenarios and the early successes we’ve achieved.
MongoDB(Jan 2014, 采纳)
For problems that fit the document database model, MongoDB is now the most popular choice. In addition to ease of use and a solid technical implementation, the community and ecosystem contributed to this success. We are aware of problems where teams were tempted by the popularity of MongoDB when a document database was not a good fit or they did not understand the inherent complexity. When used appropriately, however, MongoDB has proven itself on many projects.
MongoDB(Oct 2012, 试验)
For problems that fit the document databases model, MongoDB provides easy programmability, a query interface, high availability with automated failover, and automated sharding capabilities. It allows for a smooth transition to NoSQL data stores from the RDBMS model, with the inclusion of familiar concepts, such as the ability to define indexes.
MongoDB(Aug 2010, 试验)
Document-oriented databases treat each record as a document with the ability to add any number of fields of arbitrary size. A relatively large amount of the attention that has been directed at document databases has landed on mongoDB, a highly scalable option with support for querying, indexing, replication and sharding. Beyond its enterprise feature set, its popularity is aided by its driver support for Java, Ruby, PHP, C#, Python and a number of other languages.
Logstash & Graylog2(Jan 2014, 试验)
As the systems we build involve more fine-grained services spread across more machines than ever before, the challenge of how to get information aggregated to allow for easy problem identification and resolution is more pressing than ever. Logstash has emerged as an easy way to parse and filter logs at source, and then forward them to a single aggregation point. Although Logstash provides some searching and filtering, Graylog2 is often used in conjunction to provide for more fully-featured querying and reporting.
Elastic Search(Jan 2014, 采纳)
Over the past year we have seen a gradual uptake in the adoption of Elastic Search as an open source search platform. It is an extensible, multi-tenanted, and horizontally scalable search solution based on Apache Lucene. It allows complex data structures to be indexed and retrieved through a JSON based REST API. It provides an elegant model of operation with automatic discovery of peers in a cluster, failover, and replication. Elastic Search can be extended with a plugin system that allows adding new functionality and changing existing behavior. The community around this tool is quite vibrant as illustrated by the number of client libraries available in languages like Java, C#, Ruby, and JavaScript.
SMS and USSD as a UI(Jan 2014, 采纳)
58%  of all phones sold last year globally were feature phones. In many developing countries, this is an even larger majority. If your market requires you to develop for these areas, you need to develop with this constraint in mind. These phones use SMS and USSD as a user interface. SMS is a long standing technique for sending messages, and USSD allows you to send SMS like messages in a secure session.  You should look at USSD and SMS as another UI and UX platform and treat them as first-class citizens.
Cloud-init(Jan 2014, 评估)
Cloud-init is a simple but powerful technique for carrying out actions on a cloud instance at boot time. It is particularly useful when used with instance metadata to allow a newly booted instance to pull the configuration, dependencies and software needed to perform a particular role. When used together with the Immutable or Phoenix server pattern, this can create a very responsive and light-weight mechanism for managing deployments in the cloud.
Clojure(Jan 2014, 采纳)
Clojure is a dynamic, functional language that runs on the JVM. Although its roots are in Lisp, one of the oldest computer languages, it also embodies many modern programming concepts, including lazy evaluation and advanced concurrency abstractions. Clojure has spawned a vibrant community of programmers who are contributing a rich set of frameworks and tools. One example of these is Midje, an innovative spin on unit testing and mocking frameworks.
Clojure(Jul 2011, 评估)
The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion.
Clojure(Apr 2010, 评估)
In the previous radar, we lumped functional languages together in a group. For this version, we’ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears “in the box” in Visual Studio 2010.
Mobile testing on mobile networks(Jan 2014, 采纳)
We increasingly see mobile applications that work really well during development and testing, but run into trouble when they are deployed in the real world. Mobile testing on mobile networks reveals how your app performs under a variety of conditions. You might test using 3G or LTE or deliberately use a poor WiFi network with overloaded access points. Measure network performance for your target environment, then simulate the conditions using latency and packet-loss inducing tools. In addition, it is sometimes necessary to examine exactly how your device and software are using the network with a tool such as Wireshark.
Instrument all the things(Jan 2014, 试验)
You cannot act on important business events unless you monitor them. The principle, instrument all the things, encourages us to think proactively about how we achieve this at the start of our software development.This allows us to expose key metrics, monitor them, and report on them to improve operational effectiveness.
Icon fonts(Jan 2014, 试验)
With the rise of devices with multiple form factors and pixel densities, the issue of presenting high quality icons at all scales has become important. Icon fonts solve this problem by using browser support for WebFonts and SVG instead of scaled images or maintaining different icon sets. As always, when making extensive use of SVG, pay attention to power consumption on mobile devices and performance on older devices.
Hystrix(Jan 2014, 试验)
Managing the web of dependencies in a distributed system is complicated, and is a problem more people are facing with the move to finer-grained microservices. Hystrix is a library for the JVM from Netflix that implements patterns for dealing with downstream failure, offers real-time monitoring of connections, and caching and batching mechanisms to make inter-service dependencies more efficient. In combination with hystrix-dashboard and Turbine, this tool can be used to build more resilient systems and provide near-real time data on throughput, latency and fault tolerance.
Hystrix(May 2013, 评估)
Managing dependencies in distributed systems can become complicated, and is a problem more people are facing with the move to finer-grained micro services. Hystrix is a library for  the JVM from Netflix that implements patterns for dealing with downstream failure, offers real-time monitoring of connections,and caching and batching mechanisms to make inter-servicedependencies more efficient.
Gatling(Jan 2014, 试验)
Gatling is another newer player in the automated performance testing space. It is similar to Locust and is much lighter weight than the older options such as JMeter and Grinder. Built on Scala, the DSL provides extensive functionality out of the box including easily configured data feeds and response assertions. In cases where customization is needed, it is easy to drop into Scala to provide extensions. The default generation of numerous dynamic views of the data via Highcharts adds to its appeal.
Heavyweight test tools(Jan 2014, 暂缓)
Many organizations that have moved to more agile ways of working continue to use heavyweight testing tools. These tools have problems that make them unsuitable for fast moving software delivery. Large complex tools have high learning curves and require specialist skills and training, making it hard for the team themselves to test. Often this results in an unnecessary overhead for every release as other teams get involved. Expensive and limiting software licenses makes this problem even worse. Some heavyweight tools use a 'model driven' approach where an attempt is made to accurately model the usage patterns of the application, which leads to costly test script maintenance and development time being lost to 'false positives'. We have seen few situations where simple open source solutions cannot give the required level of confidence for much less time, effort and money.
Redis(Jan 2014, 采纳)
Redis has proven a useful tool on multiple Thoughtworks projects, used as both structured cache and data store distributed across multiple countries.
Backend as a service(Jan 2014, 评估)
The recent explosion of mobile-focused products, coupled with widespread adoption of 'Lean Start-up' approaches that put a premium on time-to-market for new ideas, has spawned an ecosystem of Backend as a service (BaaS) offerings that enable developers to focus on the client application while offloading backend concerns. Assess adding these services to your toolkit where fast and low-cost proving of a new product idea is important. Our usual advice on build/buy/borrow decisions still applies: be clear on which functional areas are strategic to your business and which are commodities. For potentially strategic areas be sure to plan a migration path that will allow you to use the BaaS provider to get started quickly, while avoiding friction when your architecture evolves and you need to migrate to owning this functionality and customizing it as a differentiator.
Web API(Jan 2014, 试验)
Until recently, Microsoft's Web API was the least-worst option for building a RESTful service using ASP.NET. Web API 2 fixes a number of rough edges with better support for flexible routing, sub-resources, media types and improved testability. It continues to be our preferred library for building .NET REST APIs.
Capturing client-side JavaScript errors(Jan 2014, 采纳)
Capturing client-side JavaScript errors has helped our delivery teams identify issues specific to a browser or plug-in configuration that impact user experience. Over the past year a number of service providers have started to surface in support of this requirement. Other than storing these errors in application data stores, web applications can log this data to web analytics or existing monitoring tools such as New Relic to offload storage requirements.
PhoneGap/Apache Cordova(Jan 2014, 评估)
PhoneGap, now renamed as Apache Cordova, is a platform that lets you develop cross-platform mobile applications using HTML, CSS and JavaScript. It abstracts away platform specific native code through a set JavaScript APIs that remain consistent across different mobile platforms. Cordova is available for a wide array of platforms including iOS, Android, Blackberry, Windows Phone, and WebOS.
Windows infrastructure automation(Jan 2014, 采纳)
Previously, support for Windows in tools like Chef and Puppet was lacking, leading to large amounts of Powershell scripting to achieve simple infrastructure automation tasks. Achieving the same level of automation for Windows was more challenging than for Unix. In the last 12 months however, both Chef and Puppet support for Windows has improved drastically.  That support, combined with the inherent power of Powershell makes Windows infrastructure automation extremely viable.
Windows infrastructure automation(Oct 2012, 采纳)
Mature tools such as PowerShell, together with newer options such as Chef and Puppet, lead us to highlight Windows infrastructure automation on this edition of the technology radar. Manual configuration using a mouse and menu options is slow and leads to misconfiguration and “snowflake” machines in an unknown state. We recommend command-line tools for their clarity and scriptability.
Edge Side Includes for page composition(May 2013, 试验)
Breaking up monolithic applications and building systems from microservices requires a solid strategy to integrate output from disparate systems into a coherent experience for the end-user. Integrating at the presentation layer using Edge Side Includes (ESI) for page composition is a practical and elegant solution. This can occur within your environment using a reverse proxy like Varnish or closer to the user in a Content Delivery Network (CDN).
Riemann(May 2013, 评估)
Riemann is an open source server that aggregates and relays events in real time. Written in Clojure, and based on Netty, it is capable of handling thousands of concurrent connections per node. Riemann uses a simple Protobuf protocol for events, which allows it to aggregate everything from CPU and memory use to orders placed to error rates. It forwards to systems like Graphite, triggers email alerts, and provides a dashboard for monitoring these metrics. Riemann is an important part of the movement towards handling data as generic streams of events in real-time, as opposed to using specialized systems for different types of data.
Blue-green deployment(May 2013, 试验)
Blue-green deployment is a pattern for performing software upgrades. By setting up the latest version of your application on an identical clone of your production application stack, traffic can be switched, near instantaneously, from the current production stack to the new one as soon as the test suite and the business determine it is appropriate. Though this is an old technique, infrastructure automation and resources in the cloud make it worth reconsidering.
Jekyll(May 2013, 试验)
Jekyll represents the “microization” of frameworks in the web publishing space. While the focus is maintained on doing one thing - sites that feature blogs - as transparently as possible, it also shows the path to a more lightweight future. One example of this that we like is that it is now trivially easy to publish useful documentation for your software project.
Locust(May 2013, 试验)
We are strong believers in in-line automated performance testing, although open source tools in this space have been somewhat limited to date. Locust is a firm favorite that provides the ability to write tests in Python, with good support for running multiple injectors, basic statistics generation, and a useful web dashboard. Its approach to web load testing focuses more on the simulation of users than just generating hits per second. We would typically recommend Locust over and above older tools such as JMeter or Grinder.
TestFlight & HockeyApp(May 2013, 试验)
Both TestFlight and HockeyApp allow you to manage the deployment of mobile applications without an app store, makinguser testing easier. They offer crash reporting and analytic capabilities to gather data in the field. HockeyApp supports IOS, Android, & Windows Phone, while TestFlight supports iOS and Android. We have used both tools successfully to help deliver mobile applications. This is clearly a fast evolving space.
Exhaustive browser based testing(May 2013, 暂缓)
We have previously spoken about executing automated tests at the appropriate layer of your application. In this radar, we want to be very specific - we recommend against exhaustive browser based testing. Web browser automation tools like Selenium have encouraged widespread automated testing through the browser. While these tests continue to have their place in a test portfolio, most teams find that executing the bulk of tests through the browser creates a slow and fragile test suite.
Minimizing application configuration(May 2013, 评估)
Application configuration can be a source of pain when getting started with a new tool, managing deployments to different environments, or trying to understand why applications behave differently in different places. We are a big fan of minimizing application configuration, trying to ensure that applications work sensibly out of the box with the bare minimum of Configuration.
Promises for asynchronous programming(May 2013, 采纳)
The use of promises for asynchronous programming is an old technique that is also known as futures. It is gaining renewed interest in light of the extensive use of JavaScript on both the client and server side. This technique eliminates the use of deeply nested callbacks, flags and pollers and has first-class support from libraries such as jQuery. Teams developing JavaScript codebases of significant complexity should take advantage of this.
Lua(May 2013, 评估)
An unlikely contender in the programming languages space, Lua has seen massive adoption across a variety of industries. It is used as a scripting platform in game development and music composition; embedded in point-of-sale appliances and network devices; and in extending NoSQL databases with safe execution semantics. We expect further growth in time to come.
Automated deployment pipeline(May 2013, 采纳)
The adoption of Continuous Delivery means many teams are creating an automated deployment pipeline that carries their code all the way to production. Pipelines allow the visualization of otherwise complex chains of build and deployment activities. Further, they provide the ability to reliably trace build artifacts as they progress through each stage on their path to production. Several vendors are now building CI servers that support the pipeline as a first-class feature and not just a visual element. We recommend teams look closely at these products to avoid wasting time trying to shoehorn a pipeline into a tool without adequate support.
Zepto.js(May 2013, 评估)
Zepto.js is a lightweight JavaScript library that is largely based on JQuery. The API is identical to JQuery although it does not offer full compatibility with it. With a vastly compressed file size, Zepto is a compelling option when building responsive web Applications.
CSS frameworks(May 2013, 采纳)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Performance testing as a first-class citizen(May 2013, 采纳)
While unit and acceptance testing are widely embraced as standard development practices, this trend has not continued into the realm of performance testing. Currently, the common tooling drives testers towards creating throw away code and a click-and-script mentality. Treating performance testing as a first-class citizen enables the creation of better tests that cover more functionality, leading to better tooling to create and run performance tests, resulting in a test suite that is maintainable and can itself be tested.
Responsive web design(May 2013, 试验)
One such technique for achieving this is responsive web design. Starting with a basic presentation of content - and typically keeping the essential information constant - the experience is enhanced to suit the features detected on more capable browsers. This commonly takes the form of layout and format changes based on screen size.
Co-location by telepresence(May 2013, 试验)
Increasing quality and range of choices for inexpensive or free video conferencing is leading to a new way of working for distributed teams. Always-on video connections can help create a sense of co-location by telepresence, even when the team is distributed geographically. This is becoming the defacto standard in some of our offshore delivery centers. We are also seeing increased use of screen-sharing tools like ScreenHero for remote pairing. We would caution those looking for a silver bullet to eliminate the need for physical co-location. There is no substitute for the understanding and empathy created by faceto- face communication.
Rackspace Cloud(May 2013, 试验)
While AWS continues to add more features, Rackspace Cloud has become a viable competition in the storage and compute space. Some users may value the more thorough customer support available for Rackspace, as well as the ability to mix in more traditional hosting models. We are not excited about this just because Rackspace is a client of ours and we have had the pleasure developing the platform. We have successfully used Rackspace Cloud with several other clients, and would look forward to it being offered in more geographical locations.
Reactive Extensions for .Net(May 2013, 评估)
By putting IObservables and IObservers on an equal footing with IEnumerables and IEnumerators, Rx for .NET allows developers to use their existing knowledge of LINQ (Language Integrated Query) operators to query and compose asynchronous operations and event-based code using a common underlying abstraction of observable event streams. Microsoft has also released RxJS to bring the benefits of reactive programming to JavaScript. They open sourced the entire Rx framework, making it useful for Windows rich client applications and single-page JavaScript applications.
Jasmine paired with Node.js(May 2013, 采纳)
We have long thought of JavaScript as a first class language, and have been keenly following the development of testing tools in that space. The cream of the crop for out-of-browser testing is currently Jasmine. Jasmine paired with Node.js is the go-to choice for robust testing of both client- and serverside JavaScript.
Aggregates as documents(May 2013, 采纳)
When designing a domain model, the aggregate pattern helps to add structure and modularity. Mapped to a relational database the aggregate is not visible in the table structure. Document databases, like MongoDB, allow you to model aggregates as documents. This 1:1 mapping means that the aggregate root should be the object that is loaded from the collection.
In-process acceptance testing(May 2013, 采纳)
Acceptance tests generally exercise the system from the ‘outside’, traversing an entire network stack for the security of exercising the complete application. In-process acceptance testing challenges the notion that test code and application under- test must run in different processes in order to achieve these benefits. When using an embedded container, it is easy to set up the system, run the tests over HTTP and to verify the final state without the setup costs associated with deploying to and communicating with a separate container.
PSake(May 2013, 采纳)
PSake (pronounced ‘sake’ like the Japanese rice wine) is a build automation tool implemented in PowerShell. PSake provides a tidy syntax for declaring build tasks and dependencies without programming in XML. You also have access to all the features of PowerShell and the .NET framework from within your build scripts.
HTML5 for offline applications(May 2013, 试验)
There is a tendency to equate the need for offline functionality with the need to build an app. Despite the slow standardization process, most HTML5 features have now been implemented across all major browsers. Its local storage capabilities, comprehensively supported across mobile and tablet browsers - makes HTML5 for offline applications a very suitable option.
HTML5 for offline applications(Mar 2012, 试验)
HTML5 includes features that allow control and storage of offline data within the browser using client side JavaScript. These features allows creation of offline mobile web applications in a cross platform way that would have previously required installed applications. For instance an application that can download articles for reading later or a data capture application that can work offline and upload when you are online. While the standard is not finalized yet, support for these offline features is available and ready for use in the WebKit based browsers found on iOS, Android and newer Blackberry phones.
Continuous integration in the cloud(May 2013, 试验)
Continuous integration in the cloud is one of those obvious-in-hindsight infrastructure offerings that supports agile development. With no local software and minimal configuration, it just works. With mature offerings now in place, serious developers are left with no excuse for avoiding this important practice.
Backbone.js(May 2013, 暂缓)
Backbone.js is a great example of an abstraction pushed too far. While we initially liked the ease of wire-up, in practice it suffers from the same issues as all such databound frameworks from WebForms to client/server tools. We find that it blurs the framework and model too much, forcing either bad architectural decisions or elaborate framework hackery in order to preserve sanity.
Backbone.js(Jul 2011, 评估)
Even though JavaScript increasingly plays a more important role in today’s world of software development, it is still troublesome to organize in a clean structure. Backbone.js is a library which provides an MVC (model view controller) framework for JavaScript heavy applications. It allows developers to write JavaScript code in a more manageable and testable way.
Datomic(May 2013, 评估)
A fundamental rethinking of how databases work, Datomic is an immutable database server with fascinating transactional and deployment characteristics. One of the common headaches on agile projects is managing database migrations, especially restoring previous states. Datomic makes the need for migrations go away - every version of the data (and schema) is preserved by the database. While still evolving, we appreciate Datomic’s boldness of vision.
Component-based frameworks(May 2013, 暂缓)
As the industry shifted from desktop GUI development to the web, it seemed natural to port the most successful patterns and designs to the new paradigm. After 15 years of trying, we feel that there are still no component-based frameworks that have successfully achieved this. We recommend not attempting to make web development into something that it fundamentally is not. It is time to accept the page and request-based nature of the web, and focus on the frameworks that support - rather than work against - these concepts.
Graphite(May 2013, 采纳)
While many tools exist for displaying graphs for system monitoring purposes, Graphite has emerged recently as the clear leader in this space. Capable of charting metrics in realtime, it features a round-robin database that is able to store long periods of historic data, while still providing more recent information at a higher fidelity. Numerous configuration options exist on the dashboard, and the resulting graphs can then be embedded in webpages to increase visibility.
Apache Pig(May 2013, 试验)
Hadoop continues to be the most popular framework to develop distributed data-processing applications. Although programming Hadoop applications in Java is not particularly difficult, designing efficient MapReduce pipelines does require a good amount of experience. Apache Pig simplifies Hadoop development by offering a high level language, called Pig Latin, and an execution runtime. Pig Latin is procedural and provides a SQL-like interface to work with large datasets. The execution infrastructure compiles Pig Latin into an optimized sequence of MapReduce programs that run on the cluster. Pig Latin is extensible through user-defined functions in different languages such as Ruby, JavaScript, Python and Java.
Semantic monitoring(May 2013, 试验)
Development teams typically produce tests that specify and validate application behavior, but stop running them once the application goes into production. This is a missed opportunity. Semantic monitoring uses your tests to continuously evaluate your application, combining test-execution and realtime monitoring. With microservices, and similar fine-grained architectural approaches, it is increasingly important to test their interaction at run-time. Incorporating the validation of consumer-driven contracts into a monitoring facility is one way to approach this. While still evolving, we see great promise in the merging of two separate but important verification schemes.
Mobile first(May 2013, 试验)
We are rapidly heading towards a world where the majority of consumer interactions are from mobile devices. Mobile first embraces this trend by designing user interfaces and server interactions that target mobile devices in the first instance. The mobile first strategy contrasts with approaches that assume a highly capable client device connected to a fast and reliable network and then degrade the experience to fit the limitations of the device.
NuGet(May 2013, 采纳)
Package systems for third-party library management continue to gain acceptance and features across all platforms. We called out NuGet as a recent entry, and the addition of Chocolatey NuGet exemplifies the advances and capabilities springing up around this essential agile engineering practice.
NuGet(Oct 2012, 试验)
Package management systems are a widely accepted practice for incorporating third party libraries. Tools such as RubyGems, Maven, APT, are available at both language and system level. NuGet is such a system for .Net platform. It consists of a Visual Studio IDE extension and a PowerShell module that opens the possibility for further improving build automation on the .Net platform.
WS-*(May 2013, 暂缓)
We are reiterating our advice that given the progress and acceptance of simpler web-as-platform techniques such as REST and OAuth and the known issues with WS-*, it should only be used cautiously.
WS-*(Jul 2011, 暂缓)
Previously our advice has been to tread carefully when using the WS-* stack beyond the basic profile. Given the progress and acceptance of simpler web-as-platform techniques such as REST and OAuth and the known issues with the WS-*, it should only be used cautiously.
WS-*(Jan 2011, 暂缓)
Web services are now widely used as an enabler for service oriented architectures as well as for the integration of existing applications. We see mature tools and largely interoperable implementations for web service standards covered by WS-I Basic Profile, but we remain skeptical about the proliferation and value of WS-* standards beyond Basic Profile.
Guerrilla user testing(May 2013, 采纳)
Bringing users in to a controlled environment for formal testing can be a slow and expensive proposition. Much useful, qualitative feedback can be gathered quickly and cheaply through guerrilla user testing - by going out into the world and testing with small samples of the general public. Another alternative is remote usability testing, where you can send out everything from wireframes to final applications for testing by people all over the world. Usabila, Loop11 and Treejack all provide tools where you can ask users to carry out specific tasks, and capture everything from the time taken to complete a task, to the user’s thoughts and feelings while doing so.
UIAutomator(May 2013, 评估)
UIAutomator looks like the most promising tool for testing Android user interfaces by allowing fine-grained control over components during test and facilitating testing on multiple Devices.
Database migrations for NoSQL(May 2013, 试验)
NoSQL data stores continue to become mainstream, and teams should acknowledge the need for database migrations for NoSQL. Especially with an implicit or dynamic schema you are likely to want to reconfigure data over time. There are several approaches such as running an explicit migration when deploying a new build of your application, or using dynamic migrations in code as documents are loaded and processed.
Faraday(May 2013, 评估)
Several Thoughtworks teams called out the usefulness of Faraday, a Ruby HTTP client library that provides a common interface over a variety of adapters and integrates nicely with Rack middleware.
Calatrava(May 2013, 评估)
We have previously been skeptical of claims of reusable code working across platforms. Our experience with many tools in the market has been mixed and we advise caution to our clients who are looking at these types of solutions. Taking an approach that carefully navigates these dangerous waters, we feel Calatrava is worth evaluating for mobile application development. The framework neatly follows the separation of business and presentation logic, maximising reuse where there is commonality, and providing native access where speed or device-specific idioms are to be followed.
BigQuery(May 2013, 试验)
The amount of data that even a relatively low volume website can generate is huge. Once you add in analytics, business metrics, demographics, user profiles and multiple devices, it can become overwhelming. Many organizations use data warehouses as a repository with data being sucked in from all parts of the organization. The challenge here is that these often turn into “Data Fortresses.” Even getting timely business metrics becomes a challenge, let alone running exploratory queries across the entire data set. Technologies like the cloud based BigQuery help. The pay-as-you-go model and the ability to do ad hoc queries lets you gain insight without buying specialist hardware and software. A data-driven business should put data in the hands of the decision makers, not hidden behind technological barriers and bureaucracy.
BigQuery(Oct 2012, 评估)
Google’s BigQuery brings data analytics to the cloud. Rather than loading data into an expensive data-warehouse with predefined indexes, BigQuery allows you to upload and investigate a data set through ad-hoc SQL-like queries. This is a great way to create a cheap proof-of-concept or even a complete application, as processing of hundreds of gigabytes of data by thousands of servers happens in seconds.
Frank(May 2013, 采纳)
Frank is an open source library that allows functional tests for iOS written in Cucumber and executed on a remote device. This fills an important niche where acceptance test-driven development was previously cumbersome and awkward.
Embedded servlet containers(May 2013, 采纳)
In previous radars we have talked about embedded servlet containers, and these are now widely adopted on our projects. Tools such as SimpleWeb and Webbit take the simple, embedded approach further and offer raw HTTP server functionality without implementing the Java Servlet specification. At the same time, Tomcat, the most popular Java application server, is increasingly used in embedded setups and Microsoft provides self-hosted servers for the .NET framework, lending further weight to this Trend.
Embedded servlet containers(Oct 2012, 采纳)
We have talked much already about embedded servlet containers - and these are now widely adopted on our projects. Tools such as SimpleWeb and Webbit take the simple, embedded approach further and offer raw HTTP server functionality without implementing the Java Servlet specification. We are pleased to see a corresponding reduction in the complexity of test code that takes advantage of this.
Embedded servlet containers(Mar 2012, 试验)
Embedding a servlet container, such as Jetty, inside a Java application has many advantages over running the application inside a container. Testing is relatively painless because of the simple startup, and the development environment is closer to production. Nasty surprises like mismatched versions of libraries or drivers are eliminated by not sharing across multiple applications. While you will have to manage and monitor multiple Java Virtual Machines in production using this model, we feel the advantages offered by the simplicity and isolation are significant.
Require.js & NPM(May 2013, 试验)
Our continued use of node.js on new production applications has re-enforced our need for reliable packaging of JavaScript code and libraries. The Node Package Manager (npm) is an important part of the node.js ecosystem and a useful tool for packaging node.js applications. Developers of browser applications with large amounts of JavaScript or CoffeeScript should consider Require.js to help with structuring their code and loading dependencies at run time
Logs as data(May 2013, 试验)
Log files generated by web servers, databases, networking infrastructure, and back-end systems are a valuable source of operational and behavioral data for a business. In the past, these files were mostly viewed as a source of diagnostic information in the case of failure, but with lowered cost of storage, and availability of tools such as Splunk for indexing and retrieving millions of events, they can also be a source of customer insights. Treating logs as data and storing complete logs instead of just collecting predefined metrics provides a means to answer novel questions that a business could not have previously anticipated.
JavaScript as a platform(May 2013, 试验)
JavaScript is moving outside of the browser, emerging as an important technology for cross-platform development. It is front-and-center in the approach to code reuse taken by Node.js, Meteor.js and mobile frameworks like Calatrava. Along with the recent proliferation of other languages that compile to JavaScript, this makes us wonder if we should start to consider JavaScript as a platform and not just a language.
Immutable servers(May 2013, 采纳)
Precedents set by cloud providers are now changing expectations within the corporate datacenter. In the cloud, many systems scale automatically, either to provide additional availability or in response to increased demand. Crucial to managing a growing estate, immutable servers, or ‘phoenix servers’, are a sensible approach for enterprises looking at IaaS and PaaS. In contrast, custom-configured ‘snowflake servers’ increase the load on the operations group and encourage a “works on my machine” mentality. Being able to re-provision machines - hard or virtual - from scratch using tools such as Chef or Puppet can drastically reduce the complexity of managing large server farms. Coupled with software that is designed to withstand failure, this will lead to more scalable and reliable systems.
Analyzing test runs(May 2013, 试验)
Failing tests reveal bugs in production code. However, analyzing test runs for other properties can reveal interesting information. A simple example would be to monitor which tests fail frequently and run them earlier in your build pipeline to get fast feedback. Similarly, tracking other properties such as test execution times and ratios of long-running tests to fast-tests can provide actionable metrics.
Scratch, Alice, and Kodu(May 2013, 试验)
We think it is essential to inspire the next generation of technologists. Scratch, Alice, and Kodu are programming languages that rely on visual environments and building blocks as teaching devices. They offer exciting possibilities for educational programs and organizations intending to foster programming knowledge in environments beyond academia.
Riak(May 2013, 试验)
Riak is a distributed key-value store that is schema-less and data-type agnostic. It can be put to good use in write-heavy projects to store data such as sessions, shopping carts and streaming logs - whilst it retains the ability to perform complex queries in a full-text search. The distributed cluster can self-recover without a single master, has tuneable consistency and availability settings and can do collision detection and resolution if needed - all of which can be particularly helpful in high availability environments.
Riak(Mar 2012, 评估)
Riak is a distributed key-value store that is schemaless and data-type agnostic. It can be put to good use in write heavy projects to store data such as sessions, shopping carts and streaming logs. The ability of the distributed cluster to self recover, distribute data across the cluster with tunable consistency and availability settings, do collision detection and resolve those if needed can be helpful in high availability environments and provide interesting solutions in the architecture.
Light Table(May 2013, 评估)
Like most good software developers, we choose our tools with care. We are especially keen on interesting departures from the norm, which is why we helped back the Light Table Kickstarter project. While still very early in development, the promised interactivity rivals the best of the Smalltalk world, with a modern twist; we are anxious to see what will come of this ambitious project.
Browser-based templating(May 2013, 评估)
We see several JavaScript frameworks embrace browser-based templating, moving more layout work to the client. While this approach is useful in many cases, it does introduce operational issues involving caching, performance, and search. We believe these tools should be assessed carefully to ensure suitability for the target deployment environment.
RubyMotion(May 2013, 评估)
Introducing a Ruby compiler and toolchain for developing iOS applications, RubyMotion has unsurprisingly caused quite a stir in the Thoughtworks development community. There continues to be a need to understand the underlying iOS APIs and some Objective-C when building applications, but there are clear benefits for those who find working with the Ruby language and tools more comfortable.
JavaScript MV* frameworks(May 2013, 试验)
Single-page web application development continues to flourish along with the frameworks supporting data binding, client-side templates, validation, and other capabilities. The JavaScript MV* frameworks in active use on Thoughtworks projects include AngularJS, Knockout, and Ember.js. Each has advocates and a few detractors. We expect continuing innovative churn in this vibrant space.
Singleton infrastructure(May 2013, 暂缓)
Sometimes, architectural decisions lead you to incorporate infrastructure items that you can only afford one of, such as mainframes or search appliances. This is a terrible idea. It severely restricts testing and deployment flexibility. We strongly favor infrastructure you can easily set up and tear down. Singleton infrastructure belongs to misguided vendor-driven architectures of the past.
Gradle(May 2013, 采纳)
Language-based build tools like Gradle and Rake continue to offer finer-grained abstractions and more flexibility long term than XML and plug-in based tools like Ant and Maven. This allows them to grow gracefully as projects become more complex.
Gradle(Oct 2012, 试验)
Two things have caused fatigue with XML-based build tools like Ant and Maven: too many angry pointy braces and the coarseness of plug-in architectures. While syntax issues can be dealt with through generation, plug-in architectures severely limit the ability for build tools to grow gracefully as projects become more complex. We have come to feel that plug-ins are the wrong level of abstraction, and prefer language-based tools like Gradle and Rake instead, because they offer finer-grained abstractions and more flexibility long term.
Gradle(Mar 2012, 评估)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Gradle(Jul 2011, 评估)
Gradle is an attempt to bring sanity to the enterprise build space by marrying best-of-breed tools with cutting edge techniques. Gradle allows you to interact with your existing Maven repositories, but adds scriptability to your builds with a clean domain specific language.
Maven(May 2013, 暂缓)
Language-based build tools like Gradle and Rake continue to offer finer-grained abstractions and more flexibility long term than XML and plug-in based tools like Ant and Maven. This allows them to grow gracefully as projects become more complex.
Maven(Oct 2012, 暂缓)
Maven has long been a staple of build automation in the Java space. However, given its lack of flexibility and support for automation best practices, especially in the Continuous Delivery domain, the use of alternatives such as Gradle should be considered.
Logic in stored procedures(May 2013, 暂缓)
It is startling to us that we continue to find new systems in 2011 that implement significant business logic in stored procedures. Programming languages commonly used to implement stored procedures lack expressiveness, are difficult to test, and discourage clean modular design. You should only consider stored procedures executing within the database engine in exceptional circumstances, where there is a proven performance issue.
ClojureScript(May 2013, 评估)
ClojureScript illustrates just how cross-platform the core of Clojure really is: they ported the primary parts to run on JavaScript. It is missing some of the whizzbang features of Clojure on the JVM and CLR, like software transactional memory, but has a surprisingly high fidelity with its more sophisticated cousins. One interesting option afforded by ClojureScript is the ability to send data structures à la JSON using ClojureScript as the data structure. Because Clojure is a Lisp, this means that you can also send “real” code.
F#(Oct 2012, 评估)
Microsoft’s F# continues to evolve, with the recent release of F# 3.0 beta. F# is excellent at concisely expressing business and domain logic. Developers trying to achieve explicit business logic within an application may opt to express their domain in F# with the majority of plumbing code in C#.
F#(Jul 2011, 评估)
The functional languages F#, Clojure and Scala still reside in the assess ring of the radar. Interest in functional languages continues to grow. Two characteristics of functional languages in particular are driving this interest, immutability with its implications for parallelism and functions as first class objects. While the introduction of closures to C# brings some of the latter capability, functional languages are almost synonymous with immutability. The placement of these languages within the assess ring indicates our view of their relative maturity and appropriateness. F#, based on OCaml, is fully supported within the Visual Studio toolset. F# includes support for objects and imperative constructs in addition to functional language constructs in a natural way. Scala, like F#, combines the object and functional paradigms, although the syntax of Scala is more Java-like. Clojure began as a JVM language and is now available on the .NET CLR. Clojure does allow for mutable state although it has an extensive set of immutable persistent data structures, all supporting multi-threaded applications. There are many similarities between these three languages, but at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala. More work clearly needs to be done to validate this assertion.
F#(Apr 2010, 评估)
In the previous radar, we lumped functional languages together in a group. For this version, we’ve exploded that group and started calling out the ones interesting to us. Of the current crop of functional languages, the one we like the most is Clojure: a simple, elegant implementation of Lisp on the JVM. The other two that we fi nd interesting are Scala (a re-thinking of Java in functional form) and F#, the OCaml derivative from Microsoft that now appears “in the box” in Visual Studio 2010.
AppCode(Oct 2012, 采纳)
Apple’s mobile devices are going strong and native apps are a cornerstone of their success. Writing these native apps has become much more pleasant and productive since JetBrains launched AppCode, an IDE for iOS and OS X development that replicates the strengths of their IDEs for other platforms.
SaaS performance testing tools(Oct 2012, 试验)
Rather than wrestling with licenses and setting up clusters of machines for performance testing, we’re seeing a rise in SaaS performance testing tools such as Blitz.io and Tealeaf. These services make it easy to run performance tests with a huge number of geographically diverse clients, without investing heavily in infrastructure.
Feature branching(Oct 2012, 暂缓)
Disappointingly, we continue to see development teams embrace the practice of feature branching to isolate work and defer integration. Feature branches commonly cause significant pain and unpredictability during late merges, but more importantly prevent the continual design improvement necessary to maintain high quality software. We recommend continuous integration and branch by abstraction as an alternative to feature branching.
VCS with “implicit workflow”(Oct 2012, 暂缓)
Some tools seek to enable and facilitate different ways of working. Unfortunately other tools are created using a different premise, one of low trust in users and the need to enforce a predefined process. ClearCase and TFS do this. This makes version control systems with “implicit workflow” unsuitable tools for modern agile software development. Project methodologies and the best ways of working on a project need to emerge. Tools that enforce high ceremony around things like check in just get in the way and kill productivity.
Vert.x(Oct 2012, 评估)
Representing yet another evolution away from traditional, free-standing application containers, Vert.x is an application framework that bridges synchronous and asynchronous programming styles. This gives the programmer the option to trade off scalability and performance for simplicity. Unlike Node.js, Vert.x is a library that can be called from a variety of languages supported on the JVM, including Java, Ruby and JavaScript.
Hybrid clouds(Oct 2012, 试验)
Hybrid clouds combine the best features of public clouds and private data centers. They allow applications to run in a private data center during normal periods, and then use rented space in a public cloud for overflow capacity during peak traffic periods. There are now a number of infrastructure solutions that allow automatic and consistent deployment across a hybrid cloud, such as Palette and RightScale. With robust offerings from Amazon, Rackspace and others, we are moving hybrid clouds to “Trial” on this edition of the radar.
Hybrid clouds(Mar 2012, 评估)
Hybrid clouds describe a set of patterns that combine the best features of public clouds and private data centers. They allow applications to run in a private data center during normal periods then use rented space in a public cloud for overflow capacity during peak traffic periods. Another way to combine public and private clouds in an agile way is to use the elasticity and malleability of public clouds for developing and understanding an application’s production characteristics, then moving it into permanent infrastructure in a private data center when it is stable.
Meteor.js(Oct 2012, 暂缓)
Meteor.js is a client- and server-side JavaScript application framework, run inside a web browser, or in a Node.js container, and backed by MongoDB for persistence. It uses “Smart Packages” - little bundles of code that can run in the browser or as part of a cloud service. It allows hot code deploys and live in-browser updates. We think the idea is great, even if the framework is not yet ready for primetime.
ATOM(Oct 2012, 采纳)
One of the foundational technologies of the Web as platform, Atom is an extensible data syndication format with broad tool support in almost all languages. In conjunction with the Atom Publication Protocol, Atom comprises a lightweight platform for publishing and consuming data with high quality-of-service guarantees. Atom-based solutions trade scalability for latency, however, making Atom often inappropriate for very low-latency scenarios.
JavaScript micro frameworks(Oct 2012, 试验)
With mobile applications on the rise, JavaScript size and performance is even more critical. JavaScript micro frameworks have emerged as a direct response to ‘bloat’ in some of the larger libraries. These small libraries do exactly one thing, such as DOM selection or MVC, and can be under one kilobyte in size. By combining a number of micro frameworks, developers can get exactly the functionality they need without the overhead of a larger library. Microjs.com hosts a collection of these micro frameworks, as well as a tool that can bundle them into a single library.
Agile analytics(Oct 2012, 试验)
Applying agile methods to data warehousing, business intelligence and agile analytics provides better return and improved business responsiveness. This is done by applying lightweight technologies like REST services to move data around in near real-time instead of batch updates. This allows information about customer behavior and application usage to be derived and responses incorporated within the applications for better user experience and data visualization.
Java portal servers(Oct 2012, 暂缓)
A continuing cause of delivery problems lies in the use of Java Portal Server packages. These problems occur in both open source and commercial portal platforms. The promised productivity of these platforms is hindered by their complex and unwieldy programming models and difficulty in automating deployment, data migration, and tests. Although product demos are compelling, the base features of portal products are often a poor fit for real web applications, while the extra advertised features such as single sign-on or search are usually already served by existing, targeted, enterprise assets.
Infrastructure automation of development workstations(Oct 2012, 试验)
Automation is one of the core practices of Continuous Delivery. While companies are getting better at automating the management of infrastructure and environments, one commonly forgotten aspect is infrastructure automation of development workstations. This leads to huge gains in productivity by avoiding manually building specific environments and allows a seamless pairing environment. As with other parts of the environment, tools like Puppet and Chef can be used though they are not entirely necessary as the judicious use of platform packaging and language build tools can be sufficient.
Care about languages(Oct 2012, 采纳)
The industry is experiencing something of a renaissance in programming languages. Thoughtworks thinks it is time to start assessing which other languages will help your organization while taking stock of the useful lifetime remaining for your current choices. You need to care about languages. Traditionally structured organizations with separate support teams may find skills constrain choice, DevOps offers a path forwards here.
AngularJS and Knockout(Oct 2012, 试验)
We are seeing a common pattern of creating single-page web applications. Rather than requiring full page refresh, these request smaller sets of data from the server, and change the displayed content of their page through modifying the DOM. To make this more manageable, JavaScript MV* frameworks have been developed that support data binding, client-side templates, and validation. While lightweight applications may not need a framework, for more complex scenarios, AngularJS and Knockout should be considered as the current front-runners in this field.
Domain-specific PaaS(Oct 2012, 试验)
We find that many businesses are starting to build their own internal cloud deployment environments that can be easily replicated for development and testing environments. In many cases, provisioning is selfservice, and with a single keystroke, developers can create a set of hosts that implement core enterprise assets and collaborating systems. In a sense, this is a domain-specific PaaS offered to internal customers.
Domain-Specific Languages(Oct 2012, 试验)
Domain-Specific Languages is an old technique that we think is significantly under-used. We hope that the publication of Martin Fowler’s latest book will encourage more people to utilize them.
Domain-Specific Languages(Aug 2010, 试验)
A significant amount of innovation occurred in the JavaScript space thanks to the Ruby on Rails community. This same community has helped to move both internal and external DSLs forward as a means for more closely mapping business requirements in code. Ruby’s syntax lends itself easily to the creation of easily readable DSLs, while language tools such as ANTLR help to make the creation of new domain specific languages more accessible to interested developers.
Out-of-container functional testing(Oct 2012, 试验)
With the popularity of embedded HTTP servers increasing, so has the technique of out-of-container functional testing. That is writing tests at the boundary of the system, using a mock container to provide both fast feedback and high coverage. Servers such as Jetty and tools like Plasma for the .Net platform can provide a significant reduction in the time it takes to run your test suite.
Linux containers(Oct 2012, 试验)
One style of virtualization that is particularly attractive for SaaS and PaaS implementations is the virtual container. Linux containers such as OpenVZ provide the isolation and management benefits of a virtual machine without the overhead usually associated with general-purpose virtualization. In the container model, the guest OS is limited to being the same as the underlying host OS, but that is not a serious limitation for many cloud applications.
Require.js(Oct 2012, 试验)
As adoption continues to expand, so does the size of many JavaScript codebases. To improve modularity of code and help manage this, we are seeing teams embrace libraries such as Require.js. Using the Asynchronous Module Definition (AMD) format, code is split into modules, easing development and maintenance, and an optimization tool then combines and minifies scripts for production deployment.
Jade(Oct 2012, 试验)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Jade(Mar 2012, 试验)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Deployment and scripting test tools(Oct 2012, 评估)
With deployment automation tools maturing, including PowerShell on Windows, scripts are increasingly sophisticated and contain a lot of logic. We recommend deployment and scripting test tools, such as Pester for PowerShell and TOFT for Chef and Puppet. It is critical to have good test coverage around the most important aspects of your deployment automation.
GemJars(Oct 2012, 评估)
In a mixed Ruby/Java application, running on the JVM, there are differences in package format and dependency resolution that need to be dealt with. By providing an Ivy compatible proxy that packages RubyGems as JARs and uses Ivy to resolve Gem dependencies, GemJars consolidates and simplifies the building of truly polyglot codebases.
Windows Phone(Oct 2012, 评估)
Despite a promising start to Windows Phone, a well thought-out user interface, and probably the best development experience of any mobile platform, we have seen several stumbles in the execution of the platform strategy by Microsoft and its partners. This makes us less optimistic about the future of the platform than we were in the last radar.
Windows Phone(Mar 2012, 试验)
Windows Phone 7 has surprised even some of the long time critics of Windows platforms. After many failed attempts, Microsoft has managed not only to produce a mobile operating system that provides a user experience on par with the other major contenders in the space but also the development support to go with it. Microsoft is making Windows Phone 7 a viable competitor and another choice for a more integrated experience in the corporate arena. Whether it will be able to change adoption trends remains to be seen.
Health check pages(Oct 2012, 采纳)
We have found adding simple health check pages to applications is incredibly useful. This allows people to quickly understand the health of an individual node. We often extend them to add metrics like the number of orders placed, error rates, or similar information. Using simple embedded web servers, even non-web based services can easily expose internal information over HTTP. By using microformats, these web pages can easily be scraped by other monitoring tools to become part of holistic monitoring.
Rake for Java & .NET(Oct 2012, 试验)
Of all the build tools and languages we use across our projects, the one we keep coming back to is Rake. Rake is a beautiful, simple and powerful build language implemented as an internal Domain-Specific Language on Ruby. Ruby’s ability to run across several virtual-machine platforms means that Rake is equally available - while leaving open the option to utilize more language-specific tools for some tasks. Finding a similar combination of elegance and flexibility is difficult regardless of your platform, so we recommend trying Rake for Java and .Net projects.
Test recorders(Oct 2012, 暂缓)
Test recorders seem invaluable as they provide a quick way to capture navigation through an application. However, we strongly advise against their regular use, as it tends to result in brittle tests which break with small changes to the UI. The test code they produce tends to be relatively poor and riddled with unnecessary duplication. Most importantly, test recorders tend to cut channels of communication between the test automation and development teams. When faced with an application that is difficult to test through the user interface, the solution is to have a critical conversation between the teams to build a more testable UI.
Single threaded servers with asynchronous I/O(Oct 2012, 试验)
Node.js is just one example of a class of single threaded servers with asynchronous I/O that are seeing increased popularity. A traditional web or application server associates each incoming request with a thread until all the processing tasks associated with that request are complete and the response has been sent back. If any of those tasks involve I/O, the thread blocks while that I/O takes place. This approach can waste finite resources such as file descriptors and memory since each connection occupies a thread whether or not that thread is actually consuming CPU cycles. An alternative architecture is starting to emerge in implementations like Node.js (a JavaScript server running on Google V8), Nginx (an open source web server and proxy), and Webbit (a Java application server), that uses a single thread to serve many connections, processing all I/O asynchronously. These servers support orders of magnitude more simultaneous connections because each one consumes far fewer resources.
Declarative provisioning(Oct 2012, 试验)
Tools such as Pallet offer a compelling approach to environment creation and management through declarative provisioning. Usually, this is accomplished by declaring your environment topology - a number of instances, OS, network configuration and applications - using a DSL, and then creating the entire environment automatically via a commandline tool. This approach differs in the decoupling of instance creation and application provision, and in the addition of the ability to declare dependencies between domain-specific application-level services over multiple boxes.
Configuration in DNS(Oct 2012, 试验)
Application deployments often suffer from an excess of environment-specific configuration settings, including the hostnames of dependent services. Configuration in DNS is a valuable technique to reduce this complexity by using standard hostnames like ‘mail’ or ‘db’ and have DNS resolve to the correct host for that environment. This can be achieved in multiple ways, including split-horizon DNS or configuring search subdomains. Collaboration between development teams and IT operations is essential to achieve this, but that is unfortunately still difficult in some organizations.
Polyglot Persistence(Oct 2012, 试验)
Polyglot persistence is the technique of storing data in various data stores based on efficiency and how that data is going to be used. Do not just use the default database, often an RDBMS, for all the needs of the application. Instead, ask questions like: Does session management data belong in the database or does it belong in a key-value store? Do relationships between customers and products belong in a graph database? Using NoSQL databases like MongoDB, Riak and Neo4J allows us to reconsider how data is treated, even with-in a single application.
Work-in-Progress limits(Oct 2012, 采纳)
It might sound odd for us to mention this, given how mainstream Agile development has become, but we are noticing teams rediscover and embrace work-in-progress limits. Methods such as Kanban limit the amount of in-flight work, forcing better workflow into the team and more visibility into bottlenecks.
Remote usability testing(Oct 2012, 试验)
Bringing users in to a controlled environment for formal testing can be a slow and expensive proposition. Much useful, qualitative feedback can be gathered quickly and cheaply through guerrilla user testing - by going out into the world and testing with small samples of the general public. Another alternative is remote usability testing, where you can send out everything from wireframes to final applications for testing by people all over the world. Usabila, Loop11 and Treejack all provide tools where you can ask users to carry out specific tasks, and capture everything from the time taken to complete a task, to the user’s thoughts and feelings while doing so.
ESB(Oct 2012, 暂缓)
IT departments are increasingly striving to liberate data from disparate systems. A broad set of approaches have been promoted under the generic term Service Oriented Architecture (SOA). This has led to confusion about what the term and approach actually means. We believe businesses do not need the complex enterprise service bus products advocated by vendors. ESBs actively undermine the reasons for choosing the bus approach: low latency, loose coupling, and transparency.
Zucchini(Oct 2012, 评估)
Zucchini is a testing framework that provides Cucumber-style BDD testing for iOS apps. It uses CoffeeScript for feature definitions, takes screenshots as tests are run, and we’ve been very happy with it.
Vagrant(Oct 2012, 试验)
The tool Vagrant makes it simple for teams to distribute virtualized development environments constructed using version-control friendly descriptors. Vagrant helps eliminate environmental differences in development and reduce troubleshooting waste.
Highcharts(Oct 2012, 试验)
Increasingly performant JavaScript engines, combined with widespread support for embedded SVG documents in HTML, has lead to pure JavaScript-based client-side graphing and visualization solutions gaining a lot of traction. Highcharts is one of the best ones we have come across, with out-of-the-box support for multiple highly-configurable interactive chart types, and the ability to easily render large data sets.
Mobile payment systems(Oct 2012, 采纳)
Despite apparent resistance in the Global North, mobile payment systems such as Kenya’s M-Pesa are providing secure cashless monetary transactions. With the service rolling out across Africa, the system opens up the market for the millions of people with mobile phones but lacking access to traditional banking outlets. Providers such as Square are slowly improving the situation, but the North continues to lag.
Care about hardware(Oct 2012, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Care about hardware(Mar 2012, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Advanced analytics(Oct 2012, 采纳)
Machine learning, semantic analysis, text mining, quantitative analytics, and other advanced analytics techniques have steadily matured over the past 15 years. They offer incredible potential for prediction, forecasting, identifying repeatable patterns, and providing insight into unstructured data. Historically, our ability to store and rapidly analyze large amounts of audio, video and image data has been severely limited. This placed constraints on sample size, as well as the time it would take to validate analytical models and put them into production. Now, using a spectrum of new technologies like NoSQL, data harvesters, MapReduce frameworks, and clusters of shared-nothing commodity servers, we have the power necessary to make truly effective use of these techniques. Combined with the massive increase in global data available from sensors, mobile devices and social media and we see this as a field with tremendous opportunity.
Dependency Structure Matrices(Oct 2012, 试验)
We strongly favor code-base visualization techniques. In particular, Dependency Structure Matrices (DSM) have proven to be extremely useful, especially in support of an evolutionary architecture and emergent design. Tools support for DSM is widespread.
Silverback(Oct 2012, 采纳)
There are a couple of usability testing tools that match our preferred ‘guerrilla’ approach. Eye-tracking has long been a useful technique when designing compelling user interfaces, however the equipment and software associated with it is expensive and typically requires the use of specialist firms. Crazy Egg is a cheaper, software-only solution that produces heat maps based on mouse movement. This movement has a strong correlation with gaze, and can be used as a reasonable approximation. Silverback captures not only the screen during a test, but also records the face and voice of the user. This can be invaluable in sharing rich test experiences with the wider development team.
Logic-free markup(Oct 2012, 评估)
While MVC has been a staple of web development for the past few years, most libraries and frameworks fail to adhere to one of its most important principles: keeping logic out of the view layer. The consequences of not having logicfree markup include complex dependencies, difficulty testing and inability to reuse code. Recent DSLs like Mustache are available for many languages and platforms and have started to turn the trend. They allow editing in any tool, without extra requirements for language support and provide huge gains for UI development and overall application design.
Open source IaaS(Oct 2012, 评估)
Selecting the right cloud provider from an almost bewildering array of options continues to be difficult. One strategy is to adopt an open source IaaS platform such as OpenStack or CloudStack. This allows you to run a private cloud that is consistent with a public cloud, and to migrate from one cloud provider to another should the need arise. Going one step further, Apache’s Deltacloud abstracts away from specific provider APIs to give a consistent experience across cloud platforms.
SASS, SCSS, LESS, and Stylus(Oct 2012, 采纳)
CSS has been an extremely popular and effective DSL for styling web pages. It does, however, have some annoying limitations which have led to a number of languages that build on CSS to make it easier to write and modify. We’ve had good experiences with SASS, SCSS, and LESS.
Zero-code packages(Oct 2012, 暂缓)
There are a number of enterprise software packages on the market that purport to offer flexible functionality with zero coding. This is certainly an appealing notion – that a non-technical business user could configure software to the unique requirements of any business without learning a programming language or hiring a professional software developer. However, it should be kept in mind that any change that affects the behavior of software in production, whether it is code, configuration, data or environments, could cause defects or failures in the business system. Writing code is only one step in a professional software production lifecycle. The need for repeatable analysis, testing, build, and deployment does not go away because the system is modified via a dragand- drop interface instead of a high-level programming language. When evaluating a zero-code package, ensure that the the product supports these processes and that you have the necessary IT support structures in place to implement them.
Database based integration(Oct 2012, 暂缓)
For those organizations that are required to integrate systems, many continue to use a common database, sharing data between applications through the database tier. In many cases this has become an established and accepted architectural pattern: database based integration. The side affect of such an approach is greater coupling of database schemas, release schedules, performance and quality of service across applications.
Crazy Egg(Oct 2012, 评估)
There are a couple of usability testing tools that match our preferred ‘guerrilla’ approach. Eye-tracking has long been a useful technique when designing compelling user interfaces, however the equipment and software associated with it is expensive and typically requires the use of specialist firms. Crazy Egg is a cheaper, software-only solution that produces heat maps based on mouse movement. This movement has a strong correlation with gaze, and can be used as a reasonable approximation. Silverback captures not only the screen during a test, but also records the face and voice of the user. This can be invaluable in sharing rich test experiences with the wider development team.
Acceptance test of journeys(Mar 2012, 试验)
Many teams focus acceptance testing at the story level, but this can lead to a large number of hard to maintain tests, and a focus on completing individual stories instead of coherent functionality needed to go live. A more holistic approach is to group user stories into journeys for which we create acceptance tests. Journeys through a system are a set of user interactions that provide value for both users and the business. At the outset a journey acceptance test will cover only one step, but as stories are completed the journey is expanded to encompass each stage in the user’s progress. Once the acceptance test of journeys passes, this tells us we have delivered real value.
Github(Mar 2012, 采纳)
Starting from a challenge posed to the Linux community to stop using commercial version control, Git has proved itself. Git embodies a well architected, high performance implementation of distributed version control. Git is powerful, so it should be used with respect, but that power enables agile engineering workflows that simply cannot exist with other tools. Git’s popularity is supported by the existence of GitHub. GitHub combines public and private Git repositories, social networking, and a host of other innovative tools and approaches.
Github(Jan 2011, 评估)
Subversion moves back into the Adopt section of the radar because it is a solid version control tool suitable for most teams. We consider Subversion’s features to be the basic standard for a modern version control tool. Thoughtworkers continue to embrace and recommend Distributed Version Control tools such as Git and Mercurial, but we caution that these systems often require deeper understanding to get the most out of them. New to the radar is GitHub, a “social coding” tool supporting both source code hosting and social networking. GitHub is arguably one of the main reasons Git has become the leading DVCS tool, and GitHub’s collaboration features are often used by enterprises that need to support distributed teams.
RIA(Mar 2012, 暂缓)
We have long been less than enthusiastic about RIA technologies such as Flash and Silverlight because of vendor lock in potential, anemic support for agile engineering practices, and potential for overuse. It seems even the large vendors are starting to agree with us. Now that modern versions of HTML handle most of the common cases that formerly required RIA, we feel that new projects must have enormous justification and careful strategic thought before using any of these technologies.
RIA(Aug 2010, 暂缓)
Rich Internet Applications (RIA) are a popular topic, driven by the effort and marketing of big vendors pushing their offerings. RIA is useful for complex visualizations but ill-suited for other programming tasks because it doesn’t fully support the engineering hygiene we require for our tools: testing is difficult and application partitioning is cumbersome. These frameworks also don’t support common elements we take for granted in applications hosted in a browser: bookmarking, addressability, browser controls, and other aspects. We’re not entirely critical of these tools, but think that their sweet spot is rich visualizations, not building traditional data entry CRUD applications.
RIA(Jan 2010, 评估)
Our position on Rich Internet Applications has changed over the past year. Experience has shown that platforms such as Silverlight, Flex and JavaFX may be useful for rich visualizations of data but provide few benefits over simpler web applications. Given that these toolsets have limited support for automated testing, it would suggest that a more traditional web application stack provides greater value for enterprise development. We recommend only using RIA platforms for rich visualizations incorporated into web applications, not as comprehensive development targets.
Evolutionary architecture(Mar 2012, 采纳)
We recommend adopting evolutionary architecture as an alternative to traditional up-front, heavy-weight enterprise architectural designs.
Evolutionary architecture(Jul 2011, 采纳)
In contrast to traditional up-front, heavy-weight enterprise architectural designs, we recommend adopting evolutionary architecture. It provides the benefits of enterprise architecture without the problems caused by trying to accurately predict the future. Instead of guessing how components will be re-used, evolutionary architecture supports adaptability, using proper abstractions, database migrations, test suites, continuous integration and refactoring to harvest re-use as it occurs within a system. The driving technical requirements for a system should be identified early to ensure they are properly handled in subsequent designs and implementations. We advocate delaying decisions to the latest responsible moment, which might in fact be up-front for some decisions.
Evolutionary architecture(Jan 2011, 试验)
One principle of agile software development is the notion of the last responsible moment. This notion applied to architectural considerations is controversial among traditional architects. We believe that, given properly articulated principles and appropriate test suites, architectures can evolve to meet the changing needs of a system, allowing for architectural decisions to be made at the last responsible moment without compromising the integrity of the system. We call this approach evolutionary architecture, in that we allow the architecture to evolve over time, always respecting the architectural guiding principles.
Evolutionary architecture(Jan 2010, 评估)
We assist many of our clients in adapting enterprise software architecture practices to fit within an Agile software delivery approach. In the past year we have seen increased interest in evolutionary enterprise architecture and how service oriented architectures shape the boundaries between enterprise units. The value of an evolutionary approach to enterprise architecture is the creation of lighter weight systems that ease integration between disparate parts. By embracing this approach and the notion of the web as an enterprise application platform, we have reduced overall complexity of application architectures, increased quality and scalability, and reduced development costs.
AppHarbor(Mar 2012, 试验)
AppHarbor is a Platform as a Service (PaaS) offering for the .NET Platform using the same pricing model and structure pioneered by Heroku. It is a promising take on the deployment of .NET applications as it abstracts away most of the underlying configuration needs that come with the platform. It is maturing quickly and we expect it will see growing interest in time to come.
Future of Java(Mar 2012, 评估)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Future of Java(Jul 2011, 评估)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Functional Java(Mar 2012, 评估)
Functional programming continues its slow but steady ascent into developer mind share and, increasingly, code bases. New languages like Clojure, Scala, and F# offer great new features. Now libraries such as Functional Java, TotallyLazy and LambdaJ are back porting some functional language capabilities, particularly around higher-order functions and collections, into Java. We like this trend because it previews common capabilities of future languages yet allows developers to stay in their comfort zone.
KVM(Mar 2012, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
KVM(Jul 2011, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
KVM(Jan 2011, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
KVM(Aug 2010, 采纳)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Server / application container end-of-life(Mar 2012, 暂缓)
A decade ago when memory was at a premium, application servers made a lot of sense. They were popular and useful as a mechanism to run and manage multiple applications on a shared server or cluster. These days applications are more often run on separate physical or virtual servers and the need for an application server is reduced. Consider evaluating server / application container end-of-life within your organization, and only use one if you benefit from the added complexity.
Buying solutions you can only afford one of(Mar 2012, 暂缓)
Many teams encounter problems that are caused by their test environment missing an expensive hardware component that is only present in production. While a pre-production environment in many cases cannot approach the scale of a production environment, all of its components should be present. We recommend not buying solutions you can only afford one of, such as SAN, firewalls or load balancers, as this prevents realistic testing anywhere but in production.
Communication between those responsible for hardware and software(Mar 2012, 采纳)
One of the principal mechanisms that allows agile software development to work is feedback loops. One common yet expensive broken feedback loop we have observed is the lack of communication between those responsible for hardware and software. The end result creates cost but not worth. You must view architecture holistically; neither hardware nor software has a full enough perspective to be successful alone.
Event API’s(Mar 2012, 试验)
RESTful APIs have become standard in our industry. A good REST API provides a simple, lightweight means of building customizations and integrations. However, many of the quick, high value integrations we’d like to build require knowing when something happened. Consider building an event API, which, when used in conjunction with a REST API, facilitates simple workflow, notification, and synchronization integrations. These integrations often require no more than 20 or 30 lines of code. Often event APIs take the form of a “web hook” or callback mechanism, but don’t be afraid of using a poll-based Atom style either. An Atom event API scales cheaply and gives the client the power to guarantee delivery.
Treating VMs like physical infrastructure(Mar 2012, 暂缓)
While virtualization is on the rise, some organizations are treating virtual machines like physical infrastructure. We frown on doing a full operating system install for each VM or using VMs for load testing. Virtual machines can be cloned, snapshotted, and manipulated in ways physical machines cannot, and also have vastly different performance characteristics than physical hardware. VMs should be used with full understanding of their benefits and limitations, otherwise you can really get into trouble with them.
Thoughtful caching(Mar 2012, 试验)
All too often caching is an afterthought used to address performance problems with a blanket approach and common cache lifetime. This leads to issues and workarounds. The “time value” of information is inherently linked to the business purpose and hence needs to be captured at the same time as other requirements. We believe thoughtful caching should be addressed early in the project and not just treated as a last minute performance fix.
Categorization & prioritization of technical debt(Mar 2012, 试验)
Technical debt is a powerful and useful metaphor for dealing with the compromises we make when building software. Unfortunately it has become a catch-all term for many different kinds of issues and problems, leading to confusion and “devaluation” of the term. A very useful approach for dealing with this is catagorization of technical debt, assigning value and prioritizing debt payback in an analogous way to user stories. This helps the team focus on the most important areas and keeps issues transparent and measurable.
PowerShell(Mar 2012, 试验)
Powershell is as important tool for managing Windows servers and applications. Built into Windows 2008 and Windows 7, Powershell allows Unix-like scripting and automation across a server farm. Scripts can be executed on remote machines, and a single command can manage hundreds of machines at once. Powershell scripts can deploy and configure applications and operating system components, and can be extended by writing .NET “commandlets.”
Open source BI/ETL tools(Mar 2012, 评估)
Open source BI tools such as Pentaho, JasperSoft, CloverETL, Talend, BIRT and SpagoBI are matching features with the proprietary tools and allowing for easy entry into the BI space. We recommend that you assess them.
Code in configuration(Mar 2012, 暂缓)
Many organizations try to minimize change in production IT environments. This frequently leads to behavioral anti-patterns. One example of this is over use of code in configuration to affect the behavior of production systems. Changes that really belong in code end up in configuration files which don’t necessarily pass through the same levels of testing as the application. Streamlining the path to production and focusing on quality simplifies rather than complicate things.
Coding architects(Mar 2012, 采纳)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Coding architects(Jul 2011, 采纳)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Coding architects(Jan 2011, 采纳)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Coding architects(Aug 2010, 采纳)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Mechanical sympathy(Mar 2012, 评估)
There is a worrying trend that developers are becoming too distant from the hardware on which their code runs. Increasing virtualization and separation between development and operations makes this worse. In stark contrast some teams are writing code that leverages mechanical sympathy to get incredibly high performance from their software. The LMAX Disruptor is an open-source example in Java. For high performance cases like finance and Big data, getting closer to the metal can yield big returns.
Evolutionary database(Mar 2012, 采纳)
If the rate at which business is changing is an indicator of change in requirements, then the days of doing upfront database design are gone. Instead, projects should follow evolutionary database techniques and continue to change their database schemas as new requirements are implemented over the course of the project. Deployment of database changes should also be automated so that the application release that relies on those changes does not have to wait for manual deployment of the database changes. Automated database deployment ensures that application and database changes can be deployed automatically. Evolutionary database and automated database deployments ensure highly productive teams a path to continuous delivery.
Evolutionary database(Jan 2011, 采纳)
The industry has seen significant changes to the way we use and store data over the past few years. Agile development practices have lead to greater emphasis on evolutionary database design, requiring new tools that support migration of schemas in line with changes to the domain model of an application. As storage space consistently becomes cheaper and data access speeds increase, many organizations are investigating the use of multiple schemas to hold data for different purposes, e.g. transactional and analysis schemas. Incremental data warehousing is becoming increasingly popular as the cost of moving data between a transactional data store and an analysis environment is less than the value of having access to near real-time reporting of critical business data.
Simple performance trending(Mar 2012, 采纳)
Starting performance tests late in a project is risky and costly. Very simple performance tests that exercise key parts of the system, run on a regular basis, are good enough to track trends, so we can react if we see a change in performance. Run these tests with your build or as an overnight job and graph the results to create simple performance trending. Complex performance tests in a truly representative environment are still useful, but don’t wait for them to start understanding how the performance of your code is changing.
Cloud Foundry(Mar 2012, 评估)
Cloud Foundry is an open source Platform as a Service that can be deployed in your own data center or hosted by VMWare. At present Cloud Foundry supports Java/ Spring applications, Rails, Sinatra, Grails and Node.js. Additional services include MongoDB, MySQL and Redis. The platform seems to be enjoying active development with the recent addition of Scala and Lift support. Cloud Foundry is an interesting addition to the growing list of PaaS solutions. It is not clear what the relationship between vFabric and Cloud Foundry will be going forward.
GWT(Mar 2012, 暂缓)
GWT is a reasonable implementation of a poor architectural choice. GWT attempts to hide many of the details of the web as a platform by creating desktop metaphors in Java and generating JavaScript code to implement them. First, in many ways, JavaScript is more powerful and expressive than Java, so we suspect that the generation is going in the wrong direction. Secondly, it is impossible to hide a complex abstraction difference like that from event-driven desktop to stateless-web without leaky abstraction headaches eventually popping up. Third, it suffers from the same shortcomings of many elaborate frameworks, where building simple, aligned applications is quick and easy, building more sophisticated but not supported functionality is possible but difficult, and building the level of sophistication required by any non-trivial application becomes either impossible or so difficult it isn’t reasonable.
GWT(Jan 2011, 暂缓)
In the last radar we placed the Google Web Toolkit (GWT) on hold and tried to provide a few reasons for that decision. As it turned out the conciseness of the text didn’t allow us to adequately make our points so that they were not misunderstood. We are interested in a discussion but our opinion about the suitability and usability of GWT has still not changed.
GWT(Apr 2010, 暂缓)
Google Web Toolkit (GWT) offers an interesting premise: write Swing-like Java code and generate unit testable JavaScript widgets and user interfaces. From a practical standpoint this doesn’t work well. First, using code-gen to produce the artifacts is time consuming, artificially extending build times and requiring manual changes to obtain optimal package layout. Second, if the JavaScript doesn’t behave exactly as you want you will have to hack the generated code. Third, using Java to generate JavaScript means that you can’t take direct advantage of the powerful features of JavaScript or numerous libraries such as JQuery. Finally, the JUnit support is quite limited, for example code using reflection cannot be tested.
Automate database deployment(Mar 2012, 采纳)
If the rate at which business is changing is an indicator of change in requirements, then the days of doing upfront database design are gone. Instead, projects should follow evolutionary database techniques and continue to change their database schemas as new requirements are implemented over the course of the project. Deployment of database changes should also be automated so that the application release that relies on those changes does not have to wait for manual deployment of the database changes. Automated database deployment ensures that application and database changes can be deployed automatically. Evolutionary database and automated database deployments ensure highly productive teams a path to continuous delivery.
Automate database deployment(Jan 2011, 试验)
When moving to continuous delivery, deployment of database changes should also be automated so that the application release that relies on those changes does not have to wait for manual deployment of the database changes. Automated database deployment ensures that the full cycle of deploying application and database changes is automated.
HTML 5(Mar 2012, 采纳)
While HTML5 is an evolving standard, many elements have reached the stage where they can be safely used in production to create both on and offline mobile web applications. Based on our projects we think HTML5 is ready to be adopted for mobile web applications. As the standard continues to evolve we expect HTML5 will become an increasingly viable alternative to native applications with the distinct advantage of being inherently cross platform.
HTML 5(Jan 2011, 试验)
HTML 5 continues to be the preferred choice for developing complex Web-based applications, with features including improved integration of rich audio and video content, clientside storage, better document structure, Web sockets and offline use. Safari, Chrome, Firefox and Opera each support significant subsets of the proposed standards, with support coming in Internet Explorer 9. HTML 5 is likely to remain in draft for some time to come, however; early adopters may wish to reflect on the bleakly comedic saga of two separate groups attempting to drive its evolution.
HTML 5(Apr 2010, 评估)
HTML 5 offers a large number of improvements over HTML 4 and XHTML 1.0. Many of these improvements are focused on providing support for developing complex web applications, and improving integration of rich content such as audio and video in standard ways. Features such as client-side storage, web sockets and offline use will further establish the position of the web browser as a viable enterprise application platform.
HTML 5(Jan 2010, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Scrum certification(Mar 2012, 暂缓)
Scrum was one of the founding approaches to Agile software development, and continues to provide a worthwhile core for the management side of software development. Scrum Certification schemes have proven counterproductive, granting only a veneer of competence, which often misleads teams into a distorted experience of agility.
Cross-platform mobile toolkits(Mar 2012, 暂缓)
With very few exceptions, tools that claimed to create seamless user experiences across Windows, Linux and OSX did not deliver. We ended up with compromised experiences on one or more of the operating systems. Mobile adds complexity to this problem with different hardware form factors and conventions for user interactions. We have made several attempts to use cross platform mobile toolkits on our projects with varying degrees of success. We saw issues like having to create a project for each platform or invoking specific native UI widgets to get things working. For these reasons we have put cross platform mobile toolkits in hold. While this may change in the future, we remain skeptical especially given past experiences on hardware that was far more homogeneous.
JavaScript as a first class language(Mar 2012, 采纳)
Rich experiences delivered via the web to desktops, tablets and mobile devices rely heavily on JavaScript, and we continue to recommend treating JavaScript as a “first class” language within your application. Developers should carefully consider how they structure, test, refactor and maintain JavaScript code, applying the same rigor as they would with any other programming language.
JavaScript as a first class language(Jul 2011, 采纳)
The maintainability, testability and readability of JavaScript is a very significant contributor to the productivity of teams producing Web-based applications and sites. Thoughtworks believes JavaScript deserves to be treated as a first class language, viewing it as second class citizen has become an excuse for a whole series of bad practice we would not tolerate in Java or C#. We need to use the same kind of tools (e.g. unit testing) and approaches (e.g. refactoring) as we’d use for any other production language. V8 and other JavaScript engines are raising the bar on performance, while Flash & Silverlight seem to be losing momentum to HTML5 + JavaScript in areas where a rich client-like experience is required. This is good news for all interested in open standards on the Web.
jQuery Mobile(Mar 2012, 评估)
Thoughtworks has used jQuery Mobile on two projects with mobile websites and had mixed experiences. One project found the library very useful for dealing with device differences and graceful degradation on older browsers. On this project we were working in a way that fit with the jQuery Mobile approach. Our other project found the tool less useful and felt to some extent it was trying to force them to work a particular way that did not fit their application well. For these reasons we have decided to leave this tool in assess. If you are doing mobile web it is definitely worth spiking but it may not fit every application.
Heroku(Mar 2012, 试验)
Heroku is a beautifully simple Platform as a Service (PaaS). Although Heroku began as a Ruby on Rails platform, it is evolving to support a variety of languages and web frameworks, most recently Clojure. Heroku uses a standard stack and deploys applications with a simple Git push. Heroku’s recent acquisition by Salesforce.com has not diminished its service quality.
Heroku(Jan 2011, 试验)
Heroku is a beautifully simple Platform as a Service (PaaS) for Rack-compatible frameworks such as Ruby on Rails. In contrast to similar offerings for other languages, which often limit development to a programming model specific to the service platform, Heroku uses the standard Rails stack and even allows deployment with a plain Git push. Heroku was recently acquired by Salesforce.com and so has significant backing behind their service.
Production immune system(Mar 2012, 评估)
Continuous Delivery techniques are shortening the “last mile” to get changes into production, allowing more frequent feature releases. A production immune system tracks changes as they are put into production, and automatically rolls back changes that have a negative effect on key metrics, such as revenue. Solid metrics, as well as automated A/B deployment, are required for this kind of aggressive rollback to be successful.
Manual infrastructure management(Mar 2012, 暂缓)
Despite advances in automation, many people fall back on manual infrastructure management. We often see problems caused by manual configuration of firewalls and load balancers, and especially by DBAs cutting and pasting SQL scripts to run against production databases. All of these activities, if not fully automated, should at least be scripted and repeatable across environments.
Data visualizations of development and operations(Mar 2012, 采纳)
We have long advocated for both static and dynamic code analysis tools to help glean information about your code base. As the focus of software development broadens because of the Continuous Delivery movement, data visualizations of development and operations with effective, actionable profiling and monitoring should be part of your technical stack as well.
Git(Mar 2012, 采纳)
Starting from a challenge posed to the Linux community to stop using commercial version control, Git has proved itself. Git embodies a well architected, high performance implementation of distributed version control. Git is powerful, so it should be used with respect, but that power enables agile engineering workflows that simply cannot exist with other tools. Git’s popularity is supported by the existence of GitHub. GitHub combines public and private Git repositories, social networking, and a host of other innovative tools and approaches.
Git(Jan 2011, 试验)
In previous radars we recommended Distributed Version Control (DVCS) tools in general while mentioning Git and Mercurial in particular. In this edition we narrow our recommendation to only Mercurial and Git as these two have become the clear front-runners. Due to its success and the associated network effect GitHub remains the recommended option for enterprises that want to interact with the open source community.
Experience Design (XD)(Mar 2012, 评估)
Experience Design (XD) is an example of ways in which agility must evolve to accommodate real-world constraints. We are always interested in finding innovative ways to incorporate what have traditionally been up-front exercises into practices like Continuous Delivery. XD is a ripe field for study.
Emergent design(Mar 2012, 采纳)
Emergent design is one of the more advanced aspects of agile engineering practices, and therefore an area of active research & development. Such architectures should be driven by the underlying technical requirements of the system, rather than speculative planning for a future that may change. We have identified at least two facets of emergent design: the Lean software principle of last responsible moment, which mostly applies to greenfield projects, and finding & harvesting idiomatic patterns, which is more applicable to existing projects.
Emergent design(Jul 2011, 采纳)
As Agile practices move further toward mainstream adoption, we see significant benefits from the adoption of Lean software development practices as well. These practices have their roots in the Toyota Production System and complement much of our understanding of Agile software development to date. One topic that Lean has also given us greater insight into is that of set-based design. Set-based design leads us to implement similar solutions at the same time while the cost of doing so is constrained. This leads us into the area of emergent design and the ability to let experience shape our design decisions and defer key decisions until the last responsible moment.
FPM(Mar 2012, 试验)
There are many advantages to using OS-native packages to deploy components and dependencies, however the tools which build native packages for Linux are not trivial. FPM is a useful tool which makes it easy to create RPM, DEB, or Solaris packages with a minimum of fuss.
GPGPU(Mar 2012, 评估)
The use of GPUs for computing offers efficiencies and performance for certain classes of problems that would be prohibitively expensive for more traditional hardware. Problems that fit Single Instruction Multiple Data (SIMD) processing models can gain significant advantages at the cost of difficult learning curves using specialized APIs. OpenCL, CUDA from NVidia and DirectCompute from Microsoft offer developers access to General-purpose computing on graphics processing units (GPGPU).
Message buses without smarts(Mar 2012, 试验)
In contrast we have seen considerable success with Simple Message Buses where the integration problems are solved at the end points, rather than inside a vendor ESB system. The most well known Simple Message Bus approach is one based on the principles of REST and leveraging the proven scalability of the web. However organizations that have already invested in ESB infrastructure can leverage the useful parts of that infrastructure (reliable messaging etc) while still using a Simple Message Bus approach and performing integrations at the edges of the system.
OpenSocial(Mar 2012, 评估)
OpenSocial is a specification that provides a standard way to share content between semi-trusted applications. While initially proposed for public facing social networking sites, it has possibly more potential within the corporate firewall, where the benefits of being able to share data and content between applications in a standard manner frequently outweigh the requirements of scale and security.
Tablet(Mar 2012, 试验)
Tablet devices provide a new model of computing. The next generation of tablets show the potential for new interaction paradigms, and we expect interest and innovation to continue to escalate.
Tablet(Jan 2011, 试验)
The iPhone changed the face of the mobile phone. The iPad has the potential to radically alter the way users interact with and consume Web-based resources and applications and will spawn a plethora of similar tablet devices. The addition of wireless application distribution in IOS4 allows organizations to securely host and distribute in-house applications without using the App Store, overcoming one of the main barriers to corporate adoption. IOS4’s introduction of multitasking with applications running in the background has opened up new possibilities for enterprise applications, at the cost of extra battery usage.
Single command deploy(Mar 2012, 试验)
A key step in the Continuous Delivery process is the ability to release software arbitrarily close to when the business wants it. The ability to do single command deploy relies on a complete set of activities that fall under the umbrella of Continuous Delivery including extensive automation of everything from build/test to scripted environment provisioning and deployment. We have found that adopting this as a goal tends to drive the automation and testing pre-requisites upstream into the rest of your organization.
Test at the appropriate level(Mar 2012, 采纳)
The advent of behavior-driven design (BDD) testing frameworks like Cucumber, combined with browser automation tools like Selenium, has encouraged widespread use of acceptance testing at the browser level. This unfortunately encouraged doing the bulk of testing where the cost to run the tests is the greatest. Instead, we should test at the appropriate level, as close to the code as possible, so that tests can be run with maximum efficiency. Browser-level tests should be the icing on the cake, supported by acceptance and unit tests executed at appropriate layers.
Continuous Delivery (CD)(Mar 2012, 采纳)
If you are wondering “What comes after agile?,” you should look towards continuous delivery. While your development processes may be fully optimized, it still might take your organization weeks or months to get a single change into production. Continuous delivery focuses on maximizing automation including infrastructure as code, environment management and deployment automation to ensure your system is always ready for production. It is about tightening your feedback loops and not putting off anything until the end. Continuous delivery is not the same as continuous deployment, which means deploying every change to production. Continuous delivery is not a cowboy show. It puts you in charge of your production environment. The business can pick and choose what and when to deploy. If you think you’ve nailed agile development, but aren’t considering how to achieve continuous delivery, you really haven’t even started.
Build your own radar(Mar 2012, 试验)
Building your own technology radar helps you decide, normalize, and publicize consensus technology views for all interested parties. Thoughtworks produces a technology radar for clients and friends, telling the world our opinions about upcoming technology trends. You should do this for your own company as well. Too many decisions in large companies happen in a vacuum, with no input from the technologists who have to live with them every day.
JavaScript tooling(Mar 2012, 试验)
JavaScript is now established as a powerful, mainstream language that can be used in a variety environments both on client and server sides. As JavaScript codebases expand, more JavaScript tooling support becomes necessary, especially in the continuous integration and testing spaces. Tools like Backbone.js, SpineJS, JavaScriptMVC, Jasmine, JSTestDriver and HRcov are coming to the forefront. They are created by a vibrant community that continues to grow.
DevOps(Mar 2012, 采纳)
Improving the interactions and relationship between development and IT operations gives us more effective delivery and production systems that are more stable and maintainable. Creating a DevOps culture requires attention to team organization, work practices, reporting lines, and incentives - leading to joint responsibility for faster and safer delivery. We recommend adopting DevOps because we cannot see any situation where attention in this area will not have a positive benefit.
DevOps(Jan 2011, 试验)
The DevOps movement continues to gain traction as people pay more attention to the often-broken relationship between development and operations. DevOps promotes closer collaboration and joint responsibility between development and operations. DevOps applies agile practices to operations processes such as provisioning, change management and production monitoring and also brings productionlike thinking, tools and environments to development. DevOps is a key underpinning for organizations wanting to achieve continuous delivery of application releases into production.
DevOps(Aug 2010, 评估)
DevOps is a new movement seeking to achieve the business need for rapid delivery of software products while maintaining the stability of live environments. It uses two approaches: first, promoting closer collaboration between development and operations; second, applying practices shared with agile (collaboration, automation, simplicity, etc) to operations processes such as provisioning, change management, and production monitoring. It encompasses culture, processes, and tools - all supporting better communication, faster feedback and delivery, and more predictable outcomes.
Sonar(Mar 2012, 评估)
Measuring software internal quality is still a mystery, even though many source code metrics have been around for years. The problem with those metrics is they usually only capture one aspect of quality. We must consult many metrics to come to a conclusion about the overall quality of our code. Sonar is an integrated tool for checking, tracking and visualizing those metrics. It not only combines metrics together, but also mixes them with historical measures, giving us a better insight into the internal quality of the codebase.
vFabric(Mar 2012, 评估)
vFabric is a new Platform as a Service (PaaS) offering from VMWare. Based on enhanced versions of opensource web and messaging platforms Tomcat, Apache, and RabbitMQ, vFabric aims to deliver a Java based PaaS on a variety of cloud platforms. Currently supported platforms include VMForce, a collaboration between VMWare and force.com, Google App Engine and Amazon EC2. The addition of the GemFire in-memory distributed data management platform and Hyperic monitoring and management tool make vFabric an interesting set of technologies for Java developers looking to move to the cloud.
Client-side MVC(Mar 2012, 试验)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Mobile web(Mar 2012, 采纳)
Mobile web was in our trial ring on previous radars, but we’ve moved it into adopt in recognition of the fact we have created many mobile web applications. We believe this is the right way to create web content for mobile devices.
Mobile web(Jan 2011, 试验)
Mobile Web was in our Assess category on previous radars, but we’ve moved it into Trial in recognition of the fact that the Web is increasingly consumed through iPhone, Android and tablet devices. Many devices can render a fair approximation of a desktop browser experience, but to present the user with a truly optimal experience we recommend adapting a site to the screen size, display and control behaviors particular to the device. Techniques such as progressive enhancement can allow a single site to adapt to both desktop and mobile browsers. Large format mobile devices, such as the Apple iPad and Amazon Kindle, provide a new model of ubiquitous computing. Their long battery life, simple interfaces and easy connectivity have the potential to change the way we interact with computers. Apple’s new user interfaces discard the familiar desktop metaphors of files and folders that have been standard since the introduction of the Macintosh in 1984.
Log aggregation & indexing(Mar 2012, 试验)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Ubiquitous computing(Mar 2012, 试验)
Ubiquitous computing is tricky term as it covers many different ideas. What we find interesting and exciting at the moment is that both consumer and specialist mobile devices are increasingly based on commodity operating systems such as Android or iOS. This means that in many cases, software can be developed by organizations themselves, opening the door to innovative new applications without requiring expensive niche skills. Lower price points for the hardware also make this area more accessible, especially with peripherals like payment card readers, PIN key pads and high quality bar code scanners becoming available for both Android and iOS devices. When combined with features already available on these consumer devices, whole new ways of working open up.
TLB(Jul 2011, 试验)
If your test suites are growing slower and you have already verified that it is not a serious problem with your application, first make your tests faster, then look at parallelization. The Test Load Balancer (TLB) project is a big development in the world of parallel test execution. It removes the inefficiencies of manual work distribution using smart algorithms and historical test execution data to optimize workload distribution and minimize elapsed time. Further, it orders the tests in intelligent ways like executing the test that failed in the previous execution first to get quicker feedback. Parallel execution can occur across a grid of machines or across multiple processes on a single machine. JUnit, RSpec, Test::Unit, Twist and Cucumber are currently supported and NUnit is under development.
Next-generation test tools(Jul 2011, 试验)
The Ruby language community is responsible for a number of innovations in the area of testing. The next generation of testing tools such as rspec and Cucumber are two such tools that have come out of this community. These tools, along with Thoughtworks’ Twist, provide a way to express tests in a more natural language syntax that captures the intent of the system in a way that end users can quickly grasp.
Event driven business intelligence(Jul 2011, 评估)
This technique was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Capability modeling(Jul 2011, 试验)
Initiatives that span multiple projects require shared understanding of the business context, operating model, and strategic goals of an organization, as well as any existing technical, organizational and process constraints impinging on planning and design activities. As part of our evolutionary approach to enterprise architecture, we use business capability modelling to create lightweight hierarchical models of the business functions that are an essential part of an organization’s needs and goals. Capabilities describe an organization’s operating model in terms of goals and competencies (what is to be done), rather than implementation specifics (how things are done). Whereas business architecture models based on people, process or technology are contingent, volatile and often short lived, and therefore ill-suited to the long-term planning needs of the organization, capability models provide a description of the business context that is stable enough to serve as a basis for identifying and prioritising technology and process initiatives.
OAuth(Jul 2011, 评估)
OAuth is a web-friendly, lightweight standard for authorization that allows a user to share private resources between internet services, e.g., allowing your favorite social networking site to access your photos from your favorite photo sharing site. OAuth is simple, avoids password proliferation, and allows a service to grant bare minimum privileges. If you are exposing your application’s data in a lightweight, web-friendly manner you should strongly consider using OAuth as your standard for authorization.
OAuth(Jan 2011, 评估)
OAuth is a Web-based authorization protocol that allows applications to access a user’s secured resources in another application without the user having to share their private security credentials. Now an RFC, OAuth represents a significant standards-based attempt to improve privacy and security for Web browser and machine-based access to distributed Web resources. Library support is patchy and adopters can expect to spend some time wrangling their code to achieve true interoperability. OAuth 2.0 is due towards the end of 2010, with specific flows for Web applications, desktop applications, mobile phones, and household devices. Because OAuth 2.0 is not backwardly compatible with version 1 and the implementation challenges around the current version, OAuth is still in the assess ring.
OAuth(Apr 2010, 评估)
The Web is a global data structure that enables us to share information. However not all data is meant to be shared by everyone and it’s important to be able to share information on the Web in a disciplined and governable manner without requiring massive centralized infrastructure. OAuth provides a way of sharing resources on the Web responsibly and securely. It is a Web protocol (for Web browsers or machine-to-machine interactions), which allows federated authorization of access to Web resources. What’s interesting is that OAuth is a simple protocol to implement and utilize and yet its design goals match many common enterprise authorization problems. OAuth remains in the assessment category, however, because it has fragmented, and the IETF has not yet drawn the community back together under an Internet RFC.
Iterative data warehousing(Jul 2011, 试验)
Like iterative software development, there is lot of value to be gained by delivering data warehousing projects using iterative techniques. Iterative data warehousing techniques allow the end users of the data warehouse to determine what reports they want and the ETL developers and data modelers to deliver those features without wasting time with data modeling and ETL jobs that do not provide immediate value to the business.
Iterative data warehousing(Aug 2010, 评估)
The industry has seen significant changes to the way we use and store data over the past few years. Agile development practices have lead to greater emphasis on evolutionary database design, requiring new tools that support migration of schemas in line with changes to the domain model of an application. As storage space consistently becomes cheaper and data access speeds increase, many organizations are investigating the use of multiple schemas to hold data for different purposes, e.g. transactional and analysis schemas. Incremental data warehousing is becoming increasingly popular as the cost of moving data between a transactional data store and an analysis environment is less than the value of having access to near real-time reporting of critical business data.
Mercurial(Jul 2011, 试验)
In previous radars we recommended Distributed Version Control (DVCS) tools in general while mentioning Git and Mercurial in particular. In this edition we narrow our recommendation to only Mercurial and Git as these two have become the clear front-runners. Due to its success and the associated network effect GitHub remains the recommended option for enterprises that want to interact with the open source community.
JRuby(Jul 2011, 采纳)
Charles Nutter and the JRuby team continue to improve JRuby at a frantic pace. It is fast and they place massive importance on keeping their ecosystem up-to-date, including DB adapters, gem management, and modern Rails deployment. Rails 3 + JRuby is an awesome platform. There really is no reason to not be using Ruby, one of our favorite languages, in the enterprise.
JRuby(Jan 2011, 采纳)
Functional languages have a wide range of practical uses, including simulation, computational fi nance, computational science, large scale data processing and parsing. These fields benefit from functional programming techniques that simplify concurrent execution and the expression of complex mathematical functions concisely. Functional programming requires a shift in thinking for enterprise developers experienced in object oriented development. Moving to an often terse syntax for solving complex problems may initially be intimidating to many. As with all forms of programming languages, syntax is just one aspect of the language itself. In functional programming another significant aspect is the use of common idioms. These idioms speed code comprehension and increase overall maintainability. This might not be news to all, but it is worth noting that dynamic languages are long ready for adoption and trial. Ruby, particularly when deployed on JRuby, is ready for adoption. Thoughtworks uses Ruby and JRuby extensively in both its Services and Product work. Groovy is ready for trial and could prove more accessible than Ruby/JRuby in a Java shop. For the right type of applications, Ruby, JRuby, and Groovy prove far more effective, expressive, and productive than Java and C#.
Procedure oriented integration(Jul 2011, 暂缓)
One of the goals of SOA has been to decouple services by exchanging human-readable business documents instead of programming parameters. However, in implementing SOA, many businesses have simply used web services to expose the underlying programming models of back-end systems. Procedure oriented integration is nothing more than remote procedure calls implemented via a different protocol. The consequences of this are additional layers of complexity with no improvement in business flexibility. To avoid this, implementers of SOA should first understand the business meaning of their services, then implement human-readable contracts that are independent of legacy system implementation.
New Relic beyond Rails(Jul 2011, 试验)
We have regularly used New Relic hosted performance monitoring with Ruby on Rails systems in development and production. The combination of fast setup and comprehensive reporting has proven extremely valuable in troubleshooting performance. We are now seeing good results from the New Relic monitoring services for Java and .NET systems.
Visualization and metrics(Jul 2011, 采纳)
Data visualizations have been effective in business and IT decision making. Organizations are making effective use of real time data through visualizations. These visualizations include point in time data as well as trends plotted over time. We are seeing increased adoption of these techniques in optimizing operations and software development.
Visualization and metrics(Jan 2011, 采纳)
Evolutionary and emergent design of enterprise systems requires significant vigilance by development and architecture teams. Collecting metrics to capture development trends is a key part of understanding the stress points for a system under development. Assessing this information in its raw form is even more difficult than taking stock of a system at the source code level. To address this concern we have found a number of visualization tools and techniques to get what we refer to as the 1000ft view of the system and its internal quality. This 1000ft view allows us to identify visual patterns that help find and address issues more quickly.
Caching reverse proxies(Jul 2011, 采纳)
Application designs that incorporate caching reverse proxies as first class design elements are simpler and more resilient to infrastructure failures. Placing a caching reverse proxy between an application and a web service it consumes reduces the risk of service failures affecting the application while improving overall system performance.
HAML(Jul 2011, 试验)
HAML is a language that allows you to use indentation to lay out the structure of HTML. While not a general replacement for HTML, it is effective for focusing on the hierarchical structure of tags.
Deltacloud(Jul 2011, 评估)
Every Infrastructure as a Service (IaaS) cloud offering provides their own API for performing common tasks. Deltacloud aims to abstract those APIs and provide a RESTful interface for performing common cloud management functions, making it possible to migrate virtual infrastructure between clouds.
Progressive Enhancement(Jul 2011, 采纳)
Recent use of progressive enhancement with mobile applications has been very effective and demonstrates the universal nature of this web design strategy. We encourage people to adopt this strategy to keep their code clean and give each user the optimal experience for their device.
API management services(Jul 2011, 评估)
Exposing APIs to a large developer community creates nonfunctional requirements that are often the same from one business to another. Key management, authentication, access control, traffic management, caching, tracking and reporting are often implemented as commodity functions that can be reused across applications and businesses without modification. Some service providers have spotted this trend and are offering API management via software as a service. Prominent vendors in this space include Mashery and Apigee, who both offer the option of hosting the service on a customer’s own infrastructure. API management services may also be interesting to enterprise customers who are using Web as platform techniques for their internal SOA, providing a lighter weight alternative to traditional SOA management tools.
Decision driven BI(Jul 2011, 评估)
Traditional approaches to implementing data warehouses and business intelligence work from the bottom up in horizontal tiers, assembling and cleansing data sources from across the enterprise then aggregating them into a comprehensive data mart before reports can be generated. Some people are now employing an alternative approach that starts with the real outcome--a business decision--and pulls work items through the process as needed to support that decision. Decision driven business intelligence allows a more incremental approach to BI and facilitates rapid feedback to the decision makers who are the ultimate consumers of business intelligence.
Smart systems(Jul 2011, 评估)
Smart Phones with a GPS, cameras and a screen are but one example of smart systems which are proliferating around us, fusing the real and the digital world. Augmented reality apps like Google Goggles, geolocation services & smart grids are just some of the possible applications.
Splunk(Jul 2011, 试验)
Application logs are both a blessing and a curse. They are comforting to have when a production issue arises, but actually digging out the data we need usually requires cobbling together scripts written in tools such as AWK and sed. Splunk is an elegant solution that quickly analyzes many standard log file formats like IIS, Log4J and syslog, and is extensible to custom formats. It indexes files, statically or in real time, to generate canned or custom reports. If the raw log fields do not provide what you need, simply use a regular expression, either inline or to define a new field, to get the desired level of detail. Splunk’s full power is difficult to describe, so we recommend downloading and trying it.
Concurrency abstractions and patterns(Jul 2011, 试验)
Concurrency is a difficult problem and increasingly difficult to avoid. Hardware isn’t getting faster but multicore platforms are becoming the norm, with even mobile phones containing two or more processors. Concurrency abstractions and patterns -- which are not new, but less widely known -- are helping address many of the challenges seen in this space. In particular the models seen in Clojure, Erlang, Retlang and Event Patterns offer a more testable and reliable approach than the better known threads, locks and semaphores.
Platform roadmaps(Jul 2011, 采纳)
Almost every enterprise has “legacy systems” that are expensive to operate and upgrade. Often a system will become legacy over the course of several years, through neglect or atrophy. We recommend using platform roadmaps to maximize the value of a systems portfolio and plan for the upgrade and eventual retirement of systems.
Subversion(Jul 2011, 采纳)
Subversion moves back into the Adopt section of the radar because it is a solid version control tool suitable for most teams. We consider Subversion’s features to be the basic standard for a modern version control tool. Thoughtworkers continue to embrace and recommend Distributed Version Control tools such as Git and Mercurial, but we caution that these systems often require deeper understanding to get the most out of them. New to the radar is GitHub, a “social coding” tool supporting both source code hosting and social networking. GitHub is arguably one of the main reasons Git has become the leading DVCS tool, and GitHub’s collaboration features are often used by enterprises that need to support distributed teams.
Subversion(Jan 2010, 试验)
Distributed version control systems such as Git and Mercurial have had significant exposure in the past year or more as open source projects move to this toolset en masse. The social networking aspect that GitHub and Bitbucket have brought to distributed version control has helped to propel these tools forward and into enterprises looking for ways to develop across multiple geographies. The move for many to a distributed version control system has resulted in a move away from tools such as Subversion and other centralized version control systems. As organizations assess and choose between these two different toolsets, we suggest that you evaluate both in relation to your team’s specific needs. While we have seen widespread adoption of distributed version control tools within Thoughtworks and beyond, we still advocate the use of continuous integration and limits to the amount of time that code is spent outside of the main branch.
NoSQL(Jul 2011, 试验)
NoSQL technologies are maturing daily, allowing for innovative solutions as businesses need to scale massively or ask intelligent questions of existing data. Technologies like MongoDB, Riak, Neo4J, Cassandra and many others are helping power the NoSQL space.
NoSQL(Jan 2011, 试验)
NoSQL is about scale, massive datasets, cloud data, social network data, data in buckets, data in graphs i.e. a range of use cases for which “traditional” SQL databases may not be the optimal choice. Unravelling NoSQL and trying to explain what it is and why you should or should not be interested in it is difficult as the term covers a wide range of technologies, data architectures and priorities and represents as much a movement or a school of thought as it does any particular technology. Types of NoSQL technologies include key-value, column and object stores as well as document, graph and XML databases.
Selenium 2 testing of mobile websites(Jul 2011, 评估)
When building mobile web applications we can now use Selenium 2 mobile tests to run the same acceptance tests on iOS, Android and Blackberry. This works on emulators, simulators and physical devices. We have successfully used this approach on production software for all 3 platforms. While the Blackberry driver is still in beta, we found it stable enough for use. The key challenge is the different ways to install the driver and start the browser, but this only needs to be solved once. We suggest that companies doing mobile web for these devices try this approach. We see no reason why this approach cannot be extended to Windows Phone in the future.
Cross mobile platforms(Jan 2011, 评估)
While there has been much publicity around Apple’s squashing cross-platform development options for the iPhone and iPad, there are still perfectly valid options. PhoneGap and Appcelerator Titanium’s approach is to provide a native compatibility layer for all the major mobile platforms to your Web standard HTML+CSS+JS application.
Apache camel(Jan 2011, 试验)
In today’s connected systems environments almost all new development needs to integrate with existing applications and services. In conjunction with our adoption of simple message buses and integration techniques at the edges of a system, we have successfully used small libraries such as Apache Camel to perform the protocol bridging, message transformation and message routing tasks common to such integrations. Camel’s fluent Java interface, unit testing support and connectors for many different transports and message formats provide for an effective anti-corruption layer when implementing distributed applications.
Application appliances(Jan 2011, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Application appliances(Aug 2010, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Application appliances(Apr 2010, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Real-time business intelligence(Jan 2011, 评估)
Business are running 24x7, but the information needed to make business decisions is being provided by outdated methods using ETL jobs in batch mode. The batch window is shrinking as businesses move to global markets and are open for longer durations. The data provided by these jobs is out of date by the time the business needs to make a decision. There is substantial value in taking the event as it happens in the transactional system and feeding it to the data warehouse so that the business can get near real-time business intelligence.
RDF triple stores(Jan 2011, 评估)
While we are bullish on RDFa, we remain highly guarded on native RDF triple stores as a persistence mechanism. The leading available triple stores vary greatly in their capabilities, capacity, and performance characteristics. If you are exploring the use of a triple store, you must do extensive testing to make sure the triple store fits your needs.
Facebook as business platform(Jan 2011, 试验)
Facebook has become popular in part due to its rich API and explosion of third-party applications. Thoughtworks is now starting to see our clients consider Facebook as a business platform. In addition to having a Facebook presence, businesses are building Facebook applications that are tightly integrated with their own services and offer useful functionality to Facebook users.
Build pipelines(Jan 2011, 采纳)
The past 2 years or more has seen a proliferation of continuous integration tools and platforms leading to substantial innovation in the build and release space. Distribution of builds is one such innovation and yet another is the way in which builds are now structured to make greater use of automation in various stages of the build. Build pipelines help to provide greater insight into the quality of each build and the environments to which they have been deployed. A natural expansion of the build pipeline meme is the adoption of continuous deployment techniques, where the intention is to extend the build pipeline into the production environment. This relies on automated deployment techniques and authorization mechanisms built into the continuous integration toolset. One of the key benefits is the ability to move new functionality into production rapidly and reliably.
Squid(Jan 2011, 采纳)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Squid(Aug 2010, 采纳)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Squid(Apr 2010, 采纳)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Ruby(Jan 2011, 采纳)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Ruby(Aug 2010, 采纳)
This language/framework was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Automation of technical tests(Jan 2011, 试验)
We strongly believe that all software delivery organizations need to be making use of automated technical tests. This sort of test spans failover testing, performance testing and soak testing among others; these activities can start early in a project’s life-cycle and continue through to maintenance. The common practice of waiting until near the end of a project is fraught with risk with little time available to find and fix problems. For example the requirement for a comprehensive production-like environment before the start of performance testing is a dangerous fallacy, we can discover bottlenecks, track performance trends and test our performance tests, without waiting for a perfect environment.
Automation of technical tests(Apr 2010, 试验)
Significant advances in the tools for automating functional testing haven’t been replicated in the technical testing space. Data management for performance, load and soak testing is a particular issue. However, the tools are improving and increased visibility for these tools supports the early and often technical testing that we advocate.
Android(Jan 2011, 采纳)
The iPhone and android operating systems have rapidly become key players in the mobile platform marketplace. Apple’s app store and Google’s open source operating system have helped both companies leapfrog the competition in capturing developer mindshare.
App containers(Jan 2011, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
App containers(Aug 2010, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Java language end of life(Jan 2011, 评估)
The purchase of Sun, and thus their Java assets, by Oracle introduced uncertainty regarding the future of Java. This uncertainty continues despite the recent announcements of Oracle’s Java roadmap, which had both encouraging and worrying aspects. As a result we continue to highlight the issue. We recommend monitoring the situation rather than any immediate actions to move off the platform.
Java language end of life(Aug 2010, 评估)
As we have discussed previously, the Java language appears to be moving slowly as the Java community waits for Java 7. Having waited for new language features to surface for almost 3 years, the Java community has begun to innovate in new languages that run on the Java Virtual Machine, languages such as Groovy, JRuby, Scala and Clojure. With the increase in number of languages available on the JVM, we expect enterprises to begin to assess the suitability of reducing the amount of Java specific code developed in their enterprise applications in favor of these newer languages. This is not to say that enterprises should outright abandon Java as a programming language, we do however suggest that you look for alternatives that may be more fi t for purpose in the area that new development is taking place.
Java language end of life(Jan 2010, 评估)
As C# continues to surge ahead, the Java language appears to be moving slowly as the Java community waits for Java 7. Having waited for new language features to surface for almost 3 years, the Java community has begun to innovate in new languages that run on the Java Virtual Machine, languages such as Groovy, JRuby, Scala and Clojure. With the increase in number of languages available on the JVM, we expect enterprises to begin to assess the suitability of reducing the amount of Java specific code developed in their enterprise applications in favor of these newer languages.
Service choreography(Jan 2011, 试验)
Integrated business processes now routinely span multiple systems and even enterprises. This raises the question of how these processes should be coordinated. In our experience centralized orchestration solutions often fail to deliver the promised benefits. They are costly to implement, and because they maintain application state on behalf of many consumers, they are often difficult to scale. This has lead us to prefer service choreography, where independently distributed participants collaborate according to an application protocol. Using the Web as platform, hypermedia-driven application protocols allow us to implement integrated business processes that are easy to evolve and easy to scale.
Web as platform(Jan 2011, 采纳)
Our understanding of the Web has matured to the point where we believe it is a viable platform for building distributed systems. RESTful techniques have advanced past pretty URIs + JSON towards hypermedia systems that project business protocols over the Internet and support seamless business process and service composition. The Web provides a powerful capability for scale, resiliency, and ease of implementation with commodity infrastructure like caches and Web servers with commodity protocols (like HTTP, AtomPub, and OAuth). Moving from trial to adopt is indicative of our position that the Web is ready for primetime, not just for Internet-facing systems but as a practical base for enterprise systems delivery.
Web as platform(Jan 2010, 试验)
We assist many of our clients in adapting enterprise software architecture practices to fit within an Agile software delivery approach. In the past year we have seen increased interest in evolutionary enterprise architecture and how service oriented architectures shape the boundaries between enterprise units. The value of an evolutionary approach to enterprise architecture is the creation of lighter weight systems that ease integration between disparate parts. By embracing this approach and the notion of the web as an enterprise application platform, we have reduced overall complexity of application architectures, increased quality and scalability, and reduced development costs.
EC2 & S3(Jan 2011, 试验)
AWS is the most mature and broadest of the current cloud offerings providing scalable services for computation (EC2), storage (S3 & SBS), databases (SimpleDB & RDS), messaging (SQS & SNS), etc. The list of services provided by AWS continues to expand rapidly with new services being added on an almost monthly basis, (http://bit.ly/90887v). While existing applications can be deployed on AWS through the use of Amazon Machine Images the full benefits of this platform will come from applications that are developed to take advantage of AWS. The usage based billing model adopted by AWS allows organizations to scale applications without large upfront investment and avoid the overhead cost of under utilized hardware.
EC2 & S3(Apr 2010, 试验)
The Cloud continues to be of interest to us, with Software as a Service the most mature cloud component. Platform and Infrastructure as service offerings have reached different levels of maturity, and we reflect that in our placement of EC2, Google App Engine and Azure.
Restfulie(Jan 2011, 评估)
The hypermedia constraint from REST is now understood as critical in sharing business protocols over the Web. Unfortunately many frameworks for building computer to- computer systems on the Web are ignorant of this constraint and tend towards simple CRUD systems. Restfulie is the first of a new generation of frameworks that natively support hypermedia, for Ruby, Java, and .NET. In Restfulie, business protocols are implemented using DSLs and exposed across the Web through hypermedia representations; clients drive those protocols through a similar declarative mechanism, consuming server-generated representations as they work towards a business goal. As the fi rst framework of its kind, Restfulie is opinionated and provides strict “training wheels” in order to bootstrap newcomers. However, it is an empirical proof that the Web and hypermedia can be used to orchestrate complex business activities.
Groovy(Jan 2011, 试验)
Functional languages have a wide range of practical uses, including simulation, computational fi nance, computational science, large scale data processing and parsing. These fields benefit from functional programming techniques that simplify concurrent execution and the expression of complex mathematical functions concisely. Functional programming requires a shift in thinking for enterprise developers experienced in object oriented development. Moving to an often terse syntax for solving complex problems may initially be intimidating to many. As with all forms of programming languages, syntax is just one aspect of the language itself. In functional programming another significant aspect is the use of common idioms. These idioms speed code comprehension and increase overall maintainability. This might not be news to all, but it is worth noting that dynamic languages are long ready for adoption and trial. Ruby, particularly when deployed on JRuby, is ready for adoption. Thoughtworks uses Ruby and JRuby extensively in both its Services and Product work. Groovy is ready for trial and could prove more accessible than Ruby/JRuby in a Java shop. For the right type of applications, Ruby, JRuby, and Groovy prove far more effective, expressive, and productive than Java and C#.
RDFa(Jan 2011, 评估)
RDFa, a mechanism for attaching meaningful vocabularies to HTML content that is being quickly and widely adopted by content providers, is the first mainstream success to arise from the Semantic Web stack. RDFa enables tools ranging from custom point integrations to Google spiders to more richly understand your Web content. If you would like to quickly open up your content to a multitude of integration possibilities in a simple, cheap, standards-based fashion, we recommend you try RDFa.
RDFa(Apr 2010, 评估)
Semantic Web W3C standards, and the tools implementing them, are at last worthy of real attention. RDF and RDFa allow anyone to say anything about anything in a sharable, structured format. This proves a much more powerful means of linking and structuring data from disparate sources than the strictness of RDBMS, or the mess that is unstructured Web data. Correspondingly SPARQL is the query standard that allows information to be mined from RDF marked-up data.
RDFa(Jan 2010, 评估)
The semantic web and its underlying technologies, including RDF & SPARQL, have been around for 8 years or more. Broader uptake of the Cloud and non-relational databases such Neo4j have helped move the semantic web into the reach of enterprise developers. Outside of the semantic web, nonrelational databases are being adopted as alternatives to relational databases in a number of situations. Leveraging these technologies will require new approaches to architecture and development that suggest widespread adoption will only occur over a number of years.
WCF HTTP(Jan 2011, 评估)
Microsoft’s WCF HTTP API, though currently in the early stages of development, is evolving rapidly, and we’re already impressed by its support for HTTP primitives as well as idioms such as content negotiation and conditional requests. The API encourages the development of highly testable solutions with a clear separation of concerns. What is of particular interest to us is the way in which the project is being developed in Codeplex’s open source community. The ability for the community to steer the development of this part of the .NET platform merits this project’s early inclusion in the radar. While the license does allow for using the library in production today, given the current volatility of the API, we caution against taking a dependency at this early stage; many of the features we’ve admired in recent releases, such as its use of an attributelight programming model based on convention over configuration, may not make it into the first version.
C# 4.0(Jan 2011, 采纳)
When C# first appeared, many saw it as a direct competitor to the Java language’s dominance in enterprise application development. This was often attributed to the syntactical similarities that the two languages shared. Since its introduction, however, C# has continued to move forward with the adoption of language features such as lambda expressions, extension methods, object initializers and automatic property setters and getters, all of which are available in the 3.5 release of the language. With the 4.0 release of C#, we will see the introduction of a dynamic keyword and named and optional parameters, which will continue to bring C# more in line with languages such as Ruby and well ahead of the Java language.
Intentional Software(Aug 2010, 暂缓)
Thoughtworks has been working with Intentional Software for the past several years, and we are thrilled at the recent limited availability and production use of the Intentional Domain Workbench. We believe this technology represents a radical departure from the traditional software development approach. We place this technology in the assess ring, since we believe that it is time to begin exploring the application of Intentional’s technology in proofs of concept.
ALT.NET(Aug 2010, 采纳)
While .NET has proven itself as a solid platform, many practitioners are dissatisfied with many of the default Microsoft tools and practices. This has led to the growth of the Alt.NET community, which champions techniques that we find more effective along with (usually opensource) tools that better support them.
Google App Engine(Aug 2010, 评估)
This platform was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Google App Engine(Apr 2010, 评估)
The Cloud continues to be of interest to us, with Software as a Service the most mature cloud component. Platform and Infrastructure as service offerings have reached different levels of maturity, and we reflect that in our placement of EC2, Google App Engine and Azure.
IE6 End of Life(Aug 2010, 采纳)
IE6 is a significantly deficient browser with many documented security holes and should be phased out as soon as possible. Browsers such as Firefox and Chrome can be installed alongside IE, allowing the user to choose which one to use. We recommend that organizations with intranet applications that require IE6 consider using it only for those specific applications, and install one of these alongside for general use.
IE6 End of Life(Jan 2010, 采纳)
Web browsers continue to evolve as they strive to keep pace with new specifications in HTML, CSS and JavaScript. Alas, many enterprises have yet to embrace the end of life for IE6 and move to a newer and more standards compliant option. Of the browsers available today, Firefox and Opera provide support for the widest range of platforms. The Google browser, Chrome, brings new innovation to the browser space by splitting browser tabs into separate processes while providing a new implementation of JavaScript. These changes appear to give Chrome a significant performance boost over other browsers and have influenced the creation of a netbook OS called Chrome OS. While enterprises may look to move off IE6 and onto Microsoft’s IE8, we remain concerned about IE8’s current level of compliance to web standards.
IE8(Aug 2010, 暂缓)
Internet browsers such as Google Chrome, Safari, Opera and Firefox, have made serious inroads in the implementation of the HTML 5 specification. With these advances it is now possible to experience many of the improvements that HTML brings. Unfortunately so far Microsoft has lagged on implementing these new standards. We recommend that organizations favor standards compliant browsers over IE8.
IE8(Jan 2010, 暂缓)
Web browsers continue to evolve as they strive to keep pace with new specifications in HTML, CSS and JavaScript. Alas, many enterprises have yet to embrace the end of life for IE6 and move to a newer and more standards compliant option. Of the browsers available today, Firefox and Opera provide support for the widest range of platforms. The Google browser, Chrome, brings new innovation to the browser space by splitting browser tabs into separate processes while providing a new implementation of JavaScript. These changes appear to give Chrome a significant performance boost over other browsers and have influenced the creation of a netbook OS called Chrome OS. While enterprises may look to move off IE6 and onto Microsoft’s IE8, we remain concerned about IE8’s current level of compliance to web standards.
Location based services(Aug 2010, 评估)
Google maps has led the way in bringing mapping mainstream. But businesses, governments and non-profit organizations are now learning to use these location based services to communicate more effectively with customers. With other mapping services providers getting into the act, there is going to be a proliferation of applications built around mapping targeted at customers who are now much more map-savvy.
JVM as platform(Aug 2010, 采纳)
While the radar has called out the possibility of the Java language nearing its end of life, the JVM is demonstrating its resilience as a general-purpose virtual machine for other languages such as Ruby, Groovy, Scala and Clojure.
Puppet(Aug 2010, 试验)
Puppet is a free, open source data center automation tool for managing changes to your production and production-like environments. Using Puppet, you can keep the configuration of your environments in version control and push changes out to your systems in a controlled, automated fashion. Infrastructure automation tools like puppet have the benefits of reducing manual effort allowing ops to focus on higher priorities, providing consistency and repeatability by reducing waste eliminating environmental differences between test and production environments.
Google as corporate platform(Aug 2010, 评估)
At the start of October 2009, Thoughtworks became a customer of Google Apps. Although we have heard a wide range of opinions about the user experience offered by Google Mail, Calendar and Documents, the general consensus is that our largely consultant workforce is happy with the move. The next step that we as a company are looking to embrace is Google as a corporate platform beyond the standard Google Apps; in particular we are evaluating the use of Google App Engine for a number of internal systems initiatives. Google App Engine, Amazon EC2 and Salesforce.com all claim to be Cloud providers, yet each of their offerings differ. The Cloud fits into a broad categorization of service offerings split out into Infrastructure as a Service (e.g. Amazon EC2 and Rackspace), Platform as a Service (e.g. App Engine) and Software as a Service (e.g. Salesforce.com). In some cases, providers may span multiple service categories, further diluting the Cloud as a label. Regardless, the value of infrastructure, platform and software in the cloud is difficult to question and although many offerings have hit bumps in the road, they certainly have earned their position on the radar.
ASP(Aug 2010, 采纳)
We have been tracking ASP.NET MVC since its early release candidates. This is an exciting development in the .NET space from Microsoft, both in the programming model and in the open source license under which Microsoft has released the library. ASP.NET MVC is similar to MVC frameworks on the Java platform and is a move away from the ASP.NET Web Forms approach to one that supports greater levels of automated testing.
iPhone(Aug 2010, 采纳)
The iPhone changed the face of the mobile phone. The iPad has the potential to radically alter the way users interact with and consume Web-based resources and applications and will spawn a plethora of similar tablet devices. The addition of wireless application distribution in IOS4 allows organizations to securely host and distribute in-house applications without using the App Store, overcoming one of the main barriers to corporate adoption. IOS4’s introduction of multitasking with applications running in the background has opened up new possibilities for enterprise applications, at the cost of extra battery usage.
iPhone(Apr 2010, 采纳)
The iPhone and android operating systems have rapidly become key players in the mobile platform marketplace. Apple’s app store and Google’s open source operating system have helped both companies leapfrog the competition in capturing developer mindshare.
Distributed version control(Apr 2010, 试验)
Subversion moves back into the Adopt section of the radar because it is a solid version control tool suitable for most teams. We consider Subversion’s features to be the basic standard for a modern version control tool. Thoughtworkers continue to embrace and recommend Distributed Version Control tools such as Git and Mercurial, but we caution that these systems often require deeper understanding to get the most out of them. New to the radar is GitHub, a “social coding” tool supporting both source code hosting and social networking. GitHub is arguably one of the main reasons Git has become the leading DVCS tool, and GitHub’s collaboration features are often used by enterprises that need to support distributed teams.
Distributed version control(Jan 2010, 试验)
Distributed version control systems such as Git and Mercurial have had significant exposure in the past year or more as open source projects move to this toolset en masse. The social networking aspect that GitHub and Bitbucket have brought to distributed version control has helped to propel these tools forward and into enterprises looking for ways to develop across multiple geographies. The move for many to a distributed version control system has resulted in a move away from tools such as Subversion and other centralized version control systems. As organizations assess and choose between these two different toolsets, we suggest that you evaluate both in relation to your team’s specific needs. While we have seen widespread adoption of distributed version control tools within Thoughtworks and beyond, we still advocate the use of continuous integration and limits to the amount of time that code is spent outside of the main branch.
Large format mobile devices(Apr 2010, 评估)
Large format mobile devices, such as the Apple iPad and Amazon Kindle, provide a new model of ubiquitous computing. Their long battery life, simple interfaces and easy connectivity have the potential to change the way we interact with computers. Apple’s new user interfaces discard the familiar desktop metaphors of files and folders that have been standard since the introduction of the Macintosh in 1984.
Language workbenches(Apr 2010, 暂缓)
It is likely that test languages will continue to evolve with the assistance of language workbenches, tools that assist in the creation of domain specific languages. Tools such as Jetbrains’ MPS and Intentional Software’s offering are leading the industry in this area. Both provide ways of creating new languages to map business software more closely to the end user’s domain language.
Cloud(Apr 2010, 采纳)
The Cloud continues to be of interest to us, with Software as a Service the most mature cloud component. Platform and Infrastructure as service offerings have reached different levels of maturity, and we reflect that in our placement of EC2, Google App Engine and Azure.
Lean software development(Apr 2010, 试验)
As Agile practices move further toward mainstream adoption, we see significant benefits from the adoption of Lean software development practices as well. These practices have their roots in the Toyota Production System and complement much of our understanding of Agile software development to date. One topic that Lean has also given us greater insight into is that of set-based design. Set-based design leads us to implement similar solutions at the same time while the cost of doing so is constrained. This leads us into the area of emergent design and the ability to let experience shape our design decisions and defer key decisions until the last responsible moment.
Visualizations for business data(Apr 2010, 评估)
This tool was included in this edition of the Radar for visibility. We felt that there wasn't anything substantial to add to the discourse around it, but that it was important to keep this in view.
Functional languages(Jan 2010, 评估)
The remaining two language types included on the radar are often grouped together. While functional and concurrent languages may be adopted in similar environments, their approaches are different. Functional programming focuses on expressing code in the form of mathematical functions that avoid maintaining state across multiple invocations. While functional languages such as Haskell have been around for a number of years, new functional (themed) languages such as Scala, F# and Clojure have sparked some interest in this paradigm. Due to the way in which functional languages manage state, interest in these languages has increased by many developers seeking to make the most out of multi-core processors. Many concurrent languages are also functional languages. The distinction lies in the emphasis on running operations in parallel. A number of such languages exist; Erlang is currently the most popular of these languages. Concurrent languages commonly provide some means for handling concurrency by using messages to communicate across multiple threads.
Non-relational databases(Jan 2010, 试验)
The semantic web and its underlying technologies, including RDF & SPARQL, have been around for 8 years or more. Broader uptake of the Cloud and non-relational databases such Neo4j have helped move the semantic web into the reach of enterprise developers. Outside of the semantic web, nonrelational databases are being adopted as alternatives to relational databases in a number of situations. Leveraging these technologies will require new approaches to architecture and development that suggest widespread adoption will only occur over a number of years.
Firefox(Jan 2010, 采纳)
Web browsers continue to evolve as they strive to keep pace with new specifications in HTML, CSS and JavaScript. Alas, many enterprises have yet to embrace the end of life for IE6 and move to a newer and more standards compliant option. Of the browsers available today, Firefox and Opera provide support for the widest range of platforms. The Google browser, Chrome, brings new innovation to the browser space by splitting browser tabs into separate processes while providing a new implementation of JavaScript. These changes appear to give Chrome a significant performance boost over other browsers and have influenced the creation of a netbook OS called Chrome OS. While enterprises may look to move off IE6 and onto Microsoft’s IE8, we remain concerned about IE8’s current level of compliance to web standards.
Polyglot development environments(Jan 2010, 暂缓)
Polyglot programming continues to gain widespread acceptance across the industry reflecting the reality that software developers have many languages and tools at their disposal. One area that we have yet to see take off is the creation of polyglot development environments, capable of satisfying multiple language needs of development teams. While Eclipse, IntelliJ, Visual Studio and others have some cross-language capabilities, their support for a wide range of languages is limited at best.
Concurrent languages(Jan 2010, 评估)
The remaining two language types included on the radar are often grouped together. While functional and concurrent languages may be adopted in similar environments, their approaches are different. Functional programming focuses on expressing code in the form of mathematical functions that avoid maintaining state across multiple invocations. While functional languages such as Haskell have been around for a number of years, new functional (themed) languages such as Scala, F# and Clojure have sparked some interest in this paradigm. Due to the way in which functional languages manage state, interest in these languages has increased by many developers seeking to make the most out of multi-core processors. Many concurrent languages are also functional languages. The distinction lies in the emphasis on running operations in parallel. A number of such languages exist; Erlang is currently the most popular of these languages. Concurrent languages commonly provide some means for handling concurrency by using messages to communicate across multiple threads.
Chrome(Jan 2010, 评估)
Web browsers continue to evolve as they strive to keep pace with new specifications in HTML, CSS and JavaScript. Alas, many enterprises have yet to embrace the end of life for IE6 and move to a newer and more standards compliant option. Of the browsers available today, Firefox and Opera provide support for the widest range of platforms. The Google browser, Chrome, brings new innovation to the browser space by splitting browser tabs into separate processes while providing a new implementation of JavaScript. These changes appear to give Chrome a significant performance boost over other browsers and have influenced the creation of a netbook OS called Chrome OS. While enterprises may look to move off IE6 and onto Microsoft’s IE8, we remain concerned about IE8’s current level of compliance to web standards.
User centered design(Jan 2010, 采纳)
The benefits of user-centered design are often understated. Gaining a broader understanding of data flows and users’ goals simplify the overall architecture of a system while optimizing user interaction. In the past year we have seen a greater uptake of user-centered design in Agile software development practices as experts in both fields have established new ways of working together.
Google Wave(Jan 2010, 暂缓)
Google Wave has sprung up over the past few months and looks to be a promising platform for collaboration over the Internet. The platform is still in early beta and suffers from some stability issues. Some early developers have integrated with the Google Wave platform but commercial releases of software that utilize Google Wave will likely wait until the beta tag has been lifted from the product.
Chrome OS(Jan 2010, 评估)
Web browsers continue to evolve as they strive to keep pace with new specifications in HTML, CSS and JavaScript. Alas, many enterprises have yet to embrace the end of life for IE6 and move to a newer and more standards compliant option. Of the browsers available today, Firefox and Opera provide support for the widest range of platforms. The Google browser, Chrome, brings new innovation to the browser space by splitting browser tabs into separate processes while providing a new implementation of JavaScript. These changes appear to give Chrome a significant performance boost over other browsers and have influenced the creation of a netbook OS called Chrome OS. While enterprises may look to move off IE6 and onto Microsoft’s IE8, we remain concerned about IE8’s current level of compliance to web standards.`